\section{Tools and Methodologies}
Traditionally, applications for trusted personal devices undergo
extensive testing and code review in order to avoid programming 
errors and security flaws. However, test campaigns and code review
can be expensive and do not guarantee the absence of programming
errors and security flaws. Thus, we propose to use validation
techniques based on annotations and verification conditions,
that do guarantee the lack of programming mistakes and that
all security properties that have been specified and verified
do indeed hold.



This chapter describes some tools that have been developed during the
Inspired project, that can be handled to validate Java applications
and methodologies that can be applied depending on different
validation purposes.  All those tools are part a Java application
validation workshop called JACK.


The first section is a general presentation of the JACK tool, section
2 introduces a JACK extension allowing to verify with some automation
some security properties, section 3 presents an associated tool
allowing to describe security properties with automata, section 4 is
about the proof facilities in JACK, section 5 describes Jack features
at bytecode level and section 6 concludes with some perspectives in
Java application validation tool development.

\subsection{JACK}
\input{fm03/fme_jack_intro}
\subsubsection{Foundations}
\input{fm03/fme_jack_section3}
\subsubsection{Jack Proof Obligation Language}
\input{fm03/jpol}
\subsubsection{User Interface}
\input{fm03/fme_jack_section4}
%\subsubsection{Case study}
%\input{fm03/fme_jack_section5}
%\subsubsection{Conclusion}
%\input{fm03/fme_jack_concl}

\subsection{Security property propagation}\label{sec:highlevel}
\input{isaac/intro}


\subsection{JavaCard applet security properties}
To show the usefulness of the security property propagation, we applied it to
several realistic examples of smart card applications. When doing
this, we actually found violations against the security policies
documented for some of these applications.
\input{isaac/secprop}


\subsubsection{Automatic Verification of Security Properties}\label{SecVerif}
As explained above, we are interested in the verification of
high-level security properties that are not directly related to a
single method or class, but that guarantee the overall
well-functioning of an application. Writing appropriate JML
annotations for such properties is tedious and error-prone, as they
have to be spread all over the application. Therefore, we propose a
way to construct such annotations automatically. First we synthesize
core-annotations for methods directly involved in the property.  For
example, when specifying that no nested transactions are allowed, we
annotate the methods \texttt{beginTransaction},
\texttt{commitTransaction} and
\texttt{abortTransaction}. Subsequently, we propagate the necessary 
annotations to all methods (directly or indirectly) invoking these
core-methods.  The generated annotations are sufficient to respect the
security properties, \emph{i.e.}~if the applet does not violate the
annotations, it respects the corresponding high-level security
property.

Whether the applet respects its annotations can be established with
JACK~\cite{BRL-JACK}. Since for most security properties the
annotations are relatively simple---but there are many---it is
important that these verifications are done automatically, without any
user interaction. The results in Section~\ref{SecResults} show that
for the generated annotations all correct proof obligations can indeed
be automatically discharged.

\input{isaac/verif}
%\input{isaac/results}

%\input{isaac/related}
%\input{isaac/conclusion}
\subsubsection{Properties as automata}
\input{thibault}

\subsection{Bytecode validation}
\input{sac/intro}
\input{sac/architecture}
\input{sac/classFileExt}
\input{sac/wpbc}
\input{sac/wpSingleInstr}
\input{sac/results}
%\input{sac/conclusion}

%\subsection{Perspectives}
%\input{fm03/fme_jack_section6}

