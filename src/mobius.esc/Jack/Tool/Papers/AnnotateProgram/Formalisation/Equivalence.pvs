% Relation that witnesses the simulation between monitored and annotated
% program
Equivalence[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    IMPORTING ValProp[Name]

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MVATotalSemantics[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name],
            AnnotateProgram[CP, Name],
            AnnotateProgramProperties[CP, Name]

  mp : VAR (wf_and_complete_MP)

  % MVA control point is modeled by ghost variable cp(mp)
  % i.e., the control point maps to the unique integer that is held by cp(mp)
  MVA_cp_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    Int(unique(cp(sA))) = gvs(sAP)(cp(mp))

  % for every MVA control point, there is a ghost variable that maps this
  % control point to a unique (integer) value
  MVA_cps_modeled?(mp)(sAP : APState) : boolean =
    FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      Int(unique(q)) = gvs(sAP)(name_of(mp)(q))

  % Variables declared in monitor have corresponding ghost variable
  % Values coincide
  MVA_vars_modeled?(sA : AState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)

  % MVA_modeled?:
  % A monitor state sA is modeled by an annotated program state  sAP if:
  % the current control point is correctly modeled
  % for each automaton control point, there is a unique ghost variable
  % automaton variables and ghost variables representing those coincide
  MVA_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    MVA_cp_modeled?(mp)(sA, sAP) AND
    MVA_cps_modeled?(mp)(sAP) AND
    MVA_vars_modeled?(sA, sAP)


  % from APState, compute AState, such that ghots variables representing
  % automaton variables have corresponding values
  APStateToAStore(mp)(sAP : APState) : Store =
     LAMBDA(n : Name) : 
       IF var_names(vdsA(mva(mp)))(n)
       THEN gvs(sAP)(n)
       ELSE Bottom
       ENDIF 

  % APStateToAStore is wellformed
  APStateToAStore_wf_store : LEMMA % :-)
    FORALL(sAP : APState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
        wf_store(APStateToAStore(mp)(sAP))(var_names(vdsA(mva(mp))))

  % APStateToAStore(s) is correctly modeled by s
  APStateToAStore_MVA_modeled? : LEMMA % :-)
    FORALL(sAP : APState) :
      FORALL (n : Name) : 
        defined?(APStateToAStore(mp)(sAP)(n)) IMPLIES
        APStateToAStore(mp)(sAP)(n) = gvs(sAP)(n)

  % Program_gvs_modeled?:
  % ghost variables declared in monitored program (ie., old ghost variables)
  % have same value as ghost variables in annotated program
  Program_gvs_modeled?(sMP : MPState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Program_modeled?:
  % program states coincide, old ghost variables coincide
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND 
    Program_gvs_modeled?(sMP, sAP)

  % MP_modeled?
  % Monitored program state sMP is correctly modeled by annotated program
  % state sAP, i.e.,:
  % monitor state is correctly modeled
  % program state coincides
  MP_modeled?(mp)(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(mp)(astate(sMP), sAP) AND
    Program_modeled?(sMP, sAP)


  % Every guard of the MVA can be translated into an expression that
  % evaluates to the same result. Note that if evaluation
  % of the expression cannot result in an exception (v would be Bottom).
  % Furthermore, evaluation must have no side-effects.
  guard_to_expression_behavior(mp) : boolean =
    FORALL (t : Transition, sAP : APState, sMVA : AState, arg : ValOrExcpt) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      wf_store(stA(sMVA))(var_names(vdsA(mva(mp)))) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_vars_modeled?(sMVA, sAP) IMPLIES
      ts(mva(mp))(t) IMPLIES 
        EXISTS (e : [ValOrExcpt -> Expr], v : (Bool?), n : nat) : 
          guard_to_expression(guard(t)) = e AND
          wf_Expr(ann_program(mp))(e(arg)) AND
          derive(ann_program(mp))(e(arg), sAP, v, sAP)(n) AND
          Bool(guard(t)(stA(sMVA), fvs(st(pstate(sAP))), arg)) = v

  % Every expression in an action of a transtion can be evaluated in the
  % program, resulting in the same value.
  % Evaluation is side-effect-free. 
  % Note that the evaluation of the expresion can not throw an exception 
  % (since eval cannot return Bottom)
  eval_action_behavior(mp) : boolean =
    FORALL (t : Transition, oa : OneAction, sAP : APState, sMVA : AState) :
      ts(mva(mp))(t) IMPLIES
      member(oa, action(t)) IMPLIES
      wf_Expr(mva(mp))(source(oa)) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
      wf_store(stA(sMVA))(var_names(vdsA(mva(mp)))) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_vars_modeled?(sMVA, sAP) IMPLIES
        EXISTS (n : nat) : 
          derive(ann_program(mp))
                (source(oa), sAP, 
                 eval(source(oa))(stA(sMVA), fvs(st(pstate(sAP)))), sAP)(n)

  % an MVA that is used for annotation generation is wellbehaved if
  % both guards and action expressions can be correctly transformed into
  % program expressions
  well_behaved_MVA_for_annot_gen(mp) : boolean =
    guard_to_expression_behavior(mp) AND
    eval_action_behavior(mp) 

  % related_states:
  % Monitored program state sMP is related to annotated program state sAP, if:
  % both states are wellformed
  % the monitor is not stuck
  % if the monitor has reached halted, the annotated program throws a 
  % JMLException
  % otherwise: sMP is modeled by sAP (i.e., the annotated program state
  % models the monitored program state)
  related_states(mp)(sMP : MPState, sAP : APState) : boolean = 
    wf_state(mp)(sMP) AND
    wf_state(ann_program(mp))(sAP) AND
    NOT stuck(sMP) AND
    IF cp(astate(sMP)) = halted
    THEN up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc
    ELSE MP_modeled?(mp)(sMP, sAP)
    ENDIF


END Equivalence


% Basic properties about consequences and preservation of 
% related_states relation
RelatedStatesProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    IMPORTING ValProp[Name]

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING Equivalence[CP, Name]

  mp : VAR (wf_and_complete_MP)

  % if states are related, get_address returns same value
  get_address_same_in_related_states : LEMMA % :-)
    FORALL(vn : Name, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        get_address(vn, sMP) = get_address(vn, sAP)

  % if states are related, get_dynamic_type_name returns same value
  get_dynamic_type_name_same_in_related_states : LEMMA % :-)
    FORALL(vn : Name, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        get_dynamic_type_name(vn, sMP) = get_dynamic_type_name(vn, sAP)

  % if states are related, halted in monitor implies exception in annotated
  % program
  halted_implies_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES 
      cp(astate(sMP)) = halted IMPLIES
        up?(ex(pstate(sAP)))
  
  % MP_modeled implies that states have some exception flag
  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(mp)(sMP, sAP) IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  % related_states implies that states have same exception flag
  related_states_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES 
      NOT cp(astate(sMP)) = halted IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  % if states are related, lookup of variable names that occur in monitored
  % program returns the same value
  related_states_implies_same_lookup : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, n : Name) :
      related_states(mp)(sMP, sAP) IMPLIES 
      NOT cp(astate(sMP)) = halted IMPLIES
      ext_declared_var_names(program(mp))(n) IMPLIES
        lookup(n, sMP) = lookup(n, sAP)

  % MP_modeled preserved by updates on program state
  MP_modeled_preserved_by_update : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp)(sMP, sAP) IMPLIES
      (FORALL (pstate1, pstate2 : PState) : 
        (st(pstate1) = st(pstate2) IMPLIES st(upd(pstate1)) = st(upd(pstate2))))
      IMPLIES
      (FORALL (pstate : PState) : (ex(upd(pstate)) = ex(pstate))) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        MP_modeled?(mp)(update_PState(sMP, upd), update_PState(sAP, upd))

  % related_states preserved by update_local operation
  related_states_preserved_by_update_local : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(vn : Name, v : (defined?)) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      is_local(vn, pstate(sMP)) IMPLIES
      is_local(vn, pstate(sAP)) IMPLIES
        related_states(mp)(update_PState(sMP, update_local(vn, v)), 
                           update_PState(sAP, update_local(vn, v)))

  % related_states preserved by catching an exception
  related_states_preserved_by_catch : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        related_states(mp)(update_PState(sMP, catch), 
                           update_PState(sAP, catch))

  % related_states preserved by throwing an exception
  related_states_preserved_by_raise : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
      (cp(astate(sMP)) = halted IMPLIES JMLExc?(e)) IMPLIES
        related_states(mp)(update_PState(sMP, raise(e)), 
                           update_PState(sAP, raise(e)))

  % related_states preserved by function update_stack
  related_states_preserved_by_update_stack : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState,
            this_val : Val, arg :  (getLocalDecls(program(mp))), 
            param_val : Val, lvds : finite_set[Decl]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      (FORALL (l : Decl) : lvds(l) IMPLIES 
                           getLocalDecls(program(mp))(l)) IMPLIES
        related_states(mp)(update_stack(this_val, arg, param_val, lvds, sMP),
                           update_stack(this_val, arg, param_val, lvds, sAP))

  % related_states preserved by function update_stack
  related_states_preserved_by_update_stack_lookup : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState,
            mn: Name, md : Method, parent, this, param : Val) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      up?(lookup_mthd(program(mp), parent, mn)) IMPLIES
      md = down(lookup_mthd(program(mp), parent, mn)) IMPLIES
        related_states(mp)(update_stack(this, arg(md), param, lvars(md), sMP),
                           update_stack(this, arg(md), param, lvars(md), sAP))

  % MP_modeled implies that:
  % lookup of control point in monitor returns the same value as
  % lookup of cp(mp) ghost variable in annotated program
  % NOTE: The use of equalities[Val] is needed for parser/typechecker:
  % disambiaguation of =
  MP_modeled_lookup_correspondence : LEMMA % :-)
    FORALL (q1, q2 : CP, sMP : MPState, sAP : APState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      MP_modeled?(mp)(sMP, sAP) IMPLIES
      cps(mva(mp))(q1) IMPLIES
      cps(mva(mp))(q2) IMPLIES
      cp(astate(sMP)) = q1 IMPLIES
        (q1 = q2) =
        equalities[Val].=((Int(val2int(lookup(cp(mp), sAP))),
                           Int(val2int(lookup(name_of(mp)(q2), sAP)))))

  % related states consequence
  related_states_lookup_correspondence : LEMMA % :-)
    FORALL (q1, q2 : CP, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      cps(mva(mp))(q1) IMPLIES
      cps(mva(mp))(q2) IMPLIES
      cp(astate(sMP)) = q1 IMPLIES
        (q1 = q2) =
        equalities[Val].=((Int(val2int(lookup(cp(mp), sAP))),
                           Int(val2int(lookup(name_of(mp)(q2), sAP)))))

END RelatedStatesProperties
