// $ANTLR 2.7.2: "jml.g" -> "JmlParser.java"$

// @(#)$Id: jml.g,v 1.4 2002/04/24 08:40:53 antoine Exp $


// Copyright (C) 1999-2001 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JML; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

// JML concrete syntax
//
// AUTHORS: Gary T. Leavens, Clyde Ruby, Anand Ganapathy, and Arun Raghavan,
//          with help (long ago) from Albert Baker
// This grammar is based on the example Java grammar that ships with Antlr,
// by John Mitchell, Terence Parr, John Lilley, Scott Stanchfield,
// Markus Mohnen, and Peter Williams.
// It was last synchronized to Version 1.17.

package jml; //LB

public interface JavaTokenTypes {
	int EOF = 1;
	int NULL_TREE_LOOKAHEAD = 3;
	int ADDITIVE_ASSIGNMENT_OP = 4;
	int ADDITIVE_OP = 5;
	int BITWISE_OP = 6;
	int BITWISE_ASSIGNMENT_OP = 7;
	int EQUALITY_OP = 8;
	int LOGICAL_OP = 9;
	int MULTIPLICATIVE_ASSIGNMENT_OP = 10;
	int MULTIPLICATIVE_OP = 11;
	int RELATIONAL_OP = 12;
	int SHIFT_ASSIGNMENT_OP = 13;
	int SHIFT_OP = 14;
	int POST_INCREMENT_OP = 15;
	int PRE_INCREMENT_OP = 16;
	int UNARY_NUMERIC_OP = 17;
	int ACCESSIBLE_KEYWORD = 18;
	int AFFIRM_KEYWORD = 19;
	int ASSIGNABLE_KEYWORD = 20;
	int LABEL_KEYWORD = 21;
	int LOOP_ASSIGNABLE_KEYWORD = 22;
	int ASSUME_KEYWORD = 23;
	int HENCE_BY_KEYWORD = 24;
	int BREAKS_KEYWORD = 25;
	int CALLABLE_KEYWORD = 26;
	int CONSTRAINT_KEYWORD = 27;
	int CONTINUES_KEYWORD = 28;
	int DECREASING_KEYWORD = 29;
	int DEPENDS_KEYWORD = 30;
	int DIVERGES_KEYWORD = 31;
	int ENSURES_KEYWORD = 32;
	int EQUIVALENCE_OP = 33;
	int IMPLICATION_OP = 34;
	int INVARIANT_KEYWORD = 35;
	int JAVA_MODIFIER = 36;
	int JAVA_BUILTIN_TYPE = 37;
	int JML_MODIFIER = 38;
	int LETOLD_KEYWORD = 39;
	int MAINTAINING_KEYWORD = 40;
	int MEASURED_BY_KEYWORD = 41;
	int MODIFIER_SET = 42;
	int PRIVACY_MODIFIER = 43;
	int QUANTIFIER_TOKEN = 44;
	int REPRESENTS_KEYWORD = 45;
	int REQUIRES_KEYWORD = 46;
	int RETURNS_KEYWORD = 47;
	int SIGNALS_KEYWORD = 48;
	int WHEN_KEYWORD = 49;
	int ACCESSIBLE_SEQ = 50;
	int ARRAY_DECLARATOR = 51;
	int ASSERT = 52;
	int ASGNABLE_SEQ = 53;
	int LOOP_ASGNABLE_SEQ = 54;
	int BREAKS_SEQ = 55;
	int CALLABLE_SEQ = 56;
	int CASE = 57;
	int CAST = 58;
	int CONJOINABLE_SPEC = 59;
	int CONSTRUCTOR = 60;
	int CONT_SEQ = 61;
	int DIMS = 62;
	int DIM_EXPRS = 63;
	int DINFORMALLY = 64;
	int DIV_SEQ = 65;
	int DOC_ATSIGN = 66;
	int DOC_ATSIGN_KEYWORD = 67;
	int DOC_AUTHOR = 68;
	int DOC_COMMENT_START = 69;
	int DOC_DEPRECATED = 70;
	int DOC_EXCEPTION = 71;
	int DOC_JML_SPECS = 72;
	int DOC_NL_WS = 73;
	int DOC_NON_EMPTY_TEXTLINE = 74;
	int DOC_NON_NL_WS = 75;
	int DOC_PARAM = 76;
	int DOC_RETURN = 77;
	int DOC_SEE = 78;
	int DOC_SERIAL = 79;
	int DOC_SERIALDATA = 80;
	int DOC_SERIALFIELD = 81;
	int DOC_SINCE = 82;
	int DOC_THROWS = 83;
	int DOC_UNKNOWN_KEYWORD = 84;
	int DOC_VERSION = 85;
	int ENS_SEQ = 86;
	int EXT_ALSO = 87;
	int EXT_AND = 88;
	int FOR_INIT = 89;
	int FOR_TEST = 90;
	int FOR_UPDATER = 91;
	int INIT = 92;
	int INSTANCE_INIT = 93;
	int LOOP_INV_SEQ = 94;
	int METH = 95;
	int NESTED_CLASS = 96;
	int PARAM = 97;
	int POST_DEC = 98;
	int POST_INC = 99;
	int QUANTIFIED_EXPR = 100;
	int QUANT_VARS = 101;
	int REPLACE = 102;
	int RETURNS_SEQ = 103;
	int SET_COMPR = 104;
	int SIG_SEQ = 105;
	int LOOP_SIG_SEQ = 106;
	int SPEC_CASE = 107;
	int STAR_ELEMS = 108;
	int VAR_DECL = 109;
	int VF_SEQ = 110;
	int SPEC_STATEMENT = 111;
	int LITERAL_package = 112;
	int REFINE = 113;
	int MODEL = 114;
	int LITERAL_import = 115;
	int DOC_COMMENT = 116;
	int SEMI = 117;
	int IDENT = 118;
	int DOT = 119;
	int STAR = 120;
	int T_TYPEOFALLTYPES = 121;
	int LITERAL_private = 122;
	int LITERAL_public = 123;
	int LITERAL_protected = 124;
	int LITERAL_static = 125;
	int LITERAL_transient = 126;
	int LITERAL_final = 127;
	int LITERAL_abstract = 128;
	int LITERAL_native = 129;
	int LITERAL_synchronized = 130;
	int LITERAL_const = 131;
	int LITERAL_volatile = 132;
	int LITERAL_strictfp = 133;
	int LITERAL_class = 134;
	int LITERAL_extends = 135;
	int WEAKLY = 136;
	int LCURLY = 137;
	int RCURLY = 138;
	int LITERAL_interface = 139;
	int LITERAL_implements = 140;
	int COMMA = 141;
	int STATIC_INITIALIZER = 142;
	int INITIALIZER = 143;
	int LPAREN = 144;
	int RPAREN = 145;
	int LITERAL_throws = 146;
	int ASSIGN = 147;
	int L_ARROW = 148;
	int STRING_LITERAL = 149;
	int INITIALLY = 150;
	int READABLE_IF = 151;
	int MONITORED_BY = 152;
	int PURE = 153;
	int INSTANCE = 154;
	int SPEC_PUBLIC = 155;
	int SPEC_PROTECTED = 156;
	int MONITORED = 157;
	int UNINITIALIZED = 158;
	int GHOST = 159;
	int NON_NULL = 160;
	int INVARIANT = 161;
	int INVARIANT_REDUNDANTLY = 162;
	int CONSTRAINT = 163;
	int CONSTRAINT_REDUNDANTLY = 164;
	int FOR = 165;
	int T_EVERYTHING = 166;
	int LITERAL_super = 167;
	int LITERAL_this = 168;
	int T_OTHER = 169;
	int LITERAL_new = 170;
	int DEPENDS = 171;
	int DEPENDS_REDUNDANTLY = 172;
	int REPRESENTS = 173;
	int REPRESENTS_REDUNDANTLY = 174;
	int T_SUCH_THAT = 175;
	int AXIOM = 176;
	int LITERAL_void = 177;
	int ALSO = 178;
	int AND = 179;
	int BEHAVIOR = 180;
	int EXCEPTIONAL_BEHAVIOR = 181;
	int NORMAL_BEHAVIOR = 182;
	int FOR_EXAMPLE = 183;
	int EXAMPLE = 184;
	int EXCEPTIONAL_EXAMPLE = 185;
	int NORMAL_EXAMPLE = 186;
	int IMPLIES_THAT = 187;
	int SUBCLASSING_CONTRACT = 188;
	int ACCESSIBLE = 189;
	int ACCESSIBLE_REDUNDANTLY = 190;
	int LBRACK = 191;
	int RBRACK = 192;
	int CALLABLE = 193;
	int CALLABLE_REDUNDANTLY = 194;
	int LCURLY_VBAR = 195;
	int VBAR_RCURLY = 196;
	int MODEL_PROGRAM = 197;
	int FORALL = 198;
	int LET = 199;
	int OLD = 200;
	int REQUIRES = 201;
	int PRE = 202;
	int REQUIRES_REDUNDANTLY = 203;
	int PRE_REDUNDANTLY = 204;
	int T_NOT_SPECIFIED = 205;
	int WHEN = 206;
	int WHEN_REDUNDANTLY = 207;
	int MEASURED_BY = 208;
	int MEASURED_BY_REDUNDANTLY = 209;
	int LITERAL_if = 210;
	int COLON = 211;
	int LABEL = 212;
	int LOOP_MODIFIES = 213;
	int ASSIGNABLE = 214;
	int MODIFIABLE = 215;
	int MODIFIES = 216;
	int ASSIGNABLE_REDUNDANTLY = 217;
	int MODIFIABLE_REDUNDANTLY = 218;
	int MODIFIES_REDUNDANTLY = 219;
	int T_FIELDS_OF = 220;
	int T_NOTHING = 221;
	int DOT_DOT = 222;
	int ENSURES = 223;
	int POST = 224;
	int ENSURES_REDUNDANTLY = 225;
	int POST_REDUNDANTLY = 226;
	int LOOP_EXSURES = 227;
	int SIGNALS = 228;
	int SIGNALS_REDUNDANTLY = 229;
	int EXSURES = 230;
	int EXSURES_REDUNDANTLY = 231;
	int DIVERGES = 232;
	int DIVERGES_REDUNDANTLY = 233;
	int LITERAL_else = 234;
	int LITERAL_while = 235;
	int LITERAL_do = 236;
	int LITERAL_for = 237;
	int LITERAL_break = 238;
	int LITERAL_continue = 239;
	int LITERAL_return = 240;
	int LITERAL_throw = 241;
	int LITERAL_switch = 242;
	int LITERAL_case = 243;
	int LITERAL_default = 244;
	int LITERAL_try = 245;
	int LITERAL_finally = 246;
	int LITERAL_catch = 247;
	int LITERAL_assert = 248;
	int HENCE_BY = 249;
	int HENCE_BY_REDUNDANTLY = 250;
	int ASSERT_REDUNDANTLY = 251;
	int ASSUME = 252;
	int ASSUME_REDUNDANTLY = 253;
	int SET = 254;
	int PLUS_ASSIGN = 255;
	int MINUS_ASSIGN = 256;
	int STAR_ASSIGN = 257;
	int DIV_ASSIGN = 258;
	int MOD_ASSIGN = 259;
	int SR_ASSIGN = 260;
	int BSR_ASSIGN = 261;
	int SL_ASSIGN = 262;
	int BAND_ASSIGN = 263;
	int BOR_ASSIGN = 264;
	int BXOR_ASSIGN = 265;
	int UNREACHABLE = 266;
	int CHOOSE = 267;
	int OR = 268;
	int CHOOSE_IF = 269;
	int ELSE = 270;
	int ABRUPT_BEHAVIOR = 271;
	int CONTINUES = 272;
	int CONTINUES_REDUNDANTLY = 273;
	int R_ARROW = 274;
	int BREAKS = 275;
	int BREAKS_REDUNDANTLY = 276;
	int RETURNS = 277;
	int RETURNS_REDUNDANTLY = 278;
	int MAINTAINING = 279;
	int MAINTAINING_REDUNDANTLY = 280;
	int LOOP_INVARIANT = 281;
	int LOOP_INVARIANT_REDUNDANTLY = 282;
	int DECREASING = 283;
	int DECREASING_REDUNDANTLY = 284;
	int DECREASES = 285;
	int DECREASES_REDUNDANTLY = 286;
	int QUESTION = 287;
	int EQUIV = 288;
	int NOT_EQUIV = 289;
	int LIMPLIES = 290;
	int BACKWARD_IMPLIES = 291;
	int LOR = 292;
	int LAND = 293;
	int BOR = 294;
	int BXOR = 295;
	int BAND = 296;
	int NOT_EQUAL = 297;
	int EQUAL = 298;
	int LT = 299;
	int GT = 300;
	int LE = 301;
	int GE = 302;
	int IS_SUBTYPE_OF = 303;
	int LITERAL_instanceof = 304;
	int SL = 305;
	int SR = 306;
	int BSR = 307;
	int PLUS = 308;
	int MINUS = 309;
	int DIV = 310;
	int MOD = 311;
	int INC = 312;
	int DEC = 313;
	int BNOT = 314;
	int LNOT = 315;
	int LITERAL_true = 316;
	int LITERAL_false = 317;
	int LITERAL_null = 318;
	int T_LBLNEG = 319;
	int T_LBLPOS = 320;
	int T_RESULT = 321;
	int T_OLD = 322;
	int T_NOT_MODIFIED = 323;
	int T_FRESH = 324;
	int T_REACH = 325;
	int T_NONNULLELEMENTS = 326;
	int T_TYPEOF = 327;
	int T_ELEMTYPE = 328;
	int T_TYPE = 329;
	int T_LOCKSET = 330;
	int T_IS_INITIALIZED = 331;
	int T_INVARIANT_FOR = 332;
	int INFORMAL_DESCRIPTION = 333;
	int LITERAL_boolean = 334;
	int LITERAL_byte = 335;
	int LITERAL_char = 336;
	int LITERAL_short = 337;
	int LITERAL_int = 338;
	int LITERAL_long = 339;
	int LITERAL_float = 340;
	int LITERAL_double = 341;
	int NUM_INT = 342;
	int CHAR_LITERAL = 343;
	int NUM_FLOAT = 344;
	int T_FORALL = 345;
	int T_EXISTS = 346;
	int T_MAX = 347;
	int T_MIN = 348;
	int T_SUM = 349;
	int T_PRODUCT = 350;
	int T_NUM_OF = 351;
	int SPEC_SL_COMMENT = 352;
	int SL_COMMENT = 353;
	int NON_NL_WS = 354;
	int NL_WS = 355;
	int IGNORED_AT_IN_COMMENT = 356;
	int ML_COMMENT = 357;
	int WS = 358;
	int NOWARN_LABEL = 359;
	int NOWARN_LABEL_LIST = 360;
	int JML_BACKSLASH_SEQUENCE = 361;
	int ESC = 362;
	int HEX_DIGIT = 363;
	int VOCAB = 364;
	int EXPONENT = 365;
	int FLOAT_SUFFIX = 366;
	int BADCHAR = 367;
}
