\nextslide{3. Modelling in Coq}
\begin{enumerate}
\item Presentation
\item Memory model
\begin{enumerate} \small
\item Types
\item Memory model
\item Pure methods
\end{enumerate}
\item Proofs
\begin{enumerate} \small
\item Lemmas
\item Human interface
\item Tactics
\end{enumerate}
\end{enumerate}
\nextslide{Coq}
\small
Coq is based on the {\purple calculus of inductive constructions}.\\
You can express: types, axioms, functions
variables, definitions, {\purple lemmas}...

Lemmas have to be proved.\\
To prove a lemma you have to build a {\purple proof term} out of the types, 
axioms, variables... \\
To build this proof term you use special commands 
called {\purple tactics} within a proof script.

{\purple Custom tactics} can be created composing more primitive ones.\\

It can easily express the logics for ESC/Java and Jack.
\nextslide{General architecture}
3 parts are generated:
\blist 
\item The {\purple prelude} containing the logic used 
\blist \small
\item ESC/Java: 1 file 'static'
\item Jack: several files, with some generated dynamically
 (for the properties on class fields, and the subtyping relation)
\elist
\item The {\purple proof obligation} (1 file)
\item A file containing some {\purple custom tactics}
\elist
\nextslide{Types for Jack and ESC/Java}\small
Types for variable:
\blist
\item Variable with Java {\purple primitive types} (int,  boolean...) 
have their types  mapped to corresponding {\purple Coq types} (Z, bool...)
\item Variable can be also of type {\purple REFERENCES}.
\elist

A variable of type REFERENCES subtypes a Java Type:
\blist
\item In Jack:\\
{\purple Inductive} Types : Set :=\\
$|$    class : Classes\rarrow Types\\
$|$ array : Types\rarrow Z\rarrow Types.
\item In ESC/Java there is a separation between types for class and
for arrays\\
\rarrow There are some {\purple special axioms} for the types of arrays
\elist


\nextslide{Subtyping (1)}\small
\blist
\item Jack: in the dynamic prelude 
\begin{tabbing}
{\purple Defi}\={\purple nition} subtypes (t1: Types) (t2: Types): Prop :=\+\\
   {\purple match} t2 {\purple with}\\
    $|$ (class \=c\_int) $=>$\+ \\
       ...\-\\
    $|$ (class c\_MemoryState) $=>$\+\\ {\purple match} t1 {\purple with}\\
        $|$(class c\_MemoryStateJavaLight) $=>$ True\\
        $|$ (class c\_MemoryState) $=>$ True\\
        $|$ \_ $=>$ False\\
        {\purple end}\\
       ... \-\\
    $|$ \_ $=>$ t1 = t2\\
    {\purple end}.
\end{tabbing}
\elist
\nextslide{Subtyping (2)} \small
\blist 
\item ESC/Java : in the proof obligation
\elist
For Jack and for ESC/Java we need an  {\purple axiom of transitivity}:\\
\rarrow It could be proved for the Jack version, but the proof 
takes lots of time to compute.

 {\purple Axiom} subtypes\_trans :\\
 {\purple forall} a b , subtypes b a  \rarrow  {\purple forall} c, subtypes c b \rarrow subtypes  c a. 

\nextslide{Memory model (1)}\small
In Jack fields modifications/access and array modifications are done with 
 {\purple overriding constructs}:
\blist
\item overridingCoupleRef
\item overridingCoupleZ
\item overridingArray
\elist
\begin{tabbing}
 {\purple Definition} over\=riding\=Couple f obj inst res  := \+ \\
 if (= obj inst) then  \+ \\
      res \- \\
 else\+ \\
    f (obj).
\end{tabbing}
The variable is replaced by the overriding.\\
Array access is done with the relation: \\
 {\purple Variable} myTypeelement: REFERENCES \rarrow Z \rarrow myType. 

\nextslide{Memory model (2)}
\small
In ESC/Java fields access/modifications and array access are done through a sort of  {\purple heap} (more uniform than Jack):

 {\purple Variable} select: S\rarrow S\rarrow A.\\
 {\purple Variable} store: S\rarrow S\rarrow A\rarrow S.
 \begin{tabbing}
 {\purple Axiom} \= select\_store1: \+\\
 {\purple forall} (var obj :S)(val :A), (select (store obj var val) var) = val.
 \end{tabbing}
 {\purple Variable} arrselect: S\rarrow Z\rarrow A.\\
 {\purple Variable} arrstore: S\rarrow Z\rarrow A\rarrow S.

Problems: 
\blist
\item the array select/store should be different
(not the case on the proof tree)
\item select/store and their axioms have to be parametized 
for {\purple each variable type}
\elist

\nextslide{Expressions types}\small
In JML forall and exist expressions are of type boolean\\
\rarrow {\purple not the case at all} in Coq\\
Coq use Proposition (type Prop).
\blist
\item Jack does the differenciation in the proof tree \\
\rarrow No problems
\item ESC/Java does tries to do differenciation (recent work...)\\
\rarrow {\purple Not finished} yet, but when the new vcGen is finished
 it should be corrected\\
\rarrow the Coq translator must deduce from the context if an 'and' should be
boolean or between two Prop
\elist

\nextslide{The pure methods}
%\small
Pure methods are some methods you can {\purple use in your specification} 
in JML.
\blist \small
\item No 'visible' side effect
\item A constructor can be pure
\item We'd like them to be deterministic
\elist
The main problem: keeping track of the pure method name


\nextslide{Jack approach}
\small
\blist
\item At first pure methods were directly unfolded 
  within the proof obligations
\item Now there is a couple definition / hypothesis \\
\elist

{\purple Definition} myfun\_1 : A1Type\rarrow A2Type\rarrow ResType\rarrow Prop :=\\
{\purple fun} (h arg1 arg2 Res) {\purple $=>$} Context1\rarrow Res = true. (* ResType = bool *)

{\purple Definition} myfun\_2 : A1Type\rarrow A2Type\rarrow ResType\rarrow Prop :=\\
{\purple fun} (h arg1 arg2 Res) {\purple $=>$} Context2\rarrow Res = false.\\
...\\
(* Used within an hypothesis : *)\\
... \rarrow myfun\_2 this l\_var1 Res\_23\rarrow Res\_23 = true.\\

\nextslide{ESC/Java approach}\small
\blist
\item False heap with a variable / hypothesis
\elist
{\purple Variable} myfun :  Heap\rarrow A1Type\rarrow A2Type\rarrow ResType.\\
...\\
{\purple Variable} state\_1 : Heap.\\
{\purple Variable} state\_2 : Heap.\\
...\\
(* Used within an hypothesis : *)\\
... \rarrow myfun state\_1 this l\_var1 = true.\\
(* Used within another hypothesis : *)\\
... \rarrow myfun state\_2 this l\_var1 = false.\\
%In order to prove: \\
%myfun state\_1 this l\_var1 = true.\\
\nextslide{What  we would like to have}
\small
\blist
\item The same kind as the new one in Jack but using a heap.\\
\rarrow The first step in order to have within JML functions
that can be directly defined in the theorem prover language in order to
gain {\purple expressiveness}
\elist

\begin{tabbing}
{\purple Definition} \= myfun : Heap\rarrow A1Type\rarrow 
A2Type\rarrow ResType\rarrow Prop := \\\>
{\purple fun} (h arg1 arg2 Res) {\purple $=>$} \= (Context1 h\rarrow Res = true) $\wedge$\\
\>\> (Context2 h\rarrow Res = false).
\end{tabbing}
\blist
\item Problem: it would totally change the memory model in Jack and 
partly change it in ESC/Java.
\elist


\nextslide{POs generated by Jack and ESC/Java}
\blist
\item ESC/Java, {\purple refutation} based: \\\small
pre \rarrow (not (npost)) \\
where npost is the weakest precondition of the negation of the postcondition.
False has to be proved:
\blist \item  good for first order provers (Simplify) 
\item not so for
interactive proof assistants (our case)
\elist
\norm
\item Jack:\\ 
\small
it gives each hypothesis with some {\purple hints} from their origin:
\blist 
\item bad for the performances of first order provers
\item useful informations for the proof script (makes the lemma
nearly human readable)
\elist
\elist


\nextslide{POs presentation}
Making more readable the POs generated:
\blist
\item ESC/Java: 
\blist \small
\item before the translation to Coq the tree is cleaned from useless 
informations ({\purple buggy})
\item problem: the form of the lemma
\elist
\item Jack:
\blist \small
\item once translated it is passed to Coq  to {\purple pretty print}
\item separation between the different kind of hypothesis
\elist 
\item Cleaning with tactics
\elist
\nextslide{Solving proofs}

To prove lemmas in Coq we have to use tactics \\
\rarrow LTac
\blist \small
\item
Most of ESC/Java POs can be solved using the {\tt firstorder} tactic due
to its Simplify-Theorem-Prover history.
\item
For Jack: the model used is not really oriented for
first order provers
\item The tactics are necessary especially when POs are big.
\elist
In fact, having {\purple lightweight} and {\purple powerful} 
tactics is crucial.

\nextslide{Tactics }

\blist
\item Lightweight and general:
\blist \small \item elimAnd, elimOr
\item tryApply
\item solveInc
\item cleanUp
\elist
\item Tool specific:
\blist \small
\item solveOver, heap management axioms
\item arrtac, array heap management axioms
\item absurd
\elist
\item The starting tactic
\item Custom {\tt auto} with {\purple hints database}
\elist
\nextslide{Automatic POs resolution}

\blist
\item ESC/Java: \\\small
The starting tactic + {\tt intuition} or
 {\tt firstorder} solve nearly all the one Simplify manages to solve, 
 but {\purple testing on bigger examples is needed}\\
If we turn off proof simplification we get easily POs of more 
than {\purple 1Mo of text} (in Coq)
\norm
\item Jack:\\\small
Automation in Coq is really worst than with Simplify, but on the samples
Simplify was not able to solve all the POs whereas they can be solved 
{\purple interactively} with Coq.

\elist


\nextslide{Some stats (from a bcv sample)}
\small
\begin{tabular}{p{0.34\textwidth} c c c c}
{\bf Classes:} & VerificationException & State & Instruction & Verifier \\
\raggedright {\bf Nbr of code lines:} & 13 & 14 & 47 & {\purple 66}\\
\raggedright {\bf Annotations lines:} & 5 & 20 & 54 & {\purple 81}\\
\raggedright {\bf POs (Jack) :} &  60 & 26 & 129 & {\purple 627} \\
\raggedright {\bf Simplify (Jack):} &  60 & 26 & 53 & {\purple 5}\\
\raggedright {\bf POs (ESC/Java):} &  3 & 6 & 14 & {\purple 3} \\
\raggedright {\bf Simplify - warnings:} &  6 & 2  & 9 & {\purple 5}\\

\end{tabular}
