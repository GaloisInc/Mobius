\nextslide{3. The plugin for Coq}
\begin{enumerate}
\item Presentation
\item Memory model
\begin{enumerate} \small
\item Types
\item Memory model
\end{enumerate}
\item Proofs
\begin{enumerate} \small
\item Lemmas
\item Human interface
\item Tactics
\end{enumerate}
\end{enumerate}
\nextslide{Coq}
\small
Coq is based on the {\purple calculus of inductive constructions}.\\
You can express: types, axioms, functions
variables, definitions, {\purple lemmas}...

Lemmas have to be proved.\\
To prove a lemma you have to build a {\purple proof term} out of the types, 
axioms, variables... \\
To build this proof term you use special commands 
called {\purple tactics} within a proof script.

{\purple Custom tactics} can be created composing more primitive ones.\\

It can easily express the logics for Jack.
\nextslide{General architecture}
3 parts are generated:
\blist 
\item The {\purple prelude} containing the logic used 
\blist \small
\item Several files, with some generated dynamically
 (for the properties on class fields, and the subtyping relation)
\elist
\item The {\purple proof obligation} (1 file)
\item A file containing some {\purple custom tactics}
\elist
\nextslide{Types}\small
Types for variable:
\blist
\item Variable with Java {\purple primitive types} (int,  boolean...) 
have their types  mapped to corresponding {\purple Coq types} (Z, bool...)
\item Variable can be also of type {\purple REFERENCES}.
\elist

A variable of type REFERENCES subtypes a Java Type:

{\purple Inductive} Types : Set :=\\
$|$    class : Classes\rarrow Types\\
$|$ array : Types\rarrow Z\rarrow Types.



\nextslide{Subtyping (1)}\small
\blist
\item In the dynamic prelude :
\begin{tabbing}
{\purple Defi}\={\purple nition} subtypes (t1: Types) (t2: Types): Prop :=\+\\
   {\purple match} t2 {\purple with}\\
    $|$ (class \=c\_int) $=>$\+ \\
       ...\-\\
    $|$ (class c\_MemoryState) $=>$\+\\ {\purple match} t1 {\purple with}\\
        $|$(class c\_MemoryStateJavaLight) $=>$ True\\
        $|$ (class c\_MemoryState) $=>$ True\\
        $|$ \_ $=>$ False\\
        {\purple end}\\
       ... \-\\
    $|$ \_ $=>$ t1 = t2\\
    {\purple end}.
\end{tabbing}
\elist
\nextslide{Subtyping (2)} 
We need an  {\purple axiom of transitivity}:\\
\rarrow It could be proved for the Jack version, but the proof 
takes lots of time to compute.
\begin{tabbing}
 {\purple Axiom} subtypes\_trans :\\
 {\purple forall} a b , \= subtypes b a  \rarrow \+ \\
  {\purple forall} c, subtypes c b \rarrow subtypes  c a. 
\end{tabbing}
\nextslide{Memory model}\small
In Jack fields modifications/access and array modifications are done with 
 {\purple overriding constructs}:
\blist
\item overridingCoupleRef
\item overridingCoupleZ
\item overridingArray
\elist
\begin{tabbing}
 {\purple Definition} over\=riding\=Couple f obj inst res  := \+ \\
 if (= obj inst) then  \+ \\
      res \- \\
 else\+ \\
    f (obj).
\end{tabbing}
The variable is replaced by the overriding.\\
Array access is done with the relation: \\
 {\purple Variable} myTypeelement: REFERENCES \rarrow Z \rarrow myType. 

\nextslide{Expressions types}\small
In JML forall and exist expressions are of type boolean\\
\rarrow {\purple not the case at all} in Coq\\
Coq use Proposition (type Prop).
\blist
\item Jack does the differenciation in the proof tree \\
\rarrow No problems
\elist


\nextslide{POs generated by Jack }


It gives each hypothesis with some {\purple hints} from their origin:
\blist \small
\item bad for the performances of first order provers
\item useful informations for the proof script (makes the lemma
nearly human readable)
\elist

Making more readable the POs generated:

\blist \small
\item once translated it is passed to Coq  to {\purple pretty print}
\item separation between the different kind of hypothesis
\elist 
\rarrow Cleaning with tactics

\nextslide{Solving proofs}

To prove lemmas in Coq we have to use tactics \\
\rarrow LTac
\blist \small
\item The model used is not really oriented for
first order provers
\item The tactics are necessary especially when POs are big.
\elist
In fact, having {\purple lightweight} and {\purple powerful} 
tactics is crucial.

\nextslide{Tactics }

\blist
\item Lightweight and general:
\blist \small \item elimAnd, elimOr
\item tryApply
\item solveInc
\item cleanUp
\elist
\item Tool specific:
\blist \small
\item solveOver, heap management axioms
\item arrtac, array heap management axioms
\item absurd
\elist
\item The starting tactic
\item Custom {\tt auto} with {\purple hints database}
\elist
\nextslide{Automatic POs resolution}

\small
Automation in Coq can be done several ways:
\blist
\item Light way
\item Tough way (nearly unusable!)
\item Custom way
\elist
It is  really worst than with Simplify, but on the samples
Simplify was not able to solve all the POs whereas they can be solved 
{\purple interactively} with Coq.




\nextslide{Some stats (from a bcv sample)}
\small
\begin{tabular}{p{0.34\textwidth} c c c c}
{\bf Classes:} & VerificationException & State & Instruction & Verifier \\
\raggedright {\bf Nbr of code lines:} & 13 & 14 & 47 & {\purple 66}\\
\raggedright {\bf Annotations lines:} & 5 & 20 & 54 & {\purple 81}\\
\raggedright {\bf POs (Jack) :} &  60 & 26 & 129 & {\purple 627} \\
\raggedright {\bf Simplify (Jack):} &  60 & 26 & 53 & {\purple 5}\\
\raggedright {\bf POs (ESC/Java):} &  3 & 6 & 14 & {\purple 3} \\
\raggedright {\bf Simplify - warnings:} &  6 & 2  & 9 & {\purple 5}\\

\end{tabular}
