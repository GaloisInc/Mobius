\chapter{Java Validation}
This chapter gives an overview of the JML language and the tools that have been developed to deal with the it.

\section{Java and JavaCard}
 Formal validation of Java programs is a growing research
 field.  As Java has become a reference language, many technologies are
 emerging to help Java program validation.  Java can also be
 considered as a good support for formal techniques, as it has precise 
semantics \cite{Gosl00a}.

JavaCard is a popular programming language for multiple
application smart cards.  According to the JavaCard Forum \footnote{http://www.javacardforum.org},
which involves key players in the field of smart cards, 
including smart card manufacturers and banks, the JavaCard language has two
important features that make it the ideal choice for smart cards: 
\begin{itemize}
\item JavaCard programs are written in a subset of Java, using
the JavaCard APIs (Application Programming Interfaces). JavaCard
developers can therefore benefit from the well-established Java technology; 

\item the JavaCard security model enables multiple applications to
coexist  on the same card and communicate securely, and in principle,
enables new applications to be loaded on the card after its issuance.
\end{itemize}
Yet recent research has unveiled several problems in the JavaCard
security model, most notably with object sharing and the associated
mechanism of shareable interfaces.
This has  emphasized the necessity to develop environments for
verifying the security of the JavaCard platform and of JavaCard
programs.  Thus far JavaCard security (and also Java security) has
been studied  mainly at two levels:    
\begin{itemize}
\item  platform level: here the goal is to prove safety properties of
the language, in particular type safety and properties related to
memory management; 
\item  application level: here the goal is to prove that a specific
program obeys a given property, and in particular that it satisfies a
security policy, for example based on information flow. 
\end{itemize}
We are focusing at the application level, developing tools and methodologies based on JML to reach this goal.
\section{JML}
JML~\cite{Leavens-Baker-Ruby99b,Leavens-Baker-Ruby03}, the
``Java Modeling Language'', is a behavioral interface
specification language for Java; that is, it specifies both the behavior
and the syntactic interface of Java code.  The syntactic interface of
a Java class or interface consists of its method signatures,
the names and types of its fields, etc.
This is what is commonly meant by an application programming
interface (API).
The behavior of such an API can be precisely documented in JML annotations;
these describe the intended way that programmers should
use the API.  In terms of behavior, JML can detail, for example, the
preconditions and postconditions for methods as well as class
invariants.

An important goal for the design of JML is that it should be easily
understandable by Java programmers. This is achieved by staying as
close as possible to Java syntax and semantics.  Another important
design goal is that JML {\em not} impose any particular design method
on users; instead, JML should be able to document Java programs
designed in any manner \cite{Leavens-Baker-Ruby03}.

JML uses Java's expression syntax in assertions,
thus JML's notation is easy for programmers to learn.  
Because JML supports quantifiers such as
\verb_\forall_ and \verb_\exists_, and because JML allows ``model''
(i.e., specification-only) fields and methods, specifications can
easily be made precise and complete.
JML assertions are written as special
annotation comments in Java code,
so that they are ignored by Java compilers but can be used
by tools that support JML\@.  Within annotation comments JML extends the
Java syntax with several keywords.  It also extends Java's expression syntax with several
operators.
The central ingredients of a JML specification are preconditions
(given in {\tt requires} clauses), postconditions (given in {\tt
  ensures} clauses), and (class and interface) invariants.  These are
all expressed as boolean expressions in JML's extension to Java's
expression syntax.
In addition to ``normal'' postconditions, the language also supports
``exceptional'' postconditions, specified in {\tt signals} clauses.
These can be used to specify what must be true when a method throws an
exception. 

%=====================================================================
\input{sttt/sttt}

\section{ESC/Java2}
\label{escjava}

ESC/Java2 tool~\cite{Flanagan-Et-Al02}, originally developed at Compaq Research,
performs what is called ``extended static
checking''~\cite{ESC:Overview,10yearsESC},
compile-time checking that goes well beyond type checking.  It can
check relatively simple assertions and can check for certain kinds of
common errors in Java code, such as dereferencing \texttt{null},
indexing an array outside its bounds, or casting a reference to an
impermissible type.  ESC/Java2 supports a subset of JML and also checks
the consistency between the code and the given JML annotations.  The
user's interaction with ESC/Java2 is quite similar to the interaction
with the compiler's type checker: the user includes JML annotations in
the code and runs the tool, and the tool responds with a list of
possible errors in the program.

JML annotations affect ESC/Java2 in two ways.  First, the given JML
annotations help ESC/Java2 suppress spurious warning messages.   Second,
annotations make ESC/\-Java2 do additional checks.  
In these two ways, the use of JML annotations enables ESC/Java2 to
produce warnings not at the source locations where errors manifest
themselves at runtime, but at the source locations where the errors
are committed.

%=====================================================================
%\section{Applications of JML to Java Card}
%\label{applications}

%Although JML is able to specify arbitrary sequential Java programs,
%most of the serious applications of JML and JML tools up to now
%have targeted Java Card.  Java Card$^{TM}$ is a dialect of Java specifically
%designed for the programming of the latest generation of smartcards.
%Java Card is adapted to the hardware limitations of smartcards; for
%instance, it does not support floating point numbers, strings, object
%cloning, or threads.

%Java Card is a well-suited target for the application of formal
%methods.  It is a relatively simple language with a restricted API\@.
%Moreover, Java Card programs, called ``applets'', are small, typically
%on the order of several KBytes of bytecode.  Additionally, correctness
%of Java Card programs is of crucial importance, since they are used in
%sensitive applications such as bank cards and mobile phone SIMs.  (An
%interesting overview of security properties that are relevant for Java
%Card applications is available~\cite{MarletLM01}.)

%JML, and several tools for JML, have been used for Java Card,
%especially in the context of the EU-supported project VerifiCard
%(www.verificard.org).  JML has been used to write a formal
%specification of almost the entire Java Card
%API~\cite{PollBergJacobs01}.  This experience has shown that JML is
%expressive enough to specify a non-trivial existing API\@.  The
%runtime assertion checker has been used to specify and verify a
%component of a smartcard operating system~\cite{PollHarteldeJong02}.



