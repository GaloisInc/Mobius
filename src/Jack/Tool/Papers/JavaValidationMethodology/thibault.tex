By relying on the propagation tool it has become possible to propose new mechanisms based on high level representation of properties to build a bridge between specification and the verification of a specific implementation. As the propagation tool already capable of deducing annotations from methods' specification, the only missing step to lower the gap between specification and annotations is to describe properties at a more abstract level. This move towards high level specification is deeply facilitated by the frequent use of tools such as UML to specify software components.

\subsection{The Automaton model}
A minimal set of constraint can be defined concerning the choice of the abstract model with the hope of keeping most of JML's expressiveness. First of all, the chosen model needs to be able to generate JML annotation for native methods. This requirement is mainly due to the fact that Java Card API is not provided together with JML specification. As a result, the model being chosen must be able to fit with both native and non-native methods. Secondly, the abstract model should consider methods' sequences as well as their pre and postconditions : this level of description surely is not only the most adequate to connect implementation to its high level specification, but also very crucial to smart verification. Furthermore, this choice is of great importance to connect the present work with the existing propagation tool. Finally, all possible improvement such as the support of invariants would be definitely a plus to keep as much as possible of the JML expressiveness.
For many reasons, the choice of finite state machine as a model to describe these properties is about to fulfill the previous expectations. FSM have been historically employed to model check software execution. Thereof, it is possible to assert that it is capable of specifying valid and invalid sequences in an intuitive way to people of the verification field. Nevertheless, the semantic of this automaton would require to be adapted to the expression of properties. It will be in particular compulsory to make an automaton stick to a property, by defining what could be the properties' states and what could make it switch from one to another. However, automatons make trivial the possibility to express pre and postcondition as they can be seen as methods' use cases, which is possible to describe through automatons' conditional evolution. As a consequence, the model used for this present study will be the FSM model.

\subsection{Translating automatons to Properties}
Starting from the use of FSM, the initial problem was to correlate the semantic of states and transitions with a program execution to characterize properties. On one hand, the state should be characterized by a unique set of properties from which a given set of evolution is possible. Hence, a program state could be defined by a set of values attached to program variables, or possibly by method's status (i.e. active state would represent the method currently executed). On the other hand, the evolution between those states is expressible with the automaton model through guards, update, and message passing. Once again, several possibilities are acceptable. In the case where the active state represents the method currently executing, transitions might be use to express pre and postconditions through guards and even specify some entry/exit action in the update field. Nevertheless, it is as well acceptable to assert that program's evolution is conditioned by the sequent call and returns of method, so that transition should be attached to methods, and pre and postconditions could be specified as state invariants.
Even though several formalisms would be suitable, many of them could be discarded due to the limited nature of the properties expressible. First, correlating the active state with the method currently executing happened to be a bad idea. Such a representation imposes transition to define the pre and postcondition with the meaning that a method would neither be executed without respecting the preconditions of the incoming transitions nor terminate without fulfilling the postcondition specified as guard. For a unique transition plays both the roles of pre and post condition, choosing this modeling scheme would be perfectly appropriate to for expressing exact sequences of method call for which postcondition stands also as the precondition of the next method being called. This could be practical for describing completely known sequences which would be the case for protocols specification. However, considering the annotation of the beginTransaction and commitTransaction methods (which are involved in the transaction process of smart cards) demonstrates in the general case the need to partially specify sequences as methods have to be called in between those two methods. Moreover, this representation is not suitable to express properties dealing with recursion.
As a result, methods will be attached to transition through the definition of method's events. Because transitions are meant to express a logical condition for going from the active state to the next, the FSM model supposes that the transition to take no time for switching. Therefore, events on methods should be define so that to be expressible in transitions. Fortunately, these events appear obvious for they are exactly the one considered in specifying pre and postcondition. First is the method call, which will cause the method to be executed. Second and third are the normal termination invoke by a simple return statement or an exceptional termination triggered by the throw statement. As a consequence, the whole systems evolution will be conditioned by 3 types of event which could stand for any language supporting exceptions.
From what has been defined so far, transitions' role could finally be defined to carrying method's contract and the contribution of states to the model could be clarified. Yet, only two possibilities are offered to specify the contract: either states or transitions have to carry the pre and postconditions. The choice of state invariant to carry this information was discarded right away for the simple reason that a unique description would again stand for sequent post and preconditions. Guards appeared to be more likely to hold the contract for it would link methods' events to their triggering conditions. In other words, taking a transition would mean that the associated method call or return was done with respect to the pre or postcondition. This solution presents the huge advantage of keeping state free to specify invariants in accordance with the meaning a user would give to it. 

\subsection{Implementing the concept}
Because the process of translating automation into high level properties is now known from the reader, it becomes possible to consider the implementation problem. For an input was needed to describe the automatons, the choice of an entry point tool will be discussed first. Next, implementation choices such as the elaboration of data structures and the form of JML statements used will be explained. In conclusion, output files will be described so as to explain how the effective annotation of Java code is performed. All along this part, a rather simple but practical example will be followed so as to show a complete flow of property design.

\subsubsection{Automaton input} 
The first step to have been considered in the implementation phase was the choice of an input for the FSM description. Lots of tools are available for free on the Internet, so that it appeared immediately unnecessary to loose time in building a custom one. Among all possible tool one of the most interesting one was the UML plug-in for Eclipse called Omondo. The most interesting feature about it was precisely that Eclipse used as the unique environment for all the verification flow. Nonetheless, the input given as an XML file seemed very difficult to interpret, as no DTD description was available for it. Fortunately, the tool was implemented for evaluation first, so the choice was made to select another tool also supporting XML format, which would allow to reused our primary implementation and extend it to XML. UPPAAL was therefore selected for its simple FSM representation and the availability of its DTD flat schema. 
Nevertheless, the choice of UPPAAL as input for our properties appeared to be very suitable to our problematic. The most interesting feature of this tool is the native support of multiple uses of automation through an instantiation mechanism. Because in our description automatons are properties, this mechanism should be used profitably to make properties described once reusable. For instance, the specification of no recursive behavior would possibly be extensively reused in some specification from the same or another project. In addition, the efficient separations of concepts the tool kept a XML simple description making it very easy to extract. Moreover, not only is the interface very user-friendly so the user rapidly gets efficient in describing property, but very practical to extract Encapsulated Post Script images (namely '.eps' files) of the property to be used in writing down the specification.

\subsubsection{Generating JML}
Because the contract generated would basically deal with the state variable visibility, it is compulsory to first set up how FSM would be inserted in the code. First of all, methods being constraint by a property may belong to various classes. Hence, it appears practical to describe automatons in dedicate classes instead of inserting it in one random method's class consider for the property. Furthermore, by using the instance names defined by the user himself for naming this class, proof obligations are made more transparent to user. However, the current state of the automaton has to be made public unless they would not be usable inside the method's contract. This is exemplified figure 3 in which is presented the skeleton of automaton class synthesized for the above "NoNestedCall" property. Finally, building a unique modification function for the state would be very practical not only to structure the code but also improve the readability of the JML generated. This part is discussed in the next section.
As automatons are to be represented in isolated classes, all the elements of the description dealing only with this automaton found logically there place inside this class. This is basically the case of local variables, which are used only in the scope of their automaton. Not only would they be placed in this class, but also would they be declared private members of the class so as to restrict to the visibility of these variables strictly to their useful scope. Moreover, a unique modification function would be defined for of these variables in order to improve the structuring of code. For similar reasons, invariants which express properties in close relation with automatons and their local variables had to be included into the class as well. 

Although it is very similar to what was said for local variables, the case of global variables has not been treated yet. The specificity of global variable is that have to be visible at least to several automatons otherwise they would simply be local. Therefore, they visibility should be declared public. Nevertheless, it is important to keep a unique function, now also public, to modify so as to keep the code as structured as possible. Moreover, automatons should be defined inside independent classes in order for global variables not to be inserted in a random class. This is both useful to structuring the code and to avoid interference of local to general variables. Finally, the name of this class could be predefined, as it would be at most only class containing global variables in the whole verification. For the convenience, this class is called by default "GlobalVariables". 

\paragraph{Invariants, update functions}
Although invariants are the easiest properties extractible from the description, they still are useful to emphasize some visibility issues. The invariants expressible with the predefined model basically consist in asserting a conditional property to stand at any time the state specified is active. This logical implication is possible to generate almost by a single copy and paste of the invariant given in the automaton's description. This makes the annotation very easy to produce so-far. Nevertheless, care should be taken not to consider them as real class invariants: first because they do not belong properly to the class. As a result, they are concerned with the visibility issues of private variable. It is therefore necessary to use the $spec\_public$ key word to make them accessible for the spec outside the class. Obviously, this remark stands also the visibility of guards which will encounter the same need for specifying them public to the specification. However, the simple invariant given for the Error state of the "NoNestedCall" property is here below. 

//@ static invariant (state==Error) ==> (false) ;
Building the evolution function of each individual automaton could be constructed by iterating on all transition composing the automaton. In the present case, each transition defines a new possible behaviour of the property. Each transition enriches the evolution function of one statement taking into account not only the guard but also the correct method event. Because the method would be called by each individual method, the function generated has to take into account the current state of the automaton, the guard if any is specified, as well as proper methods' event (namely call, return or throw) which it received as parameter. Later on, this function would have to be implanted after precondition or before postcondition checks have and be used as entry or exit actions. 

Similarly, update functions defined for variables requires gathering information by using regular expressions and iterating on all update fields of the given automatons. Regular expressions have to be used both to identify the variable updated and to isolate how the modification would be performed. Then a new statement in the modification function could be generated to complete the modification function of the identified variable: the modification should obviously be permitted only if the transition is about to be taken, which is analogous to what was said for evolution function. In the case of local variable, the update function is completely constructed once the automaton they belong to has been covered entirely. On the Contrary, global variables need the complete set of properties to be covered to be fully built.

\paragraph{'Modifies' clause}
Although generating a modification clause could be though simple owing to the fact that it deals only with updates, it is actually a lot more complicated than the problems treated so far. Because the modification clause aims to take inventory of all modified variables outside the function, information should gather not only the variables modified by the function itself but also by their sub-function. Because, our model is able to express such sub-function use, these should be considered when generating the modification clause. Nevertheless, what can be generated only depends on the information extractable from the description. In other words, as long as sub-functions are used but not constrained by an automaton description, the modification they introduced would logically not be taken into account. 
As a result of this complexity, the class diagram established while describing the XML parsing had to be refined. Because sub-functions call and return is express through the specification of path inside the automaton, gathering information basically consists in a graph exploration. This introduced the need to enhance the data structure described previously in order to improve the efficiency of the search. Thus, a graph structure was added to the Property, State, and Transition classes. In the mean time, several algorithms adapted to the current exploration problem caused by sub-functions usage were implemented to speed up the analysis. 
Still, generating the 'modifies' clauses remained a difficult problem owing to the difficulty of identifying valid sequences. Being able to identify sub-functions usage requires first being able to identify all valid sequences leading from a call to a return. Sequences are seen from the graph defined above as a simple path which by definition prevents any transition of being used twice. However, it does allow a single state to be used more than once: it is possible for a function to make used of recursive function (namely described by a circuit) before returning. Sequences are asserted to be valid if it is feasible for a method to be called by the first transition of the sequence and to return by its last transition. This criterion was implemented by evaluating the depth of the call stack for any of the simple paths and circuits available between a given call and return. 
However, the exploitation valid sequences allow simply identifying all sub-functions used by a given method. Consequently it would be necessary to wait for all automatons to have been explored and for each individual method to know the variables directly affect to generate correctly the 'modifies' clause. Not doing so might result in incomplete specification since the set of modified variables may not be complete before all properties were covered. Only then, information could be merged to give birth to a correct 'assignable clause'. In performing this operation, care was taken to avoid redundant declarations. 

\paragraph{Pre and postconditions}
Despite of its apparent simple complexity, generating methods contract still is not trivial. Although preconditions are easy to synthesize, the difficult part of the problem stands in expressing a correct postcondition. According to what had been defined in the previous, a postcondition has to take into account the incoming state to assert that a termination is valid. Nevertheless, this is almost not obtainable since the incoming state of our representation is not visible from the postcondition. Because the evolution of the automaton have to be performed before the verification of the postcondition (at least for semantic reasons), this 'incoming' state is not visible. However this state is neither available through the use of the '\old()' JML statement because it only give back the value stored at the time the method was called. Consequently, solutions had to be found to circumvent this problem.
Even if several solutions were conceivable, the effort made to build correct 'modifies' clause strongly orientated the choice of the solution. The first solution considered was both efficient and of the simplest imaginable. It simply consisted in inserting a new variable in the automaton class to represent at each time the value of the state before the evolution function was called for the last time. Nevertheless, a more creative solution was selected, which lead to strengthen the definition of postcondition. Due to the work performed for the modification clause, it is possible to list the entire possible path. Therefore, the postcondition could be directly specified as regard the value of state at the time the function was called. This definition is provably more restrictive since it keeps guarantying a valid state after leaving the function but imposes more restriction on the way used to reach the output state. 

\paragraph{Entry and Exit Actions}
As a conclusion of the generation process, statements have to be generated to perform the entry and exit actions. These actions which will be performed immediately after method's call and right before exiting the method constitutes the mandatory complement to make out model function. These actions basically consist in updating automatons' states as well as global and local variable, for which functions were already implemented. Consequently, for each transition declaring an update while calling or returning from a function a simple statement making use of this function would be generated. 
Nevertheless, these statements are not possible to generate by using only JML. The troubles come from the difficulty to insert entry and exit actions in the code at the appropriate place. More precisely, inserting exit actions before a return state would have no meaning if this return statement makes use of a function (e.g. a statement that would be similar to " return modifyEverthing();"). Besides, the return can even be differed by the use of a finally clause. Furthermore, even if the entry point of a function can be considered known2, the exceptional termination point of the function is not predictable, so that it is impossible to anticipate where the exit statement should be inserted. Although each return or throw statement could be identify, Java can still leave the function by throwing any runtime exception such as a NullPointerException. As long as the use of entry or exit action is not supported by JML language, the recourse to java statement will be unfortunately unavoidable.
As a consequence of the use of Java statements, each individual method constrained would have to endure functional modifications. In order to identify all possible source of interruptions, a global capture clause had to be generated. Though, in order not to modify the application functionally, care should be taken not to forget to throw again the Exception caught. Moreover, the Java structure try{}catch{}finally{}(exemplified in figure 6) appeared to be also had to be used in order to 'catch' also the termination for normal execution. So far, the use of Java statement could be considered an advantage, since these would be easier to insert into the code. However, this would lead to restrictions later on as detailed in the part called 'current" limitations' of the next chapter.

\subsubsection{Output files}
After generating JML all the previous JML statement the effective annotation of code had to be considered resulting in the generation of 2 different files. The first of these two is a ".prop" file dedicated to be used by the propagation tool. As a result, it basically contains the methods definition in association with the contract  extracted from the description. Starting from this, propagation is performed the standard way by users. The second file is made up for gathering the modification of functions due to the need of entry/exit actions. This file basically consists in redefining the function's first and final lines. Nevertheless, no automation is provided yet to place them automatically into the code being verified. Hopefully, this functionality would never have to be coded if new JML statements supporting those actions could be inserted into Jack.
