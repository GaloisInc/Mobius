\label{JavaModellingLanguage}
 This section briefly presents JML and the tools that have been
 developed around it.  JML \cite{LBR00} is a language that allows one to
 specify Java classes by formally expressing properties and
 requirements on those classes and their methods.  Some keywords and
 logical constructions have been added to Java, but the core
 expression language is close to Java.  JML benefits from Java's
 precise semantics.  JML has also been defined so that specifications
 are easy to read and write by Java programmers.  Taking those facts
 into account, many tools have been developed around JML annotations.

\paragraph{Specifying Java applets}
 Figure \ref{JMLexample} presents an example JML specification. The
 language provides keywords to specify:
\begin{itemize}
 \item \textit{Class invariants}: invariants correspond to properties
 on member and class variables that must always hold (from an external
 observer point of view, since invariants are not required to hold
 inside method implementations), and are introduced using the
 \texttt{invariant} keyword.
In the example, the integer \texttt{i} is positive.
 \item \textit{Preconditions}: preconditions are associated to methods, and correspond to properties that must hold in order to
call the method. The \texttt{requires} keyword is used to define
 preconditions. In the example, the method parameter \texttt{c} is
required to be non-null.
 \item \textit{Postconditions}: as preconditions express the properties that must be true when calling a
method, postconditions describes the behavior of the method by
 expressing the properties ensured by the method. They are expressed
 using the \texttt{ensures} keyword.
In the example, the value of \texttt{i} will become 3 for the current
instance and 2 for the parameter \texttt{c}.
 Special postconditions can also be used to describe exceptional behaviors, in particular, when
the method throws an exception. JML uses the special \texttt{exsures}
 keyword to define those special postconditions. In the example, it is
 expressed that the method will not throw any exceptions.
\end{itemize}

Additionally, JML requires specifying which variables can be modified
by a method. This is specified with the \texttt{modifies} keyword.
In the example, it is specified that only the variables
\texttt{i} will be modified for the instances \texttt{this} and
\texttt{c} by the method \texttt{m}.

\begin{figure}[htp]
{\tt
\begin{tabbing}
 \hspace{3 cm} \=cla\=ss  C \{ \\
 \> \> short i; \\
 \> \> //@ invariant i >= 0;\\[2 mm]
 \> \> //@ requires c != null;\\
 \> \> //@ modifies i, c.i; \\
 \> \> //@ ensures i == 3 \&\& c.i == 2; \\
 \> \> //@ exsures (Exception) false; \\
 \> \> voi\=d m(C c) \{\\
 \> \> \> i = 3;\\
 \> \> \> c.i = 2;\\
 \> \> \} \\
 \> \}
\end{tabbing}
}
 \caption{JML example}
\label{JMLexample}
\end{figure}

%This kind of specification is called lightweight.
The language contains more complex constructions that allows one to model more complex behaviors.  Some
realistic examples have already been modeled using JML: the Java Card API \cite{PVBJ00a}, part of the Java
Standard Edition API \cite{HJVB00}, or a banking applet for smart cards \cite{Catano37:FME:2002}.  Those
examples show that using JML is a realistic way to model Java programs, especially with the Java
Card\footnote{Java Card is a standard defined by Sun Microsystems tailored to smart card. It is a subset of
Java.  It does not support threads, multi-dimensional arrays, floating point types, etc.} restrictions.
\paragraph{Tools}
 Before presenting the tool that we have developed, we describe, in
 this section, the other existing tools that are
supporting JML in order to compare them with our approach.
 An overview on tools supporting JML is presented in
 \cite{Leavens-etal00}.  From this time, different new tools have been
 developed and existing tools have been improved.  Three categories
 can be distinguished: runtime checkers, static validation tools and
 proof tools.
\paragraph{Runtime checker} A runtime checker is part of the JML release.
 The JML release consists of different tools:
\begin{itemize}
\item a type-checker, allowing to verify the syntax of the JML
specifications,
\item the \texttt{jmldoc} tool, that is similar to \texttt{JavaDoc}, but adds the JML
specification to the generated html documentation and
\item the \texttt{jmlc} tool \cite{Cheon-Leavens02c}, that uses the JML annotation in
order to add runtime assertions in the generated code.
\end{itemize}
The assertion checking allows running the code with dynamic tests
checking for the correctness of the preconditions, the postconditions
and the invariants.  Thus, problems can be found early, as a
specification violation will generate false assertions, potentially
before introducing a visible runtime error.  \texttt{jmlc} is
integrated with
\texttt{Junit}\footnote{JUnit is a regression testing framework, see
\texttt{http://www.junit.org}} giving \texttt{jmljunit} \cite{Cheon-Leavens02}.  This
tool generates an oracle and skeletons used by \texttt{Junit} to run
test cases.

\paragraph{Static validation tools} The main tool in this category
 is the \ESC\ \cite{PLDI_02*234} static checker for Java.  It performs
 a static analysis of a Java source file in order to check for
 potential errors in the program.  This tool does not aim to provide a
 formal assurance that the verified class is correct.  The spirit of
 \ESC\ is to be a lightweight tool that aims to be used during
 development in order to identify and correct bugs early.  For
 example, it is really efficient to warn about potential null pointer
 usage, and provides counter-examples when a property expressed could
 be erroneous.  An experiment on \ESC\ is notably presented in
 \cite{Catano37:FME:2002}.

\paragraph{Proof tools} This is the category that our tool, \JACK,
 belongs to. The idea behind those tools is to convert the JML
annotated source code into formal models.  Such a conversion allows to
reason mathematically on the program, and to achieve correctness
proofs.  Those proof tools are targeted to Java Card, which does not
contain complex Java features which would be difficult to handle such
as, for example, multi-threading.
\begin{itemize}
 % maybe detail more the LOOP tool using the comments from MH.
 \item The \LOOP\ tool \cite{Jacobs:2001:LJM,Huisman:2000:JPV,denJac01}
 is a tool converting Java annotated sources to PVS models.  It treats
 the complete Java Card language and now proposes an automated proof
 obligation generation using weakest precondition calculus.
 \item The Java Interactive Verification Environment (\texttt{Jive})
 \cite{MeyerP00} aims to also translate JML
 annotated Java in PVS models.  It proposes an interactive environment to
 deal with the proof obligation generation.  Nevertheless, it does not
 handle all the Java Card language.
\item The \texttt{Krakatoa} tool \cite{krakatoa} is the more recent
 one. It aims to translate Java annotated sources into an internal
%INRIA
 language from which proof obligations are generated into Coq\footnote{Coq is a proof assistant developed by the INRIA: \texttt{http://coq.inria.fr}}.
\end{itemize}
 All those tools are actually developed within the VerifiCard\footnote{European IST Project: \texttt{http://www.verificard.org}} project.
 They all have the same goal but approaches are slightly different.
