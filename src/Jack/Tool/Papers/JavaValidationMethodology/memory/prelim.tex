\subsubsection{Java class files} \label{classFileFormat}
The standard format for Java bytecode programs is the so-called class
file format which is specified in the Java Virtual Machine
Specification~\cite{VMSpec}. For the purpose of this paper, it is
sufficient to know that class files contain the definition of a single
class or interface, and are structured into a hierarchy of different
attributes that contain information such as the class name, the name
of its superclass or the interfaces it implements, a table of the
methods declared in the class. Moreover an attribute may contain other
attributes. For example the attribute that describes a single method
contains a \verb!Local_Variable_Table! attribute that describes the
method parameters and its local variables.
%; further in this section we will denote the table of local variables
%by $l$ and the $i^{th}$ variable by $l[i]$.

In addition to these attributes which provide all the information
required by a standard implementation of the JVM, class files can
accommodate user-defined attributes.  We take advantage of this
possibility and introduce additional attributes given in the Bytecode
Specification Language, described below.


\subsubsection{The Bytecode Specification Language}
The {\it Bytecode Specification Language} (BCSL) \cite{LM05:acc} is a
variant of the Java Modelling Language (JML) \cite{JMLRefMan} tailored
to Java bytecode. For our purposes, we only need to consider a
restricted fragment of BCSL, which is given in Fig.~\ref{fig:bml}; we
let $\expression$ and $\predicate$ denote respectively the set of BCSL
expressions and predicates. As for JML, BCSL specifications contain
different forms of statements, in the form of predicates tagged with
appropriate keywords. BCSL predicates are built from expressions using
standard predicate logic; furthermore BCSL expressions are bytecode
programs that correspond to effect-free Java expressions, or BCSL
specific expressions.  The latter include expressions of the form
\verb!\oldp(exp)! which refers to the value of the expression
\verb!exp! at the beginning of the method, or $\mbox{\tt
exp}^{\mbox{{\tt pc}}}$ which refers to the value of the expression
\verb!expr! at program point \verb!pc!. Note that the latter is not
standard in JML but can be emulated introducing a ghost variable
$\mbox{\tt exp}^{\mbox{{\tt pc}}}$ and performing the ghost assignment
\verb!set exp!$\mbox{}^{\mbox{{\tt pc}}}$\verb!= exp! at program point
\verb!pc!.


Statements can be used for the following purposes:
\begin{itemize}
\item Specifying method preconditions, which following the design by
contract principles, must be satisfied upon method invocation. They
are formulated using statements of the form $\requires \ \predicate$;


\item Specifying method postconditions, which must be guaranteed upon
returning normally from the method. Such postconditions are formulated
using statements of the form $\ensures\ \predicate$;

\item Specifying method exceptional postconditions, which must be
guaranteed upon returning exceptionally from the method. Such
postconditions are formulated using statements of the form \\
$\exsures{Exception} \predicate$, that record the reason for
exceptional termination;

\item Stating loop invariants, which are predicates that must hold
every time the program enters the loop: $\invariant\ \predicate$;

\item Guaranteeing termination of loops and recursive methods, using
statements of the form $\variant\ \expression$ which provide a measure (in
the case of BCSL, a positive number) that strictly decreases at each
iteration of the loop/recursive call;


\item Local assertions, using $\assert \ \predicate$, which asserts
that $\predicate$ holds at the program point immediately after the
assertion;

\item Declaring and updating ghost variables, using statements of the
form $\declare \ \ghost \ Type \ name$ and $ \ghostSet \ \expression =
\expression$;


\item Keeping track of variables that are modified by a method or in a
loop, using declarations of the form $\modifies \ var$. During the
generation of verification conditions, one checks that variables that
are not declared as modifiable by the clause above will not be
modified during the execution of the method/loop. This information is
also used to generate the verification conditions.
\end{itemize}

\begin{figure}
%\begin{frameit}
$$
\begin{array}{lll} 
\mbox{\annotation}-{\sf stmt} & = &
                                       \requires \ \predicate \\
                              & \mid & \ensures  \ \predicate  \\
                           & \mid  & \exsures{Exception} \ \predicate  \\
                               & \mid  &  \assert  \ \predicate  \\
                                & \mid & \invariant \  \predicate  \\
                                & \mid & \variant \  \expression  \\
                                & \mid &  \declare \ \ghost \ Type \ name \\
                                 & \mid & \modifies  \ var  \\
                                 & \mid & \ghostSet \ \expression = \expression

\end{array}
$$
\caption{{\sc Specification language}}\label{fig:bml}
%\end{frameit}
\end{figure}

Note that, as alluded above, annotations are not
inserted directly into bytecode; instead they are gathered into
appropriate user defined attributes of an extended class file. Such
extended class files can be obtained either through direct
manipulation of standard class files, or using an extended compiler
that outputs extended class files from JML annotated programs,
see~\cite{LM05:acc}.

\subsubsection{Verification of annotated bytecode}
In order to validate annotated Java bytecode programs, we resort to a
verification environment for Java bytecode, which is an adaptation by
L.~Burdy and the second author~\cite{LM05:acc} of
JACK~\cite{BRL-JACK}. The environment consists of two main
components:
\begin{itemize}
\item A verification condition generator, which takes as input an annotated
applet and generates a set of verification conditions which are sufficient
to guarantee that the applet meets its specification;

\item A proof engine that attempts to discharge the verification
conditions automatically, and then sends the remaining verification
conditions to proof assistants where they can be discharged
interactively by the user.

\end{itemize}


\paragraph{Generating the Verification Conditions}\label{subsec:verification}
The verification condition generator (VCGen) takes as input an
extended class file and returns as output a set of proof obligations,
whose validity guarantees that the program satisfies its
annotations. The VCGen proceeds in a modular fashion in the sense that
it addresses each method separately, and is based on computing weakest
preconditions. More precisely, for every method $\method$,
postcondition $\psi$ that must hold after normal termination of
$\method$, and exceptional postcondition $\psi'$ that must hold after
exceptional termination of $\method$ (for simplicity we consider only
one exception in our informal discussion), the VCGen computes a
predicate $\phi$ whose validity at the onset of method execution
guarantees that $\psi$ will hold upon normal termination, and $\psi'$
will hold upon exceptional termination. The VCGen will then return
several proof obligations that correspond, among other things, to the
fact that the precondition of $\method$ given by the specification
entails the predicate $\phi$ that has been computed, and to the fact
that variants and invariants are correct.


The procedure for computing weakest preconditions is described in
detail in~\cite{LM05:acc}. In a nutshell, one first defines for each
bytecode a predicate transformer that takes as input the
postconditions of the bytecode, i.e. the predicates to be satisfied
upon execution of the bytecode (different predicates can be provided
in case the bytecode is a branching instruction), and returns a
predicate whose validity prior to the execution of bytecode guarantees
the postconditions of the bytecode. The definition of such functions
is based on a single instruction, so the next step is to use these
functions to compute weakest preconditions for programs.  This is done
by building the control flow graph of the program, and then by
computing the weakest preconditions of the program, using the graph.

Note that the verification condition generator operates on BCSL
statements which are built from extended BCSL expressions. Indeed,
predicate transformers for instructions need to refer to the operand
stack and must therefore consider expressions of the form
\verb!st(i)! which represent the \verb!i!-element of the stack \verb!st!.

%$$wp( \store \ l(i) , \psi , \psi') = \psi[\verb!top! \leftarrow \verb!top-1!][l[i] \leftarrow \verb!st(top)!].$$


\paragraph{Discharging verification conditions}
Verification conditions are expressed in an intermediate language and
then translated to automatic theorem provers and proof assistants.  In
our examples, we have used Simplify~\cite{simplify} as automatic
prover and Coq~\cite{coq} as proof assistant. The Coq plug-in for Jack
was developed by J.~Charles, and adapted to Java bytecode by L.~Burdy.


\subsubsection{Correctness of the method}\label{subsec:sound}
The verification method is correct in the sense that one can prove
that for all methods $\method$ of the program the (exceptional)
postcondition of the method holds upon (exceptional) termination of
the method provided the method is called in a state satisfying the
method precondition and provided all verification conditions can be
shown to be valid.


The correctness of the verification method is established relative to
an operational semantics that describes the transitions to be taken by
the virtual machine depending upon the state in which the machine is
executed. There are many formalisations of the operational semantics
of the JVM, see
e.g.~\cite{FM03:jar,KN02:tcs,siv04:jlap,BSS:jbook}. 

%Such semantics manipulate states of the form
%$\config{h,\fram{m,\pc,l,s},\stf}$, where $h$ is the heap of objects,
%$\fram{m,\pc,l,s}$ is the current \emph{frame} and $\stf$ is the
%current call stack (a list of frames). A frame $\fram{m,\pc,l,s}$
%contains a method name $m$ and a program point $\pc$ within $m$, a set
%of local variables $l$, and a local operand stack~$s$.
%%The rule for the generic instruction \instr\ is formalized as a
%The operational semantics for each instruction is formalised as rules specifying transition between states, or between a state and some tag that
%indicates abnormal termination. For example, the semantics of
% the instruction $\store$ is given by the transition
%rule below, where  $\InstAt(m,\pc)$ is the function that extracts
%the $\pc$-th instruction from the body of method $\method$:

%$$\frac{
%%\begin{array}[c]{c}
%\InstAt(m,\pc)=\store \ i
%%\end{array}}%
%}
%{\begin{array}[t]{c}
%\config{h,\fram{m,\pc,l,v::s},\stf} \to_{\store\ i} \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
%\config{h,\fram{m,\pc+1,l[i \mapsto v],s},\stf}
%\end{array}}$$
%In order to establish the correctness of our method, one first needs
%to establish the correctness of the predicate transformer for each
%bytecode. For example for the instruction $\store$ we show that:
%$$\begin{array}[t]{c} 
%wp(\store \ i , \psi )( \config{h,\fram{m,\pc,l,v::s},\stf} ) \ \ \Rightarrow  
%\\
%\psi( \config{h,\fram{m,\pc+1,l[i \mapsto v],s},\stf})
%\end{array}$$
%In the above $\psi(\config{h,\fram{m,\pc,l,v::s},\stf} )$ is to be
%understood as the instance of the formula $\psi$ in which all local
%variables $l$ and field references are substituted with their
%corresponding values in state $\config{h,\fram{m,\pc,l,v::s},\stf} $.


%The proof proceeds by a case analysis on the instruction to be
%executed, and makes an intensive use of auxiliary substitution
%lemmas that relate e.g. the stack of the pre-state with the stack
%of the post-state of executing an instruction. Then one proves the
%correctness of the method by induction on the length of the
%execution sequence.

We have proved the correctness of our method for a fragment of the JVM
that includes the following constructs: Stack manipulation: \push,
\pop, \dup, \dup 2, \swap, \numop, etc; Arithmetic instructions:
type\_\add, type\_\sub, etc; Local variables manipulation:
type\_\load, type\_\store, etc; Jump instructions: \If, \goto; Object
creation and object manipulation: \new, \putfd, \getfd, \newarray,
etc; Array instructions: \arrst, \arrld, etc; Method calls and return:
\invvir, \return; Subroutines: \jsr\ and \ret.

Note however that our method imposes some mild restrictions on the
structure of programs: for example, we require that $\jsr$ and
$\throw$ instructions are not entry for loops in the control flow
graph in order to prevent pathological recursion.  Lifting such
restrictions is left for future work.

