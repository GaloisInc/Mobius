\newcommand{\compil}[2]{\overline{#1}^{#2}}

\newcommand{\compilp}[1]{{\cal C}(#1)}


\chapter{Conclusion} 

The work in this task has led to the development of methodologies and
tools that help developers improve the reliability of their code
without affecting their productivity. The tool is integrated in a
widely used developer environment, namely Eclipse, and provides access
to a range of techniques that bring increasing levels of reliability.
The methodology and the tool have been used satisfactorily for a
number of purposes, but should be improved further to enhance its
applicability.

Future work should address limitations of the JML technology, and
increase support for automation, both at the level of specification
and verification. In addition, future work should also provide support
for refinement in JML, as well as for using automated testing
techniques for proof obligations that have not been discharged
automatically.


\paragraph{API annotation}
While the proof obligation generator is largely independent of the
underlying dialect of Java and of the underlying profile, it relies on
annotated APIs. In our work, we have found convenient to focus on
smartcard case studies and thus we have been unable to use annotated
JavaCard APIs that were developed by the University of Nijmegen.
However, there are no comprehensively annotated API outside of the
JavaCard API, even if previous work on GlobalPlatform security
requirements done at INRIA could be used to annotate a Java
implementation of GlobalPlatform. A major issue in adapting our method
to Trusted Personal Devices will be to annotate the APIs provided by
INSPIRED. Such a task is labour-intensive, but on the other hand it
only has to be performed once, and thus an expert can be used for this
purpose.

\paragraph{Annotation assistants}
Automated support for annotating programs is of great benefit to allow
program verification to scale to larger programs. Integrating existing
tools that generate specific annotations in JACK would greatly improve
its usefulness. Two lines of work should be pursued independently:
first, one should integrate tools that generate general-purpose
annotations, such as defensive specifications that prevent run-time
exceptions, loop invariants, class invariants or object invariants.
Second, one should pursue the work on generating annotations from 
high-level security properties.


\paragraph{Support for reasoning about programs}
Despite having shown its usefulness of a variety of case studies, the
JML technology is still under development, and many technical issues
remain to be solved. For example, JML is currently not appropriate for
reasoning on complex data-structures such as linked-lists or trees
because no global property on these structures can be stated in JML.
This limitation of JML is related to the first-order logic on which
JML is based and that prevents complex quantification over structures
or predicates. Another severe restriction of current JML verification
tools is the limited support they provide for reasoning about
concurrent programs.  There are some ongoing efforts at Iowa, Kansas,
and Santa Cruz to extend JML with support for reasoning about
multi-threaded programs, but at the time of writing no tool support
has been provided, and it is not clear how the logic relates to the
Java Memory Model.



\paragraph{Combining static verification with test and run-time checking}
While automated provers are rather successful in discharging proof
obligations, there remain cases where proof obligations have to be
proved interactively, or checked. Both options are costly in term of
time invested on establishing the validity of the proof obligation,
and it should be possible to resort to more automatic techniques, such
as testing, that is well-established for increasing reliability of
smartcard obligations. There have been many works that study the
generation of test cases from JML annotated programs, see
e.g.~\cite{jll04:ase}. This promising line of work should be pursued
and better integrated with proofs, in the sense that tests should only
focus on unproved obligations. A more ambitious goal would be to refine
annotations according to the results of testing.


\paragraph{Support for refinement}




