\chapter{Evaluations}
\section{Industrial evaluation: Oberthur}
\section{Industrial evaluation: Axalto}
\section{Bytecode Verifier}
The tools have also been tested on a bytecode verifier java implementation. A termination proof has been provided.
A specific implementation has been coded with on one hand the main loop which remain unchanged whatever the specifications of the virtual machine Java chosen, and other instructions and memory states which depends on selected model.
The main loop is in a package which contains abstract classes: 
the instructions and the states are implemented in a more generic way.
The package containing the implementation is composed from the instructions for the standard Java types and of the states of memory typing. 
\subsection {Memory states}
The memory states are represented by the State class, which is an abstract class.  It does not contain any precise definition of the memory: 
one has no information on the stack or on the local variables table. 
The implementation is relatively simple: 
it is a class which contains a type stack and a table of the types of the local variables. 
Functions allowing to read simply these structures and to generate verification error in the cases of misuse are defined.   
\subsection{Instructions}
The instructions are also represented by an abstract class: 
the class Instruction.  
Since in the Kildall algorithm each instruction is associated to a memory state,  the Instruction class has a field of the State type. 
An instruction can also have one or more successors. 
This relation is represented by a field which is the list of the successors of the instruction.  
One of the other aspects is the fact that on associate to each instruction a boolean field to determine if it has been modified or not.

Several propreties of the bytecode verifier are for;alised in this class.
First of all one verifies that the successors of the instruction are well included in the others instructions of the program. 
If these successors pointed towards external instructions, an verification error would be returned. 

The others important properties concern the pure function {\tt buildNewState}.
This function builds the typing state of the execution of an instruction  on the current state.
This construction can fail if the instruction tries for example to pop an element when the stack is empty.
If it succeeds, a new non null state is build.

Around ten instructions have been implementeds:  {\tt load} and {\tt blind} for the access to local variables, {\tt push} and {\ ttpop}   to obtain or put element on the stack, {\tt op1} and {\ ttop2} which is two operators who consume both the two top element of the stack and which replaces them by a eesultat of a certain type, {\tt ifle} and {\tt jump} instructions of jump towards another instruction successor, {\tt nop}  the instruction which does not do anything   and finally {\tt stop} which is an instruction which does not have a successor.
These instructions have an associated type in the OperandType class,
who can be None, Type1 or Type2.  Those are the minimal instructions to have a Java-like program.  
\subsection {The main loop}
The main loop is implementes in the Verifier class.
It is not an abstract class because it uses the properties of the State and Instruction abstract classes  to verify an instruction set on particular states.
This class provides two functions, the function  {\ tt verify} in which the loop is written and the function {\ tt check} which verify an instruction.

%The m \ 'ethode check ensures that all \ 'states of the successors of an instruction donn \ 'ee,    are larger or \ 'equal that the \ 'states before the ex \ 'ecution of the m \ 'ethode. This   propri \ 'and \ 'E seems simple \ `has to express but it implies several Pr \ 'erequis.  First of all it should be guaranteed that the successors of the instructions point all worms of   valid instructions. Then that all the instructions are diff \ 'erentes of no one and that theirs  \ 'states are too diff \ 'erents of no one them.    The Pr \ calculation weaker 'econdition of Jack forces us \ `has to add these propri \ 'and \ 'be    Li \ 'ees \ `with the S \ 'emantic of the language Java.  .   %Pour to facilitate the evidence I have \ 'and \ 'E oblig \ 'E  %de to add a certain number of assertions.    

The {\ tt verify} method is the main loop of the bytecode verifier.
It contains two nested loops. 
The internal one is a {\tt for} loop which iterates on the instructions  and verify all the quoted instructions (as described in the Kildall algorithm). 
The termination of the internal loop is easy to prove.
The {\tt for} loop executes as many time as there are numbers in the table.
The external {\tt while} loop stops the algorithm when no more instruction typing state is modified.
This termination is not obvious to prove, especially with JML, since it only allow to prove loop termination by giving an integer variant.

Since the states have to be used to show the algorithm termination,  
one has to make correspond each state  with an integer. 
Thus at each loop iteration, the integer associated with the state either increase or preserve the same value; and it exists a maximum value.


\begin{figure}[ht]  
\begin{center}    
\begin{tabular}{p {0.4 \textwidth} c c c c}  
{\bf Classes:} & State & Instruction & Verifier \\  
{\bf Lines of code:} & 14 & 47 & 66 \\  
{\bf Lines of annotations:} & 20 & 54 & 81 \\  \raggedright 
{\bf Proof obligations:} & 26 & 129 & 627 \\  \raggedright 
{\bf Automatically proved proof obligations:} & 17 & 93 & 112 \\  
{\bf Average length of a non-automatic proof:} & 3 & 6 & 12 \\    
\end{tabular}  
\end{center}  
\caption{Some statistics on proof}  
\label{stats}  
\end{figure}    
\subsection{Proofs}
The first proofs are relatively easy. 
The State class is proven almost automatically; 
except for the constructor where it is necessary to break a disjunction ({\tt instance S $\vee$ S = null}) to prove the invariants.

The Instruction class has also been relatively easy to prove. 
A significant number of proof was done automatically (approximately 90 \%); 
then majority of proof could be trivially resolved, except some lemma concerning  a loop termination.    

Finally the Verifier class was harder to prove.
The lemmas were containing too many hypotheses to be automatically proved.
Around 500 proof obligations have to be resolved manually.
Some of them was obvious and were resolved with quite the same script, but the script cannot be automated.
Some of them was complex: the proof script became little large (an average of 30 steps).
The lemmas conerning the loop invariant of the verify method and its initialisation were the most difficult.
\section{Low-Footprint Java-to-Native Compilation}
\input{cardis05/cardis05}
\section{Memory consumption}
%\subsection{Introduction}
\input{memory/intro}
%\subsection{Preliminaries}\label{sec:prelim}
%\input{memory/prelim}
\subsection{Modelling memory consumption}\label{sec:verif}
\input{memory/technical}
\subsection{Inferring memory allocation}\label{sec:infer}
\input{memory/infer}
%\subsection{Conclusion}\label{sec:conc}
%\input{memory/conclusion}
\section{Test coverage}
