\chapter{Evaluations}
\section{Industrial evaluation: Oberthur}
\section{Industrial evaluation: Axalto}
The new version of Jack (i.e. 1.8, then 1.8.1) has been evaluated on the 
Payflex case study with the automatic mode using Simplify combined with 
the interactive mode using Coq.\\

Relevant changes on the Coq mode include :
\begin{itemize}
\item the transitivity relation for subtypes is now explicit :
      as a result, proofs about the payflex file system are better handled
      when one must decide whether a file of type T is also of type T' 
or not.
  \item  the display of proof obligation hypothesis is clearer and more 
readable than on previous version
  \item an prototype editor for coq inside Eclipse has been developed. It 
can be used as an   
      alternative to ProofGeneral or CoqIDE.
  \item the use of pure (i.e. side-effect free) method calls in JML 
annotations  is better handled:
      the method call is no longer automatically replaced by its 
postcondition, instead it is    
      displayed as a Java method call and the user can unfold it when 
desired (as is done in the
      Krakatoa tool for instance)
  \item JML model variables (i.e. used for specification purpose only) are 
now well supported.
\end{itemize}

\noindent Other add-in :
one can use some methods declared with the keyword 'native' (it is 
not standard JML) in annotations.These methods are native with respect to a particular prover, that is they must be defined directly in the prover.\\
      That is a way to develop some 'specification libraries' to reuse 
when needed.\\ 
      This is still very experimental and only works for Coq for the 
moment. No way to exploit this feature in our case
     study has been found yet.\\

It seems no improvement has been done on the Simplify mode as the rate 
of proof obligations fulfilled
 automatically in our case study did not change.

\paragraph{JML}
Another aspect is the work we continue on the JML specification of the
JC applet in general (as the tool uses as input the JML
specification). Some theoretical results on the verification of
specific properties have been obtained, and a paper has been issued on
the subject\cite{Rousset}. We start the development of a tool with
graphical interface to assist the writing of annotations:\\ From an
UML class diagram or the code itself of an application, it proposes
some specification patterns to the user (non-null by default for
references, ranges for variable of integer type and arrays length),
then translation to adequate class invariants and method preconditions
is performed. In practice, annotations generated in that manner reveal
sufficient to prove that each method 'does not go wrong' (i.e. is
runtime error free) and all the verification conditions are filled in
automatic mode with Simplify using tools like Krakatoa or Jack.


\section{Bytecode Verifier}
The tools have also been tested on a bytecode verifier java implementation. A termination proof has been provided.
A specific implementation has been coded with on one hand the main loop which remain unchanged whatever the specifications of the virtual machine Java chosen, and other instructions and memory states which depends on selected model.
\subsection{Implementation and Modelisation}
The main loop is in a package which contains abstract classes: 
the instructions and the states are implemented in a more generic way.
The package containing the implementation is composed from the instructions for the standard Java types and of the states of memory typing. 
\subsubsection {Memory states}
The memory states are represented by the State class, which is an abstract class.  It does not contain any precise definition of the memory: 
one has no information on the stack or on the local variables table. 
The implementation is relatively simple: 
it is a class which contains a type stack and a table of the types of the local variables. 
Functions allowing to read simply these structures and to generate verification error in the cases of misuse are defined.   
\subsubsection{Instructions}
The instructions are also represented by an abstract class: 
the class Instruction.  
Since in the Kildall algorithm each instruction is associated to a memory state,  the Instruction class has a field of the State type. 
An instruction can also have one or more successors. 
This relation is represented by a field which is the list of the successors of the instruction.  
One of the other aspects is the fact that on associate to each instruction a boolean field to determine if it has been modified or not.

Several properties of the bytecode verifier are formalised in this class.
First of all one verifies that the successors of the instruction are well included in the others instructions of the program. 
If these successors pointed towards external instructions, an verification error would be returned. 

The others important properties concern the pure function {\tt buildNewState}.
This function builds the typing state of the execution of an instruction  on the current state.
This construction can fail if the instruction tries for example to pop an element when the stack is empty.
If it succeeds, a new non null state is build.

Around ten instructions have been implemented:  {\tt load} and {\tt blind} for the access to local variables, {\tt push} and {\tt pop}   to obtain or put element on the stack, {\tt op1} and {\tt op2} which is two operators who consume both the two top element of the stack and which replaces them by a result of a certain type, {\tt ifle} and {\tt jump} instructions of jump towards another instruction successor, {\tt nop}  the instruction which does not do anything   and finally {\tt stop} which is an instruction which does not have a successor.
These instructions have an associated type in the OperandType class,
who can be None, Type1 or Type2.  Those are the minimal instructions to have a Java-like program.  
\subsubsection {The main loop}
The main loop is implemented in the Verifier class.
It is not an abstract class because it uses the properties of the State and Instruction abstract classes  to verify an instruction set on particular states.
This class provides two functions, the function  {\tt verify} in which the loop is written and the function {\tt check} which verify an instruction.

%The m \ 'ethode check ensures that all \ 'states of the successors of an instruction donn \ 'ee,    are larger or \ 'equal that the \ 'states before the ex \ 'ecution of the m \ 'ethode. This   propri \ 'and \ 'E seems simple \ `has to express but it implies several Pr \ 'erequis.  First of all it should be guaranteed that the successors of the instructions point all worms of   valid instructions. Then that all the instructions are diff \ 'erentes of no one and that theirs  \ 'states are too diff \ 'erents of no one them.    The Pr \ calculation weaker 'econdition of Jack forces us \ `has to add these propri \ 'and \ 'be    Li \ 'ees \ `with the S \ 'emantic of the language Java.  .   %Pour to facilitate the evidence I have \ 'and \ 'E oblig \ 'E  %de to add a certain number of assertions.    

The {\ tt verify} method is the main loop of the bytecode verifier.
It contains two nested loops. 
The internal one is a {\tt for} loop which iterates on the instructions  and verify all the quoted instructions (as described in the Kildall algorithm). 
The termination of the internal loop is easy to prove.
The {\tt for} loop executes as many time as there are numbers in the table.
The external {\tt while} loop stops the algorithm when no more instruction typing state is modified.
This termination is not obvious to prove, especially with JML, since it only allow to prove loop termination by giving an integer variant.

Since the states have to be used to show the algorithm termination,  
one has to make correspond each state  with an integer. 
Thus at each loop iteration, the integer associated with the state either increase or preserve the same value; and it exists a maximum value.


\begin{figure}[ht]  
\begin{center}    
\begin{tabular}{p {0.4 \textwidth} c c c c}  
{\bf Classes:} & State & Instruction & Verifier \\  
{\bf Lines of code:} & 14 & 47 & 66 \\  
{\bf Lines of annotations:} & 20 & 54 & 81 \\  \raggedright 
{\bf Proof obligations:} & 26 & 129 & 627 \\  \raggedright 
{\bf Automatically proved proof obligations:} & 17 & 93 & 112 \\  
{\bf Average length of a non-automatic proof:} & 3 & 6 & 12 \\    
\end{tabular}  
\end{center}  
\caption{Some statistics on proof}  
\label{stats}  
\end{figure}    
\subsection{Proofs}
The first proofs are relatively easy. 
The State class is proved almost automatically; 
except for the constructor where it is necessary to break a disjunction ({\tt instance S $\vee$ S = null}) to prove the invariants.

The Instruction class has also been relatively easy to prove. 
A significant number of proof was done automatically (approximately 90 \%); 
then majority of proof could be trivially resolved, except some lemma concerning  a loop termination.    

Finally the Verifier class was harder to prove.
The lemmas were containing too many hypotheses to be automatically proved.
Around 500 proof obligations have to be resolved manually.
Some of them was obvious and were resolved with quite the same script, but the script cannot be automated.
Some of them was complex: the proof script became little large (an average of 30 steps).
The lemmas concerning the loop invariant of the verify method and its initialization were the most difficult.
\section{Low-Footprint Java-to-Native Compilation}
\input{cardis05/cardis05}
\section{Memory consumption}
%\subsection{Introduction}
\input{memory/intro}
%\subsection{Preliminaries}\label{sec:prelim}
%\input{memory/prelim}
\subsection{Modeling Memory Consumption}\label{sec:verif}
\input{memory/technical}
\subsection{Inferring Memory Allocation}\label{sec:infer}
\input{memory/infer}
%\subsection{Conclusion}\label{sec:conc}
%\input{memory/conclusion}
%\section{Test coverage}
