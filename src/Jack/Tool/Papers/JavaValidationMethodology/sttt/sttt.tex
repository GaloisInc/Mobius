
JML~\cite{Leavens-Baker-Ruby99b,Leavens-Baker-Ruby03}, the
``Java Modeling Language'', is useful for specifying detailed
designs of Java classes and interfaces.  JML is a behavioral interface
specification language for Java; that is, it specifies both the behavior
and the syntactic interface of Java code.  The syntactic interface of
a Java class or interface consists of its method signatures,
the names and types of its fields, etc.
This is what is commonly meant by an application programming
interface (API).
The behavior of such an API can be precisely documented in JML annotations;
these describe the intended way that programmers should
use the API.  In terms of behavior, JML can detail, for example, the
preconditions and postconditions for methods as well as class
invariants.

An important goal for the design of JML is that it should be easily
understandable by Java programmers. This is achieved by staying as
close as possible to Java syntax and semantics.  Another important
design goal is that JML {\em not} impose any particular design method
on users; instead, JML should be able to document Java programs
designed in any manner \cite{Leavens-Baker-Ruby03}.

The work on JML was started by Gary Leavens and his colleagues and
students at Iowa State University, but has grown into a cooperative,
open effort.  Several groups worldwide are now building tools that
support the JML notation and are involved with the ongoing design of
JML\@.  The open, cooperative nature of the JML effort is important
both for tool developers and users, and we welcome participation by
others.  For potential users, the fact that there are several tools
supporting the same notation is clearly an advantage.  For tool
developers, using a common syntax and semantics can make it much
easier to get users interested. After all, one of the biggest hurdles
to using a new specification-centric tool is often the lack of
familiarity with the associated specification language.

\medskip

The next section introduces the JML notation.  Sections~\ref{tools}
through \ref{toolsEnd} then discuss the tools currently available for
JML in more detail.  Section~\ref{applications} discusses the
applications of JML in the domain of Java Card, the Java dialect for
programming smartcards.  Section~\ref{related} discusses some related
languages and tools, such as OCL and other runtime assertion checkers,
and Section~\ref{conclusions} concludes.

%=====================================================================
\subsection{The JML Notation}
\label{notation}

JML blends Eiffel's Design by Contract approach~\cite{Meyer97} with
the Larch~\cite{Guttag-Horning93} tradition (and others that space
precludes mentioning).  Because JML supports quantifiers such as
\verb_\forall_ and \verb_\exists_, and because JML allows ``model''
(i.e., specification-only) fields and methods, specifications can
easily be made more precise and complete than is typical for Eiffel software.
However, like Eiffel, JML uses Java's expression syntax in assertions,
thus JML's notation is easier for programmers to learn than notations
based on a language-independent specification language, like the Larch Shared
Language~\cite{Leavens-Baker-Ruby03,Leavens-etal03a} or
OCL~\cite{WarmerKleppe99}.

%% Note that I have used the newly specified constructor to illustrate
%% a point about ESC/Java below, so beware if you try to save space by
%% deleting it. -- Gary

\begin{figure*}
{\small
\verbatiminput{Purse.java}}
\caption{\label{example}Example JML specification}
\end{figure*}

Figure~\ref{example} gives an example of a JML specification that
illustrates its main features.  JML assertions are written as special
annotation comments in Java code,
either after \verb_//@_ or between \verb_/*@ ... @*/_,
so that they are ignored by Java compilers but can be used
by tools that support JML\@.  Within annotation comments JML extends the
Java syntax with several keywords---in the example in
Figure~\ref{example}, the JML keywords {\tt invariant}, {\tt
  requires}, {\tt assignable}, {\tt ensures}, and {\tt signals} are
used.  It also extends Java's expression syntax with several
operators---in the example \verb_\forall_, \verb_\old_, and
\verb_\result_ are used; these begin with a backslash so they do not
clash with existing Java identifiers.

The central ingredients of a JML specification are preconditions
(given in {\tt requires} clauses), postconditions (given in {\tt
  ensures} clauses), and (class and interface) invariants.  These are
all expressed as boolean expressions in JML's extension to Java's
expression syntax.

In addition to ``normal'' postconditions, the language also supports
``exceptional'' postconditions, specified in {\tt signals} clauses.
These can be used to specify what must be true when a method throws an
exception.  For example, the {\tt signals} clause in
Figure~\ref{example} specifies that {\tt debit} may throw a {\tt
  PurseException}, and, in that case, the balance will not change (as
specified by the use of the \verb+\old+ keyword).

The {\tt assignable} clause for the method {\tt debit} specifies a
frame condition, namely that {\tt debit} will assign to only the {\tt
  balance} field.  Although not a traditional part of design by
contract languages like Eiffel, such frame conditions are essential for
verification of code when using some of the tools described later.

\medskip

There are many additional features of JML that are not used in the
example in Figure~\ref{example}. We briefly discuss the most important
of these below.

%% [[[I wonder if, in this journal version, the model variable
%% feature of JML deserves a more systematic treatment. -- Gary]]]
\begin{itemize}
\item Model variables, which play the role of abstract values for
  abstract data types~\cite{Cheon-etal03}, allow specifications that
  hide implementation details.
  For example, if instead of a class {\tt Purse}, we were specifying
  an interface {\tt PurseInterface}, we could introduce the balance as
  such a model variable.  A class implementing this interface could
  then specify how this model field is related to the class's
  particular representation of balance.
  
\item An extensive library that provides Java types that can be used
  for describing behavior mathematically.  This library includes such
  concepts as sets, sequences, and relations.  It is similar to
  similar libraries of mathematical concepts found in VDM, Z, LSL, or
  OCL, but allows such concepts to be used directly in assertions,
  since they are embodied as Java objects.
  
\item A semantics that prevents side-effects in assertions.  This
  both allows assertion checks to be used safely during debugging, and
  supports mathematical reasoning about assertions.
  This semantics works conservatively, by allowing a method to only be
  used in assertions only if it is declared as 
  {\tt pure}, meaning the method does not have any side-effects and
  does not perform any input or output \cite{Leavens-Baker-Ruby03}.
%\footnote{Unfortunately, some methods that one would like to be pure,
%  such as String's equals method, are not.  This is a topic of current
%  research.}
  For example, if there is a method {\tt getBalance()} that is
  declared as {\tt pure},
\begin{verbatim}
  /*@ pure @*/ int getBalance() { ... }
\end{verbatim}
  then this method can be used in the specification instead of the field
  {\tt balance}.
\item Finally, JML supports all the Java modifiers ({\tt public},
  {\tt protected}, and {\tt private}) for expressing visibility.  For
  example, invariants can be declared {\tt protected} if
  they are not observable by clients but intended for use by
  programmers of subclasses.  (Technically, the invariants and method
  specifications in the Purse example of Figure~\ref{example} have default
  or package visibility, and thus would only be visible to code in the
  same package.)
\end{itemize}

%=====================================================================
\subsection{Tools for JML}
\label{tools}

For a specification language, just as for a programming language, a
range of tools is necessary to address the various needs of the
specification language's users such as reading, writing, and checking
JML annotations.\footnote{Most of these tools rely upon an underlying
  tool that type checks a Java program and its JML specification.}


%% Isn't some transition text necessary here, as we jump right into the
%% detailed discussion of each of these tools without a prelude?
%% -- Joe
%% [[[How's this?  -- Gary]]]

The rest of this paper describes the various tools that are currently
available for JML.  The following categorization serves also as an
organization for the immediately following sections of this paper.

\smallskip

\begin{itemize}
\item {\bf Runtime assertion checking and testing:}
\begin{itemize}
\item One way of checking the correctness of JML specifications is by
  runtime assertion checking, i.e., simply running the Java code and
  testing for violations of JML assertions.  Such runtime assertion
  checks are accomplished by using the JML compiler {\tt jmlc}
  (Section~\ref{jmlc}).
\item Given that one often wants to do runtime assertion checking in
  the testing phase, there is also a {\tt jmlunit} tool
  (Section~\ref{jmlunit}) which combines runtime assertion checking
  with unit testing.
\end{itemize}
\item {\bf Static checking and verification:} More ambitious than
  testing if the code satisfies the specifications at runtime, is
  verifying that the code satisfies its specification statically.
  Verifying a specification gives more assurance in the correctness of
  code as it establishes the correctness for all possible execution paths,
  whereas runtime assertion checking is limited by the execution paths
  exercised by the test suite being used.  Of course, correctness of a
  program with respect to a given specification is not decidable in
  general.  A verification tool must trade off the level of automation
  it offers (i.e., the amount of user interaction it requires) and the
  complexity of the properties and code that it can handle.  There are
  several tools for statically checking or verifying JML assertions
  providing different levels of automation and supporting different
  levels of expressivity in specifications.
\begin{itemize}
\item The program checker ESC/Java (Section~\ref{escjava}) can
  automatically detect certain common errors in Java code and check
  relatively simple assertions.
\item ESC/Java2 (Section~\ref{escjava2}) extends ESC/Java
  to support more of the JML syntax and to add other functionality.
\item The CHASE tool (Section~\ref{Chase}) checks some aspects of
  frame conditions.
\item The LOOP tool (Section~\ref{loop}) translates JML-annotated code
  to proof obligations that one can then try to prove using the
  theorem prover PVS\@.  The LOOP tool can handle more complex
  specifications and code than automatic checkers like ESC/Java can,
  but at the price of more user interaction.
\item Krakatoa~\cite{krakatoa03a} is similar to LOOP, but integrates
  with the Coq theorem prover.  It is currently under development and
  handles a subset of Java.
\item The program checker JACK (Section~\ref{jack}) offers similar
  functionality to ESC/Java, but is more ambitious in attempting real
  program verification.
\end{itemize}

\item {\bf Generating specifications: } In addition to
  these tools for checking specifications, there are also tools that
  help a developer write JML specifications, with the aim of reducing
  the cost of producing JML specifications.
\begin{itemize}
\item The Daikon tool (Section~\ref{daikon})
  infers likely invariants by observing the runtime behavior
  of a program.
\item The Houdini tool (Section~\ref{houdini}) postulates annotations
  for code, then uses ESC/Java to check them.
\item The {\tt jmlspec} tool can produce a skeleton of a
  specification file from Java source and can compare the interfaces of
  two different files for consistency.
\end{itemize}

\item {\bf Documentation}: Finally, in spite of all the tools
  mentioned above, ultimately human beings must 
  read and understand JML specifications.  The {\tt jmldoc} tool
  (Section~\ref{jmldoc}) helps the reading process by producing
  browsable HTML from JML 
  specifications, in the style of Javadoc.  The resulting HTML is a
  convenient format for reading large bodies of JML specifications.

\end{itemize}

\subsection{Documentation Generation}
\label{jmldoc}

%% Why is this a separate subsection here, if it was just discussed
%% above?  I suggest moving (some of) this discussion up into the item
%% above. -- Joe

Since JML specifications are meant to be read and written by ordinary
Java programmers, it is important to support the conventional ways
that these programmers create and use documentation.  Consequently,
the {\tt jmldoc} tool (authored by David Cok)
produces browsable HTML pages containing both the
API and the specifications for Java code, in the style of pages
generated by Javadoc~\cite{Friendly95}.

This tool reuses the parsing and checking performed by the JML checker
and connects it to the doclet API underlying Javadoc.  In this way,
\texttt{jmldoc} remains consistent with the definition of JML and
creates HTML pages that are very familiar to a user of Javadoc.  The
{\tt jmldoc} tool combines and displays in one place all of the
specifications that pertain to a given class, interface, method, or
field; it combines annotations across a series of source files that
constitute successive refinements of a given class or interface, as
well as the relevant specifications of overridden methods.

%=====================================================================
\subsection{Runtime Assertion Checking and Testing}

\subsubsection{Runtime Assertion Checking}
\label{jmlc}

The JML compiler (\texttt{jmlc}), developed at Iowa State University,
is an extension to a Java compiler and compiles Java programs
annotated with JML specifications into Java
bytecode~\cite{Cheon03,Cheon-Leavens02b}.  The compiled bytecode includes
runtime assertion checking instructions that check JML specifications
such as preconditions, normal and exceptional postconditions,
invariants, and history constraints.  The execution of such assertion
checks is transparent in that, unless an assertion is violated, and
except for performance measures (time and space), the behavior of the
original program is unchanged.  The transparency of runtime assertion
checking is guaranteed, as JML assertions are not allowed to have any
side-effects~\cite{Leavens-etal03a}.

The JML language provides a rich set of specification facilities to
write abstract, complete behavioral specifications of Java program
modules~\cite{Leavens-etal03a}.  It opens a new possibility in runtime
assertion checking by supporting abstract specifications written in
terms of specification-only declarations such as model fields, ghost
fields, and model methods.  Thus the JML compiler represents a
significant advance over the state of the art in runtime assertion
checking as represented by Design by Contract tools such as
Eiffel~\cite{Meyer97}, or by Java tools such as
iContract~\cite{Kramer98} or Jass~\cite{Bartetzko-etal01}.  The
\texttt{jmlc} tool also supports advances such as (stateful) interface
specifications, multiple inheritance of specifications, various forms
of quantifiers and set comprehension notation, support for strong and
weak behavioral subtyping~\cite{Liskov-Wing94,Dhara-Leavens96}, and a
contextual interpretation of undefinedness~\cite{Leavens-etal03a}.

In sum, the JML compiler brings ``programming benefits'' to formal
interface specifications by allowing Java programmers to use JML
specifications as practical and effective tools for debugging,
testing, and design by contract.

\subsubsection{Unit Testing}
\label{jmlunit}

A formal specification can be viewed as a test
oracle~\cite{Peters-Parnas98,Antoy-Hamlet00}, and a runtime assertion
checker can be used as the decision procedure for the test
oracle~\cite{Cheon-Leavens02}.  This idea has been implemented as a
unit testing tool for Java (\texttt{jmlunit}), by combining JML with
the popular unit testing tool JUnit~\cite{Beck-Gamma98}.  The
\texttt{jmlunit} tool, developed at Iowa State University, frees the
programmer from writing most unit test code and significantly
automates unit testing of Java classes and interfaces.

The tool generates JUnit test classes that rely on the JML runtime
assertion checker.  The test classes send messages to objects of the
Java classes under test.  The testing code catches assertion violation
errors from such method calls to decide if the test data violate the
precondition of the method under test; such assertion violation errors
do not constitute test failures.  When the method under test satisfies
its precondition, but otherwise has an assertion violation, then the
implementation failed to meet its specification, and hence the test
data detects a failure~\cite{Cheon-Leavens02}.  In other words, the
generated test code serves as a test oracle whose behavior is derived
from the specified behavior of the class being tested.  The user is
still responsible for generating test data; however the test classes
make it easy for the user to supply such test data. In addition, the
user can supply hand-written JUnit test methods if desired.

Our experience shows that the tool allows us to perform unit testing
with minimal coding effort and detects many kinds of errors.
Ironically, about half of our test failures were caused by
specification errors, which shows that the approach is also useful for
debugging specifications.  In addition, the tool can report assertion coverage
information, identifying assertions that are always true or always
false, and thus indicating deficiencies in the set of test cases.
However, the approach requires specifications to be fairly complete
descriptions of the desired behavior, as the quality of the generated
test oracles depends on the quality of the specifications. Thus, the
approach trades the effort one might spend in writing test cases for
effort spent in writing formal specifications.

%\section{Static Techniques for JML}
%\label{static}
%
%More ambitious than {\em testing} if the code satisfies the specifications
%at runtime, by doing runtime assertion checking, is
%{\em verifying} that the code
%satisfies its specifications statically.
%This can give more assurance in the correctness of code:
%verification establishes the correctness for all possible inputs,
%unlike runtime assertion checking, which is always limited by the test
%suite being used.
%
%Correctness of a program with respect to
%a given specification is not decidable in general.
%A verification tool must trade off the level of automation the tool
%offers (i.e., the amount of user interaction it requires)
%and the expressiveness of the properties and code that it can handle.
%There are several tools for verification of JML assertions,
%that provide different levels of automation
%and support different levels of expressivity in specifications.

%=====================================================================
\subsection{Static Checking and Verification}
\label{toolsEnd}

\subsubsection{Extended Static Checking with ESC/Java}
\label{escjava}

ESC/Java tool~\cite{Flanagan-Et-Al02}, developed at Compaq Research,
performs what is called ``extended static
checking''~\cite{ESC:Overview,10yearsESC},
% KRML: I would prefer \emph{extended static checking}, but such a
% change would probably require similar changes to other places of the
% document where double quotes are used.  For example, one would
% probably change ``model'' in:
%     JML allows ``model'' (i.e., specification-only) fields
% to \emph{model}.  Ditto for ``candidate annotations'' below.
% [[[I'd also like that... -- Gary]]]
compile-time checking that goes well beyond type checking.  It can
check relatively simple assertions and can check for certain kinds of
common errors in Java code, such as dereferencing \texttt{null},
indexing an array outside its bounds, or casting a reference to an
impermissible type.  ESC/Java supports a subset of JML and also checks
the consistency between the code and the given JML annotations.  The
user's interaction with ESC/Java is quite similar to the interaction
with the compiler's type checker: the user includes JML annotations in
the code and runs the tool, and the tool responds with a list of
possible errors in the program.

JML annotations affect ESC/Java in two ways.  First, the given JML
annotations help ESC/Java suppress spurious warning messages.  For
example, in Figure~\ref{example}, the constructor's
precondition \texttt{p != null} lets ESC/Java determine that the
dereference of \texttt{p} in the constructor's body is valid, and thus
ESC/\-Java produces no \texttt{null}-dereference warning.  Second,
annotations make ESC/\-Java do additional checks.  For example,
when checking a caller of the \texttt{Purse} constructor, the
precondition \texttt{p != null} causes ESC/Java to emit a warning if
the actual parameter for \texttt{p} may be passed in as \texttt{null}.
In these two ways, the use of JML annotations enables ESC/Java to
produce warnings not at the source locations where errors manifest
themselves at runtime, but at the source locations where the errors
are committed.

An interesting property of ESC/Java is that it is neither sound nor
complete; that is, it neither warns about all errors, nor does it
warn only about actual errors.  This is a deliberate design choice:
the aim is to increase the cost-effectiveness of the tool.  In some
situations, convincing a mechanical checker of the absence of some
particular error may require a large number of JML annotations
(consider, for example, a hypothetical program that dereferences
\texttt{null} if four of the program's large-valued integer variables
satisfy the equation in Fermat's Last Theorem).  To make the tool more
cost-effective, it may therefore be prudent to ignore the possibility
of certain errors, which is what ESC/Java has been designed to do.
The ESC/Java User's Manual~\cite{escjava:userman} contains a list of
all cases of unsoundness and incompleteness in ESC/Java.

Under the hood, ESC/Java is powered by detailed program semantics and
an automatic (non-interactive) theorem prover.  ESC/Java translates a
given JML-an\-no\-tat\-ed Java program into verification
conditions~\cite{LeinoSaxeStata:JavaViaGC,FlanaganSaxe:POPL01},
logical formulas that are valid if and only if the program is free of
the kinds of errors being analyzed.  Any verification-condition
counterexamples found by the theorem prover are turned into
programmer-sensible warning messages, including the kind and source
location of each potential error.  The ESC/Java User's
Manual~\cite{escjava:userman} also provides a detailed description of
the semantics of JML annotations, as they pertain to ESC/Java.

\subsubsection{ESC/Java2}
\label{escjava2}

Development of version 1 of ESC/Java ceased with the dissolving of the
SRC group at Compaq.  Consequently Cok and Kiniry have in progress a
version 2 of ESC/Java, built on the source code release provided by
Compaq and HP.  This version has the following goals:
\begin{itemize}
\item to migrate the code base of ESC/Java and the code accepted by
  ESC/Java to Java 1.4;
\item to update ESC/Java to accept annotations consistent with current
  version of JML;
\item to increase the general use of the tool by packaging it in an
  easy-to-use form;
\item to increase the amount of JML that ESC/Java statically checks,
  consistent with the original engineering goals of ESC/Java;
\item and, over time, to update the associated tools of the ESC suite
  (Calvin, Houdini, RCC) in a similar manner.
\end{itemize}

There is currently an alpha version of ESC/Java2 available
(from \url{http://www.cs.kun.nl/ita/research/} 
\url{projects/sos/projects/escjava.html}).
This release includes the following improvements with respect to the original
ESC/\-Java.

%% [[[I worried that the following had too much detail for most
%% readers. I'm especially thinking about the second point below,
%% which detailed all the features of JML that are not thoroughly type
%% checked. I edited to try to correct this. --Gary]]]

\begin{itemize}
\item Parses Java 1.4 (the old version only parsed Java 1.3). 
  In particular ESC/Java2 handles the Java
  \verb$assert$ statement.  The user has the option of treating the
  statement as in Java, namely, as a conditional statement that
  might throw an exception.  Alternatively, ESC/Java2 will translate
  the Java \verb$assert$ statement into a JML \verb$assert$ statement,
  producing a static warning if the condition in the
  statement appears not to be always true.
\item Parses all of current JML.  This is a somewhat moving target,
  since JML is the subject of current discussion and research.
  Nevertheless the core part of JML is stable and that is the portion
  that ESC/Java2 attempts to statically check.  Some
  of the more esoteric features of JML (e.g. model programs)
  % the clauses in the \verb$code_contract$
  % section, the resource clauses \verb$\working_space$, \verb$space$,
  % \verb$\duration$, and the frame and datagroup features)
  are only parsed, are not thoroughly type checked, and are ignored for
  purposes of static checking.
\item Allows specifications to be placed in (multiple) files separate from the
  implementation, using JML's refinement features.  ESC/Java2 makes checks
  using the appropriate combination of all available specifications and
  implementations.  It also checks these specifications for consistency.
\item Follows the JML semantics for specification inheritance.
  The constructs specific to ESC/Java version 1
  (\verb$also_requires$, etc.)
  % \verb$also_ensures$, \verb$also_modifies$, and \verb$also_exsures$).
  were dropped.
\end{itemize}

Many other details in the static checking have also been improved in
ESC/Java2, making it more suitable for general use.

%% [[[Cut text below:]]]
%   The integration and inheritance of
%   \verb$non_null$ annotations was also improved.
% \item The static checking provided in ESC/Java has been expanded in
%   ESC/Java2 in these ways: checking of the \texttt{assert} statement;
%   checking of \texttt{initially} and \texttt{constraint} clauses;
%   improvements in handling \texttt{modifies} (\texttt{assignable})
%   clauses; checking of \verb$\not_modified$ expressions; allowing and
%   checking the application of \verb$\typeof$ to primitive types;
%   handling of \texttt{forall} and \texttt{old} method specification
%   clauses.

There are two major areas of development of ESC/\-Java2 that will
improve overall usability of the tool, besides performance
improvements.  The first is the use of model variables and method
calls in annotation expressions.  Model variables are an important
abstraction mechanism in writing specifications and model methods
allow much more readable and compact specifications.  This is a
current topic of research and experimentation and some partial
facilities in this direction are a part of the current alpha release
of ESC/Java2.

The second important needed advance is to provide some level of
checking of the frame conditions (i.e., JML's \texttt{modifies} or
\texttt{assignable} clauses).  It is an acknowledged unsoundness of
ESC/Java that these are not checked and faulty \texttt{modifies}
clauses can be a subtle source of errors.  In particular, the default
\texttt{modifies} clause in some JML specifications is that everything
is potentially modified; this interpretation is not currently
implemented.

\subsubsection{Chase}
\label{Chase}

The CHASE tool highlights the complementary nature of the tools
available for JML.  As previously mentioned, one source of unsoundness
of ESC/Java is that it does not check {\tt assignable} clauses.  The
semantics of these frame axioms are also not checked by the JML
compiler.  The CHASE tool~\cite{CH03} tries to remedy these problems.
It performs a syntactic check on {\tt assignable} clauses, which, in
the spirit of ESC/Java, is neither sound nor complete, but which spots
many mistakes made in the user's {\tt assignable} clauses.  This is another
example of the utility of a common language; developers can reap the
benefits of complementary tools.
(The latest JML tools from Iowa State are also incorporating some of this
functionality.) 
%% \footnote{Current work on ESC/Java by David Cok and Joe Kiniry intends
%%   to added checking of \texttt{assignable} clauses.}

\subsubsection{Program Verification with LOOP}
\label{loop}

The University of Nijmegen's LOOP tool~\cite{Jacobs-etal98,Huisman01}
translates JML-annotated Java code into proof obligations for the
theorem prover PVS~\cite{OwreRRSS96}.  One can then try to prove these
obligations, interactively, in PVS\@.  The translation from JML to
formal proof obligations builds on a formal semantics for sequential
Java that has has been formalized in PVS, and which has been extended
to provide a formal semantics for a large part of JML\@.  The
verification of the proof obligations is accomplished using a Hoare
Logic~\cite{JacobsPoll01a} and a weakest-precondition
calculus~\cite{Jacobs03} for Java and JML\@.

Interactive theorem proving is very labor-intensive, but allows
verification of more complicated properties than can be handled by
extended static checking with ESC/Java.  A recent paper describing a
case study with the LOOP tool, giving the best impression of the state
of the art, is now available~\cite{BreunesseBJ02}.

%% It seems there isn't enough to say about this to justify its own section.
% \subsection{Krakatoa}
% \label{krakatoa}
% 
% Krakatoa~\cite{krakatoa03a} is a
% program verification tool for JML-annotated code that is currently
% under development.  It is similar to LOOP, but produces proof
% obligations for the theorem prover Coq\authcomment{Add citation}, and
% currently covers only a subset of Java.

\subsubsection{Static Verification with JACK}
\label{jack}

The JACK~\cite{JACK} tool has been developed at the research lab
of Gemplus, a manufacturer of smartcards and smartcard software.  JACK
aims to provide an environment for Java and Java Card program
verification using JML annotations.  It implements a fully automated
weakest precondition calculus in order to generate proof obligations
from JML-annotated Java sources. Those proof obligations can then be
discharged using a theorem prover.  Currently the proof obligations
are generated for the B-Method's prover~\cite{Abrial96}.

The approach taken in JACK is somewhere between the approaches of ESC/Java and
LOOP, but probably closer to LOOP than to ESC/Java; JACK tries to
provide the best features of both of these tools.
On the one hand, JACK is much more
ambitious than ESC/Java, in that it aims at real program verification
rather than just extended static checking, and JACK does not make all
the assumptions that result in soundness issues in ESC/Java, some of
which were made to speed up checking.  On the other hand, JACK does
not require its users to have expertise in the use of a theorem prover
as LOOP does.

An important design goal of the JACK tool is to be usable by normal
Java developers, allowing them to validate their own code.  Thus, care has
been taken to hide the mathematical complexity of the
underlying concepts, and JACK provides a dedicated proof obligation
viewer. This viewer presents the proof obligations as execution paths
within the program, highlighting the source code relevant to the proof
obligations. Moreover, goals and hypotheses are displayed in a
Java/JML-like notation.  To allow developers to work in a familiar
environment, JACK is integrated as a plug-in in the
%% [[[KRML: Is there an appropriate~\cite for Eclipse, perhaps one
%% mentioning this URL?  JRK: I think it isn't even necessary, as
%% Eclipse is a widely known, non-academic IDE\@.  Also, we didn't/won't
%% include a cite for jContract either.]]]
popular Eclipse\footnote{\url{http://www.eclipse.org}} IDE\@.

As earlier mentioned, JACK provides an interface to the automatic
theorem prover of the Atelier B toolkit. The prover can usually
automatically prove up to 90\% of the proof obligations; the remaining
ones have to be proved outside of JACK, using the classical B proof
tool.  However, JACK is meant to be used by Java developers, who
cannot be expected to use the B proof tool.  Therefore, in addition to
the proved and unproved states, JACK adds a ``checked'' state, that
allows developers to indicate that they have manually checked the
proof obligation. In order to better handle those cases, other
different approaches could be investigated, such as integration with
test tools such as {\tt jmlunit}, integration of other proof
assistants, or perhaps support from a proof-expert team.

%% I made this last paragraph more general to wrap up this section
%% in a more complete fashion. -- Joe

\vspace{0.5cm}

%% [[[I don't understand the ``Despite using formal techniques,''
%% below. -- Gary.]]]
Despite using formal techniques, the goals of ESC/Java and JACK are not
only to allow formal methods experts to prove Java program
correctness, but also to allow Java programmers to obtain high
assurance of code correctness.  We believe that this may be a way to
let non-experts venture into the formal world.

%=====================================================================
\subsection{Generating Specifications} 

\subsubsection{Invariant Detection with Daikon}
\label{daikon}

Most tools that work with JML assume the existence of a JML
specification, then verify code against the specification.  Writing
the JML specification is left to a programmer.  Because this task can
be time-consuming, tedious, and error-prone, the Daikon invariant
detector~\cite{Ernst2000:PhD,ErnstCGN2001:TSE} provides assistance in
creating a specification.  Daikon outputs observed program properties
in JML syntax (as well as other output formats) and automatically inserts
them into a target program.

The Daikon tool dynamically detects likely program invariants.  In
other words, given program executions, it reports properties that were
true over those executions.  The set of reported properties is also
known as an ``operational abstraction.''  Invariant detection operates
by observing values that a program computes at runtime, generalizing
over those values, and reporting the resulting properties.  The
properties reported by Daikon encompass numbers ($x \le y$, $y=ax+b$),
collections ($x \in \mathit{mytree}$, $\mathit{mylist}$ {\it is
  sorted\/}), pointers ($\mathit{n} = \mathit{n.child.parent}$),
and conditionals ($\mathit{if\,} p \neq \mathit{null\; then\; p.value}
> x$); a complete list appears in the Daikon user manual.  Daikon is
available at {\small\url{http://pag.lcs.mit.edu/daikon/}}.  Several
other implementations of dynamic invariant detection
exist~\cite{HangalL02,PytlikRKR2003,HenkelD2003}, but they do not
presently produce output in JML format.

Like any dynamic analysis, the accuracy of the inferred invariants
depends in part on the quality and completeness of the test cases, and
other executions may falsify some of the reported properties.
(Furthermore, the actual behavior of the program is not necessarily
the same as its intended behavior.)  However, Daikon uses static
analysis, statistical tests, and other mechanisms to reduce the number
of false positives~\cite{ErnstCGN2000:Relevance}.  Even if a property
is not true in general, Daikon's output provides valuable information
about the test suite over which the program was run.  Combining
invariant detection with a static verifier such as ESC/Java helps to
overcome the problems of both techniques: the unsoundness of the
dynamic analysis and the static analysis's need for annotations.

Even with modest test suites, Daikon's output is remarkably accurate.
In one set of experiments~\cite{NimmerE02:ISSTA}, over 90\% of the
properties that it reported were verifiable by ESC/Java (the other
properties were true, but were beyond the capabilities of ESC/Java),
and it reported over 90\% of the properties that ESC/Java needed in
order to complete its verification.  For example, if Daikon generated
100 properties, users had only to delete less than 10 properties and
to add another 10 properties in order to have a verifiable set of
properties.  In another experiment~\cite{NimmerE02:FSE}, users who
were provided with Daikon output (even from unrealistically bad test
suites) performed statistically significantly better on a program
verification task than did users who did not have such assistance.

In addition to aiding the task of static checking as described above,
operational abstractions generated by the Daikon invariant detector
have been used to generate and improve test
suites~\cite{HarderME03,XieN2003:ASE,GuptaH2003}, to automate
theorem-proving~\cite{NeWinE02:TR841,NeWinEGKL04:STTT}, to identify
refactoring opportunities~\cite{KataokaEGN01}, to aid program
analysis~\cite{DodooDLE02,DodooLE2003:TR}, and to to detect anomalies
and bugs~\cite{RazKS2002,GroceV2003,Brun2003}, among other uses.

\subsubsection{Inferring annotations with Houdini}
\label{houdini}

An obstacle to using program verification tools such as ESC/Java on
legacy code is the lack of annotations in such a program.  The
warnings
% that ESC/Java then produces
more likely point out missing annotations than errors in the code.
The Houdini tool~\cite{Flanagan-Et-Al01,Houdini-theory:IPL} attempts
to alleviate this problem by supplying many of the missing
annotations.

Houdini works by making up ``candidate annotations'' for the given
program.  These candidate annotations compare fields and array lengths
to -1, 0, 1, constants used in array constructors, \texttt{null},
\texttt{true}, and \texttt{false} (depending on the type of the
field), and indicate that arrays and subarrays contain no null
elements.  To find which of the candidate annotations hold for the
program, Houdini repeatedly invokes ESC/Java, removing those candidate
annotations that ESC/Java finds to be inconsistent with the code.
When all remaining candidate annotations are consistent with the code,
Houdini invokes ESC/Java a final time to produce warnings that are
then presented to the user.  Houdini thus retains the precision of
ESC/Java, trading quick turnaround for a reduced annotation effort.

Note that any user-supplied JML annotations in the program still get
used by Houdini, since they become part of each invocation of
ESC/Java.  Thus, the benefits of using JML annotations are the same
for Houdini as for ESC/Java, but Houdini can find program errors from
a smaller set of user-supplied JML annotations.

%=====================================================================
\subsection{Applications of JML to Java Card}
\label{applications}

Although JML is able to specify arbitrary sequential Java programs,
most of the serious applications of JML and JML tools up to now
have targeted Java Card.  Java Card$^{TM}$ is a dialect of Java specifically
designed for the programming of the latest generation of smartcards.
Java Card is adapted to the hardware limitations of smartcards; for
instance, it does not support floating point numbers, strings, object
cloning, or threads.

Java Card is a well-suited target for the application of formal
methods.  It is a relatively simple language with a restricted API\@.
Moreover, Java Card programs, called ``applets'', are small, typically
on the order of several KBytes of bytecode.  Additionally, correctness
of Java Card programs is of crucial importance, since they are used in
sensitive applications such as bank cards and mobile phone SIMs.  (An
interesting overview of security properties that are relevant for Java
Card applications is available~\cite{MarletLM01}.)

JML, and several tools for JML, have been used for Java Card,
especially in the context of the EU-supported project VerifiCard
(www.verificard.org).  JML has been used to write a formal
specification of almost the entire Java Card
API~\cite{PollBergJacobs01}.  This experience has shown that JML is
expressive enough to specify a non-trivial existing API\@.  The
runtime assertion checker has been used to specify and verify a
component of a smartcard operating system~\cite{PollHarteldeJong02}.

ESC/Java has been used with great success to verify a realistic
example of an electronic purse implementation in Java
Card~\cite{CatanoHuisman02}. This case study was instrumental in
convincing industrial users of the usefulness of JML and feasibility
of automated program checking by ESC/Java for Java Card applets.  This
provided the motivation for the development of the JACK tool discussed
earlier, which is specifically designed for Java Card programs.  One
of the classes of the electronic purse mentioned above has provided
the most serious case study to date with the LOOP
tool~\cite{BreunesseBJ02}.

As witnessed by the development of the JACK tool by Gemplus, Java Card
smartcard programs may be one of the niche markets where formal
methods have a promising future. Here, the cost that companies are
willing to pay to ensure the absence of certain kinds of bugs is quite
high.  It seems that, given the current state of the art, using static
checking techniques to ensure relatively simple properties (e.g., that
no runtime exception ever reaches the top-level without being caught)
seems to provide an acceptable return-on-investment.  It should be
noted that the very simplicity of Java Card is not without its
drawbacks.  In particular, the details of its very primitive
communication with smartcards (via a byte array buffer) is not easily
abstracted away from.  It will be interesting to investigate if J2ME (Java 2
Micro Edition), which targets a wider range of electronic consumer
products, such as mobile phones and PDAs, is also an interesting
application domain for JML\@.

%=====================================================================
\subsection{Related Work}
\label{related}

\subsubsection{Other runtime assertion checkers}

Many runtime assertion checkers for Java exist, for example, Jass,
iContract, and Parasoft's jContract, to name just a few.  Each of
these tools has its own specification language, thus specifications
written for one tool do not work in any other tool.  And while some of
these tools support higher-level constructs such as quantifiers, all
are quite primitive when compared to JML\@.  For example, none include
support for purity specification and checking, model methods,
refinements, or unit test integration.  The developers of Jass have
expressed interest in moving to JML as their specification language.

%% We explained in Section~\ref{jmlc} why we believe that the JML
%% provides a significant advance in expressivity versus such design by
%% contract tools.

\subsubsection{JML vs.\ OCL}

Despite the similarity in the acronyms, JML is {\em very} different in
its aims from UML~\cite{RumbaughJacobsonBooch98}.
The most basic difference is that the UML aims to cover all phases of
analysis and design with many notations, and tries to be independent
of programming language, while JML only deals with detailed designs
(for APIs) and is tied to Java.  The ``model'' in
JML refers to abstract, specification-only fields that can be used to
describe the behavior of various types.  By contrast, the ``model'' of
UML refers to the general modeling process (analysis and design) and
is not limited to abstractions of individual types.
%% [[[Text cut, as it's incorporated above in a better form, I
%% hope. -- Gary]]]
% Unlike UML, which attempts
% to have notations for all phases of the analysis and design process,
% JML has the much more modest aim of describing the behavior of Java
% classes and interfaces and recording detailed design and
% implementation decisions.

JML does have some things in common with the Object Constraint
Language (OCL)~\cite{WarmerKleppe99}, which is part of the UML
standard.  Like JML, OCL can be used to specify invariants and pre-
and postconditions.  An important difference is that JML explicitly
targets Java, whereas OCL is not specific to any one programming
language.  One could say that JML is related to Java in the same way
that OCL is related to UML\@.

JML clearly has the disadvantage that it can not be used for, say, C++
programs, whereas OCL can.  But it also has obvious advantages when it
comes to syntax, semantics, and expressivity.  Because JML sticks to
the Java syntax and typing rules, a typical Java programmer will
prefer JML notation over OCL notation, and, for instance, prefer to
write (in JML):
\begin{verbatim}
     invariant pin != null && pin.length == 5;
\end{verbatim}
rather than the OCL:
\begin{verbatim}
     inv: pin <> null and pin->size() = 5
\end{verbatim}

JML supports all the Java modifiers such as {\tt static}, {\tt
  private}, {\tt public}, etc., and these can be used to record
detailed design decisions for different readers.
Furthermore, there are legal Java
expressions that can be used in JML specifications but that cannot be
expressed in OCL\@.
%% [[[Like what?  Can we give an example?]]]
% Thus JML can specify more details about Java programs than would be
% possible in OCL\@.

More significant than these limitations, or differences in syntax, are
differences in semantics.  JML builds on the (well-defined) semantics
of Java. So, for instance, {\tt equals} has the same meaning in JML
and Java, as does {\tt ==}, and the same rules for overriding,
overloading, and hiding apply.  One cannot expect this for OCL\@.  In
fact, a semantics for OCL was only recently
proposed~\cite{brucker.ea:proposal:2002}.

In all, we believe that a language like JML, which is tailored to
Java, is better suited for recording the detailed design of a Java
programs than a generic language like OCL\@.  Even if one uses UML in
the development of a Java application, it may be better to use JML
rather than OCL for the specification of object constraints,
especially in the later stages of the development.

%=====================================================================
\subsection{Conclusions}
\label{conclusions}

We believe that JML presents a promising opportunity to introduce
formal specification to industry.  It has the following strong points:

\begin{enumerate}
\item JML is {\em easy to learn} for any Java programmer, since its
  syntax and semantics are very close to Java.
  
  We believe this a crucial advantage, as the biggest hurdle to
  introducing formal methods in industry is often that people are not
  willing, or do not have the time, to learn yet another language.
  
\item There is no need to invest in the construction of a formal model
  before one can use JML\@. Or rather: the source code {\em is} the
  formal model.  This brings two further advantages:
  \begin{itemize}
  \item It is easy to introduce the use of JML {\em gradually}, simply
    by adding the odd assertion to some Java code.
  \item JML can be used {\em for existing} (legacy) code and APIs.
    Indeed, most applications of JML and its tools to date
    (e.g.,~\cite{BreunesseBJ02,CatanoHuisman02,PollBergJacobs01}) have
    involved existing APIs and code.
  \end{itemize}

\item There is a (growing) availability of a wide range of tool
      support for JML\@.
\end{enumerate}

Unlike B, JML does not impose a particular design method on its users.
Unlike UML, VDM, and Z, JML is tailored to specifying both the syntactic
interface of Java code and its behavior.
Therefore, JML is better suited than these alternative languages
for documenting the detailed design of existing Java programs.

\smallskip

As a common notation shared by many tools, JML offers users multiple
tools supporting the same notation.  This frees them from having to
learn a whole new language before they can start using a new tool.
The shared notation also helps the economics both for users and tool
builders.  Any industrial use of formal methods will have to be
economically justified, by comparing the costs (the extra time and
effort spent) against the benefits (improvements in quality, number of
bugs found).  Having a range of tools, offering different levels of
assurance at different costs, makes it much easier to start using JML\@.
One can begin with a technique that requires the least time and effort
(perhaps runtime assertion checking) and then move to more
labor-intensive techniques if and when that seems worthwhile, until
one has reached a combination of tools and techniques that is
cost-effective for a particular situation.

%% [[[From reviewer #1: The JML effort comprises tools that have been
%% specifically developed for it ( jml, jmlunit, jmldoc,...) and
%% previously existing tools that have been adapted to JML (daikon,
%% ESC/Java,...). It should be clear that for this project to work, it is
%% important to achieve a seamless integration of these tools. It may be
%% a good idea to add a few comments on the problems the authors have
%% faced to integrate these tools, and the degree of integration they
%% have achieved so far.]]]

\smallskip

There are still many opportunities for further development of both the
JML language and its tools.  For instance, we would also like to see
support for JML in integrated development environments
(such as Eclipse) and integration with other kinds of static
checkers.  We believe that, as a common language, JML can provide an
important vehicle to transfer more tools and techniques from academia
to industry.

%% [[[JRK: add references for these issues or not?
%% EP Let's not: we seem to have plenty of references already.]]]

More generally, there are still many open issues involving the
specification of object-oriented systems that the JML effort is
investigating.  When exactly should 
invariants hold? % \cite{Mueller-Poetzsch-Heffter-Leavens03a}?
How should concurrency properties be specified?
JML's specification inheritance forces behavioral subtyping
\cite{Dhara-Leavens96,Leavens-Baker-Ruby03}, but subtyping in
Java is used for implementation inheritance as well; is it practical
to always weaken the specifications of supertypes enough so that their
subtypes are behavioral subtypes?
There are also semantics issues with frame axioms, pure
methods, and aliasing. % \cite{Mueller-Poetzsch-Heffter-Leavens03}.

The subtleties involved in such open problems are evidenced by the slightly
different ways in which different tools approach these problems.
This reflects the research (as opposed to industrial development)
focus of most of those involved in JML and its tools.
Nevertheless, JML seems to be successful in providing a common
notation and a semantics that is, at least for a growing core subset,
shared by many tools.  These commonalities provide value
to both tool developers and users.

