%=====================================================================
\section{Tools for JML}
\label{tools}

For a specification language, just as for a programming language, a
range of tools is necessary to address the various needs of the
specification language's users such as reading, writing, and checking
JML annotations.

This section describes the various tools that are currently
available for JML.

\subsection{Documentation Generation}
\label{jmldoc}

Since JML specifications are meant to be read and written by ordinary
Java programmers, it is important to support the conventional ways
that these programmers create and use documentation.  Consequently,
the {\tt jmldoc} tool (authored by David Cok)
produces browsable HTML pages containing both the
API and the specifications for Java code, in the style of pages
generated by Javadoc~\cite{Friendly95}.

The {\tt jmldoc} tool combines and displays in one place all of the
specifications that pertain to a given class, interface, method, or
field; it combines annotations across a series of source files that
constitute successive refinements of a given class or interface, as
well as the relevant specifications of overridden methods.

%=====================================================================
\subsection{Runtime Assertion Checking}
\label{jmlc}

The JML compiler (\texttt{jmlc}), developed at Iowa State University,
is an extension to a Java compiler and compiles Java programs
annotated with JML specifications into Java
bytecode~\cite{Cheon03,Cheon-Leavens02b}.  The compiled bytecode includes
runtime assertion checking instructions that check JML specifications
such as preconditions, normal and exceptional postconditions,
invariants, and history constraints.  The execution of such assertion
checks is transparent in that, unless an assertion is violated, and
except for performance measures (time and space), the behavior of the
original program is unchanged.  The transparency of runtime assertion
checking is guaranteed, as JML assertions are not allowed to have any
side-effects~\cite{Leavens-etal03a}.

\subsection{Unit Testing}
\label{jmlunit}

A formal specification can be viewed as a test
oracle~\cite{Peters-Parnas98,Antoy-Hamlet00}, and a runtime assertion
checker can be used as the decision procedure for the test
oracle~\cite{Cheon-Leavens02}.  This idea has been implemented as a
unit testing tool for Java (\texttt{jmlunit}), by combining JML with
the popular unit testing tool JUnit~\cite{Beck-Gamma98}.  The
\texttt{jmlunit} tool, developed at Iowa State University, frees the
programmer from writing most unit test code and significantly
automates unit testing of Java classes and interfaces.

The tool generates JUnit test classes that rely on the JML runtime
assertion checker.  The test classes send messages to objects of the
Java classes under test.  The testing code catches assertion violation
errors from such method calls to decide if the test data violate the
precondition of the method under test; such assertion violation errors
do not constitute test failures.  When the method under test satisfies
its precondition, but otherwise has an assertion violation, then the
implementation failed to meet its specification, and hence the test
data detects a failure~\cite{Cheon-Leavens02}.  In other words, the
generated test code serves as a test oracle whose behavior is derived
from the specified behavior of the class being tested.  The user is
still responsible for generating test data; however the test classes
make it easy for the user to supply such test data. In addition, the
user can supply hand-written JUnit test methods if desired.

%=====================================================================
\subsection{Invariant Detection with Daikon}
\label{daikon}

Most tools that work with JML assume the existence of a JML
specification, then verify code against the specification.  Writing
the JML specification is left to a programmer.  Because this task can
be time-consuming, tedious, and error-prone, the Daikon invariant
detector~\cite{Ernst2000:PhD,ErnstCGN2001:TSE} provides assistance in
creating a specification.  Daikon outputs observed program properties
in JML syntax (as well as other output formats) and automatically inserts
them into a target program.

The Daikon tool dynamically detects likely program invariants.  In
other words, given program executions, it reports properties that were
true over those executions.  The set of reported properties is also
known as an ``operational abstraction.''  Invariant detection operates
by observing values that a program computes at runtime, generalizing
over those values, and reporting the resulting properties.  The
properties reported by Daikon encompass numbers ($x \le y$, $y=ax+b$),
collections ($x \in \mathit{mytree}$, $\mathit{mylist}$ {\it is
  sorted\/}), pointers ($\mathit{n} = \mathit{n.child.parent}$),
and conditionals ($\mathit{if\,} p \neq \mathit{null\; then\; p.value}
> x$).  

Like any dynamic analysis, the accuracy of the inferred invariants
depends in part on the quality and completeness of the test cases, and
other executions may falsify some of the reported properties.
(Furthermore, the actual behavior of the program is not necessarily
the same as its intended behavior.)  However, Daikon uses static
analysis, statistical tests, and other mechanisms to reduce the number
of false positives~\cite{ErnstCGN2000:Relevance}.  Even if a property
is not true in general, Daikon's output provides valuable information
about the test suite over which the program was run.  

