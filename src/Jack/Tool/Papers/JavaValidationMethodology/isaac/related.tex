\section{Related Work}\label{SecRelated}

Our approach to enforce security policies relies on the combination of:
%\begin{inparaenum}[i)]
%\item 
an annotation assistant that generates JML annotations from 
high-level security properties,
%\item 
a proof obligation generator for annotated
applets, using \emph{e.g.} a weakest precondition calculus, and
%\item
an automated or interactive theorem prover to discharge all 
generated proof obligations.
%\end{inparaenum}
Experience suggests that our approach provides accurate and automated
analyses that may handle statically a wide range of security properties. 

%It is to
%be contrasted with some other approaches to enforce security policies
%statically, in particular:
%\begin{itemize}
%\item program analyses, which are fully automatic, but whose results are
%often hard to exploit due to a high rate of spurious warnings; and
%\item type systems, implemented by automatic type inference
%engines, but usually tailored towards a single property,
%\emph{e.g.}~\/confidentiality or availability, and often too 
%restrictive to be used in practice.
%\end{itemize}
Proof-carrying code~\cite{Necula97} provides another appealing
solution to enforce security policies statically, but it does not
directly address the problem of obtaining appropriate specifications
for the code to be downloaded.  In fact, our mechanism may be used in
the context of proof-carrying code as a generator of verification
conditions from high-level security properties.


Run-time monitoring provides a dynamic measure to enforce safety and
security properties, and has been instrumented for Java through a
variety of tools, see
\emph{e.g.}~\/\cite{bartetzko01assertions,BratKPV00,TKL03:rv}.
Security automata provide another means to specify security policies
and to monitor program executions. Different forms of automata (edit
automata, truncation automata, insertion automata, \emph{etc.}) have
been proposed, to prevent or react against violations of security
policies, see
\emph{e.g.}~\cite{Schneider99,wal00:popl,HMS03:tr,Erlingsson03}. Inspired
by aspect-oriented programming, Colcombet and Fradet~\cite{CF00:popl}
propose a technique to compose programs in a simple imperative
language with optimised security automata. However, run-time
monitoring is not an option for smart card applications, in particular
because of the card's limited resources.

 
%Leaving the application domain of security policies and focusing on
%program specification and verification techniques, one encounters
%annotation assistants, such as Daikon and Houdini. But these tools
%synthesise simple safety annotations and functional invariants,
%without being guided by user input---in our case, the security
%properties are user input. Further apart, one encounters testing,
%which remains the technique most commonly used by the smart card
%industry to guarantee the quality of applications. However,
%testing cannot guarantee that an application complies to its security
%policy, because the program is only tested on sample values; in fact,
%program verification techniques have been shown to discover subtle 
%programming errors that remain undetected by intensive testing.
