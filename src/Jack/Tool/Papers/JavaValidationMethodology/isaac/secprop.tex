\subsection{High-level Security Properties for Applets}  \label{SecHighLevelSecProp}

% However, as these applications should be
%able to share information, this raises big challenges for the security
%of smart cards. Moreover, one would like that a smart card holder
%dynamically can download new applications, while the card is already
%out in the field, which of course raises even more security
%issues. 

Over the last years, smart cards have evolved from proprietary into
open systems, making it possible to have applications from different
providers on a single card. To ensure that these applications cannot
damage the other applications or the card itself, strict security
policies---expressed as high-level security properties---must be
obeyed.  Such properties are high-level in the sense that they have
impact on the whole application and are not restricted to single
classes. Below we will present several examples. It is important to
notice that we restrict our attention to source code-level security of
applications.

The properties that we consider can be divided in several groups,
related to different aspects of smart cards. First of all there are
properties dealing with the so-called \emph{applet life cycle},
describing the different phases that an applet can be in. Many actions
can only be performed when an applet is in a certain phase. Second,
there are properties dealing with the transaction mechanism, the Java
Card solution for having atomic updates. Further there are properties
restricting the kind of exceptions that can occur, and finally, we
consider properties dealing with access control, limiting the possible
interactions between different applications. For each group we present
some example properties. For all these properties encodings into JML
annotations exist.

We would like to emphasise that there exist many more
relevant security properties for smart cards, for example specifying
memory management, information flow and management of sensitive
data. Identifying all relevant security properties for smart cards,
and expressing them formally, is an important ongoing research issue.
 

\paragraph {Applet life cycle}

A typical applet life cycle defines phases as {\it loading},
{\it installation}, {\it personalisation}, {\it selectable},
{\it blocked} and {\it dead}
(see \emph{e.g.}~\/\cite{MarletL01}).  Each phase corresponds to a
different moment in the applet's life. First an applet is loaded on
the card, then it is properly installed and registered with the Java
Card Runtime Environment. Next the card is personalised,
\emph{i.e.}~all information about the card owner, permissions, keys
\emph{etc.} is stored. After this, the applet is selectable, which means
that it can be repeatedly selected, executed, and deselected. However,
if a serious error occurs, for example there
have been too many attempts to verify a pin code, the card can get
blocked or even become dead. From the latter state, no recovery is
possible.

In many of these phases, restrictions apply on who can perform
actions, or on which actions can be performed. These restrictions give
rise to different security properties, to be obeyed by the applet.

\begin{quote}
\textbf{Authenticated initialisation} Loading, installing and 
personalising the applet can only be done by an authenticated
authority.\smallskip\\
\textbf{Authenticated unblocking} When the card is blocked,
only an authenticated authority can execute commands and possibly
unblock it.\smallskip\\
\textbf{Single personalisation} An applet can be
personalised only once.
\end{quote}


\paragraph {Atomicity}

A smart card does not include a power supply, thus a brutal retrieval
from the terminal could interrupt a computation and bring the system in
an incoherent state. To avoid this, the Java Card
specification prescribes the use of a transaction mechanism to
control synchronised updates of sensitive data. A 
statement block surrounded by the methods \texttt{beginTransaction()} and
\texttt{commitTransaction()} can be considered atomic.
If something happens while executing the transaction (or if
\texttt{abortTransaction()} is executed), the card will
roll back its internal state to the state before the transaction was
begun.

To ensure the proper functioning and prevent abuse of this mechanism,
several security properties can be specified.

\begin{quote}
\textbf{No nested transactions} Only one level of transactions
is allowed.\smallskip\\
\textbf{No exception in transaction} All exceptions that may be thrown
inside a transaction, should also be caught inside the
transaction.\smallskip\\
\textbf{Bounded retries}
No pin verification may happen within a transaction.
\end{quote} 
The second property ensures that the \texttt{commitTransaction} will
always be executed. If the exception is not caught, the
\texttt{commitTransaction} would be ignored and the transaction would
not be finished. The last property excludes pin verification within a
transaction. If this would be allowed, one could abort the transaction
every time a wrong pin code has been entered. As this rolls
back the internal state to the state before the transaction was
started, this would also reset the retry counter, thus allowing an
unbounded number of retries. Even though the specification of the Java
Card API prescribes that the retry counter for pin verification cannot
be rolled back, in general one has to check this kind of properties.

\paragraph{Exceptions}

Raising an exception at the top level can reveal
information about the behaviour of the application and in principle it
should be forbidden. However, sometimes it is necessary to pass on
information about a problem that occurred. Therefore, the Java
Card standard defines so-called ISO exceptions, where a pre-defined
status word explains the problem encountered. These exceptions are the
only exceptions that may be visible at top-level; all other exceptions
should be caught within the application.

\begin{quote}
\textbf{Only ISO exceptions at top-level}
No exception should be visible at top-level, except ISO
exceptions.
\end{quote}

\paragraph {Access control} 

Another feature of Java Card is an isolation mechanism between
applications: the firewall. The firewall ensures that several
applications can securely co-exist on the same card, while managing
limited collaboration between them: classes and interfaces defined in
the same package can freely access each other, while external classes
can only be accessed via explicitly shared
interfaces. Inter-application communication via shareable interfaces
should only take place when the applet is selectable, in all other
phases of the applet life cycle only authenticated authorities are
allowed to access the applet. 
\begin{quote}
\textbf{Only selectable applications shareable} An application is accessible
via a shareable interface only if it is selectable.
\end{quote}

