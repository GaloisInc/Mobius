\subsection{Results}\label{SecResults}

For several realistic examples of Java Card applications, we checked
whether they respect the security properties presented in
Section~\ref{SecHighLevelSecProp}, and actually found some violations.
This section presents these results, focusing on the atomicity
properties.

\subsubsection{Core-annotations for Atomicity Properties}

The core-annotations related to the atomicity properties specify the
methods related to the transaction mechanism declared in class
\texttt{JCSystem} of the Java Card API. As explained above, a static
ghost variable \texttt{TRANS} is used to keep track of whether there
is a transaction in progress.  Section~\ref{SubSecJML} presents the
annotations for method
\texttt{beginTransaction}; for \texttt{commitTransaction} and 
\texttt{abortTransaction} similar annotations are synthesised. 
After propagation, these annotations are sufficient to check for the
absence of nested transactions.


%for the core-annotations related to the atomicity
%properties, in the class \texttt{javacard.framework.JCSystem} of the
%Java Card API---where the methods related to the transaction
%mechanism are defined---we declare a static ghost variable
%\texttt{TRANS} keeping track of whether there is a transaction in
%progress. This variable is initialised to 0, denoting that there is
%no transaction in progress.
%\begin{verbatim}
%//@ static ghost int TRANS == 0;
%\end{verbatim}
%The method \texttt{beginTransaction} is annotated as follows.
%\begin{verbatim}
%/*@ requires TRANS == 0;
%  @ assignable TRANS;
%  @ ensures TRANS == 1;
% */
%public static native void beginTransaction() 
%                          throws TransactionException;
%\end{verbatim}

To check for the absence of uncaught exceptions inside transactions,
we use a special feature of JACK, namely pre- and postcondition
annotations for statement blocks (as presented
in~\cite{BurdyRL03}). Block annotations are  similar to method
specifications. The propagation algorithm is adapted, so that it not
only generates annotations for methods, but also for designated
blocks. As core-annotation, we add the following annotation for
\texttt{commitTransaction}. 
\begin{verbatim}
/*@ exsures (Exception) TRANS == 0; @*/
public static native void commitTransaction() 
                          throws TransactionException;
\end{verbatim}
This specifies that exceptions only can occur if no transaction is in
progress. Propagating these annotations to statement blocks ending
with a commit guarantees that if exceptions are thrown, they have to
be caught within the transaction.

%that these only can raise exceptions, if they
%do not start a transaction.

%An exceptional postcondition is added claiming that an exeption can be
%thrown only if no transaction is open.  The propagation of this
%exceptional postcondition mechanism leads to annotate the block that
%terminates with the commit of the transaction and all calling methods.

Finally, in order to check that only a bounded number of retries of
pin-verification is possible, we annotate the method \texttt{check}
(declared in the interface \texttt{Pin} in the
standard Java Card API) with a precondition, requiring that no
transaction is in progress.
\begin{verbatim}
/*@ requires TRANS == 0; @*/
public boolean check(byte[] pin, short offset, byte length);
\end{verbatim}

%Finally, although it is a requirement of the JavaCard specification that if a pin check is
%done during transaction the pin data doesnot participate in the transaction , i.e. pin data is not rollbacked if abort
%of transaction occurs. Anyway being a question of good programming practice not to do authentification during transaction 
%we can verify it with this specification. 
\subsubsection{Checking the Atomicity Properties}


As mentioned above, we tested our method on realistic examples of
industrial smart card applications, including the so-called Demoney
case study, developed as a research prototype by Trusted
Logic\footnote{{\tt http://www.trusted-logic.fr}}, and the PACAP case
study\footnote{{\tt
http://www.gemplus.com/smart/r\_d/publications/case-study}}, developed
by Gemplus. Both examples have been explicitly developed as test cases
for different formal techniques, illustrating the different issues
involved when writing smart card applications. We used the
core-annotations as presented above, and propagated these throughout
the applications.

For both applications we found that they contained no nested
transactions, and that they did not contain attempts to verify pin
codes within transactions. All proof obligations generated
\emph{w.r.t.}~these properties are trivial and can be discharged
immediately. However, to emphasise once more the usefulness of having
a tool for generating annotations, in the PACAP case study we
encountered cases where a single transaction gave rise to twenty-three
annotations in five different classes. When writing these annotations
manually, it is very easy to forget some of them.

Finally, in the PACAP application we found transactions containing
uncaught exceptions. Consider for example the following code fragment.
\begin{verbatim}
void appExchangeCurrency(...) { 
  ...
  /*@ exsures (Exception) TRANS == 0; @*/ 
  { ...
  JCSystem.beginTransaction();      
  try {balance.setValue(decimal2); ...}
  catch (DecimalException e) {
    ISOException.throwIt(PurseApplet.DECIMAL_OVERFLOW); }
  JCSystem.commitTransaction();
  } ... }
\end{verbatim}
The method \texttt{setValue} that is called can actually throw a
decimal exception, which would lead to throwing an ISO exception, and
the transaction would not be committed. This clearly violates the
security policy as described in
Section~\ref{SecHighLevelSecProp}. After propagating the
core-annotations, and computing the appropriate proof obligations,
this violation is found automatically, without any problems.
%Notice that since the possibility to throw an exception is
%hidden inside a method call, it is not completely obvious to find the
%violation of the security policy using manual code-inspection only.

%Concerning nested transactions, even if proof obligations are obvious,
%the precondition propagation generates annotations for 23 methods among 5 classes.
%It can be really time-saving to generate those annotations rather than writing them
%manually.
