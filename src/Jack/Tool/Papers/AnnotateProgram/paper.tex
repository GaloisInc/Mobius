\documentclass[]{llncs}
\title{A Formal Connection between Security Properties and JML Annotations
\thanks{This work is partially funded by the IST FET
programme of the European Commission, under the IST-2005-015905
\textsf{Mobius} project.}}

\author{Marieke Huisman\inst{1} \and Alejandro Tamalet\inst{2}\thanks{Research done while at INRIA Sophia Antipolis}}
\institute{INRIA Sophia Antipolis, France \and 
University of Nijmegen, Netherlands}

\begin{document}

\maketitle
\begin{abstract}
\end{abstract}

\section{Introduction}\label{SecIntro}

With the emergence of a new generation of trusted personal devices
(mobile phones, PDAs, smart cards \emph{etc.}), the development of
techniques to avoid logical attacks against these devices has become
of major importance. This is in particular due to the fact that these
devices are more and more connected to networks, and in addition
provide support to execute complex applications, since this has made
it easier to launch an attack and to replicate it from one device to
another.  Exploiting this, a malicious attacker spreading over the
network and massively disconnecting or disrupting devices could have
significant consequences.  


A traditional means to ensure security of an application is to monitor
its execution with a security automaton.  Every time a
security-critical method is called or finished in the application, the
security automaton changes its internal state. If it reaches an
``illegal'' state, the application will be stopped and a security
violation will be reported. However, for applications for trusted
personal devices, such a runtime monitoring approach is not
suitable. The device is passed to the end-user and out of reach of the
original provider. For the end-user, it would be unacceptable that the
device suddenly would be blocked, because of a security violation, and
that he/she would have to return to the provider to unblock the
device. 

Instead, for such applications a statical means to enforce security is
necessary. A commonly advocated approach is to require that the application
carries a correctness proof with it, that can be validated before
installing the application on the device. In such a proof carrying
code scenario, the application provider is required to create this
proof. Traditional proof carrying code has focused on simple security
properties that can be checked with a type checker. Within the
\textsf{Mobius} project, a more advanced proof carrying code scenario
is developed where security properties are encoded as logical
formulae, and classical program verification techniques are used to
produce the proof. 

However, typical program verification tools that can be used in such
an approach use a pre-postcondition style for the specifications,
while security properties are typically expressed as automata or
temporal properties. Typically, security experts characterise security
requirements by a collection of security rules that have to be
followed by the application developer, and automata or temporal logic
are a natural and intuitive formalism to express this kind of
properties. 

This paper proposes a translation from typical security
properties expressed as an automaton (or a safety temporal logic
formula, which can be translated into an automaton~\cite{Wolper?}) 
into a specification that can be verified by a standard program
verification tool. Since the Java Virtual Machine (and variations) is
the most common platform for trusted personal devices\footnote{The
standard Java set-up for such devices is the Connected Limited Device
Configuration, see \texttt{http://java.sun.com/products/cldc/},
together with the MIDP profile, see
\texttt{http://java.sun.com/products/midp/}.}, we use JML as the
program verification specification language.  JML (Java Modeling
Language)~\cite{Leavens...} is a behavioural interface specification
langugage for Java, \emph{i.e.}\ it allows to express
pre-postcondition style specifications, but also provides more
advanced constructs like class invariants and history
constraints. Several tools exist that allow to statically verify
whether a program respects its JML annotations, \emph{e.g.}\
JACK~\cite{} and  ESC/Java~\cite{CokK04}, that both will be merged
into the \textsf{Mobius} tool set. Moreover, it is also possible to do
runtime checking of a JML specification using the \texttt{jmlc} and
\texttt{jmlrac} tools. Runtime checking of a JML specifications means
that at every method entry or exit point preconditions or
postconditions, class invariants, history constraints \emph{etc.} are
evaluted, and an exception is returned if the annotation is
violated. In addition, at any point in the program code, an assertion
can be added, that is supposed to hold whenever control reaches this
point.

We prove that our translation is behaviour preserving: whenever the
application monitored by the automaton does not produce a security
violation, runtime checking of the generated JML annotations will 
not produce an annotation exception. The next step is then to
propagate the annotations (as described
in~\cite{PavlovaBBHL04cardis}), which means that the annotations that
are generated directly give rise to new program
annotations. Eventually, this will produce a completely annotated
application, and if it can be proven statically that the annotated
program respects its annotations, it also respects the security
property expressed by the automaton.

This paper focuses on the first step of the process: from automata to
core-annotations. All results in the paper have been established
formally using the PVS theorem prover~\cite{Owre?}. In earlier work,
we have presented the propagation
algorithm~\cite{PavlovaBBHL04cardis}, and proven correctness for a
limited case (only static properties that do not depend on concrete
program instances are considered, and branching conditions are not
taken into account~--~the two possible branches are simply both
propagated). It is future work to extend this to a complete
correctness proof, and to improve the propagation algorithm to take
branching conditions into account (as much as possible). We will then
also exploit the existing PVS formalisation, to prove the formal
correctness of the propagation with a theorem prover.

The rest of this paper is organised as follows. The next section
introduces the particular automaton format that we use, and shows how
it can be used to encode typical security
properties. Section~\ref{SecAnnotGen} then presents the annotation
generation algorithm, and proves it
correctness. Section~\ref{SecTowardsStaticVer} discusses how these
results will be extended to achieve static verification, while
Section~\ref{SecImplem} discusses implementation of the algorithm (as
part of the \textsf{Mobius} toolset). Finally, Section~\ref{SecConcl}
concludes and discusses future work.


\section{Modeling Security Properties with Automata}\label{SecMVA}
Introduction of MVA format + several properties

\section{The Annotation Generation Algorithm}\label{SecAnnotGen}

from MVA:
The algorithm
Formalisation
Correctness proof (i.e. the major lemmas)

\section{Towards Static Verification of Security Properties}\label{SecTowardsStaticVer}
 
Now we only generate set-annotations.
Using a variation of Mariela's propagation algorithm, we can achieve static verification (formalisation future work)

\section{Implementation}\label{SecImplem}

\section{Conclusions \& Future Work }\label{SecConcl}

\bibliographystyle{plain}
\bibliography{bibli,../specification,/net/home/mhuisman/Research/Everest/Biblio/everest}

\end{document}
