\documentclass[]{llncs}
\title{A Formal Connection between Security Automata and JML Annotations
\thanks{This work is partially funded by the IST FET
programme of the European Commission, under the IST-2005-015905
\textsf{Mobius} project.}}

\author{Marieke Huisman\inst{1} \and Alejandro Tamalet\inst{2}\thanks{Research done while at INRIA Sophia Antipolis}}
\institute{INRIA Sophia Antipolis, France \and
University of Nijmegen, Netherlands}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbold}
\usepackage{epsfig}
\pagestyle{plain}
\usepackage{xspace}
\input{commands}
\usepackage{paralist}

\begin{document}

\maketitle
\begin{abstract}
Security automata are a convenient way to describe security
policies. They are often used to monitor an application, and to
interrupt it as soon it violates the security policy. But such a
scenario is not always convenient, therefore, we consider the security
automata as specification only, and verify adherence to it
statically. To achieve this, we generate JML annotations that inline
the monitor in the application.

The translation from security automata to program annotations is
defined in several steps:
\begin{inparaenum}[(\itshape i\upshape)]
\item complete the security automata, adding a special trap
state that should not be reached (whereas partial automata, describing
only the allowed transitions are sufficient for monitoring);
\item generate special set-annotations at the level of method
specifications, capturing the behaviour of the security automata,
together with an invariant stating that the error state should not be
reached; and
\item inline the annotations into the method body.
\end{inparaenum}
An annotation propagation algorithm can then be used to generate
appropriate pre- and postconditions that are sufficient to guarantee
adherence to the annotations, and that can be verified statically.

We have developed a generic program semantics that is instantiated for
monitoring and run-time annotation checking. We prove that every
translation step preserves the program behaviour. In particular this
means that monitoring will not find a security violation iff run-time
annotation checking will not find any annotation violation (provided
that earlier existing annotations are not violated either).

Both program semantics, translation and correctness proofs are
formalised using the PVS theorem prover. The correctness proofs
revealed several subtleties that have to be considered in the
definition of the algorithm, and the program behaviour.
\end{abstract}


\input{introduction}
\input{mva}
\input{program}
\input{annotgen}
\input{relatedwork}
\input{concl}

\bibliographystyle{plain}
\bibliography{bibli,../specification,everest,crossrefs,strings}

\end{document}
