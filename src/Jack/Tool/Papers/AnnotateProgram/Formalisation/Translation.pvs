Translation [CP, Name : TYPE+] : THEORY
BEGIN

ASSUMING 

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists_annot_gen : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

    IMPORTING InlineVariableNames[Name]

    name_of_exists_inline : ASSUMPTION
      EXISTS (f : [p : Program -> [Method -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

    IMPORTING MVA[CP, Name]

    CP_not_only_halted : ASSUMPTION
      EXISTS(cp : CP) : NOT cp = halted

ENDASSUMING

  IMPORTING CompleteMonitorProgramPropertiesPreservation[CP, Name],
            AnnotateProgramPropertiesPreservation[CP, Name],
            InlineAnnotationsPropertiesPreservation[Name],
            MonitoredProgramCompletessRelation[CP, Name],
            CorrectnessAnnProgram[CP, Name],
            CorrectnessInlineProgram[Name]

  mp : VAR (wf_and_partial_MP)

  translate(mp) : Program = inline_program(ann_program(complete_MP(mp)))

  main : THEOREM
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (sMP : MPState, sAP : APState) :
    well_behaved_MVA(mp) IMPLIES
    legal_Program_partial_MP(mp) IMPLIES
    contains_no_method_call_in_sets_in_program(program(mp)) IMPLIES
    wf_set_stmts(mp) IMPLIES
      run_monitored_program(mp)(main, arg)(root_object)(sMP) IMPLIES
      run_annotated_program(translate(mp))(main, arg)(root_object)(sAP) IMPLIES
        EXISTS (R : [MPState, APState -> boolean]) : R(sMP, sAP)   
    
END Translation
