(FiniteSetProps
 (get_y_from_x_TCC1 0
  (get_y_from_x_TCC1-1 nil 3383049701 nil ("" (subtype-tcc) nil nil)
   unchecked nil nil nil nil nil))
 (subset_prop 0
  (subset_prop-1 nil 3383049728 3390895702
   ("" (skosimp)
    (("" (expand "is_finite")
      (("" (skolem!)
        ((""
          (inst + "N!1"
           "LAMBDA (x: {x: X | EXISTS (y: Y): P!1(x, y)}): f!1(x, choose({y: Y | P!1(x, y)}))")
          (("1" (expand "injective?")
            (("1" (skosimp)
              (("1" (inst?)
                (("1" (assert) nil nil)
                 ("2" (typepred "x2!1")
                  (("2" (skolem!)
                    (("2" (rewrite "nonempty_exists")
                      (("2" (inst?) nil nil)) nil))
                    nil))
                  nil)
                 ("3" (typepred "x1!1")
                  (("3" (skolem!)
                    (("3" (rewrite "nonempty_exists")
                      (("3" (inst?) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem!)
            (("2" (name "y!1" "choose({y: Y | P!1(x!1, y)})")
              (("1" (expand "choose")
                (("1" (use "epsilon_ax[Y]")
                  (("1" (assert) nil nil)
                   ("2" (typepred "x!1")
                    (("2" (inst?)
                      (("2" (skolem!) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "x!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("3" (skolem!)
            (("3" (typepred "x!1")
              (("3" (rewrite "nonempty_exists")
                (("3" (skolem!) (("3" (inst?) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((is_finite const-decl "bool" finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (P!1 skolem-const-decl "pred[[X, Y]]" FiniteSetProps nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Y formal-type-decl nil FiniteSetProps nil)
    (X formal-type-decl nil FiniteSetProps nil)
    (choose const-decl "(p)" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (y!1 skolem-const-decl "Y" FiniteSetProps nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (y!1 skolem-const-decl "Y" FiniteSetProps nil)
    (x2!1 skolem-const-decl "({x: X | EXISTS (y: Y): P!1(x, y)})"
     FiniteSetProps nil)
    (x1!1 skolem-const-decl "({x: X | EXISTS (y: Y): P!1(x, y)})"
     FiniteSetProps nil)
    (injective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (epsilon_ax formula-decl nil epsilons nil)
    (epsilon const-decl "T" epsilons nil)
    (y!1 skolem-const-decl "Y" FiniteSetProps nil)
    (x!1 skolem-const-decl "{x: X | EXISTS (y: Y): P!1(x, y)}"
     FiniteSetProps nil)
    (x!1 skolem-const-decl "{x: X | EXISTS (y: Y): P!1(x, y)}"
     FiniteSetProps nil)
    (y!1 skolem-const-decl "Y" FiniteSetProps nil))
   713843 480 t nil)))
(EpsilonProps
 (epsilon_singleton 0
  (epsilon_singleton-1 nil 3383050062 3383050067
   ("" (skolem!)
    (("" (lemma "epsilon_ax[T]")
      (("" (inst?)
        (("" (expand* "singleton")
          (("" (split)
            (("1" (propax) nil nil) ("2" (inst + "x!1") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (epsilon_ax formula-decl nil epsilons nil)
    (T formal-nonempty-type-decl nil EpsilonProps nil))
   2785 30 t nil))
 (choose_singleton?_TCC1 0
  (choose_singleton?_TCC1-1 nil 3384083790 nil
   ("" (subtype-tcc) nil nil) unchecked nil nil nil nil nil))
 (choose_singleton? 0
  (choose_singleton?-1 nil 3384083791 3384083832
   ("" (skosimp)
    (("" (expand* "choose" "the" "singleton" "member") nil nil)) nil)
   unfinished
   ((choose const-decl "(p)" sets nil) (the const-decl "(p)" sets nil))
   40327 20 t shostak)))
(FiniteSetProp
 (finite_set_restrict 0
  (finite_set_restrict-1 nil 3381829584 3383472927
   ("" (skosimp*)
    (("" (typepred "s!1")
      (("" (expand "is_finite")
        (("" (skosimp*)
          (("" (inst 1 "N!1" _)
            ((""
              (inst 1
               "LAMBDA(u : ({u : U | s!1(f!1(u)) AND P!1(u)})) : f!2(f!1(u))")
              (("" (expand "injective?")
                (("" (skosimp*)
                  (("" (inst -2 "x1!1" "x2!1")
                    (("" (inst -1 "f!1(x1!1)" "f!1(x2!1)")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil FiniteSetProp nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (U formal-type-decl nil FiniteSetProp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   157 90 t shostak)))
(FiniteSetInduction
 (finite_set_induction 0
  (finite_set_induction-1 nil 3383502370 3383503053
   ("" (skosimp*)
    ((""
      (use "wf_induction[finite_set[T], LAMBDA(x, y : finite_set[T]) : card(x) < card(y)]")
      (("1" (split -1)
        (("1" (inst -1 "x!1") nil nil)
         ("2" (skosimp*)
          (("2" (case-replace "nonempty?(x!2)")
            (("1" (inst -4 "remove(choose(x!2), x!2)" "choose(x!2)")
              (("1" (inst -2 "remove(choose(x!2), x!2)")
                (("1" (rewrite "card_remove")
                  (("1" (assert)
                    (("1"
                      (case-replace
                       "add(choose(x!2), remove(choose(x!2), x!2)) = x!2")
                      (("1" (apply-extensionality :hide? t)
                        (("1" (auto-rewrite "member" "add" "remove")
                          (("1" (assert)
                            (("1" (iff)
                              (("1"
                                (split 1)
                                (("1"
                                  (skosimp*)
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (use "choose_member[T]")
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2" (flatten) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skosimp*)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case-replace "x!2 = emptyset")
              (("2" (expand "nonempty?")
                (("2" (expand "emptyset")
                  (("2" (expand "empty?")
                    (("2" (expand "member")
                      (("2" (apply-extensionality :hide? t)
                        (("2" (inst -2 "x!3") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "wf_card") nil nil))
      nil))
    nil)
   unfinished
   ((wf_card formula-decl nil WF_Card nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (choose_member formula-decl nil sets_lemmas nil)
    (add const-decl "(nonempty?)" sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (remove const-decl "set" sets nil)
    (choose const-decl "(p)" sets nil) nil
    (empty? const-decl "bool" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil FiniteSetInduction nil)
    (wf_induction formula-decl nil wf_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   6409 630 t shostak)))

