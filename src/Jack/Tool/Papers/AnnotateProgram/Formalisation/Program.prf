(|JType|)
(|Excpt|)
(|Body|)
(|Program|
 (|reserved_words_TCC1| 0
  (|reserved_words_TCC1-2| NIL 3394869706 3395740947
   ("" (EXPAND "is_finite")
    ((""
      (INST 1 "6"
       "LAMBDA (n : {n: Name | n = This OR n = Super OR n = rsIf OR n = rsThen OR n = rsElse}) :
                         IF n = This THEN 1
                         ELSIF n = Super THEN 2
                         ELSIF n = rsIf THEN 3
                         ELSIF n = rsThen THEN 4
                         ELSIF n = rsElse THEN 5
                         ELSE 0 ENDIF")
      (("" (EXPAND "injective?")
        (("" (SKOSIMP)
          (("" (LIFT-IF)
            (("" (ASSERT)
              (("" (GRIND) (("" (TYPEPRED "x1!1") (("" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |Program| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|This| CONST-DECL "Name" |Program| NIL)
    (|Super| CONST-DECL "Name" |Program| NIL)
    (|rsIf| CONST-DECL "Name" |Program| NIL)
    (|rsThen| CONST-DECL "Name" |Program| NIL)
    (|rsElse| CONST-DECL "Name" |Program| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL))
   99 98 NIL NIL)
  (|reserved_words_TCC1-1| NIL 3394869664 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL
   NIL NIL NIL NIL NIL)))
(|ProgramFunctions|
 (|var_names_TCC1| 0
  (|var_names_TCC1-1| NIL 3390821142 3395741435
   ("" (SKOLEM-TYPEPRED)
    (("" (EXPAND "is_finite")
      (("" (SKOLEM!)
        ((""
          (INST 1 "N!1"
           "LAMBDA (n : ({n: Name | EXISTS (f: FieldDecl): fs!1(f) AND name(f) = n})) :
                    f!1(choose({f : FieldDecl | fs!1(f) AND name(f) = n}))")
          (("1" (EXPAND "injective?")
            (("1" (SKOSIMP)
              (("1" (INST?)
                (("1" (ASSERT) NIL NIL)
                 ("2" (TYPEPRED "x2!1")
                  (("2" (REWRITE "nonempty_exists")
                    (("2" (SKOLEM!) (("2" (INST?) NIL NIL)) NIL)) NIL))
                  NIL)
                 ("3" (TYPEPRED "x1!1")
                  (("3" (REWRITE "nonempty_exists")
                    (("3" (SKOLEM!) (("3" (INST?) NIL NIL)) NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (SKOLEM!)
            (("2" (TYPEPRED "n!1")
              (("2" (REWRITE "nonempty_exists")
                (("2" (SKOLEM!) (("2" (INST?) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|fs!1| SKOLEM-CONST-DECL "finite_set[FieldDecl[Name]]" |ProgramFunctions|
     NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|f!2| SKOLEM-CONST-DECL "FieldDecl[Name]" |ProgramFunctions| NIL)
    (|f!2| SKOLEM-CONST-DECL "FieldDecl[Name]" |ProgramFunctions| NIL)
    (|nonempty_exists| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|x1!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (f: FieldDecl[Name]): fs!1(f) AND name(f) = n})"
     |ProgramFunctions| NIL)
    (|x2!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (f: FieldDecl[Name]): fs!1(f) AND name(f) = n})"
     |ProgramFunctions| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|n!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (f: FieldDecl[Name]): fs!1(f) AND name(f) = n})"
     |ProgramFunctions| NIL)
    (|f!2| SKOLEM-CONST-DECL "FieldDecl[Name]" |ProgramFunctions| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   184 184 T NIL))
 (|var_names_TCC2| 0
  (|var_names_TCC2-1| NIL 3390821142 3395741437
   ("" (SKOLEM-TYPEPRED)
    (("" (EXPAND "is_finite")
      (("" (SKOLEM!)
        ((""
          (INST 1 "N!1"
           "LAMBDA (n : ({n: Name | EXISTS (l: LocalVarDecl): ls!1(l) AND name(l) = n})) :
                      f!1(choose({l : LocalVarDecl | ls!1(l) AND name(l) = n}))")
          (("1" (EXPAND "injective?")
            (("1" (SKOSIMP)
              (("1" (INST?)
                (("1" (ASSERT) NIL NIL)
                 ("2" (TYPEPRED "x2!1")
                  (("2" (REWRITE "nonempty_exists")
                    (("2" (SKOLEM!) (("2" (INST?) NIL NIL)) NIL)) NIL))
                  NIL)
                 ("3" (TYPEPRED "x1!1")
                  (("3" (REWRITE "nonempty_exists")
                    (("3" (SKOLEM!) (("3" (INST?) NIL NIL)) NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (SKOLEM!)
            (("2" (TYPEPRED "n!1")
              (("2" (REWRITE "nonempty_exists")
                (("2" (SKOLEM!) (("2" (INST?) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|ls!1| SKOLEM-CONST-DECL "finite_set[LocalVarDecl[Name]]"
     |ProgramFunctions| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|l!1| SKOLEM-CONST-DECL "LocalVarDecl[Name]" |ProgramFunctions| NIL)
    (|l!1| SKOLEM-CONST-DECL "LocalVarDecl[Name]" |ProgramFunctions| NIL)
    (|nonempty_exists| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|x1!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (l: LocalVarDecl[Name]): ls!1(l) AND name(l) = n})"
     |ProgramFunctions| NIL)
    (|x2!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (l: LocalVarDecl[Name]): ls!1(l) AND name(l) = n})"
     |ProgramFunctions| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|n!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (l: LocalVarDecl[Name]): ls!1(l) AND name(l) = n})"
     |ProgramFunctions| NIL)
    (|l!1| SKOLEM-CONST-DECL "LocalVarDecl[Name]" |ProgramFunctions| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   185 185 T NIL))
 (|getFieldDecls_TCC1| 0
  (|getFieldDecls_TCC1-3| NIL 3391148557 3395741439
   ("" (SKOSIMP*)
    (("" (USE "finite_set_induction[Class]")
      ((""
        (INST -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND fields(c)(f)})")
        (("" (SPLIT -1)
          (("1" (INST -1 "classes(p!1)") NIL NIL)
           ("2" (HIDE 2)
            (("2" (SKOSIMP*)
              (("2"
                (CASE-REPLACE " ({f: FieldDecl |
                  EXISTS (c: Class): add(t!1, x!1)(c) AND fields(c)(f)}) = union({f : FieldDecl | fields(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND fields(c)(f)})")
                (("1" (HIDE -1)
                  (("1" (USE "finite_union[FieldDecl]")
                    (("1" (HIDE -1 2)
                      (("1" (TYPEPRED "fields(t!1)")
                        (("1"
                          (CASE-REPLACE
                           "fields(t!1) = {f : FieldDecl | fields(t!1)(f)}")
                          (("1" (ASSERT)
                            (("1" (APPLY-EXTENSIONALITY :HIDE? T) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T)
                  (("2" (HIDE -1 2)
                    (("2" (EXPAND "union")
                      (("2" (EXPAND "add")
                        (("2" (EXPAND "member")
                          (("2" (IFF)
                            (("2" (PROP)
                              (("1" (SKOSIMP*)
                                (("1" (SPLIT -1)
                                  (("1" (ASSERT) NIL NIL)
                                   ("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL))
                                  NIL))
                                NIL)
                               ("2" (INST?) NIL NIL)
                               ("3" (SKOSIMP*)
                                (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (HIDE 2)
            (("3" (EXPAND "emptyset")
              (("3"
                (CASE-REPLACE "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (USE "finite_emptyset[FieldDecl]") NIL NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T) (("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|finite_set_induction| FORMULA-DECL NIL |FiniteSetInduction| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|x!1| SKOLEM-CONST-DECL "finite_set[Class]" |ProgramFunctions| NIL)
    (|t!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|finite_emptyset| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL))
   179 178 T NIL)
  (|getFieldDecls_TCC1-2| NIL 3390902649 3391148163
   ("" (SKOSIMP*)
    (("" (USE "finite_set_induction[Class]")
      ((""
        (INST -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND fields(c)(f)})")
        (("" (SPLIT -1)
          (("1" (INST -1 "classes(p!1)") NIL NIL)
           ("2" (HIDE 2)
            (("2" (SKOSIMP*)
              (("2"
                (CASE-REPLACE " ({f: FieldDecl |
                      EXISTS (c: Class): add(t!1, x!1)(c) AND fields(c)(f)}) = union({f : FieldDecl | fields(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND fields(c)(f)})")
                (("1" (HIDE -1)
                  (("1" (USE "finite_union[FieldDecl]")
                    (("1" (HIDE -1 2)
                      (("1" (TYPEPRED "fields(t!1)")
                        (("1"
                          (CASE-REPLACE
                           "fields(t!1) = {f : FieldDecl[Name] | fields(t!1)(f)}")
                          (("1" (APPLY-EXTENSIONALITY 1) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T)
                  (("2" (HIDE -1 2)
                    (("2" (EXPAND* "union" "add" "member")
                      (("2" (IFF)
                        (("2" (PROP)
                          (("1" (SKOSIMP*)
                            (("1" (SPLIT -1)
                              (("1" (ASSERT) NIL NIL)
                               ("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL))
                              NIL))
                            NIL)
                           ("2" (INST?) NIL NIL)
                           ("3" (SKOSIMP*)
                            (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (HIDE 2)
            (("3" (EXPAND "emptyset")
              (("3"
                (CASE-REPLACE "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (USE "finite_emptyset[FieldDecl]") NIL NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T) (("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   UNFINISHED
   ((|finite_set_induction| FORMULA-DECL NIL |FiniteSetInduction| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) NIL
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL) NIL
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|finite_emptyset| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL))
   412 330 T NIL)
  (|getFieldDecls_TCC1-1| NIL 3390821142 3390894974
   ("" (SKOLEM!)
    (("" (TYPEPRED "classes(p!1)")
      (("" (EXPAND "is_finite") (("" (SKOLEM!) (("" (POSTPONE) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   UNCHECKED NIL 5557840 390 T NIL))
 (|getLocalDecls_TCC1| 0
  (|getLocalDecls_TCC1-2| NIL 3390903916 3395741443
   ("" (SKOSIMP*)
    (("" (USE "finite_set_induction[Class]")
      ((""
        (INST -1
         "LAMBDA(C : finite_set[Class]) : is_finite[LocalVarDecl]({l : LocalVarDecl | EXISTS (c : Class, m : Method) : C(c) AND methods(c)(m) AND (lvars(m)(l) OR l = arg(m))})")
        (("" (SPLIT -1)
          (("1" (INST -1 "classes(p!1)") NIL NIL)
           ("2" (HIDE 2)
            (("2" (SKOSIMP*)
              (("2"
                (CASE-REPLACE " {l: LocalVarDecl |
                  EXISTS (c: Class, m: Method):
                    add(t!1, x!1)(c) AND
                     methods(c)(m) AND (lvars(m)(l) OR l = arg(m))} = union({l : LocalVarDecl | EXISTS (m : Method) : methods(t!1)(m) AND (lvars(m)(l) OR l = arg(m))}, {l : LocalVarDecl |
                  EXISTS (c: Class, m: Method):
                    x!1(c) AND methods(c)(m) AND (lvars(m)(l) OR l = arg(m))})"
                 :HIDE? T)
                (("1" (USE "finite_union[LocalVarDecl]")
                  (("1" (HIDE -1 2)
                    (("1" (USE "finite_set_induction[Method]")
                      (("1"
                        (INST -1
                         "LAMBDA(M : finite_set[Method]) : is_finite[LocalVarDecl]({l: LocalVarDecl |EXISTS(m : Method) : M(m) AND (lvars(m)(l) OR l = arg(m))})")
                        (("1" (SPLIT -1)
                          (("1" (INST?) NIL NIL)
                           ("2" (HIDE 2)
                            (("2" (SKOSIMP*)
                              (("2"
                                (CASE-REPLACE "{l: LocalVarDecl |
                      EXISTS (m: Method):
                        add(t!2, x!2)(m) AND (lvars(m)(l) OR l = arg(m))} = union(lvars(t!2), union(singleton(arg(t!2)), {l : LocalVarDecl | EXISTS (m: Method): x!2(m) AND (lvars(m)(l) OR l = arg(m))}))"
                                 :HIDE? T)
                                (("1" (USE "finite_union[LocalVarDecl]")
                                  (("1" (USE "finite_union[LocalVarDecl]") NIL
                                    NIL))
                                  NIL)
                                 ("2" (HIDE -1 2)
                                  (("2" (APPLY-EXTENSIONALITY :HIDE? T)
                                    (("2" (EXPAND "union")
                                      (("2" (EXPAND "add")
                                        (("2" (EXPAND "singleton")
                                          (("2" (EXPAND "member")
                                            (("2" (IFF)
                                              (("2" (PROP)
                                                (("1" (SKOSIMP*)
                                                  (("1" (INST?)
                                                    (("1" (SPLIT -1)
                                                      (("1" (ASSERT) NIL NIL)
                                                       ("2" (ASSERT) NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (INST?)
                                                  (("2" (ASSERT) NIL NIL)) NIL)
                                                 ("3" (INST?)
                                                  (("3" (ASSERT) NIL NIL)) NIL)
                                                 ("4" (SKOSIMP*)
                                                  (("4" (INST?)
                                                    (("4" (ASSERT) NIL NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("3" (HIDE 2)
                            (("3" (EXPAND "emptyset")
                              (("3"
                                (CASE-REPLACE
                                 "{f : LocalVarDecl | FALSE} = emptyset[LocalVarDecl]")
                                (("1" (USE "finite_emptyset[LocalVarDecl]") NIL
                                  NIL)
                                 ("2" (APPLY-EXTENSIONALITY :HIDE? T)
                                  (("2" (GRIND) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T)
                  (("2" (HIDE -1 2)
                    (("2" (EXPAND "union")
                      (("2" (EXPAND "add")
                        (("2" (EXPAND "member")
                          (("2" (IFF)
                            (("2" (PROP)
                              (("1" (SKOSIMP*)
                                (("1" (SPLIT -1)
                                  (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)
                                   ("2" (INST? 2) (("2" (ASSERT) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (SKOSIMP*)
                                (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL))
                                NIL)
                               ("3" (SKOSIMP*)
                                (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (HIDE 2)
            (("3" (EXPAND "emptyset")
              (("3"
                (CASE-REPLACE
                 "{f : LocalVarDecl | FALSE} = emptyset[LocalVarDecl]")
                (("1" (USE "finite_emptyset[LocalVarDecl]") NIL NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T) (("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|finite_set_induction| FORMULA-DECL NIL |FiniteSetInduction| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|t!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (|x!1| SKOLEM-CONST-DECL "finite_set[Class]" |ProgramFunctions| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|x!2| SKOLEM-CONST-DECL "finite_set[Method]" |ProgramFunctions| NIL)
    (|t!2| SKOLEM-CONST-DECL "Method[Name]" |ProgramFunctions| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|singleton?| CONST-DECL "bool" |sets| NIL)
    (|nonempty_union2| APPLICATION-JUDGEMENT "(nonempty?)" |sets| NIL)
    (|nonempty_union1| APPLICATION-JUDGEMENT "(nonempty?)" |sets| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|finite_emptyset| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL))
   343 342 T NIL)
  (|getLocalDecls_TCC1-1| NIL 3390821142 3390821234 ("" (SUBTYPE-TCC) NIL NIL)
   UNCHECKED NIL 605 450 NIL NIL))
 (|getGhostDecls_TCC1| 0
  (|getGhostDecls_TCC1-3| NIL 3391148598 3395741444
   ("" (SKOSIMP*)
    (("" (USE "finite_set_induction[Class]")
      ((""
        (INST -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND ghost_vars(c)(f)})")
        (("" (SPLIT -1)
          (("1" (INST -1 "classes(p!1)") NIL NIL)
           ("2" (HIDE 2)
            (("2" (SKOSIMP*)
              (("2"
                (CASE-REPLACE " ({f: FieldDecl |
                          EXISTS (c: Class): add(t!1, x!1)(c) AND ghost_vars(c)(f)}) = union({f : FieldDecl | ghost_vars(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND ghost_vars(c)(f)})")
                (("1" (HIDE -1)
                  (("1" (USE "finite_union[FieldDecl]")
                    (("1" (HIDE -1 2)
                      (("1" (TYPEPRED "ghost_vars(t!1)")
                        (("1"
                          (CASE-REPLACE
                           "ghost_vars(t!1) = {f : FieldDecl | ghost_vars(t!1)(f)}")
                          (("1" (ASSERT)
                            (("1" (APPLY-EXTENSIONALITY :HIDE? T) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T)
                  (("2" (HIDE -1 2)
                    (("2" (EXPAND* "union" "add" "member")
                      (("2" (IFF)
                        (("2" (PROP)
                          (("1" (SKOSIMP*)
                            (("1" (GROUND)
                              (("1" (INST?)
                                (("1" (SPLIT)
                                  (("1" (PROPAX) NIL NIL)
                                   ("2" (PROPAX) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (INST?) NIL NIL)
                           ("3" (SKOSIMP*)
                            (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (HIDE 2)
            (("3" (EXPAND "emptyset")
              (("3"
                (CASE-REPLACE "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (USE "finite_emptyset[FieldDecl]") NIL NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T) (("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|finite_set_induction| FORMULA-DECL NIL |FiniteSetInduction| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|x!1| SKOLEM-CONST-DECL "finite_set[Class]" |ProgramFunctions| NIL)
    (|t!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|finite_emptyset| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL))
   195 195 T NIL)
  (|getGhostDecls_TCC1-2| NIL 3390903999 3391148164
   ("" (SKOSIMP*)
    (("" (USE "finite_set_induction[Class]")
      ((""
        (INST -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND ghost_vars(c)(f)})")
        (("" (SPLIT -1)
          (("1" (INST -1 "classes(p!1)") NIL NIL)
           ("2" (HIDE 2)
            (("2" (SKOSIMP*)
              (("2"
                (CASE-REPLACE " ({f: FieldDecl |
                      EXISTS (c: Class): add(t!1, x!1)(c) AND ghost_vars(c)(f)}) = union({f : FieldDecl | ghost_vars(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND ghost_vars(c)(f)})")
                (("1" (HIDE -1)
                  (("1" (USE "finite_union[FieldDecl]")
                    (("1" (HIDE -1 2)
                      (("1" (TYPEPRED "ghost_vars(t!1)")
                        (("1"
                          (CASE-REPLACE
                           "ghost_vars(t!1) = {f : FieldDecl | ghost_vars(t!1)(f)}")
                          (("1" (APPLY-EXTENSIONALITY) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T)
                  (("2" (HIDE -1 2)
                    (("2" (EXPAND "union")
                      (("2" (EXPAND "add")
                        (("2" (EXPAND "member")
                          (("2" (IFF)
                            (("2" (PROP)
                              (("1" (SKOSIMP*)
                                (("1" (SPLIT -1)
                                  (("1" (ASSERT) NIL NIL)
                                   ("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL))
                                  NIL))
                                NIL)
                               ("2" (INST?) NIL NIL)
                               ("3" (SKOSIMP*)
                                (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (HIDE 2)
            (("3" (EXPAND "emptyset")
              (("3"
                (CASE-REPLACE "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (USE "finite_emptyset[FieldDecl]") NIL NIL)
                 ("2" (APPLY-EXTENSIONALITY :HIDE? T) (("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   UNFINISHED
   ((|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL) NIL
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL) NIL
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|finite_set_induction| FORMULA-DECL NIL |FiniteSetInduction| NIL))
   436 310 T NIL)
  (|getGhostDecls_TCC1-1| NIL 3390821142 3390821234 ("" (SUBTYPE-TCC) NIL NIL)
   UNCHECKED NIL 474 450 NIL NIL))
 (|declared_var_names_TCC1| 0
  (|declared_var_names_TCC1-1| NIL 3394869665 3395741445
   ("" (SKOSIMP)
    ((""
      (CASE-REPLACE "{n: Name |
              var_names(getFieldDecls(p!1))(n) OR
              var_names(getLocalDecls(p!1))(n) OR
              var_names(getGhostDecls(p!1))(n)} =
              union(union(var_names(getFieldDecls(p!1)), var_names(getLocalDecls(p!1))), var_names(getGhostDecls(p!1)))")
      (("1" (HIDE -1) (("1" (USE "finite_union[Name]") NIL NIL)) NIL)
       ("2" (HIDE 2) (("2" (EXPAND* "union" "member") NIL NIL)) NIL))
      NIL))
    NIL)
   PROVED
   ((|finite_union| APPLICATION-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|var_names| CONST-DECL "finite_set[Name]" |ProgramFunctions| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|getFieldDecls| CONST-DECL "finite_set[FieldDecl]" |ProgramFunctions| NIL)
    (|var_names| CONST-DECL "finite_set[Name]" |ProgramFunctions| NIL)
    (|getLocalDecls| CONST-DECL "finite_set[LocalVarDecl]" |ProgramFunctions|
     NIL)
    (|getGhostDecls| CONST-DECL "finite_set[FieldDecl]" |ProgramFunctions| NIL)
    (|setof| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL))
   6 5 T NIL))
 (|class_names_TCC1| 0
  (|class_names_TCC1-1| NIL 3390821142 3395741446
   ("" (SKOLEM!)
    (("" (TYPEPRED "classes(p!1)")
      (("" (EXPAND "is_finite")
        (("" (SKOLEM!)
          ((""
            (INST 1 "N!1"
             "LAMBDA (n : ({n: Name | EXISTS (c : Class): classes(p!1)(c) AND name(c) = n})) :
                      f!1(choose({c : Class | classes(p!1)(c) AND name(c) = n}))")
            (("1" (EXPAND "injective?")
              (("1" (SKOSIMP)
                (("1" (INST?)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (TYPEPRED "x2!1")
                    (("2" (REWRITE "nonempty_exists")
                      (("2" (SKOLEM!) (("2" (INST?) NIL NIL)) NIL)) NIL))
                    NIL)
                   ("3" (TYPEPRED "x1!1")
                    (("3" (REWRITE "nonempty_exists")
                      (("3" (SKOLEM!) (("3" (INST?) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (SKOLEM!)
              (("2" (TYPEPRED "n!1")
                (("2" (REWRITE "nonempty_exists")
                  (("2" (SKOLEM!) (("2" (INST?) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|c!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (|n!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (c: Class[Name]): classes(p!1)(c) AND name(c) = n})"
     |ProgramFunctions| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|x2!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (c: Class[Name]): classes(p!1)(c) AND name(c) = n})"
     |ProgramFunctions| NIL)
    (|x1!1| SKOLEM-CONST-DECL
     "({n: Name | EXISTS (c: Class[Name]): classes(p!1)(c) AND name(c) = n})"
     |ProgramFunctions| NIL)
    (|nonempty_exists| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|c!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (|c!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|p!1| SKOLEM-CONST-DECL "Program[Name]" |ProgramFunctions| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   188 188 T NIL))
 (|method_names_TCC1| 0
  (|method_names_TCC1-1| NIL 3390821142 3395741448
   ("" (SKOSIMP*)
    (("" (TYPEPRED "methods(c!1)")
      (("" (EXPAND "is_finite")
        (("" (SKOLEM!)
          ((""
            (INST 1 "N!1"
             "LAMBDA (n: {n: Name | EXISTS (m: Method): classes(p!1)(c!1) AND methods(c!1)(m) AND name(m) = n}):
                     f!1(choose({m : Method | methods(c!1)(m) AND name(m) = n}))")
            (("1" (EXPAND "injective?")
              (("1" (SKOSIMP)
                (("1" (INST?)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (TYPEPRED "x2!1")
                    (("2" (REWRITE "nonempty_exists")
                      (("2" (SKOLEM!)
                        (("2" (INST?) (("2" (PROP) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL)
                   ("3" (TYPEPRED "x1!1")
                    (("3" (REWRITE "nonempty_exists")
                      (("3" (SKOLEM!)
                        (("3" (INST?) (("3" (PROP) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (SKOLEM!)
              (("2" (TYPEPRED "n!1")
                (("2" (REWRITE "nonempty_exists")
                  (("2" (SKOLEM!) (("2" (INST?) (("2" (PROP) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|n!1| SKOLEM-CONST-DECL "{n: Name |
         EXISTS (m: Method):
           classes(p!1)(c!1) AND methods(c!1)(m) AND name(m) = n}"
     |ProgramFunctions| NIL)
    (|m!1| SKOLEM-CONST-DECL "Method[Name]" |ProgramFunctions| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|x2!1| SKOLEM-CONST-DECL "({n: Name |
    EXISTS (m: Method[Name]):
      classes(p!1)(c!1) AND methods(c!1)(m) AND name(m) = n})"
     |ProgramFunctions| NIL)
    (|x1!1| SKOLEM-CONST-DECL "({n: Name |
    EXISTS (m: Method[Name]):
      classes(p!1)(c!1) AND methods(c!1)(m) AND name(m) = n})"
     |ProgramFunctions| NIL)
    (|nonempty_exists| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|m!1| SKOLEM-CONST-DECL "Method[Name]" |ProgramFunctions| NIL)
    (|m!1| SKOLEM-CONST-DECL "Method[Name]" |ProgramFunctions| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|p!1| SKOLEM-CONST-DECL "Program[Name]" |ProgramFunctions| NIL)
    (|c!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL))
   210 207 T NIL))
 (|methods_TCC1| 0
  (|methods_TCC1-1| NIL 3392356310 3395741455
   ("" (SKOSIMP*)
    (("" (USE "finite_set_induction[Class]")
      ((""
        (INST -1 "LAMBDA(C : finite_set[Class]) : is_finite[Method[Name]]
            ({m: Method[Name] |
                EXISTS (c: Class[Name]): C(c) AND methods(c)(m)})")
        (("" (ASSERT)
          (("" (SPLIT -1)
            (("1" (INST -1 "classes(p!1)") NIL NIL)
             ("2" (HIDE 2)
              (("2" (SKOSIMP*)
                (("2"
                  (CASE-REPLACE "({m: Method[Name] |
                   EXISTS (c: Class[Name]): add(t!1, x!1)(c) AND methods(c)(m)})
     = union({m : Method[Name] | methods(t!1)(m)}, {m : Method[Name] | EXISTS (c : Class[Name]) : x!1(c) AND methods(c)(m)})"
                   :HIDE? T)
                  (("1" (USE "finite_union[Method[Name]]")
                    (("1" (HIDE -1 2)
                      (("1" (TYPEPRED "methods(t!1)")
                        (("1"
                          (CASE-REPLACE
                           "methods(t!1) = {m : Method[Name] | methods(t!1)(m)}"
                           :HIDE? T)
                          (("1" (GRIND) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (HIDE -1 2)
                    (("2" (APPLY-EXTENSIONALITY :HIDE? T)
                      (("2" (EXPAND* "union" "add" "member")
                        (("2" (IFF)
                          (("2" (PROP)
                            (("1" (SKOSIMP*)
                              (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)
                             ("2" (INST?) NIL NIL)
                             ("3" (SKOSIMP*)
                              (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("3" (HIDE 2)
              (("3" (EXPAND "emptyset")
                (("3"
                  (CASE-REPLACE
                   "{m: Method[Name] | FALSE} = emptyset[Method[Name]]")
                  (("1" (USE "finite_emptyset[Method[Name]]") NIL NIL)
                   ("2" (APPLY-EXTENSIONALITY :HIDE? T) (("2" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set"
     |finite_sets| NIL)
    (|finite_set_induction| FORMULA-DECL NIL |FiniteSetInduction| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|finite_emptyset| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL)
    (|x!1| SKOLEM-CONST-DECL "finite_set[Class]" |ProgramFunctions| NIL)
    (|t!1| SKOLEM-CONST-DECL "Class[Name]" |ProgramFunctions| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL))
   624 615 T NIL))
 (|get_class_TCC1| 0
  (|get_class_TCC1-1| NIL 3390821142 3395741455 ("" (SUBTYPE-TCC) NIL NIL)
   PROVED
   ((|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|class_names| CONST-DECL "finite_set[Name]" |ProgramFunctions| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL))
   25 25 NIL NIL))
 (|lookup_inv_TCC1| 0
  (|lookup_inv_TCC1-1| NIL 3395741428 3395741504
   ("" (INST 1 "LAMBDA(x1 : [Program[Name], Val[Name]]) : TT") NIL NIL) PROVED
   ((TT ADT-CONSTRUCTOR-DECL "(TT?)" |Body_adt| NIL)
    (|BoolVarEval?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Gt?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Ge?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Neq?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Eq?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Le?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Lt?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Disj?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Conj?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (|Neg?| ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (FF? ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (TT? ADT-RECOGNIZER-DECL "[Body -> boolean]" |Body_adt| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|Body| TYPE-DECL NIL |Body_adt| NIL)
    (|Program| TYPE-EQ-DECL NIL |Program| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |ProgramFunctions| NIL))
   3054 22 T NIL)))
(|WellFormedProgram|
 (|wf_program_variables_disjoint| 0
  (|wf_program_variables_disjoint-1| NIL 3393587608 3395742071
   ("" (SKOSIMP)
    (("" (EXPAND* "wf_Program" "wf_program_variables_disjoint_def")
      (("" (GROUND) NIL NIL)) NIL))
    NIL)
   PROVED
   ((|wf_program_variables_disjoint_def| CONST-DECL "boolean"
     |WellFormedProgram| NIL)
    (|wf_Program| CONST-DECL "boolean" |WellFormedProgram| NIL))
   20 20 T SHOSTAK))
 (|wf_program_variables_not_reserved_words| 0
  (|wf_program_variables_not_reserved_words-1| NIL 3394987767 3395742071
   ("" (SKOSIMP)
    (("" (EXPAND* "wf_Program" "wf_program_variables_not_reserved_words_def")
      (("" (FLATTEN) NIL NIL)) NIL))
    NIL)
   PROVED
   ((|wf_program_variables_not_reserved_words_def| CONST-DECL "boolean"
     |WellFormedProgram| NIL)
    (|wf_Program| CONST-DECL "boolean" |WellFormedProgram| NIL))
   2 1 T SHOSTAK))
 (|wf_program_has_unique_class_names| 0
  (|wf_program_has_unique_class_names-1| NIL 3390201065 3395742071
   ("" (SKOSIMP)
    (("" (EXPAND* "wf_Program" "wf_program_has_unique_class_names_def")
      (("" (FLATTEN) (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL))
    NIL)
   PROVED
   ((|wf_program_has_unique_class_names_def| CONST-DECL "boolean"
     |WellFormedProgram| NIL)
    (|wf_Program| CONST-DECL "boolean" |WellFormedProgram| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |WellFormedProgram| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL))
   2 3 T SHOSTAK))
 (|wf_program_has_wf_classes| 0
  (|wf_program_has_wf_classes-1| NIL 3393587755 3395742101
   ("" (SKOSIMP)
    (("" (EXPAND "wf_Program")
      (("" (FLATTEN)
        (("" (EXPAND "wf_Classes") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|wf_Program| CONST-DECL "boolean" |WellFormedProgram| NIL)
    (|wf_Classes| CONST-DECL "boolean" |WellFormedProgram| NIL)
    (|Class| TYPE-EQ-DECL NIL |Program| NIL)
    (|lift| TYPE-DECL NIL |lift_adt| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|FieldDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|defined?| CONST-DECL "boolean" |ValProp| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|Val| TYPE-DECL NIL |Val_adt| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |WellFormedProgram| NIL))
   1285 4 T SHOSTAK))
 (|wf_class_has_unique_method_names| 0
  (|wf_class_has_unique_method_names-1| NIL 3393587790 3395742071
   ("" (SKOSIMP)
    (("" (EXPAND "wf_Class") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL))
    NIL)
   PROVED
   ((|wf_Class| CONST-DECL "boolean" |WellFormedProgram| NIL)
    (|Method| TYPE-EQ-DECL NIL |Program| NIL)
    (|Expr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|BoolExpr| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|JType| TYPE-DECL NIL |JType_adt| NIL)
    (|Stmt| TYPE-EQ-DECL NIL |Body_adt| NIL)
    (|LocalVarDecl| TYPE-EQ-DECL NIL |Program| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |WellFormedProgram| NIL))
   2 2 T SHOSTAK))
 (|wf_program_all_variables_declared| 0
  (|wf_program_all_variables_declared-1| NIL 3395742105 3395742114
   ("" (SKOSIMP*)
    (("" (EXPAND "wf_Program")
      (("" (FLATTEN)
        (("" (EXPAND "wf_program_all_variables_declared")
          (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   PROVED
   ((|wf_Program| CONST-DECL "boolean" |WellFormedProgram| NIL)
    (|wf_program_all_variables_declared| CONST-DECL "boolean"
     |WellFormedProgram| NIL)
    (|Name| FORMAL-NONEMPTY-TYPE-DECL NIL |WellFormedProgram| NIL))
   920 3 T SHOSTAK)))

