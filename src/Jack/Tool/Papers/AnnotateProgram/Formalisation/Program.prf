(JType)
(Excpt)
(Body)
(Program
 (reserved_words_TCC1 0
  (reserved_words_TCC1-2 nil 3394869706 3397382521
   ("" (expand "is_finite")
    ((""
      (inst 1 "6"
       "LAMBDA (n : {n: Name | n = This OR n = Super OR n = rsIf OR n = rsThen OR n = rsElse}) :
                         IF n = This THEN 1
                         ELSIF n = Super THEN 2
                         ELSIF n = rsIf THEN 3
                         ELSIF n = rsThen THEN 4
                         ELSIF n = rsElse THEN 5
                         ELSE 0 ENDIF")
      (("" (expand "injective?")
        (("" (skosimp)
          (("" (lift-if)
            (("" (assert)
              (("" (grind)
                (("" (typepred "x1!1") (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil nil
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil nil
    nil (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil) nil nil
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil))
   84 83 nil nil)
  (reserved_words_TCC1-1 nil 3394869664 nil ("" (subtype-tcc) nil nil)
   nil nil nil nil nil nil)))
(ProgramFunctions
 (var_names_TCC1 0
  (var_names_TCC1-1 nil 3390821142 3397559467 ("" (grind) nil nil)
   unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   101 101 t nil))
 (var_names_TCC2 0
  (var_names_TCC2-1 nil 3390821142 3397559468 ("" (grind) nil nil)
   unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   97 98 t nil))
 (var_names_TCC3 0
  (var_names_TCC3-1 nil 3397378010 3397559469
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   77 77 nil nil))
 (var_names_TCC4 0
  (var_names_TCC4-1 nil 3397378010 3397559470
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   116 116 t nil))
 (var_names_TCC5 0
  (var_names_TCC5-1 nil 3397378010 3397559471
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   82 82 nil nil))
 (var_names_TCC6 0
  (var_names_TCC6-1 nil 3397378010 3397559472
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   135 135 nil nil))
 (var_names_TCC7 0
  (var_names_TCC7-1 nil 3397378010 3397559473
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   99 99 nil nil))
 (var_names_TCC8 0
  (var_names_TCC8-1 nil 3397378010 3397559474
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   78 78 nil nil))
 (var_names_TCC9 0
  (var_names_TCC9-1 nil 3397378010 3397559475
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   95 95 nil nil))
 (var_names_TCC10 0
  (var_names_TCC10-1 nil 3397378010 3397559476
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   105 104 nil nil))
 (var_names_TCC11 0
  (var_names_TCC11-1 nil 3397378010 3397559477
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   104 104 nil nil))
 (var_names_TCC12 0
  (var_names_TCC12-1 nil 3397378010 3397559478
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   120 120 nil nil))
 (var_names_TCC13 0
  (var_names_TCC13-1 nil 3397378010 3397559479
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   99 100 nil nil))
 (var_names_TCC14 0
  (var_names_TCC14-1 nil 3397378010 3397559480
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   99 99 nil nil))
 (var_names_TCC15 0
  (var_names_TCC15-1 nil 3397378010 3397559481
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   95 95 nil nil))
 (var_names_TCC16 0
  (var_names_TCC16-1 nil 3397378010 3397559482
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   78 78 nil nil))
 (var_names_TCC17 0
  (var_names_TCC17-2 "" 3397383573 3397565139
   ("" (skosimp*)
    (("" (expand "size")
      (("" (expand "reduce_nat" 1 2)
        (("" (assert)
          ((""
            (name-replace "s" "reduce_nat(LAMBDA (i: int): 1,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n: Name): 1, 1, 1,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n: Name): 1, 1,
                                      LAMBDA (n: Name): 1,
                                      LAMBDA (nm: Name, n: nat): 1 + n,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (n1, n2, n3: nat):
                                        1 + n1 + n2 + n3,
                                      LAMBDA (n1: nat, nm: Name, n2: nat):
                                        1 + n1 + n2,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (l: list[[nat, nat]]):
                                        1 +
                                         sum(map[[nat, nat], nat]
                                                 (LAMBDA (n1, n2: nat):
                                                    1 + n1 + n2)
                                                 (l)),
                                      LAMBDA (n1, n2, n3: nat):
                                        1 + n1 + n2 + n3,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (nm: Name, n: nat): 1 + n, 1,
                                      LAMBDA (n: nat): 1 + n, 1,
                                      LAMBDA (n1, n2, n3: nat):
                                        1 + n1 + n2 + n3,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n: nat): 1 + n)")
            ((""
              (use "sum_geq_than_elements"
                   ("x" "s(proj_1(x!1)) + s(proj_2(x!1)) + 1"))
              (("" (split -1)
                (("1" (assert) nil nil)
                 ("2" (rewrite "map_list_composition")
                  (("2" (expand "o")
                    (("2" (replace -1)
                      (("2" (assert)
                        (("2"
                          (use "list_map_member[[BoolExpr, Stmt], nat]")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size const-decl "nat" ProgramFunctions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sum_geq_than_elements formula-decl nil listsum nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TT? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (FF? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolExpr type-eq-decl nil Body_adt nil)
    (CaseJML? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (IfThenElse? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Sequence? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Set? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Skip? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (StmtExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Throw? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (TryCatch? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (While? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assert? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Stmt type-eq-decl nil Body_adt nil)
    (branches adt-accessor-decl
     "[(CaseJML?) -> list[[BoolExpr, Stmt]]]" Body_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (map_list_composition formula-decl nil map_props nil)
    (list_map_member formula-decl nil list_map_funcs nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "T3" function_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (sum def-decl "nat" listsum nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Body type-decl nil Body_adt nil)
    (Name formal-nonempty-type-decl nil ProgramFunctions nil)
    (reduce_nat adt-def-decl "[Body -> nat]" Body_adt nil))
   216427 2720 t shostak)
  (var_names_TCC17-1 nil 3397378010 3397383381
   ("" (termination-tcc) nil nil) unfinished nil 79 79 t nil))
 (var_names_TCC18 0
  (var_names_TCC18-1 nil 3397378010 3397559822
   ("" (skosimp*)
    (("" (expand "size")
      (("" (expand "reduce_nat" 1 2)
        (("" (assert)
          ((""
            (name-replace "s" "reduce_nat(LAMBDA (i: int): 1,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n: Name): 1, 1, 1,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n: Name): 1, 1,
                                      LAMBDA (n: Name): 1,
                                      LAMBDA (nm: Name, n: nat): 1 + n,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (n1, n2, n3: nat):
                                        1 + n1 + n2 + n3,
                                      LAMBDA (n1: nat, nm: Name, n2: nat):
                                        1 + n1 + n2,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (n: nat): 1 + n,
                                      LAMBDA (l: list[[nat, nat]]):
                                        1 +
                                         sum(map[[nat, nat], nat]
                                                 (LAMBDA (n1, n2: nat):
                                                    1 + n1 + n2)
                                                 (l)),
                                      LAMBDA (n1, n2, n3: nat):
                                        1 + n1 + n2 + n3,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (nm: Name, n: nat): 1 + n, 1,
                                      LAMBDA (n: nat): 1 + n, 1,
                                      LAMBDA (n1, n2, n3: nat):
                                        1 + n1 + n2 + n3,
                                      LAMBDA (n1, n2: nat): 1 + n1 + n2,
                                      LAMBDA (n: nat): 1 + n)")
            ((""
              (use "sum_geq_than_elements"
                   ("x" "s(proj_1(x!1)) + s(proj_2(x!1)) + 1"))
              (("" (split -1)
                (("1" (assert) nil nil)
                 ("2" (rewrite "map_list_composition")
                  (("2" (expand "o")
                    (("2" (replace -1)
                      (("2" (assert)
                        (("2"
                          (use "list_map_member[[BoolExpr, Stmt], nat]")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    nil
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sum_geq_than_elements formula-decl nil listsum nil) nil nil nil
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    (map_list_composition formula-decl nil map_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (list_map_member formula-decl nil list_map_funcs nil) nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (sum def-decl "nat" listsum nil) nil nil
    (pred type-eq-decl nil defined_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) nil nil nil)
   1300 312 t nil))
 (var_names_TCC19 0
  (var_names_TCC19-1 nil 3397378010 3397559833 ("" (tcc) nil nil)
   unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   531 103 t nil))
 (var_names_TCC20 0
  (var_names_TCC20-1 nil 3397378010 3397559487
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   121 120 nil nil))
 (var_names_TCC21 0
  (var_names_TCC21-1 nil 3397378010 3397559488
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   104 103 nil nil))
 (var_names_TCC22 0
  (var_names_TCC22-1 nil 3397378010 3397559488
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   81 82 nil nil))
 (var_names_TCC23 0
  (var_names_TCC23-1 nil 3397378010 3397559490
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   114 115 nil nil))
 (var_names_TCC24 0
  (var_names_TCC24-1 nil 3397378010 3397559490 ("" (grind) nil nil)
   unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   78 78 t nil))
 (var_names_TCC25 0
  (var_names_TCC25-1 nil 3397378010 3397559491 ("" (grind) nil nil)
   unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   112 111 t nil))
 (var_names_TCC26 0
  (var_names_TCC26-1 nil 3397380658 3397559492
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   104 104 nil nil))
 (var_names_TCC27 0
  (var_names_TCC27-1 nil 3397380658 3397559493
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   105 105 nil nil))
 (var_names_TCC28 0
  (var_names_TCC28-1 nil 3397380658 3397559495
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   104 104 nil nil))
 (var_names_TCC29 0
  (var_names_TCC29-1 nil 3397380658 3397559496
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   99 99 nil nil))
 (var_names_TCC30 0
  (var_names_TCC30-1 nil 3397380658 3397559497
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   115 116 nil nil))
 (var_names_TCC31 0
  (var_names_TCC31-1 nil 3397380658 3397559497
   ("" (termination-tcc) nil nil) unchecked
   (nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   78 77 nil nil))
 (var_names_TCC32 0
  (var_names_TCC32-1 nil 3397380658 3397559886
   ("" (skosimp*)
    (("" (typepred "fs!1")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1"
             "LAMBDA (n : ({n: Name | EXISTS (f: FieldDecl): fs!1(f) AND name(f) = n})) :
                          f!1(choose({f : FieldDecl | fs!1(f) AND name(f) = n}))")
            (("1" (expand "injective?")
              (("1" (skosimp)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skolem!) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skolem!) (("3" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem!)
              (("2" (typepred "n!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil) nil nil nil nil nil
    nil (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil nil
    (injective? const-decl "bool" functions nil) nil nil
    (nonempty_exists formula-decl nil sets_lemmas nil) nil nil nil nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   1517 181 t nil))
 (var_names_TCC33 0
  (var_names_TCC33-2 nil 3397556068 3397559968
   ("" (skosimp*)
    (("" (typepred "ls!1")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1"
             "LAMBDA (n : ({n: Name | EXISTS (l: LocalVarDecl): ls!1(l) AND name(l) = n})) :
                          f!1(choose({l : LocalVarDecl | ls!1(l) AND name(l) = n}))")
            (("1" (expand "injective?")
              (("1" (skosimp)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skolem!) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skolem!) (("3" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem!)
              (("2" (typepred "n!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil) nil nil nil nil
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil nil
    (injective? const-decl "bool" functions nil) nil nil
    (nonempty_exists formula-decl nil sets_lemmas nil) nil nil nil nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   7568 838 t nil)
  (var_names_TCC33-1 nil 3397380658 3397555915
   ("" (skolem-typepred)
    (("" (expand "is_finite")
      (("" (skolem!)
        ((""
          (inst 1 "N!1"
           "LAMBDA (n : ({n: Name | EXISTS (l : LocalVarDecl): ls!1(l) AND name(l) = n})) :
                      f!1(choose({l : LocalVarDecl | ls!1(l) AND name(l) = n}))")
          (("1" (expand "injective?")
            (("1" (skosimp)
              (("1" (inst?)
                (("1" (assert) nil nil)
                 ("2" (typepred "x2!1")
                  (("2" (rewrite "nonempty_exists")
                    (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil))
                  nil)
                 ("3" (typepred "x1!1")
                  (("3" (rewrite "nonempty_exists")
                    (("3" (skolem!) (("3" (inst?) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem!)
            (("2" (typepred "n!1")
              (("2" (rewrite "nonempty_exists")
                (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (injective? const-decl "bool" functions nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   169 170 t nil))
 (var_names_union 0
  (var_names_union-1 nil 3396846432 3397559506
   ("" (skosimp*)
    (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil))
    nil)
   unfinished
   (nil nil nil nil (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    nil (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (member const-decl "bool" sets nil))
   288 288 t shostak))
 (getFieldDecls_TCC1 0
  (getFieldDecls_TCC1-3 nil 3391148557 3397559508
   ("" (skosimp*)
    (("" (use "finite_set_induction[Class]")
      ((""
        (inst -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND fields(c)(f)})")
        (("" (split -1)
          (("1" (inst -1 "classes(p!1)") nil nil)
           ("2" (hide 2)
            (("2" (skosimp*)
              (("2"
                (case-replace " ({f: FieldDecl |
                  EXISTS (c: Class): add(t!1, x!1)(c) AND fields(c)(f)}) = union({f : FieldDecl | fields(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND fields(c)(f)})")
                (("1" (hide -1)
                  (("1" (use "finite_union[FieldDecl]")
                    (("1" (hide -1 2)
                      (("1" (typepred "fields(t!1)")
                        (("1"
                          (case-replace
                           "fields(t!1) = {f : FieldDecl | fields(t!1)(f)}")
                          (("1" (assert)
                            (("1" (apply-extensionality :hide? t) nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (hide -1 2)
                    (("2" (expand "union")
                      (("2" (expand "add")
                        (("2" (expand "member")
                          (("2" (iff)
                            (("2" (prop)
                              (("1"
                                (skosimp*)
                                (("1"
                                  (split -1)
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (inst?)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (inst?) nil nil)
                               ("3"
                                (skosimp*)
                                (("3"
                                  (inst?)
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (expand "emptyset")
              (("3"
                (case-replace
                 "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (use "finite_emptyset[FieldDecl]") nil nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    nil nil nil (boolean nonempty-type-decl nil booleans nil) nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil nil
    (member const-decl "bool" sets nil) nil
    (finite_union judgement-tcc nil finite_sets nil) nil nil
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset judgement-tcc nil finite_sets nil) nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   175 175 t nil)
  (getFieldDecls_TCC1-2 nil 3390902649 3391148163
   ("" (skosimp*)
    (("" (use "finite_set_induction[Class]")
      ((""
        (inst -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND fields(c)(f)})")
        (("" (split -1)
          (("1" (inst -1 "classes(p!1)") nil nil)
           ("2" (hide 2)
            (("2" (skosimp*)
              (("2"
                (case-replace " ({f: FieldDecl |
                      EXISTS (c: Class): add(t!1, x!1)(c) AND fields(c)(f)}) = union({f : FieldDecl | fields(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND fields(c)(f)})")
                (("1" (hide -1)
                  (("1" (use "finite_union[FieldDecl]")
                    (("1" (hide -1 2)
                      (("1" (typepred "fields(t!1)")
                        (("1"
                          (case-replace
                           "fields(t!1) = {f : FieldDecl[Name] | fields(t!1)(f)}")
                          (("1" (apply-extensionality 1) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (hide -1 2)
                    (("2" (expand* "union" "add" "member")
                      (("2" (iff)
                        (("2" (prop)
                          (("1" (skosimp*)
                            (("1" (split -1)
                              (("1" (assert) nil nil)
                               ("2"
                                (inst?)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst?) nil nil)
                           ("3" (skosimp*)
                            (("3" (inst?) (("3" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (expand "emptyset")
              (("3"
                (case-replace
                 "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (use "finite_emptyset[FieldDecl]") nil nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   (nil nil nil (boolean nonempty-type-decl nil booleans nil) nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil
    (lift type-decl nil lift_adt nil) nil
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    nil (member const-decl "bool" sets nil) nil
    (finite_union judgement-tcc nil finite_sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset judgement-tcc nil finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil) nil
    nil (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   412 330 t nil)
  (getFieldDecls_TCC1-1 nil 3390821142 3390894974
   ("" (skolem!)
    (("" (typepred "classes(p!1)")
      (("" (expand "is_finite")
        (("" (skolem!) (("" (postpone) nil nil)) nil)) nil))
      nil))
    nil)
   unchecked nil 5557840 390 t nil))
 (getLocalDecls_TCC1 0
  (getLocalDecls_TCC1-2 nil 3390903916 3397559511
   ("" (skosimp*)
    (("" (use "finite_set_induction[Class]")
      ((""
        (inst -1
         "LAMBDA(C : finite_set[Class]) : is_finite[LocalVarDecl]({l : LocalVarDecl | EXISTS (c : Class, m : Method) : C(c) AND methods(c)(m) AND (lvars(m)(l) OR l = arg(m))})")
        (("" (split -1)
          (("1" (inst -1 "classes(p!1)") nil nil)
           ("2" (hide 2)
            (("2" (skosimp*)
              (("2"
                (case-replace " {l: LocalVarDecl |
                  EXISTS (c: Class, m: Method):
                    add(t!1, x!1)(c) AND
                     methods(c)(m) AND (lvars(m)(l) OR l = arg(m))} = union({l : LocalVarDecl | EXISTS (m : Method) : methods(t!1)(m) AND (lvars(m)(l) OR l = arg(m))}, {l : LocalVarDecl |
                  EXISTS (c: Class, m: Method):
                    x!1(c) AND methods(c)(m) AND (lvars(m)(l) OR l = arg(m))})"
                 :hide? t)
                (("1" (use "finite_union[LocalVarDecl]")
                  (("1" (hide -1 2)
                    (("1" (use "finite_set_induction[Method]")
                      (("1"
                        (inst -1
                         "LAMBDA(M : finite_set[Method]) : is_finite[LocalVarDecl]({l: LocalVarDecl |EXISTS(m : Method) : M(m) AND (lvars(m)(l) OR l = arg(m))})")
                        (("1" (split -1)
                          (("1" (inst?) nil nil)
                           ("2" (hide 2)
                            (("2" (skosimp*)
                              (("2"
                                (case-replace
                                 "{l: LocalVarDecl |
                      EXISTS (m: Method):
                        add(t!2, x!2)(m) AND (lvars(m)(l) OR l = arg(m))} = union(lvars(t!2), union(singleton(arg(t!2)), {l : LocalVarDecl | EXISTS (m: Method): x!2(m) AND (lvars(m)(l) OR l = arg(m))}))"
                                 :hide?
                                 t)
                                (("1"
                                  (use "finite_union[LocalVarDecl]")
                                  (("1"
                                    (use "finite_union[LocalVarDecl]")
                                    nil
                                    nil))
                                  nil)
                                 ("2"
                                  (hide -1 2)
                                  (("2"
                                    (apply-extensionality :hide? t)
                                    (("2"
                                      (expand "union")
                                      (("2"
                                        (expand "add")
                                        (("2"
                                          (expand "singleton")
                                          (("2"
                                            (expand "member")
                                            (("2"
                                              (iff)
                                              (("2"
                                                (prop)
                                                (("1"
                                                  (skosimp*)
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (split -1)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (inst?)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (inst?)
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (skosimp*)
                                                  (("4"
                                                    (inst?)
                                                    (("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (hide 2)
                            (("3" (expand "emptyset")
                              (("3"
                                (case-replace
                                 "{f : LocalVarDecl | FALSE} = emptyset[LocalVarDecl]")
                                (("1"
                                  (use "finite_emptyset[LocalVarDecl]")
                                  nil
                                  nil)
                                 ("2"
                                  (apply-extensionality :hide? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (hide -1 2)
                    (("2" (expand "union")
                      (("2" (expand "add")
                        (("2" (expand "member")
                          (("2" (iff)
                            (("2" (prop)
                              (("1"
                                (skosimp*)
                                (("1"
                                  (split -1)
                                  (("1"
                                    (inst?)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (inst? 2)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skosimp*)
                                (("2"
                                  (inst?)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil)
                               ("3"
                                (skosimp*)
                                (("3"
                                  (inst?)
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (expand "emptyset")
              (("3"
                (case-replace
                 "{f : LocalVarDecl | FALSE} = emptyset[LocalVarDecl]")
                (("1" (use "finite_emptyset[LocalVarDecl]") nil nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    nil nil nil (boolean nonempty-type-decl nil booleans nil) nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil nil nil nil
    (finite_union judgement-tcc nil finite_sets nil)
    (member const-decl "bool" sets nil) nil nil
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (nonempty_union2 application-judgement "(nonempty?)" sets nil)
    (nonempty_union1 application-judgement "(nonempty?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset judgement-tcc nil finite_sets nil) nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   360 357 t nil)
  (getLocalDecls_TCC1-1 nil 3390821142 3390821234
   ("" (subtype-tcc) nil nil) unchecked nil 605 450 nil nil))
 (getGhostDecls_TCC1 0
  (getGhostDecls_TCC1-3 nil 3391148598 3397559513
   ("" (skosimp*)
    (("" (use "finite_set_induction[Class]")
      ((""
        (inst -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND ghost_vars(c)(f)})")
        (("" (split -1)
          (("1" (inst -1 "classes(p!1)") nil nil)
           ("2" (hide 2)
            (("2" (skosimp*)
              (("2"
                (case-replace " ({f: FieldDecl |
                          EXISTS (c: Class): add(t!1, x!1)(c) AND ghost_vars(c)(f)}) = union({f : FieldDecl | ghost_vars(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND ghost_vars(c)(f)})")
                (("1" (hide -1)
                  (("1" (use "finite_union[FieldDecl]")
                    (("1" (hide -1 2)
                      (("1" (typepred "ghost_vars(t!1)")
                        (("1"
                          (case-replace
                           "ghost_vars(t!1) = {f : FieldDecl | ghost_vars(t!1)(f)}")
                          (("1" (assert)
                            (("1" (apply-extensionality :hide? t) nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (hide -1 2)
                    (("2" (expand* "union" "add" "member")
                      (("2" (iff)
                        (("2" (prop)
                          (("1" (skosimp*)
                            (("1" (ground)
                              (("1"
                                (inst?)
                                (("1"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst?) nil nil)
                           ("3" (skosimp*)
                            (("3" (inst?) (("3" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (expand "emptyset")
              (("3"
                (case-replace
                 "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (use "finite_emptyset[FieldDecl]") nil nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    nil nil nil (boolean nonempty-type-decl nil booleans nil) nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil nil
    (member const-decl "bool" sets nil) nil
    (finite_union judgement-tcc nil finite_sets nil) nil nil
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset judgement-tcc nil finite_sets nil) nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   160 159 t nil)
  (getGhostDecls_TCC1-2 nil 3390903999 3391148164
   ("" (skosimp*)
    (("" (use "finite_set_induction[Class]")
      ((""
        (inst -1
         "LAMBDA(C : finite_set[Class]) : is_finite[FieldDecl]({f : FieldDecl | EXISTS (c : Class) : C(c) AND ghost_vars(c)(f)})")
        (("" (split -1)
          (("1" (inst -1 "classes(p!1)") nil nil)
           ("2" (hide 2)
            (("2" (skosimp*)
              (("2"
                (case-replace " ({f: FieldDecl |
                      EXISTS (c: Class): add(t!1, x!1)(c) AND ghost_vars(c)(f)}) = union({f : FieldDecl | ghost_vars(t!1)(f)}, {f : FieldDecl | EXISTS (c : Class) : x!1(c) AND ghost_vars(c)(f)})")
                (("1" (hide -1)
                  (("1" (use "finite_union[FieldDecl]")
                    (("1" (hide -1 2)
                      (("1" (typepred "ghost_vars(t!1)")
                        (("1"
                          (case-replace
                           "ghost_vars(t!1) = {f : FieldDecl | ghost_vars(t!1)(f)}")
                          (("1" (apply-extensionality) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (hide -1 2)
                    (("2" (expand "union")
                      (("2" (expand "add")
                        (("2" (expand "member")
                          (("2" (iff)
                            (("2" (prop)
                              (("1"
                                (skosimp*)
                                (("1"
                                  (split -1)
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (inst?)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (inst?) nil nil)
                               ("3"
                                (skosimp*)
                                (("3"
                                  (inst?)
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (expand "emptyset")
              (("3"
                (case-replace
                 "{f : FieldDecl | FALSE} = emptyset[FieldDecl]")
                (("1" (use "finite_emptyset[FieldDecl]") nil nil)
                 ("2" (apply-extensionality :hide? t)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset judgement-tcc nil finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (finite_union judgement-tcc nil finite_sets nil) nil
    (member const-decl "bool" sets nil) nil
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    nil (lift type-decl nil lift_adt nil) nil nil
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil
    (boolean nonempty-type-decl nil booleans nil) nil nil nil)
   436 310 t nil)
  (getGhostDecls_TCC1-1 nil 3390821142 3390821234
   ("" (subtype-tcc) nil nil) unchecked nil 474 450 nil nil))
 (declared_var_names_TCC1 0
  (declared_var_names_TCC1-1 nil 3394869665 3397559513
   ("" (skosimp)
    ((""
      (case-replace "{n: Name |
              var_names(getFieldDecls(p!1))(n) OR
              var_names(getLocalDecls(p!1))(n) OR
              var_names(getGhostDecls(p!1))(n)} =
              union(union(var_names(getFieldDecls(p!1)), var_names(getLocalDecls(p!1))), var_names(getGhostDecls(p!1)))")
      (("1" (hide -1) (("1" (use "finite_union[Name]") nil nil)) nil)
       ("2" (hide 2) (("2" (expand* "union" "member") nil nil)) nil))
      nil))
    nil)
   unchecked
   ((finite_union application-judgement "finite_set" finite_sets nil)
    nil (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil nil
    nil (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil nil nil nil nil nil
    (union const-decl "set" sets nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (member const-decl "bool" sets nil))
   22 22 t nil))
 (ext_declared_var_names_TCC1 0
  (ext_declared_var_names_TCC1-1 nil 3397554464 3397559514
   ("" (skosimp*)
    (("" (rewrite "finite_union")
      (("1" (expand "is_finite")
        (("1"
          (inst 1 "1" "LAMBDA(n : ({n: Name | n = This[Name]})) : 0")
          (("1" (expand "injective?") (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (use "declared_var_names_TCC1") nil nil))
      nil))
    nil)
   unfinished
   ((finite_union judgement-tcc nil finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil nil
    nil nil nil nil nil nil (lift type-decl nil lift_adt nil) nil nil
    nil nil nil nil (= const-decl "[T, T -> boolean]" equalities nil)
    nil nil (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil) nil)
   57 57 t nil))
 (class_names_TCC1 0
  (class_names_TCC1-1 nil 3390821142 3397559516
   ("" (skolem!)
    (("" (typepred "classes(p!1)")
      (("" (expand "is_finite")
        (("" (skolem!)
          ((""
            (inst 1 "N!1"
             "LAMBDA (n : ({n: Name | EXISTS (c : Class): classes(p!1)(c) AND name(c) = n})) :
                      f!1(choose({c : Class | classes(p!1)(c) AND name(c) = n}))")
            (("1" (expand "injective?")
              (("1" (skosimp)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skolem!) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skolem!) (("3" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem!)
              (("2" (typepred "n!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skolem!) (("2" (inst?) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil) nil nil nil nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil nil nil
    (injective? const-decl "bool" functions nil) nil nil
    (nonempty_exists formula-decl nil sets_lemmas nil) nil nil nil nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   206 205 t nil))
 (method_names_TCC1 0
  (method_names_TCC1-1 nil 3390821142 3397559518
   ("" (skosimp*)
    (("" (typepred "methods(c!1)")
      (("" (expand "is_finite")
        (("" (skolem!)
          ((""
            (inst 1 "N!1"
             "LAMBDA (n: {n: Name | EXISTS (m: Method): classes(p!1)(c!1) AND methods(c!1)(m) AND name(m) = n}):
                     f!1(choose({m : Method | methods(c!1)(m) AND name(m) = n}))")
            (("1" (expand "injective?")
              (("1" (skosimp)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skolem!)
                        (("2" (inst?) (("2" (prop) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skolem!)
                        (("3" (inst?) (("3" (prop) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skolem!)
              (("2" (typepred "n!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skolem!)
                    (("2" (inst?) (("2" (prop) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil) nil nil nil nil nil
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil nil nil
    (lift type-decl nil lift_adt nil) nil nil nil
    (injective? const-decl "bool" functions nil) nil nil
    (nonempty_exists formula-decl nil sets_lemmas nil) nil nil nil nil
    nil nil (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   207 206 t nil))
 (methods_TCC1 0
  (methods_TCC1-1 nil 3392356310 3397559524
   ("" (skosimp*)
    (("" (use "finite_set_induction[Class]")
      ((""
        (inst -1
         "LAMBDA(C : finite_set[Class]) : is_finite[Method[Name]]
            ({m: Method[Name] |
                EXISTS (c: Class[Name]): C(c) AND methods(c)(m)})")
        (("" (assert)
          (("" (split -1)
            (("1" (inst -1 "classes(p!1)") nil nil)
             ("2" (hide 2)
              (("2" (skosimp*)
                (("2"
                  (case-replace "({m: Method[Name] |
                   EXISTS (c: Class[Name]): add(t!1, x!1)(c) AND methods(c)(m)})
     = union({m : Method[Name] | methods(t!1)(m)}, {m : Method[Name] | EXISTS (c : Class[Name]) : x!1(c) AND methods(c)(m)})"
                   :hide? t)
                  (("1" (use "finite_union[Method[Name]]")
                    (("1" (hide -1 2)
                      (("1" (typepred "methods(t!1)")
                        (("1"
                          (case-replace
                           "methods(t!1) = {m : Method[Name] | methods(t!1)(m)}"
                           :hide? t)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide -1 2)
                    (("2" (apply-extensionality :hide? t)
                      (("2" (expand* "union" "add" "member")
                        (("2" (iff)
                          (("2" (prop)
                            (("1" (skosimp*)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (inst?) nil nil)
                             ("3" (skosimp*)
                              (("3"
                                (inst?)
                                (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (hide 2)
              (("3" (expand "emptyset")
                (("3"
                  (case-replace
                   "{m: Method[Name] | FALSE} = emptyset[Method[Name]]")
                  (("1" (use "finite_emptyset[Method[Name]]") nil nil)
                   ("2" (apply-extensionality :hide? t)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    nil nil nil (boolean nonempty-type-decl nil booleans nil) nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil) nil
    (finite_emptyset judgement-tcc nil finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (injective? const-decl "bool" functions nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (finite_union judgement-tcc nil finite_sets nil) nil nil
    (member const-decl "bool" sets nil) nil nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   599 598 t nil))
 (get_class_TCC1 0
  (get_class_TCC1-1 nil 3390821142 3397559524
   ("" (subtype-tcc) nil nil) unchecked
   ((nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil) nil nil
    (lift type-decl nil lift_adt nil) nil nil nil nil nil
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil
    (boolean nonempty-type-decl nil booleans nil) nil nil)
   42 41 nil nil))
 (lookup_mthd_TCC1 0
  (lookup_mthd_TCC1-1 nil 3396591590 3397559525
   ("" (subtype-tcc) nil nil) unchecked
   ((nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil) nil nil nil nil nil nil
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil)
   27 27 nil nil))
 (lookup_mthd_TCC2 0
  (lookup_mthd_TCC2-1 nil 3396591590 3397559525
   ("" (skosimp*)
    (("" (expand "every")
      (("" (expand "methods")
        (("" (inst 1 "down[Class[Name]](get_class(p!1)(tgt!1))")
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   unchecked
   (nil nil nil (boolean nonempty-type-decl nil booleans nil) nil nil
    nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil
    nil (lift type-decl nil lift_adt nil) nil
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil) nil nil nil
    (choose const-decl "(p)" sets nil) nil nil)
   27 27 t nil))
 (proper_subterm_sequence 0
  (proper_subterm_sequence-2 nil 3397378089 3397559540
   ("" (induct "c3")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "<<" -3)
        (("2" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst?)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*) (("3" (expand "<<") (("3" (propax) nil nil)) nil))
      nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skosimp*)
      (("6" (expand "<<" -2)
        (("6" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp*)
      (("7" (expand "<<" -3)
        (("7" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp*)
      (("8" (expand "<<" -3)
        (("8" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil)
     ("12" (skosimp*)
      (("12" (expand "<<" -2)
        (("12" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("13" (skosimp*)
      (("13" (expand "<<" -2)
        (("13" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("14" (skosimp*)
      (("14" (expand "<<" -4)
        (("14" (split -4)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("5" (replace -1 :dir rl)
            (("5" (expand "<<" 1)
              (("5" (expand "<<" 1) (("5" (propax) nil nil)) nil))
              nil))
            nil)
           ("6" (inst? -4)
            (("6" (assert)
              (("6" (flatten)
                (("6" (expand "<<" 1) (("6" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (skosimp*)
      (("15" (expand "<<" -3)
        (("15" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("16" (skosimp*)
      (("16" (expand "<<" -2)
        (("16" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("17" (skosimp*)
      (("17" (expand "<<" -2)
        (("17" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("18" (skosimp*)
      (("18" (rewrite "every_is_forall[[BoolExpr, Stmt]]")
        (("18" (expand "<<" -2)
          (("18" (expand "<<" 1)
            (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
              (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
                (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
                  (("18" (skosimp*)
                    (("18" (inst?)
                      (("18" (assert)
                        (("18" (flatten)
                          (("18" (split 1)
                            (("1" (inst?)
                              (("1"
                                (assert)
                                (("1"
                                  (split -4)
                                  (("1"
                                    (replace -1 :dir rl)
                                    (("1"
                                      (expand "<<" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst? -2)
                                    (("2"
                                      (assert)
                                      (("2" (flatten) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1 :dir rl)
                                    (("3"
                                      (expand "<<" 1)
                                      (("3" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (inst? -3)
                                    (("4"
                                      (assert)
                                      (("4" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst?)
                              (("2"
                                (assert)
                                (("2"
                                  (split -4)
                                  (("1"
                                    (replace -1 :dir rl)
                                    (("1"
                                      (expand "<<" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst? -2)
                                    (("2"
                                      (assert)
                                      (("2" (flatten) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1 :dir rl)
                                    (("3"
                                      (expand "<<" 1)
                                      (("3" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (inst? -3)
                                    (("4"
                                      (assert)
                                      (("4" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("19" (skosimp*)
      (("19" (expand "<<" -4)
        (("19" (split -4)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("5" (replace -1 :dir rl)
            (("5" (expand "<<" 1)
              (("5" (expand "<<" 1) (("5" (propax) nil nil)) nil))
              nil))
            nil)
           ("6" (inst? -4)
            (("6" (assert)
              (("6" (flatten)
                (("6" (expand "<<" 1) (("6" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("20" (skosimp*)
      (("20" (expand "<<" -3)
        (("20" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("21" (skosimp*)
      (("21" (expand "<<" -2)
        (("21" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("22" (grind) nil nil)
     ("23" (skosimp*)
      (("23" (expand "<<" -2)
        (("23" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("24" (grind) nil nil)
     ("25" (skosimp*)
      (("25" (expand "<<" -4)
        (("25" (split -4)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("5" (replace -1 :dir rl)
            (("5" (expand "<<" 1)
              (("5" (expand "<<" 1) (("5" (propax) nil nil)) nil))
              nil))
            nil)
           ("6" (inst? -4)
            (("6" (assert)
              (("6" (flatten)
                (("6" (expand "<<" 1) (("6" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("26" (skosimp*)
      (("26" (expand "<<" -3)
        (("26" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("27" (skosimp*)
      (("27" (expand "<<" -2)
        (("27" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((some_is_exists formula-decl nil listfuncs nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil nil
    nil nil nil (list type-decl nil list_adt nil)
    (every_is_forall formula-decl nil listfuncs nil) nil nil nil nil
    nil (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil) nil nil nil nil nil nil
    nil nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil) nil)
   1471 1467 t nil)
  (proper_subterm_sequence-1 nil 3396269350 3396593333
   ("" (induct "c3")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "<<" -3)
        (("2" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst?)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp*) (("3" (expand "<<") (("3" (propax) nil nil)) nil))
      nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skosimp*)
      (("6" (expand "<<" -2)
        (("6" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp*)
      (("7" (expand "<<" -3)
        (("7" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp*)
      (("8" (expand "<<" -3)
        (("8" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil)
     ("12" (skosimp*)
      (("12" (expand "<<" -2)
        (("12" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("13" (skosimp*)
      (("13" (expand "<<" -2)
        (("13" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("14" (skosimp*)
      (("14" (expand "<<" -4)
        (("14" (split -4)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("5" (replace -1 :dir rl)
            (("5" (expand "<<" 1)
              (("5" (expand "<<" 1) (("5" (propax) nil nil)) nil))
              nil))
            nil)
           ("6" (inst? -4)
            (("6" (assert)
              (("6" (flatten)
                (("6" (expand "<<" 1) (("6" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (skosimp*)
      (("15" (expand "<<" -3)
        (("15" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("16" (skosimp*)
      (("16" (expand "<<" -2)
        (("16" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("17" (skosimp*)
      (("17" (expand "<<" -2)
        (("17" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("18" (skosimp*)
      (("18" (rewrite "every_is_forall[[BoolExpr, Stmt]]")
        (("18" (expand "<<" -2)
          (("18" (expand "<<" 1)
            (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
              (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
                (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
                  (("18" (skosimp*)
                    (("18" (inst?)
                      (("18" (assert)
                        (("18" (flatten)
                          (("18" (split 1)
                            (("1" (inst?)
                              (("1"
                                (assert)
                                (("1"
                                  (split -4)
                                  (("1"
                                    (replace -1 :dir rl)
                                    (("1"
                                      (expand "<<" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst? -2)
                                    (("2"
                                      (assert)
                                      (("2" (flatten) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1 :dir rl)
                                    (("3"
                                      (expand "<<" 1)
                                      (("3" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (inst? -3)
                                    (("4"
                                      (assert)
                                      (("4" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst?)
                              (("2"
                                (assert)
                                (("2"
                                  (split -4)
                                  (("1"
                                    (replace -1 :dir rl)
                                    (("1"
                                      (expand "<<" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst? -2)
                                    (("2"
                                      (assert)
                                      (("2" (flatten) nil nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1 :dir rl)
                                    (("3"
                                      (expand "<<" 1)
                                      (("3" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (inst? -3)
                                    (("4"
                                      (assert)
                                      (("4" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("19" (skosimp*)
      (("19" (expand "<<" -4)
        (("19" (split -4)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("5" (replace -1 :dir rl)
            (("5" (expand "<<" 1)
              (("5" (expand "<<" 1) (("5" (propax) nil nil)) nil))
              nil))
            nil)
           ("6" (inst? -4)
            (("6" (assert)
              (("6" (flatten)
                (("6" (expand "<<" 1) (("6" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("20" (skosimp*)
      (("20" (expand "<<" -3)
        (("20" (split -3)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("21" (skosimp*)
      (("21" (expand "<<" -2)
        (("21" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("22" (grind) nil nil)
     ("23" (skosimp*)
      (("23" (expand "<<" -2)
        (("23" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("24" (grind) nil nil)
     ("25" (skosimp*)
      (("25" (expand "<<" -4)
        (("25" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("5" (replace -1 :dir rl)
            (("5" (expand "<<" 1)
              (("5" (expand "<<" 1) (("5" (propax) nil nil)) nil))
              nil))
            nil)
           ("6" (inst? -4)
            (("6" (assert)
              (("6" (flatten)
                (("6" (expand "<<" 1) (("6" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("26" (skosimp*)
      (("26" (expand "<<" -3)
        (("26" (split -)
          (("1" (replace -1 :dir rl)
            (("1" (expand "<<" 1)
              (("1" (expand "<<" 1) (("1" (propax) nil nil)) nil))
              nil))
            nil)
           ("2" (inst? -2)
            (("2" (assert)
              (("2" (flatten)
                (("2" (expand "<<" 1) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replace -1 :dir rl)
            (("3" (expand "<<" 1)
              (("3" (expand "<<" 1) (("3" (propax) nil nil)) nil))
              nil))
            nil)
           ("4" (inst? -3)
            (("4" (assert)
              (("4" (flatten)
                (("4" (expand "<<" 1) (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried
   ((some_is_exists formula-decl nil listfuncs nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil nil
    nil nil nil (list type-decl nil list_adt nil)
    (every_is_forall formula-decl nil listfuncs nil) nil nil nil nil
    nil (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil) nil nil nil nil nil nil
    nil nil nil nil nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil) nil)
   1422 1422 t nil))
 (proper_subterm_set_clause_sequence 0
  (proper_subterm_set_clause_sequence-1 nil 3396269362 3397559540
   ("" (skosimp*)
    (("" (expand "proper_subterm_set_clause")
      (("" (lemma "proper_subterm_sequence")
        (("" (inst-cp - "c1!1" "c2!1" "pre_set(m!1)")
          (("" (inst-cp - "c1!1" "c2!1" "post_set(m!1)")
            (("" (inst - "c1!1" "c2!1" "exc_set(m!1)")
              (("" (ground) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   (nil nil nil (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil) nil nil nil nil nil
    nil nil nil nil nil nil nil nil nil
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil nil)
   22 22 t nil))
 (proper_subterm_is_transitive 0
  (proper_subterm_is_transitive-1 nil 3396272071 3397559547
   ("" (induct "c3")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "<<" 1)
        (("2" (expand "<<" -4)
          (("2" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (grind) nil nil)
     ("7" (skosimp*)
      (("7" (expand "<<" 1)
        (("7" (expand "<<" -4)
          (("7" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp*)
      (("8" (expand "<<" 1)
        (("8" (expand "<<" -4)
          (("8" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skosimp*)
      (("14" (expand "<<" 1)
        (("14" (expand "<<" -5)
          (("14" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil)) nil)
             ("5" (inst -4 "c1!1" "c2!1") (("5" (assert) nil nil)) nil)
             ("6" (inst -4 "c1!1" "c2!1") (("6" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (skosimp*)
      (("15" (expand "<<" 1)
        (("15" (expand "<<" -4)
          (("15" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("16" (grind) nil nil) ("17" (grind) nil nil)
     ("18" (skosimp*)
      (("18" (rewrite "every_is_forall[[BoolExpr, Stmt]]")
        (("18" (expand "<<" (-3 1))
          (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
            (("18" (rewrite "some_is_exists[[BoolExpr, Stmt]]")
              (("18" (skosimp*)
                (("18" (inst?)
                  (("18" (assert)
                    (("18" (flatten)
                      (("18" (inst 1 "x!1")
                        (("18" (assert)
                          (("18" (split -5)
                            (("1" (assert) nil nil)
                             ("2" (inst -2 "c1!1" "c2!1")
                              (("2" (assert) nil nil)) nil)
                             ("3" (assert) nil nil)
                             ("4" (inst -3 "c1!1" "c2!1")
                              (("4" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("19" (skosimp*)
      (("19" (expand "<<" 1)
        (("19" (expand "<<" -5)
          (("19" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil)) nil)
             ("5" (assert) nil nil)
             ("6" (inst -4 "c1!1" "c2!1") (("6" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("20" (skosimp*)
      (("20" (expand "<<" 1)
        (("20" (expand "<<" -4)
          (("20" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("21" (grind) nil nil) ("22" (grind) nil nil)
     ("23" (grind) nil nil) ("24" (grind) nil nil)
     ("25" (skosimp*)
      (("25" (expand "<<" 1)
        (("25" (expand "<<" -5)
          (("25" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil)) nil)
             ("5" (assert) nil nil)
             ("6" (inst -4 "c1!1" "c2!1") (("6" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("26" (skosimp*)
      (("26" (expand "<<" 1)
        (("26" (expand "<<" -4)
          (("26" (split -)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil)) nil)
             ("3" (assert) nil nil)
             ("4" (inst -3 "c1!1" "c2!1") (("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("27" (skosimp*)
      (("27" (expand "<<" 1)
        (("27" (expand "<<" -3)
          (("27" (split -3)
            (("1" (assert) nil nil)
             ("2" (inst -2 "c1!1" "c2!1") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (some_is_exists formula-decl nil listfuncs nil) nil nil nil nil nil
    nil nil nil nil nil nil (list type-decl nil list_adt nil)
    (every_is_forall formula-decl nil listfuncs nil) nil nil nil nil
    nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
    nil nil nil nil nil (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil) nil nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil) nil)
   687 684 t shostak))
 (subterm_subset_varnames 0
  (subterm_subset_varnames-1 nil 3396779500 3397561224
   ("" (auto-rewrite "union" "member" "subset?" "emptyset" "add")
    (("" (induct "b2")
      (("1" (grind) nil nil)
       ("2"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -3) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert)))
        nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil)
       ("7"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -3) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert)))
        nil nil)
       ("8"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -3) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert)))
        nil nil)
       ("9" (grind) nil nil) ("10" (grind) nil nil)
       ("11" (grind) nil nil)
       ("12"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil)
       ("13"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil)
       ("14"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -4) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert) (assert) (inst? -4 :where -1) (assert)
                (inst? -4)))
        (("14" (assert) nil nil)) nil)
       ("15"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -3) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert) (assert)))
        nil nil)
       ("16"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil)
       ("17"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil)
       ("18" (skosimp*)
        (("18" (expand "var_names" 1 2)
          (("18" (assert)
            (("18" (skosimp*)
              (("18" (rewrite "every_is_forall")
                (("18" (expand "<<" -2)
                  (("18" (rewrite "some_is_exists")
                    (("18" (skosimp*)
                      (("18" (inst -1 "x!2")
                        (("18" (assert)
                          (("18" (flatten)
                            (("18" (inst -1 "b1!1")
                              (("18"
                                (inst -2 "b1!1")
                                (("18"
                                  (assert)
                                  (("18"
                                    (case
                                     "FORALL(l : list[[BoolExpr, Stmt]]) : member(x!2, l) IMPLIES list_to_union(map(LAMBDA (x_1: [BoolExpr, Stmt]):
                          IF member(x_1, CaseJML1_var!1)
                            THEN union(var_names(PROJ_1(x_1)),
                                       var_names(PROJ_2(x_1)))
                          ELSE emptyset
                          ENDIF)
                       (l))
                   (x!1)")
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (hide 2 -3)
                                      (("2"
                                        (induct "l")
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (expand "member")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (lemma
                                             "list_map_member[[BoolExpr, Stmt], set[Name]]")
                                            (("2"
                                              (inst? -1 :where (-3 1))
                                              (("2"
                                                (inst -1 "x!2")
                                                (("2"
                                                  (split -1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand "map" 1)
                                                      (("1"
                                                        (expand
                                                         "list_to_union"
                                                         1)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (split
                                                               -6)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                (("2"
                                                                  (inst
                                                                   -4
                                                                   "x!1")
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("4"
                                                                (assert)
                                                                (("4"
                                                                  (inst
                                                                   -5
                                                                   "x!1")
                                                                  (("4"
                                                                    (assert)
                                                                    (("4"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("19"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -4) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert) (assert) (assert) (inst? -4 :where -1)
                (assert) (inst? -4) (assert)))
        nil nil)
       ("20"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -3) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert)))
        nil nil)
       ("21"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil)
       ("22" (grind) nil nil)
       ("23"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil)
       ("24" (grind) nil nil)
       ("25"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -4) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert) (assert) (assert) (inst? -4 :where -1)
                (assert) (inst? -4) (assert)))
        nil nil)
       ("26"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -3) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)
                (assert) (inst? -3 :where -1) (assert) (inst? -3)
                (assert)))
        nil nil)
       ("27"
        (apply (then (skosimp*) (expand "var_names" 1 2) (assert)
                (skosimp*) (expand "<<" -2) (split -) (assert)
                (inst? -2 :where -1) (assert) (inst? -2) (assert)))
        nil nil))
      nil))
    nil)
   unfinished
   ((every_is_forall formula-decl nil listfuncs nil) nil
    (list type-decl nil list_adt nil) nil nil nil nil nil nil nil nil
    nil nil nil (some_is_exists formula-decl nil listfuncs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member def-decl "bool" list_props nil)
    (list_to_union def-decl "set[T]" list_of_set_funcs nil) nil nil
    (list_induction formula-decl nil list_adt nil)
    (list_map_member formula-decl nil list_map_funcs nil)
    (setof type-eq-decl nil defined_types nil)
    (add const-decl "(nonempty?)" sets nil) nil nil nil nil nil nil nil
    nil nil (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil nil nil
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil) nil
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil) nil
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil) nil)
   96408 2007 t shostak))
 (subterm_subset_of_var 0
  (subterm_subset_of_var-1 nil 3396779041 3397559564
   ("" (skosimp*)
    (("" (use "subterm_subset_varnames")
      (("" (assert) (("" (grind) nil nil)) nil)) nil))
    nil)
   unfinished
   (nil nil nil (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   167 167 t shostak)))
(WellFormedProgram
 (wf_program_variables_disjoint 0
  (wf_program_variables_disjoint-1 nil 3393587608 3397559564
   ("" (skosimp)
    (("" (expand* "wf_Program" "wf_program_variables_disjoint_def")
      (("" (ground) nil nil)) nil))
    nil)
   unfinished (nil nil) 2 2 t shostak))
 (wf_program_variables_not_reserved_words 0
  (wf_program_variables_not_reserved_words-1 nil 3394987767 3397559564
   ("" (skosimp)
    ((""
      (expand* "wf_Program"
       "wf_program_variables_not_reserved_words_def")
      (("" (flatten) nil nil)) nil))
    nil)
   unfinished (nil nil) 1 1 t shostak))
 (wf_program_has_unique_class_names 0
  (wf_program_has_unique_class_names-1 nil 3390201065 3397559564
   ("" (skosimp)
    (("" (expand* "wf_Program" "wf_program_has_unique_class_names_def")
      (("" (flatten) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   unfinished
   (nil nil nil nil (boolean nonempty-type-decl nil booleans nil) nil
    nil nil (finite_set type-eq-decl nil finite_sets nil) nil nil nil
    nil nil (lift type-decl nil lift_adt nil) nil)
   20 20 t shostak))
 (wf_program_has_wf_classes 0
  (wf_program_has_wf_classes-1 nil 3393587755 3397559564
   ("" (skosimp)
    (("" (expand "wf_Program")
      (("" (flatten)
        (("" (expand "wf_Classes")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   unfinished
   (nil nil nil (lift type-decl nil lift_adt nil) nil nil nil nil nil
    (finite_set type-eq-decl nil finite_sets nil) nil nil nil
    (boolean nonempty-type-decl nil booleans nil) nil nil)
   2 2 t shostak))
 (wf_class_has_unique_method_names 0
  (wf_class_has_unique_method_names-1 nil 3393587790 3397559564
   ("" (skosimp)
    (("" (expand "wf_Class") (("" (inst?) (("" (assert) nil nil)) nil))
      nil))
    nil)
   unfinished
   (nil nil nil nil (finite_set type-eq-decl nil finite_sets nil) nil
    nil nil nil)
   2 2 t shostak))
 (wf_program_all_variables_declared 0
  (wf_program_all_variables_declared-1 nil 3395742105 3397559564
   ("" (skosimp*)
    (("" (expand "wf_Program")
      (("" (flatten)
        (("" (expand "wf_program_all_variables_declared")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   unfinished (nil nil nil) 2 2 t shostak)))

