State[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Excpt,
            WellFormedProgram[Name],
            Val,
            ValProp

  % A store is a mapping from names to values. Partial mappings are represented
  % using the value Bottom.
  Store : TYPE = [Name -> Val]

  % Field and local variables.
  PSt : TYPE = [# fvs, lvs : Store #]

  PState : TYPE = [# ex : lift[Excpt],
                     st : PSt #]

  lift_PSt(p : PSt) : PState =
    (# ex := bottom, st := p #)

  CONVERSION lift_PSt

  is_local(vn : Name, sigma : PState) : boolean =
    defined?(lvs(st(sigma))(vn))

  is_field(vn : Name, sigma : PState) : boolean =
    defined?(fvs(st(sigma))(vn))

  lookup_local(vn : Name, sigma : PState) : Val =
    lvs(st(sigma))(vn)

  lookup_field(vn : Name, sigma : PState) : Val =
    fvs(st(sigma))(vn)

  update_local(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)),
                lvs := lvs(st(sigma)) WITH [vn := v] #) #)

  update_field(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)) WITH [vn := v],
                lvs := lvs(st(sigma)) #) #)

  lookup(vn : Name, sigma : PState) : Val =
    IF is_local(vn, sigma)
    THEN lookup_local(vn, sigma)
    ELSE lookup_field(vn, sigma)
    ENDIF

  update(vn : Name, v : Val)(sigma : PState) : PState =
    IF is_local(vn, sigma)
    THEN update_local(vn, v)(sigma)
    ELSE update_field(vn, v)(sigma)
    ENDIF

  val2int(v : Val) : int =
    IF Int?(v)
    THEN i(v)
    ELSE 0
    ENDIF

  val2bool(v : Val) : bool =
    IF Bool?(v)
    THEN b(v)
    ELSE FALSE
    ENDIF


  initial_Program_state(p : Program) : PState =
    (# ex := bottom,
       st :=
         (# fvs := LAMBDA (n : Name) :
              LET fd = get_FieldDecl(n, p) IN
              IF bottom?(fd)
              THEN Bottom
              ELSE init_val(down(fd))
              ENDIF,
            lvs := LAMBDA (n : Name) :
              LET ld = get_LocalDecl(n, p) IN
              IF bottom?(ld)
              THEN Bottom
              ELSE default_value(jtype(down(ld)))
              ENDIF
         #)
    #)

  % Well formed state definition
  wf_state(p : Program)(s : PState) : boolean =
    FORALL (vn : Name) :
      (is_field(vn, s) IFF var_names(getFieldDecls(p))(vn)) AND
      (is_local(vn, s) IFF var_names(getLocalDecls(p))(vn))

  % Well formed state properties

  wf_initial_Program_state : LEMMA % :-)
    FORALL (p : Program) :
      wf_Program(p) IMPLIES wf_state(p)(initial_Program_state(p))

  wf_state_vars_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : PState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
        ((is_field(vn, s) IMPLIES NOT is_local(vn, s)) AND
         (is_local(vn, s) IMPLIES NOT is_field(vn, s)))


END State


% Semantics of Java programs without annotations. This theory is not used
% elsewhere, it is just provided as an example of the semantics instantiation
ProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  % In a program without annotations, the ghost variables will never be accessed
  % so it doesn't matter what we provide as gvs.
  IMPORTING State[Name],
            SemanticsTypes[Name, Program, PState, id]

  execute_set : (execute_set_type) =
    LAMBDA (p : Program, vn : Name, e : Expr, s1, s2 : PState, n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
      s1 = s2

  execute_CaseJML : (execute_CaseJML_type) =
    LAMBDA (p : Program, bs : list[[Expr, Stmt]], s1, s2 : PState,  n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n)) :
      s1 = s2

  on_method_event : (on_method_event_type) =
    LAMBDA (p : Program, md : Method, a : Val, s1, s2 : PState, n : nat,
            deriv_stmt : deriv_stmt_rec_type(n),
            deriv_expr : deriv_expr_rec_type(n)) :
      s1 = s2

  IMPORTING Semantics[Name, Program, PState, id, id, lookup,
                      LAMBDA (s : PState, pst : PState) : pst, %proj_2 ?
                      execute_set, execute_CaseJML,
                      on_method_event, on_method_event, on_method_event]

  run_program(p : Program)(main : Method, arg : int)(s2 : PState)
             (n : nat) : boolean =
    run_FullProgram(p)(main, arg)(initial_Program_state(p), s2)(n)


  % MH: Missing is a proof that this semantics preserves wf_state 
  % wf_state should actually be defined in this file
  % 
  % We could one day also import SemanticsProofs to prove that all
  % instantiations are indeed deterministic.

END ProgramSemantics
