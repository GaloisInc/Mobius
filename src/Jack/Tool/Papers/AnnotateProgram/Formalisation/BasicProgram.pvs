% Semantics of Java programs without annotations. This theory is not used
% elsewhere, it is just provided as an example of the semantics instantiation
ProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name],
            SemanticsTypes[Name, Program, PState, id, id]

  execute_set : (execute_set_type) =
    LAMBDA (p : Program, vn : Name, e : (wf_Expr(p)), s1, s2 : PState, n : nat,
            derive_rec : derive_rec_type(n)) :
      s1 = s2 AND n = 1

  execute_assert : (execute_assert_type) =
    LAMBDA (p : Program, e : (wf_Expr(p)), s1, s2 : PState, n : nat,
            derive_rec : derive_rec_type(n)) :
      s1 = s2 AND n = 1

  execute_CaseJML : (execute_CaseJML_type) =
    LAMBDA (p : Program, bs : (wf_Branches(p)), s1, s2 : PState,  
            v : Val, n : nat,
            derive_rec : derive_rec_type(n)) :
      s1 = s2 AND n = 1 AND v = Unit

  on_method_event : (on_method_event_type) =
    LAMBDA (p : Program, md : (wf_Method(p)), a : Val, v : ValOrExcpt,
            s1, s2 : PState, n : nat,
            derive_rec : derive_rec_type(n)) :
      s1 = s2 AND n = 1

  IMPORTING Semantics[Name, Program, PState, id, id, lookup,
                      LAMBDA(s : PState, upd : [PState -> PState]) : upd(s),
                      execute_set, execute_assert, execute_CaseJML,
                      on_method_event, on_method_event, on_method_event]

  run_program(p : Program)(main : Name, arg : int)
             (this_val : (defined?))
             (s2 : PState) : boolean =
    run_FullProgram(p)(main, arg)(initial_Program_state(p)(this_val), s2)


  IMPORTING SemanticsProofs[Name, Program, PState, id, id, lookup,
                      LAMBDA(s : PState, upd : [PState -> PState]) : upd(s),
                      execute_set, execute_assert, execute_CaseJML,
                      on_method_event, on_method_event, on_method_event]

  % MH: Missing is a proof that this semantics preserves wf_state 
  % wf_state should actually be defined in this file.

END ProgramSemantics
