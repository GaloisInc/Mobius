% Simplifications in the modeling of (the syntax of) programs:
% Just sequential programs
% We don't model arrays and interfaces
% Methods have just one parameter
% Initial values for fields are Val, not Expr. This is to avoid defining an
%   order of evaluation of those expressions.
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then

% No static fields nor static methods
% No return instruction. Methods have a result component that is an expression
%   whose value is the value to be returned

% Our additions:
% CaseJML: allows to do a case distiction on the value of a ghost variable
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?            % Integers
  BoolType : BoolType?          % Booleans
  Void : Void?                  % Void
  RefType : RefType?            % References


END JType


Excpt : DATATYPE
BEGIN

  Throwable : Throwable?
  NullPointer : NullPointer?
  JMLExc : JMLExc?


END Excpt

Body[Name : TYPE+] : DATATYPE
                         WITH SUBTYPES Expr, NumExpr, BoolExpr, RefExpr, Stmt
BEGIN

  % Numerical expressions. They are parameterized with a variable name to handle
  %  the case of variable evaluation.
  Int(i : int) : Int?                     : NumExpr
  Plus(b1, b2 : NumExpr) : Plus?          : NumExpr
%  Minus(b1, b2 : Expr) : Minus?           : NumExpr
%  Times(b1, b2 : Expr) : Times?           : NumExpr
%  Div(b1, b2 : Expr) : Div?               : NumExpr
  NumVarEval(varname : Name) : NumVarEval?: NumExpr


  % Boolean expressions
  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?                                : BoolExpr
  FF : FF?                                : BoolExpr
  Neg(b : BoolExpr) : Neg?                : BoolExpr
  Conj(b1, b2 : BoolExpr) : Conj?         : BoolExpr
%  Disj(b1, b2 : Expr) : Disj?             : BoolExpr
%  Lt (b1, b2 : Expr) : Lt?                : BoolExpr
%  Le (b1, b2 : Expr) : Le?                : BoolExpr
  Eq (b1, b2 : Expr) : Eq?                : BoolExpr
%  Neq (b1, b2 : Expr) : Neq?              : BoolExpr
%  Ge (b1, b2 : Expr) : Ge?                : BoolExpr
%  Gt (b1, b2 : Expr) : Gt?                : BoolExpr
  BoolVarEval(varname : Name) : BoolVarEval? : BoolExpr


  % Reference expressions
  Null : Null?                            : RefExpr
  RefVarEval(varname : Name) : RefVarEval?: RefExpr


  % Program's expressions
  Assign(target : Name, source : Expr) : Assign? : Expr
  BExpr(b : BoolExpr) : BExpr?                   : Expr
  CondExpr(test : BoolExpr, then_expr : Expr, 
           else_expr : Expr) : CondExpr?         : Expr
  MethodCall(tgt : Expr, name : Name, 
             arg : Expr) : MethodCall?           : Expr
  NExpr(n : NumExpr) : NExpr?                    : Expr
  RExpr(r : RefExpr) : RExpr?                    : Expr


  % Program's statements
  CaseJML(branches : list[[BoolExpr, Stmt]]) : CaseJML? : Stmt
  IfThenElse(test : BoolExpr, then_stmt : Stmt, 
             else_stmt : Stmt) : IfThenElse?        : Stmt
  Sequence(s1, s2 : Stmt) : Sequence?               : Stmt
  Set(target : Name, source : Expr) : Set?          : Stmt
  Skip : Skip?                                      : Stmt
  StmtExpr(expr : Expr) : StmtExpr?                 : Stmt
  Throw : Throw?                                    : Stmt
  TryCatch(try : Stmt, catch : Stmt, 
           finally : Stmt) : TryCatch?              : Stmt
  While(test : BoolExpr, body : Stmt) : While?      : Stmt
  Assert(expr : BoolExpr) : Assert?                 : Stmt


END Body


% Syntax of programs
Program[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ValProp[Name],
            Body[Name]

  This : Name

  % Other reserved words given as examples
  Super, rsIf, rsThen, rsElse : Name

  % Java reserved words. We only need to mention This, the other are given as
  % examples. 
  reserved_words : finite_set[Name] =
    {n : Name | n = This OR n = Super OR n = rsIf OR n = rsThen OR n = rsElse}

  % NOTE: It is not correct to have Val in programs because they belong to the
  % semantic domain, however, we do so to simplify the definition of the initial
  % state (otherwise we would have to define an order of initialization).
  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : (defined?) #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     classname : Name,
                     arg : LocalVarDecl,
                     pre : BoolExpr[Name],
                     post : BoolExpr[Name],
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt[Name],
                     pre_set : Stmt[Name],
                     post_set : Stmt[Name],
                     exc_set : Stmt[Name],
                     res : Expr[Name],
                     res_type : JType #]

  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : BoolExpr[Name],
                    ghost_vars : finite_set[FieldDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  PreProgram : TYPE = [# classes : finite_set[Class] #]


END Program


% Functions that manipulate programs or program parts
ProgramFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name],
            %% Used for proving TCCs
            FiniteSetInduction[Class],
            FiniteSetInduction[Method]

  % Used variable names

%  NOTE: There seems to be a problem with the definition of some in the 
%  CaseJML case. If we define:
%   var_names(b : Body) : set[Name] =
%     {n : Name | some(LAMBDA (m : Name) : m = n)(b)}
%
%  Then it can proved that:
%   problem_with_var_names : LEMMA
%     FORALL(x : list[[BoolExpr, Stmt]]) :
%       var_names(CaseJML(x)) = emptyset

  IMPORTING list_of_set_funcs[Name], 
            listfuncs[[BoolExpr, Stmt]],
            listsum,
            list_map_funcs

  size(b : Body) : nat = 
    reduce_nat(
       LAMBDA(i : int) : 1, % Int
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Plus
       LAMBDA(n : Name) : 1, % NumVarEval
       1, % TT
       1, % FF
       LAMBDA(n : nat) : n + 1, % Neg
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Conj
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Eq
       LAMBDA(n : Name) : 1, % BoolVarEval
       1, % Null
       LAMBDA(n : Name) : 1, % RefVarEval
       LAMBDA(nm : Name, n : nat) : n + 1, % Assign
       LAMBDA(n : nat) : n + 1, % BExpr
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % CondExpr
       LAMBDA(n1 : nat, nm : Name, n2 : nat) : n1 + n2 + 1, % MethodCall
       LAMBDA(n : nat) : n + 1, % NExpr
       LAMBDA(n : nat) : n + 1, % RExpr
       LAMBDA(l : list[[nat, nat]]) : 
         sum(map[[nat, nat], nat](LAMBDA(n1, n2 : nat) : n1 + n2 + 1)(l)) + 1, % CaseJML
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % IfThenElse
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Sequence
       LAMBDA(nm : Name, n : nat) : n + 1, % Set
       1, % Skip
       LAMBDA(n : nat) : n + 1, % StmtExpr
       1, % Throw
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % TryCatchFinally
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % While
       LAMBDA(n : nat) : n + 1)(b) % Assert


  var_names(b : Body) : RECURSIVE [Name -> boolean] =
    CASES b OF    
       Int(i) : emptyset[Name],
       Plus(b1, b2) : union(var_names(b1), var_names(b2)),
       NumVarEval(varname) : singleton(varname),
       TT : emptyset[Name],
       FF : emptyset[Name],
       Neg(b) : var_names(b),
       Conj(b1, b2) : union(var_names(b1), var_names(b2)),
       Eq (b1, b2) : union(var_names(b1), var_names(b2)),
       BoolVarEval(varname) : singleton(varname),
       Null : emptyset[Name],
       RefVarEval(varname) : singleton(varname),
       Assign(target, source) : add(target, var_names(source)),
       BExpr(b) : var_names(b),
       CondExpr(test, then_expr, else_expr) : 
         union(var_names(test), 
         union(var_names(then_expr), var_names(else_expr))),
       MethodCall(tgt, name, arg) :
         union(var_names(tgt), var_names(arg)),
       NExpr(n) : var_names(n),
       RExpr(r) : var_names(r),
       CaseJML(branches) : 
        IF null?(branches)
        THEN emptyset[Name]
        ELSE union(var_names(proj_1(car(branches))),
             union(var_names(proj_2(car(branches))),
                   var_names(CaseJML(cdr(branches)))))
        ENDIF,
       IfThenElse(test, then_stmt, else_stmt) :
         union(var_names(test), 
         union(var_names(then_stmt), var_names(else_stmt))),
       Sequence(s1, s2) : union(var_names(s1), var_names(s2)),
       Set(target, source) : add(target, var_names(source)),
       Skip : emptyset[Name],
       StmtExpr(expr) : var_names(expr),
       Throw : emptyset[Name],
       TryCatch(try, catch, finally) : 
         union(var_names(try), union(var_names(catch), var_names(finally))),
       While(test, body) : union(var_names(test), var_names(body)),
       Assert(expr) : var_names(expr)
    ENDCASES
  MEASURE size(b)

  var_names(fs : finite_set[FieldDecl]) : finite_set[Name] =
    {n : Name |EXISTS (f : FieldDecl) : fs(f) AND name(f) = n}

  var_names(ls : finite_set[LocalVarDecl]) : finite_set[Name] =
    {n : Name |EXISTS (l : LocalVarDecl) : ls(l) AND name(l) = n}


  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | ns = var_names(pre(m)) OR ns = var_names(post(m)) OR
      ns = var_names(body(m)) OR ns = var_names(pre_set(m)) OR 
      ns = var_names(post_set(m)) OR ns = var_names(exc_set(m)) OR 
      ns = var_names(lvars(m)) OR ns = var_names(res(m)) OR
      ns = singleton(name(arg(m)))})

  var_names(c : Class) : set[Name] = 
    union(Union({ns : set[Name] | EXISTS (m : Method) :
                 methods(c)(m) AND ns = var_names(m)}),
    union(var_names(fields(c)), 
    union(var_names(ghost_vars(c)), var_names(inv(c)))))

  var_names(p : PreProgram) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})


  var_names_union : LEMMA % :-)
    FORALL(fs1, fs2 : finite_set[FieldDecl]) :
      var_names(union(fs1, fs2)) = union(var_names(fs1), var_names(fs2))

  IMPORTING WF_Card[[BoolExpr, Stmt]], set2list[[BoolExpr, Stmt]]


  var_names_CaseJML_set2list : LEMMA % :-)
    FORALL(s : finite_set[[BoolExpr, Stmt]], n : Name) :
      var_names(CaseJML(set2list(s)))(n) =
          EXISTS(x : [BoolExpr, Stmt]) :
            s(x) AND union(var_names(proj_1(x)), var_names(proj_2(x)))(n)


  % Declared variable names

  getFieldDecls(p : PreProgram) : finite_set[FieldDecl] =
    {f : FieldDecl | EXISTS (c : Class) : classes(p)(c) AND 
                                          fields(c)(f)}

  getLocalDecls(c : Class) : finite_set[LocalVarDecl] =
    {l : LocalVarDecl | EXISTS (m : Method) : 
                          methods(c)(m) AND                      
                          (lvars(m)(l) OR l = arg(m))}

  getLocalDecls(p : PreProgram) : finite_set[LocalVarDecl] =
    {l : LocalVarDecl | EXISTS (c : Class) : 
                        classes(p)(c) AND getLocalDecls(c)(l)}

  arg_in_getLocalDecls : LEMMA % :-)
    FORALL(p : PreProgram, c : Class, m : Method) :
      classes(p)(c) IMPLIES
      methods(c)(m) IMPLIES
      getLocalDecls(p)(arg(m))


  getGhostDecls(p : PreProgram) : finite_set[FieldDecl] =
    {g : FieldDecl | EXISTS (c : Class) :  classes(p)(c) AND ghost_vars(c)(g)}


  get_LocalDecl(n : Name, p : PreProgram) : lift[LocalVarDecl] =
    LET ng = {l : LocalVarDecl | getLocalDecls(p)(l) AND name(l) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_FieldDecl(n : Name, p : PreProgram) : lift[FieldDecl] =
    LET ng = {f : FieldDecl | getFieldDecls(p)(f) AND name(f) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_GhostDecl(n : Name, p : PreProgram) : lift[FieldDecl] =
    LET ng = {g : FieldDecl | getGhostDecls(p)(g) AND name(g) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  declared_var_names(p : PreProgram) : finite_set[Name] =
    {n : Name | var_names(getFieldDecls(p))(n) OR
                var_names(getLocalDecls(p))(n) OR
                var_names(getGhostDecls(p))(n)}

  ext_declared_var_names(p : PreProgram) : finite_set[Name] =
    union({n : Name | var_names(getFieldDecls(p))(n) OR
                      var_names(getLocalDecls(p))(n) OR
                      var_names(getGhostDecls(p))(n)},
          {n : Name | n = This})


  class_names(p : PreProgram) : finite_set[Name] =
    {n : Name | EXISTS (c : Class) : classes(p)(c) AND name(c) = n}

  method_names(p : PreProgram, c : Class) : finite_set[Name] =
    {n : Name | EXISTS (m : Method) : classes(p)(c) AND methods(c)(m) AND
                                      name(m) = n}

  methods(p : PreProgram) : finite_set[Method] =
    {m : Method |EXISTS (c : Class) : classes(p)(c) AND methods(c)(m)}

  get_class(p : PreProgram)(tgt : Val) : lift[Class] =
    IF Reference?(tgt) AND class_names(p)(class_name(tgt))
    THEN up(choose({c : Class | classes(p)(c) AND name(c) = class_name(tgt)}))
    ELSE bottom
    ENDIF

 
  get_class_in_classes : LEMMA % :-)
    FORALL(p : PreProgram)(tgt : Val) :
      up?(get_class(p)(tgt)) IMPLIES
        classes(p)(down(get_class(p)(tgt)))

  % TODO: This specification is not correct because we can not return any method
  % in the program that has the required name, we should return the first in the
  % hierarchy of classes of the dynamic type of tgt.
  % Probably the best thing to do is to leave it undefined.
  lookup_mthd(p : PreProgram, tgt : Val, mn : Name) : lift[(methods(p))] =
    IF up?(get_class(p)(tgt)) AND method_names(p, down(get_class(p)(tgt)))(mn)
    THEN up(choose({m : Method | classes(p)(down(get_class(p)(tgt))) AND 
                                 methods(down(get_class(p)(tgt)))(m)
                                 AND name(m) = mn}))
    ELSE bottom
    ENDIF

  lookup_mthd_in_methods_class : LEMMA % :-)
     FORALL(p : PreProgram, tgt : Val, mn : Name) :
       up?(get_class(p)(tgt)) IMPLIES
       up?(lookup_mthd(p, tgt, mn)) IMPLIES
         methods(down(get_class(p)(tgt)))(down(lookup_mthd(p, tgt, mn)))


  % TODO: Maybe this function should be left undefined since it should also
  % return the conjunction of the invariant of the the parent classes.
  % If it can't find an invariant in tgt it just returns TRUE
  lookup_inv(p : PreProgram, tgt : Val) : BoolExpr =
    IF up?(get_class(p)(tgt))
    THEN inv(down(get_class(p)(tgt)))
    ELSE TT
    ENDIF


  % Proper subtern (<<) properties

  proper_subterm_set_clause(s : Stmt, m : Method) : boolean =
    s << pre_set(m) OR s << post_set(m) OR s << exc_set(m)

  IMPORTING listfuncs

  proper_subterm_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, c3 : Body) :
      Sequence(c1, c2) << c3 IMPLIES 
        c1 << c3 AND c2 << c3

  proper_subterm_set_clause_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, m : Method) :
      proper_subterm_set_clause(Sequence(c1, c2), m) IMPLIES 
        proper_subterm_set_clause(c1, m) AND proper_subterm_set_clause(c2, m)

  proper_subterm_is_transitive : LEMMA % :-)
    FORALL (c1, c2, c3 : Body) :
      c1 << c2 AND c2 << c3 IMPLIES c1 << c3

%  IMPORTING list_map_funcs[[BoolExpr, Stmt], set[Name]]

  subterm_subset_varnames : LEMMA % :-)
    FORALL(b1, b2 : Body) :
      b1 << b2 IMPLIES subset?(var_names(b1), var_names(b2))

  subterm_subset_of_var : LEMMA % :-)
    FORALL(b1, b2 : Body, v : set[Name]) :
      subset?(var_names(b1), v) IMPLIES
        b2 << b1 IMPLIES subset?(var_names(b2), v)


  proper_subterm_implies_subterm : LEMMA % :-)
    FORALL(b1, b2 : Body) : 
      b1 << b2 IMPLIES subterm(b1, b2) 


  subterm_transitive : LEMMA % :-)
    FORALL(b1, b2, b3 : Body) :
      subterm(b1, b2) IMPLIES
        subterm(b2, b3) IMPLIES
          subterm(b1, b3)

  subterm_CaseJML_set2list : LEMMA % :-)
    FORALL(s : finite_set[[BoolExpr, Stmt]], b : Body) :
      Set?(b) IMPLIES
      subterm(b, CaseJML(set2list(s))) =
        (EXISTS(x : [BoolExpr, Stmt]) : 
           s(x) AND (subterm(b, proj_1(x)) OR subterm(b, proj_2(x))))


%  program_code(p : PreProgram)(s : Stmt) : boolean =
%    EXISTS(c : Class, m : Method) :
%      classes(p)(c) AND
%      methods(c)(m) AND
%      s << body(m)

%  direct_sub_expr(s : Stmt) : RECURSIVE list[Expr] =
%    CASES s OF
%      CaseJML(branches) : append(map(proj_1)(branches),
%                                 map(direct_sub_expr o proj_2)(branches)),
%      IfThenElse(c, t, e) : cons(c, append(direct_sub_expr(t), 
%                                           direct_sub_expr(e))),
%      Sequence(s1, s2) : append(direct_sub_expr(s1), direct_sub_expr(s2)),
%      Set(target, source) : cons(source, null),
%      Skip : null
%      StmtExpr(expr) : cons(expr, null),
%      Throw : null,
%      TryCatch(t, c, f) : TryCatch?
%  While(test : Expr, body : Stmt) : While?

%  program_code(p : PreProgram)(e : Expr) : boolean =
%    EXISTS(c : Class, m : Method) :
%      classes(p)(c) AND
%      methods(c)(m) AND
%      e << body(m)


END ProgramFunctions


% Program's syntax requirements.
% We include only the requirements needed for the proofs.
% NOTE: Since the declarations are sets we can avoid some duplicate tests.
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ProgramFunctions[Name]

  wf_Body(p : PreProgram)(b : Body) : boolean = 
    (FORALL(v : Name) : var_names(b)(v) IMPLIES ext_declared_var_names(p)(v))
    AND
    (FORALL(b1 : Body) : Set?(b1) IMPLIES 
                         subterm(b1, b) IMPLIES 
                         var_names(getGhostDecls(p))(target(b1)))

  wf_Body_preserved_by_proper_subterm : LEMMA % :-)
    FORALL(p : PreProgram)(b1, b2 : Body) :
      wf_Body(p)(b1) IMPLIES
      b2 << b1 IMPLIES
        wf_Body(p)(b2)

  wf_BoolExpr(p : PreProgram)(b : BoolExpr) : boolean =
     wf_Body(p)(b)

  wf_NumExpr(p : PreProgram)(n : NumExpr) : boolean =
     wf_Body(p)(n)

  wf_RefExpr(p : PreProgram)(r : RefExpr) : boolean =
     wf_Body(p)(r)

  wf_Expr(p : PreProgram)(e : Expr) : boolean =
     wf_Body(p)(e)

  wf_Stmt(p : PreProgram)(s : Stmt) : boolean =
    wf_Body(p)(s)

  wf_Branches(p : PreProgram)(l : list[[BoolExpr, Stmt]]) : boolean =
    every(LAMBDA(x : [[BoolExpr, Stmt]]) : 
      wf_Body(p)(proj_1(x)) AND wf_Body(p)(proj_2(x)))(l)

  wf_Body_CaseJML : LEMMA % :-)
    FORALL(p : PreProgram, l : list[[BoolExpr, Stmt]]) :
      wf_Body(p)(CaseJML(l)) = wf_Branches(p)(l)

  wf_Method(p : PreProgram)(m : Method) : boolean =
    wf_Body(p)(body(m)) AND
    wf_Body(p)(pre(m)) AND
    wf_Body(p)(post(m)) AND
    wf_Body(p)(pre_set(m)) AND
    wf_Body(p)(post_set(m)) AND
    wf_Body(p)(exc_set(m)) AND
    wf_Body(p)(res(m))

  wf_Class(p : PreProgram)(c : Class) : boolean =
    (FORALL (m1, m2 : Method) :
       methods(c)(m1) IMPLIES
       methods(c)(m2) IMPLIES
       name(m1) = name(m2) IMPLIES
         m1 = m2) 
     AND
    (FORALL (m : Method) : methods(c)(m) IMPLIES wf_Method(p)(m)) AND
    (FORALL (m : Method) : methods(c)(m) IMPLIES classname(m) = name(c)) AND
     wf_Body(p)(inv(c))

  wf_Classes(p : PreProgram) : boolean =
    FORALL (c : Class) : classes(p)(c) IMPLIES wf_Class(p)(c)


  wf_program_variables_disjoint_def(p : PreProgram) : boolean =
    LET fname = var_names(getFieldDecls(p)),
        lname = var_names(getLocalDecls(p)),
        gname = var_names(getGhostDecls(p)) IN
    disjoint?(fname, lname) AND
    disjoint?(lname, gname) AND
    disjoint?(fname, gname)

  wf_program_variables_not_reserved_words_def(p : PreProgram) : boolean =
    disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names_def(p : PreProgram) : boolean =
    FORALL (c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

%  wf_program_all_variables_declared(p : PreProgram) : boolean =
%    FORALL(v : Name) : var_names(p)(v) IMPLIES declared_var_names(p)(v)

  wf_program_methods_only_in_one_class(p : PreProgram) : boolean =
    FORALL (c1, c2 : Class, m : Method) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      methods(c1)(m) IMPLIES
      methods(c2)(m) IMPLIES
        c1 = c2


%  % Basic type information
%  invariants_are_bool_expr(p : PreProgram) : boolean =
%    FORALL (c : Class) :
%      classes(p)(c) IMPLIES
%        BExpr?(inv(c))

  % TODO: review this definition
  % NOTE: In a complete specification, wf_Program would include only syntactic
  % requirements and then we would define well_typed_Program. Since we don't
  % have many type requirements, it doesn't make sense to have two different
  % notions.
  wf_Program(p : PreProgram) : boolean =
    wf_program_variables_disjoint_def(p) AND
    wf_program_variables_not_reserved_words_def(p) AND
    wf_program_has_unique_class_names_def(p) AND
    wf_Classes(p)% AND
%    wf_program_methods_only_in_one_class(p)
%    invariants_are_bool_expr(p)

  
  Program : TYPE = (wf_Program)

  AUTO_REWRITE- wf_Program

  % Properties needed of well-formed programs

  % Because we model the heap as a flat Store here we need to require that
  % variables have a unique name within the program.
  wf_program_variables_disjoint : LEMMA % :-)
     FORALL(p : Program) :
       LET fname = var_names(getFieldDecls(p)),
           lname = var_names(getLocalDecls(p)),
           gname = var_names(getGhostDecls(p)) IN
       disjoint?(fname, lname) AND
       disjoint?(lname, gname) AND
       disjoint?(fname, gname)

  wf_program_variables_not_reserved_words : LEMMA % :-)
    FORALL(p : Program) : 
      disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names : LEMMA % :-)
    FORALL (p : Program, c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_has_wf_classes : LEMMA % :-)
    FORALL (p : Program, c : Class) :
      classes(p)(c) IMPLIES
        wf_Class(p)(c)

  wf_class_has_unique_method_names : LEMMA % :-)
    FORALL (p : Program, c : Class, m1, m2 : Method) :
      wf_Class(p)(c) IMPLIES
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2

  wf_program_methods_only_in_one_class : LEMMA % :-)
    FORALL(p : Program) :
      wf_program_methods_only_in_one_class(p)

  wf_program_var_names_declared : LEMMA % :-)
    FORALL(p : Program, n : Name) :
      var_names(p)(n) IMPLIES ext_declared_var_names(p)(n)


END WellFormedProgram
