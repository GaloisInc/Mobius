% Simplifications in the modeling of (the syntax of) programs:
% Just sequential programs
% We don't model arrays and interfaces
% Methods have just one parameter
% Initial values for fields are Val, not Expr. This is to avoid defining an
%   order of evaluation of those expressions.
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then

% No static fields nor static methods
% No return instruction. Methods have a result component that is an expression
%   whose value is the value to be returned

% Our additions:
% CaseJML: allows to do a case distiction on the value of a ghost variable
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?            % Integers
  BoolType : BoolType?          % Booleans
  Void : Void?                  % Void
  RefType : RefType?            % References


END JType



Body[Name : TYPE+] : DATATYPE
                         WITH SUBTYPES Expr, Stmt
BEGIN

  IMPORTING Excpt, ValProp[Name]

  % Numerical expressions. 
  Plus(b1, b2 : Expr) : Plus?                       : Expr
  NumVarEval(varname : Name) : NumVarEval?          : Expr

  % Boolean expressions
  Neg(b : Expr) : Neg?                              : Expr
  Conj(b1, b2 : Expr) : Conj?                       : Expr
  Eq (b1, b2 : Expr) : Eq?                          : Expr
  BoolVarEval(varname : Name) : BoolVarEval?        : Expr

  % Reference expressions
  RefVarEval(varname : Name) : RefVarEval?          : Expr

  % Program's expressions
  Assign(target : Name, source : Expr) : Assign?    : Expr
  CondExpr(test : Expr, then_expr : Expr, 
           else_expr : Expr) : CondExpr?            : Expr
  MethodCall(tgt : Expr, name : Name, 
             arg : Expr) : MethodCall?              : Expr
  Const(v : (defined?)) : Const?                    : Expr


  % Program's statements
  CaseJML(branches : list[[Expr, Stmt]]) : CaseJML? : Stmt
  IfThenElse(test : Expr, then_stmt : Stmt, 
             else_stmt : Stmt) : IfThenElse?        : Stmt
  Sequence(s1, s2 : Stmt) : Sequence?               : Stmt
  Set(target : Name, source : Expr) : Set?          : Stmt
  Skip : Skip?                                      : Stmt
  StmtExpr(expr : Expr) : StmtExpr?                 : Stmt
  Throw(exc : Excpt) : Throw?                       : Stmt
  TryCatch(try : Stmt, exc : Excpt, catch : Stmt, 
           finally : Stmt) : TryCatch?              : Stmt
  While(test : Expr, body : Stmt) : While?          : Stmt
  Assert(expr : Expr) : Assert?                     : Stmt


END Body


BodyFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Body[Name]
  IMPORTING list_of_set_funcs[Name], 
            listfuncs[[Expr, Stmt]],
            listsum,
            list_map_funcs

  size(b : Body) : nat = 
    reduce_nat(
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Plus
       LAMBDA(n : Name) : 1, % NumVarEval
       LAMBDA(n : nat) : n + 1, % Neg
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Conj
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Eq
       LAMBDA(n : Name) : 1, % BoolVarEval
       LAMBDA(n : Name) : 1, % RefVarEval
       LAMBDA(nm : Name, n : nat) : n + 1, % Assign
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % CondExpr
       LAMBDA(n1 : nat, nm : Name, n2 : nat) : n1 + n2 + 1, % MethodCall
       LAMBDA(v : (defined?)) : 1, % Const
       LAMBDA(l : list[[nat, nat]]) : 
         sum(map[[nat, nat], nat](LAMBDA(n1, n2 : nat) : n1 + n2 + 1)(l)) + 1, % CaseJML
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % IfThenElse
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Sequence
       LAMBDA(nm : Name, n : nat) : n + 1, % Set
       1, % Skip
       LAMBDA(n : nat) : n + 1, % StmtExpr
       LAMBDA(e : Excpt) : 1, % Throw
       LAMBDA(n1 : nat, e : Excpt, n2, n3 : nat) : n1 + n2 + n3 + 1, % TryCatchFinally
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % While
       LAMBDA(n : nat) : n + 1 % Assert
       )(b) 


  equal_except_for(T1, x, T2, y : Body) : RECURSIVE boolean =
    (T1 = x AND T2 = y) OR
    CASES T1 OF
      Plus(b1, b2) : Plus?(T2) AND
                     equal_except_for(b1, x, b1(T2), y) AND
                     equal_except_for(b2, x, b2(T2), y),
      NumVarEval(v) : NumVarEval?(T2) AND varname(T2) = v,
      Neg(b) : Neg?(T2) AND equal_except_for(b, x, b(T2), y),
      Conj(b1, b2) : Conj?(T2) AND
                     equal_except_for(b1, x, b1(T2), y) AND
                     equal_except_for(b2, x, b2(T2), y),
      Eq(b1, b2) : Eq?(T2) AND
                     equal_except_for(b1, x, b1(T2), y) AND
                     equal_except_for(b2, x, b2(T2), y),
     BoolVarEval(v) : BoolVarEval?(T2) AND varname(T2) = v,
     RefVarEval(v) : RefVarEval?(T2) AND varname(T2) = v,
     Assign(v, e) : Assign?(T2) AND target(T2) = v AND
                    equal_except_for(e, x, source(T2), y),
     CondExpr(t, then_expr, else_expr) :
                    CondExpr?(T2) AND
                    equal_except_for(t, x, test(T2), y) AND
                    equal_except_for(then_expr, x, then_expr(T2), y) AND
                    equal_except_for(else_expr, x, else_expr(T2), y),
     MethodCall(tgt, n, arg) : MethodCall?(T2) AND
                               equal_except_for(tgt, x, tgt(T2), y) AND
                               name(T2) = n AND
                               equal_except_for(arg, x, arg(T2), y),
     Const(v) : Const?(T2) AND v(T2) = v,
     CaseJML(br) : CaseJML?(T2) AND
                   length(br) = length(branches(T2)) AND
                   (null?(br) OR
                    equal_except_for(proj_1(car(br)), x, 
                                     proj_1(car(branches(T2))), y) AND
                    equal_except_for(proj_2(car(br)), x, 
                                     proj_2(car(branches(T2))), y) AND
                    equal_except_for(CaseJML(cdr(br)), x,
                                     CaseJML(cdr(branches(T2))), y)),
     IfThenElse(t, then_stmt, else_stmt) :
                    IfThenElse?(T2) AND
                    equal_except_for(t, x, test(T2), y) AND
                    equal_except_for(then_stmt, x, then_stmt(T2), y) AND
                    equal_except_for(else_stmt, x, else_stmt(T2), y),
     Sequence(s1, s2) : Sequence?(T2) AND
                        equal_except_for(s1, x, s1(T2), y) AND
                        equal_except_for(s2, x, s2(T2), y),
     Set(v, e) : Set?(T2) AND target(T2) = v AND
                 equal_except_for(e, x, source(T2), y),
     Skip : Skip?(T2), 
     StmtExpr(expr) : StmtExpr?(T2) AND equal_except_for(expr, x, expr(T2), y),
     Throw(exc) : Throw?(T2) AND exc(T2) = exc,
     TryCatch(try, exc, catch, finally) : TryCatch?(T2) AND
        exc(T2) = exc AND
        equal_except_for(try, x, try(T2), y) AND
        equal_except_for(catch, x, catch(T2), y) AND
        equal_except_for(finally, x, finally(T2), y),
     While(test, body) : While?(T2) AND
        equal_except_for(test, x, test(T2), y) AND
        equal_except_for(body, x, body(T2), y),
     Assert(expr) : Assert?(T2) AND equal_except_for(expr, x, expr(T2), y)
    ENDCASES
  MEASURE size(T1)

  FunType : TYPE =  ({f : [Body -> Body] | 
      FORALL(v1, v2 : Body) : equal_except_for(f(v1), v1, f(v2), v2)})

  CondType : TYPE = 
    ({f : [Expr -> Expr] | 
      FORALL(v1, v2 : Expr) : equal_except_for(f(v1), v1, f(v2), v2)})

  SetType : TYPE = 
    ({f : [Expr -> Stmt] | 
      FORALL(v1, v2 : Expr) : equal_except_for(f(v1), v1, f(v2), v2)})

END BodyFunctions


% Syntax of programs
Program[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ValProp[Name],
            Body[Name],
            ValOrExcpt[Name], 
            BodyFunctions[Name]

  This : Name 

  % Other reserved words given as examples
  Super, rsIf, rsThen, rsElse : Name

  % Java reserved words. We only need to mention This, the other are given as
  % examples. 
  reserved_words : finite_set[Name] =
    {n : Name | n = This OR n = Super OR n = rsIf OR n = rsThen OR n = rsElse}

  % NOTE: It is not correct to have Val in programs because they belong to the
  % semantic domain, however, we do so to simplify the definition of the initial
  % state (otherwise we would have to define an order of initialization).
  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : (defined?) #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     classname : Name,
                     arg : LocalVarDecl,
                     pre : CondType,
                     post : CondType,
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt,
                     pre_set : SetType,
                     post_set : SetType,
                     exc_set : [Excpt -> Stmt],
                     res : Expr,
                     res_type : JType #]

  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : Expr,
                    ghost_vars : finite_set[FieldDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  PreProgram : TYPE = [# classes : non_empty_finite_set[Class] #]


END Program


% Functions that manipulate programs or program parts
ProgramFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name],
            %% Used for proving TCCs
            finite_sets@finite_sets_inductions[Class],
            finite_sets@finite_sets_inductions[Method]

  % Used variable names

%  NOTE: There seems to be a problem with the definition of some in the 
%  CaseJML case. If we define:
%   var_names(b : Body) : set[Name] =
%     {n : Name | some(LAMBDA (m : Name) : m = n)(b)}
%
%  Then it can proved that:
%   problem_with_var_names : LEMMA
%     FORALL(x : list[[Expr, Stmt]]) :
%       var_names(CaseJML(x)) = emptyset

  IMPORTING list_of_set_funcs[Name], 
            listfuncs[[Expr, Stmt]],
            listsum,
            list_map_funcs, 
            BodyFunctions[Name]


  var_names(b : Body) : RECURSIVE [Name -> boolean] =
    CASES b OF    
       Plus(b1, b2) : union(var_names(b1), var_names(b2)),
       NumVarEval(varname) : singleton(varname),
       Neg(b) : var_names(b),
       Conj(b1, b2) : union(var_names(b1), var_names(b2)),
       Eq (b1, b2) : union(var_names(b1), var_names(b2)),
       BoolVarEval(varname) : singleton(varname),
       RefVarEval(varname) : singleton(varname),
       Assign(target, source) : add(target, var_names(source)),
       CondExpr(test, then_expr, else_expr) : 
         union(var_names(test), 
         union(var_names(then_expr), var_names(else_expr))),
       MethodCall(tgt, name, arg) :
         union(var_names(tgt), var_names(arg)),
       Const(v) : emptyset[Name],
       CaseJML(branches) : 
        IF null?(branches)
        THEN emptyset[Name]
        ELSE union(var_names(proj_1(car(branches))),
             union(var_names(proj_2(car(branches))),
                   var_names(CaseJML(cdr(branches)))))
        ENDIF,
       IfThenElse(test, then_stmt, else_stmt) :
         union(var_names(test), 
         union(var_names(then_stmt), var_names(else_stmt))),
       Sequence(s1, s2) : union(var_names(s1), var_names(s2)),
       Set(target, source) : add(target, var_names(source)),
       Skip : emptyset[Name],
       StmtExpr(expr) : var_names(expr),
       Throw(exc) : emptyset[Name],
       TryCatch(try, exc, catch, finally) : 
         union(var_names(try), union(var_names(catch), var_names(finally))),
       While(test, body) : union(var_names(test), var_names(body)),
       Assert(expr) : var_names(expr)
    ENDCASES
  MEASURE size(b)

  var_names(fs : finite_set[FieldDecl]) : finite_set[Name] =
    {n : Name |EXISTS (f : FieldDecl) : fs(f) AND name(f) = n}

  var_names(ls : finite_set[LocalVarDecl]) : finite_set[Name] =
    {n : Name |EXISTS (l : LocalVarDecl) : ls(l) AND name(l) = n}


  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | 
      ns = var_names(pre(m)(Const(Unit))) OR 
      ns = var_names(post(m)(Const(Unit))) OR
      ns = var_names(body(m)) OR 
      ns = var_names(pre_set(m)(Const(Unit))) OR 
      ns = var_names(post_set(m)(Const(Unit))) OR 
      ns = var_names(exc_set(m)(Throwable)) OR 
      ns = var_names(lvars(m)) OR ns = var_names(res(m)) OR
      ns = singleton(name(arg(m)))})

  var_names(c : Class) : set[Name] = 
    union(Union({ns : set[Name] | EXISTS (m : Method) :
                 methods(c)(m) AND ns = var_names(m)}),
    union(var_names(fields(c)), 
    union(var_names(ghost_vars(c)), var_names(inv(c)))))

  var_names(p : PreProgram) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})


  var_names_union : LEMMA % :-)
    FORALL (fs1, fs2 : finite_set[FieldDecl]) :
      var_names(union(fs1, fs2)) = union(var_names(fs1), var_names(fs2))

  var_names_union2 : LEMMA % :-)
    FORALL (ls1, ls2 : finite_set[LocalVarDecl]) :
      var_names(union(ls1, ls2)) = union(var_names(ls1), var_names(ls2))

  IMPORTING WF_Card[[Expr, Stmt]], set2list[[Expr, Stmt]]

  var_names_CaseJML_set2list : LEMMA % :-)
    FORALL (s : finite_set[[Expr, Stmt]], n : Name) :
      var_names(CaseJML(set2list(s)))(n) =
        EXISTS(x : [Expr, Stmt]) :
          s(x) AND union(var_names(proj_1(x)), var_names(proj_2(x)))(n)


  var_names_CaseJML_branches : LEMMA % :-)
    FORALL (branches : list[[Expr, Stmt]], x : [Expr, Stmt], 
            n : Name) :
      member(x, branches) IMPLIES
      (var_names(proj_1(x))(n) OR var_names(proj_2(x))(n)) IMPLIES
      var_names(CaseJML(branches))(n)


%  var_names(f : [Expr -> Body]) : set[Name] =
%    {n : Name |FORALL(e : Expr) : var_names(f(e))(n)}

%  % TO PROVE
%  % I can't prove this...
%  var_names_predicate : LEMMA
%    FORALL(f : [Expr -> Body], v : Expr) :
%      subset?(var_names(f(v)), union(var_names(f), var_names(v)))

%  % TO PROVE
%  var_names_exc_predicate : LEMMA
%    FORALL(f : [Excpt -> Body], e : Excpt) :
%      var_names(f(e)) = var_names(f(Throwable))


  % Declared variable names

  getFieldDecls(p : PreProgram) : finite_set[FieldDecl] =
    {f : FieldDecl | EXISTS (c : Class) : classes(p)(c) AND 
                                          fields(c)(f)}

  getLocalDecls(c : Class) : finite_set[LocalVarDecl] =
    {l : LocalVarDecl | EXISTS (m : Method) : 
                          methods(c)(m) AND                      
                          (lvars(m)(l) OR l = arg(m))}

  getLocalDecls(p : PreProgram) : finite_set[LocalVarDecl] =
    {l : LocalVarDecl | EXISTS (c : Class) : 
                        classes(p)(c) AND getLocalDecls(c)(l)}

  arg_in_getLocalDecls : LEMMA % :-)
    FORALL(p : PreProgram, c : Class, m : Method) :
      classes(p)(c) IMPLIES
      methods(c)(m) IMPLIES
      getLocalDecls(p)(arg(m))


  getGhostDecls(p : PreProgram) : finite_set[FieldDecl] =
    {g : FieldDecl | EXISTS (c : Class) :  classes(p)(c) AND ghost_vars(c)(g)}


  get_LocalDecl(n : Name, p : PreProgram) : lift[LocalVarDecl] =
    LET ng = {l : LocalVarDecl | getLocalDecls(p)(l) AND name(l) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_FieldDecl(n : Name, p : PreProgram) : lift[FieldDecl] =
    LET ng = {f : FieldDecl | getFieldDecls(p)(f) AND name(f) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_GhostDecl(n : Name, p : PreProgram) : lift[FieldDecl] =
    LET ng = {g : FieldDecl | getGhostDecls(p)(g) AND name(g) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  declared_var_names(p : PreProgram) : finite_set[Name] =
    {n : Name | var_names(getFieldDecls(p))(n) OR
                var_names(getLocalDecls(p))(n) OR
                var_names(getGhostDecls(p))(n)}

  ext_declared_var_names(p : PreProgram) : finite_set[Name] =
    union({n : Name | var_names(getFieldDecls(p))(n) OR
                      var_names(getLocalDecls(p))(n) OR
                      var_names(getGhostDecls(p))(n)},
          {n : Name | n = This})


  class_names(p : PreProgram) : finite_set[Name] =
    {n : Name | EXISTS (c : Class) : classes(p)(c) AND name(c) = n}

  method_names(p : PreProgram, c : Class) : finite_set[Name] =
    {n : Name | EXISTS (m : Method) : classes(p)(c) AND methods(c)(m) AND
                                      name(m) = n}

  methods(p : PreProgram) : finite_set[Method] =
    {m : Method |EXISTS (c : Class) : classes(p)(c) AND methods(c)(m)}

  get_class(p : PreProgram)(tgt : Val) : lift[Class] =
    IF Reference?(tgt) AND class_names(p)(class_name(tgt))
    THEN up(choose({c : Class | classes(p)(c) AND name(c) = class_name(tgt)}))
    ELSE bottom
    ENDIF

 
  get_class_in_classes : LEMMA % :-)
    FORALL(p : PreProgram)(tgt : Val) :
      up?(get_class(p)(tgt)) IMPLIES
        classes(p)(down(get_class(p)(tgt)))

  lookup_mthd(p : PreProgram, tgt : Val, mn : Name) : lift[(methods(p))] =
    IF up?(get_class(p)(tgt)) AND method_names(p, down(get_class(p)(tgt)))(mn)
    THEN up(choose({m : Method | classes(p)(down(get_class(p)(tgt))) AND 
                                 methods(down(get_class(p)(tgt)))(m)
                                 AND name(m) = mn}))
    ELSE bottom
    ENDIF

  lookup_mthd_in_methods_class : LEMMA % :-)
     FORALL(p : PreProgram, tgt : Val, mn : Name) :
       up?(get_class(p)(tgt)) IMPLIES
       up?(lookup_mthd(p, tgt, mn)) IMPLIES
         methods(down(get_class(p)(tgt)))(down(lookup_mthd(p, tgt, mn)))


  % NOTE: We assume that the invariant contains the conjunction of the 
  %       invariants of the the parent classes.
  % If it can't find the class of tgt it just returns TRUE
  lookup_inv(p : PreProgram, tgt : Val) : Expr =
    IF up?(get_class(p)(tgt))
    THEN inv(down(get_class(p)(tgt)))
    ELSE Const(Bool(True))
    ENDIF


  % Proper subtern (<<) properties

  proper_subterm_set_clause(s : Stmt, m : Method) : boolean =
    s << pre_set(m)(Const(Unit)) OR s << post_set(m)(Const(Unit)) OR 
    s << exc_set(m)(Throwable)

  IMPORTING listfuncs

  proper_subterm_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, c3 : Body) :
      Sequence(c1, c2) << c3 IMPLIES 
        c1 << c3 AND c2 << c3

  proper_subterm_set_clause_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, m : Method) :
      proper_subterm_set_clause(Sequence(c1, c2), m) IMPLIES 
        proper_subterm_set_clause(c1, m) AND proper_subterm_set_clause(c2, m)

  proper_subterm_is_transitive : LEMMA % :-)
    FORALL (c1, c2, c3 : Body) :
      c1 << c2 AND c2 << c3 IMPLIES c1 << c3


  subterm_subset_varnames : LEMMA % :-)
    FORALL (b1, b2 : Body) :
      b1 << b2 IMPLIES subset?(var_names(b1), var_names(b2))

  subterm_subset_varnames2 : LEMMA % :-)
    FORALL (b1, b2 : Body) :
      subterm(b1, b2) IMPLIES subset?(var_names(b1), var_names(b2))

  subterm_subset_of_var : LEMMA % :-)
    FORALL (b1, b2 : Body, v : set[Name]) :
      subset?(var_names(b1), v) IMPLIES
        b2 << b1 IMPLIES subset?(var_names(b2), v)


  proper_subterm_implies_subterm : LEMMA % :-)
    FORALL (b1, b2 : Body) : 
      b1 << b2 IMPLIES subterm(b1, b2) 

  subterm_transitive : LEMMA % :-)
    FORALL (b1, b2, b3 : Body) :
      subterm(b1, b2) IMPLIES
        subterm(b2, b3) IMPLIES
          subterm(b1, b3)

  subterm_CaseJML_set2list : LEMMA % :-)
    FORALL (s : finite_set[[Expr, Stmt]], b : Body) :
      Set?(b) IMPLIES
      subterm(b, CaseJML(set2list(s))) =
        (EXISTS(x : [Expr, Stmt]) : 
           s(x) AND (subterm(b, proj_1(x)) OR subterm(b, proj_2(x))))


  var_lookup(n : Name)(t : JType) : Expr =
    CASES t OF
      IntType : NumVarEval(n),
      BoolType : BoolVarEval(n),
      RefType : RefVarEval(n),
      Void : Const(Unit)
    ENDCASES


END ProgramFunctions


% Functions to apply a predicate to each part of a program or a method
ProgramRestriction[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name]

  method_pred(p : PreProgram)(m : Method)
             (pred : [PreProgram -> [Body -> bool]]) : bool =
    (FORALL (v : Expr) : pred(p)(pre(m)(v))) AND 
    (FORALL (v : Expr) : pred(p)(post(m)(v))) AND
    pred(p)(body(m)) AND 
    (FORALL (v : Expr) : pred(p)(pre_set(m)(v))) AND
    (FORALL (v : Expr) : pred(p)(post_set(m)(v))) AND 
    (FORALL (e : Excpt) : pred(p)(exc_set(m)(e))) AND
    pred(p)(res(m))

  program_pred(p : PreProgram)
              (pred : [PreProgram -> [Body -> bool]]) : bool =
    FORALL (c : Class) :
      classes(p)(c) IMPLIES
        pred(p)(inv(c)) AND
        FORALL (m : Method) :
          methods(c)(m) IMPLIES method_pred(p)(m)(pred)

  program_method_pred(p : PreProgram)(pred : [Method -> bool]) : bool =
    FORALL (c : Class) :
      classes(p)(c) IMPLIES
        FORALL (m : Method) :
          methods(c)(m) IMPLIES pred(m)


END ProgramRestriction


% Program's syntax requirements.
% We include only the requirements needed for the proofs.
% NOTE: Since the declarations are sets we can avoid some duplicate tests.
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ProgramFunctions[Name],
            ProgramRestriction[Name]

  wf_Body(p : PreProgram)(b : Body) : boolean = 
    (FORALL(v : Name) : var_names(b)(v) IMPLIES ext_declared_var_names(p)(v))
    AND
    (FORALL(b1 : Body) : Set?(b1) IMPLIES 
                         subterm(b1, b) IMPLIES 
                         var_names(getGhostDecls(p))(target(b1)))

  wf_Body_preserved_by_proper_subterm : LEMMA % :-)
    FORALL(p : PreProgram)(b1, b2 : Body) :
      wf_Body(p)(b1) IMPLIES
      b2 << b1 IMPLIES
        wf_Body(p)(b2)

  wf_Expr(p : PreProgram)(e : Expr) : boolean =
     wf_Body(p)(e)

  wf_Stmt(p : PreProgram)(s : Stmt) : boolean =
    wf_Body(p)(s)

  wf_Branches(p : PreProgram)(l : list[[Expr, Stmt]]) : boolean =
    every(LAMBDA(x : [[Expr, Stmt]]) : 
      wf_Body(p)(proj_1(x)) AND wf_Body(p)(proj_2(x)))(l)

  wf_Body_CaseJML : LEMMA % :-)
    FORALL(p : PreProgram, l : list[[Expr, Stmt]]) :
      wf_Body(p)(CaseJML(l)) = wf_Branches(p)(l)

  wf_Body_While : LEMMA % :-)
    FORALL(p : PreProgram, b : (wf_Body(p))) :
      While?(b) IMPLIES
        wf_Body(p)(IfThenElse(test(b), b, Skip))

  wf_Body_CaseJML_branches : LEMMA
    FORALL(p : PreProgram, b : (wf_Body(p))) :
      CaseJML?(b) IMPLIES
        NOT null?(branches(b)) IMPLIES
        wf_Body(p)(IfThenElse
               (PROJ_1(car(branches(b))),
                PROJ_2(car(branches(b))),
                CaseJML(cdr(branches(b)))))

  wf_Method(p : PreProgram)(m : Method) : boolean =
    method_pred(p)(m)(wf_Body)

  wf_Class(p : PreProgram)(c : Class) : boolean =
    (FORALL (m1, m2 : Method) :
       methods(c)(m1) IMPLIES
       methods(c)(m2) IMPLIES
       name(m1) = name(m2) IMPLIES
         m1 = m2) 
     AND
    (FORALL (m : Method) : methods(c)(m) IMPLIES classname(m) = name(c))

  wf_Classes(p : PreProgram) : boolean =
    FORALL (c : Class) : classes(p)(c) IMPLIES wf_Class(p)(c)


  wf_program_variables_disjoint_def(p : PreProgram) : boolean =
    LET fname = var_names(getFieldDecls(p)),
        lname = var_names(getLocalDecls(p)),
        gname = var_names(getGhostDecls(p)) IN
    disjoint?(fname, lname) AND
    disjoint?(lname, gname) AND
    disjoint?(fname, gname)

  wf_program_variables_not_reserved_words_def(p : PreProgram) : boolean =
    disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names_def(p : PreProgram) : boolean =
    FORALL (c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_methods_only_in_one_class(p : PreProgram) : boolean =
    FORALL (c1, c2 : Class, m : Method) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      methods(c1)(m) IMPLIES
      methods(c2)(m) IMPLIES
        c1 = c2



  % NOTE: In a complete specification, wf_Program would include only syntactic
  % requirements and then we would define well_typed_Program. Since we don't
  % have many type requirements, it doesn't make sense to have two different
  % notions.
  wf_Program(p : PreProgram) : boolean =
    wf_program_variables_disjoint_def(p) AND
    wf_program_variables_not_reserved_words_def(p) AND
    wf_program_has_unique_class_names_def(p) AND
    wf_Classes(p)AND
    program_pred(p)(wf_Body)

  
  Program : TYPE = (wf_Program)

  AUTO_REWRITE- wf_Program

  % Properties needed of well-formed programs

  % Because we model the heap as a flat Store here we need to require that
  % variables have a unique name within the program.
  wf_program_variables_disjoint : LEMMA % :-)
     FORALL (p : Program) :
       LET fname = var_names(getFieldDecls(p)),
           lname = var_names(getLocalDecls(p)),
           gname = var_names(getGhostDecls(p)) IN
       disjoint?(fname, lname) AND
       disjoint?(lname, gname) AND
       disjoint?(fname, gname)

  wf_program_variables_not_reserved_words : LEMMA % :-)
    FORALL(p : Program) : 
      disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names : LEMMA % :-)
    FORALL (p : Program, c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_has_wf_classes : LEMMA % :-)
    FORALL (p : Program, c : Class) :
      classes(p)(c) IMPLIES
        wf_Class(p)(c)

  wf_class_has_unique_method_names : LEMMA % :-)
    FORALL (p : Program, c : Class, m1, m2 : Method) :
      wf_Class(p)(c) IMPLIES
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2

  wf_program_methods_only_in_one_class : LEMMA % :-)
    FORALL (p : Program) :
      wf_program_methods_only_in_one_class(p)

  wf_program_var_names_declared : LEMMA % :-)
    FORALL (p : Program, n : Name) :
      var_names(p)(n) IMPLIES ext_declared_var_names(p)(n)


END WellFormedProgram
