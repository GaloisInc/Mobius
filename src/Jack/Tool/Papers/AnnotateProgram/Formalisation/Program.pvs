% Simplifications in the modeling of (the syntax of) programs:
% Just sequential programs
% We don't model arrays and interfaces
% Methods have just one parameter
% Initial values for fields are Val, not Expr. This is to avoid defining an
%   order of evaluation of those expressions.
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then

% No static fields nor static methods
% No return instruction. Methods have a result component that is an expression
%   whose value is the value to be returned

% Our additions:
% CaseJML: allows to do a case distiction on the value of a ghost variable
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?            % Integers
  BoolType : BoolType?          % Booleans
  Void : Void?                  % Void
  RefType : RefType?            % References


END JType


Excpt : DATATYPE
BEGIN

  Throwable : Throwable?
  NullPointer : NullPointer?
  JMLExc : JMLExc?


END Excpt


% Numerical expressions. They are parameterized with a variable name to handle
%  the case of variable evaluation.
NumExpr[Name : TYPE+] : DATATYPE
BEGIN

  Int(i : int) : Int?
  Plus(b1, b2 : NumExpr) : Plus?
  Minus(b1, b2 : NumExpr) : Minus?
  Times(b1, b2 : NumExpr) : Times?
  Div(b1, b2 : NumExpr) : Div?
  NumVarEval(varname : Name) : VarEval?


END NumExpr


% Boolean expressions
BoolExpr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING NumExpr[Name]

  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?
  FF : FF?
  Neg(b : BoolExpr) : Neg?
  Conj(b1, b2 : BoolExpr) : Conj?
  Disj(b1, b2 : BoolExpr) : Disj?
  Lt (b1, b2 : NumExpr) : Lt?
  Le (b1, b2 : NumExpr) : Le?
  Eq (b1, b2 : NumExpr) : Eq?
  Neq (b1, b2 : NumExpr) : Neq?
  Ge (b1, b2 : NumExpr) : Ge?
  Gt (b1, b2 : NumExpr) : Gt?
  BoolVarEval(varname : Name) : VarEval?


END BoolExpr


% Reference expressions
RefExpr[Name : TYPE+] : DATATYPE
BEGIN

  Null : Null?
  RefVarEval(varname : Name) : RefVarEval?


END RefExpr


% Program's expressions
Expr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING BoolExpr[Name],
            NumExpr[Name],
            RefExpr[Name]

  Assign(target : Name, source : Expr) : Assign?
  BExpr(b : BoolExpr) : BExpr?
  CondExpr(test : Expr, then_expr : Expr, else_expr : Expr) : CondExpr?
  MethodCall(tgt : Expr, name : Name, arg : Expr) : MethodCall?
  NExpr(n : NumExpr) : NExpr?
  RExpr(r : RefExpr) : RExpr?


END Expr


% Program's statements
Stmt[Name : TYPE+] : DATATYPE
BEGIN
  
  IMPORTING Expr[Name]

  CaseJML(branches : list[[Expr, Stmt]]) : CaseJML?
  IfThenElse(test : Expr, then_stmt : Stmt, else_stmt : Stmt) : IfThenElse?
  Sequence(s1, s2 : Stmt) : Sequence?
  Set(target : Name, source : Expr) : Set?
  Skip : Skip?
  StmtExpr(expr : Expr) : StmtExpr?
  Throw : Throw?
  TryCatch(try : Stmt, catch : Stmt, finally : Stmt) : TryCatch?
  While(test : Expr, body : Stmt) : While?


END Stmt


% Syntax of programs
Program[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING ValProp[Name],
            Stmt[Name],
            Expr[Name]

  This, Super : Name

  % NOTE: It is not correct to have Val in programs because they belong to the
  % semantic domain, however, we do so to simplify the definition of the initial
  % state (otherwise we would have to define an order of initialization).
  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : (defined?) #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     arg : LocalVarDecl,
                     pre : Expr,
                     post : Expr,
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt,
                     pre_set : Stmt,
                     post_set : Stmt,
                     exc_set : Stmt,
                     res : Expr,
                     res_type : JType #]

  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : Expr,
                    ghost_vars : finite_set[FieldDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  Program : TYPE = [# classes : finite_set[Class] #]


END Program


% Functions that manipulate programs or program parts
ProgramFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name],  
            FiniteSetInduction[Class], %% Used for proving TCCs
            FiniteSetInduction[Method]

  getFieldDecls(p : Program) : finite_set[FieldDecl] =
    {f : FieldDecl | EXISTS (c : Class) : classes(p)(c) AND 
                                          fields(c)(f)}

  getLocalDecls(p : Program) : finite_set[LocalVarDecl] =
    {l : LocalVarDecl | EXISTS (c : Class, m : Method) : 
                        classes(p)(c) AND 
                        methods(c)(m) AND
                        (lvars(m)(l) OR l = arg(m))}

  getGhostDecls(p : Program) : finite_set[FieldDecl] =
    {g : FieldDecl | EXISTS (c : Class) :  classes(p)(c) AND ghost_vars(c)(g)}


  get_LocalDecl(n : Name, p : Program) : lift[LocalVarDecl] =
    LET ng = {l : LocalVarDecl | getLocalDecls(p)(l) AND name(l) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_FieldDecl(n : Name, p : Program) : lift[FieldDecl] =
    LET ng = {f : FieldDecl | getFieldDecls(p)(f) AND name(f) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_GhostDecl(n : Name, p : Program) : lift[FieldDecl] =
    LET ng = {g : FieldDecl | getGhostDecls(p)(g) AND name(g) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF


  class_names(p : Program) : finite_set[Name] =
    {n : Name | EXISTS (c : Class) : classes(p)(c) AND name(c) = n}

  method_names(p : Program, c : Class) : finite_set[Name] =
    {n : Name | EXISTS (m : Method) : classes(p)(c) AND methods(c)(m) AND 
                                      name(m) = n}

  get_class(p : Program)(tgt : Val) : lift[Class] =
    IF Reference?(tgt) AND class_names(p)(class_name(tgt))
    THEN up(choose({c : Class | classes(p)(c) AND name(c) = class_name(tgt)}))
    ELSE bottom
    ENDIF

  % TODO: See the TCC generated!
  lookup_mthd(p : Program, tgt : Val, mn : Name) : lift[Method] =
    LET gc = get_class(p)(tgt) IN
    IF up?(gc) AND method_names(p, down(gc))(mn)
    THEN up(choose({m : Method | classes(p)(down(gc)) AND methods(down(gc))(m)
                                 AND name(m) = mn}))
    ELSE bottom
    ENDIF

  % If it can't find an invariant in tgt it just returns TRUE
  lookup_inv(p : Program, tgt : Val) : Expr =
    IF up?(get_class(p)(tgt))
    THEN inv(down(get_class(p)(tgt)))
    ELSE BExpr(TT)
    ENDIF


  set_subterm(s : Stmt, m : Method) : boolean =
    subterm(s, pre_set(m)) OR subterm(s, post_set(m)) OR subterm(s, exc_set(m))

  var_names(ne : NumExpr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(ne)}

  var_names(be : BoolExpr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(be)}

  var_names(re : RefExpr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(re)}

  var_names(e : Expr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(e)}

  var_names(s : Stmt) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(s)}

  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | ns = var_names(pre(m)) OR ns = var_names(post(m)) OR
      ns = var_names(body(m)) OR ns = var_names(pre_set(m)) OR 
      ns = var_names(post_set(m)) OR ns = var_names(exc_set(m))})

  var_names(c : Class) : set[Name] = 
    Union({ns : set[Name] | EXISTS (m : Method) :
      methods(c)(m) AND ns = var_names(m)})

  var_names(p : Program) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})

  var_names(fs : finite_set[FieldDecl]) : finite_set[Name] =
    {n : Name |EXISTS (f : FieldDecl) : fs(f) AND name(f) = n}

  var_names(ls : finite_set[LocalVarDecl]) : finite_set[Name] =
    {n : Name |EXISTS (l : LocalVarDecl) : ls(l) AND name(l) = n}


END ProgramFunctions


% Program's syntax requirements.
% We include only the requirements needed for the proofs.
% NOTE: Since the declarations are sets we can avoid some duplicate tests.
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ProgramFunctions[Name]

  wf_Stmt(s : Stmt) : boolean

  wf_Method(m : Method) : boolean

  wf_Class(c : Class) : boolean

  wf_Program(p : Program) : boolean

%  AUTO_REWRITE- wf_Program

  % Properties needed of well-formed programs

  % TODO: This lemma is included in the following. 
  % Change ann_action_correctness and delete it
  wf_program_has_unique_ghost_var_decl : LEMMA
     FORALL (p : Program, c1, c2 : Class, gv1, gv2 : FieldDecl) :
       wf_Program(p) IMPLIES
       classes(p)(c1) IMPLIES
       classes(p)(c2) IMPLIES
       ghost_vars(c1)(gv1) IMPLIES
       ghost_vars(c2)(gv2) IMPLIES
         NOT name(gv1) = name(gv2)

  % Because we model the heap as a flat Store here we need to require that
  % variables have a unique name within the program.
  wf_program_variables_disjoint : LEMMA
     FORALL(p : Program) :
       wf_Program(p) IMPLIES
       LET fname = var_names(getFieldDecls(p)),
           lname = var_names(getLocalDecls(p)),
           gname = var_names(getGhostDecls(p)) IN
       disjoint?(fname, lname) AND
       disjoint?(lname, gname) AND
       disjoint?(fname, gname)

  wf_program_variables_not_this : LEMMA
    FORALL(p : Program) : 
      wf_Program(p) IMPLIES 
         NOT var_names(getFieldDecls(p))(This) AND
         NOT var_names(getLocalDecls(p))(This) AND
         NOT var_names(getGhostDecls(p))(This)

  wf_program_has_unique_class_names : LEMMA
    FORALL (p : Program, c1, c2 : Class) :
      wf_Program(p) IMPLIES
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_has_wf_classes : LEMMA
    FORALL (p : Program, c : Class) :
      wf_Program(p) IMPLIES
      classes(p)(c) IMPLIES
        wf_Class(c)

  wf_class_has_unique_method_names : LEMMA
    FORALL (c : Class, m1, m2 : Method) :
      wf_Class(c) IMPLIES
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2

  wf_class_has_wf_methods : LEMMA
    FORALL (c : Class, m : Method) :
      wf_Class(c) IMPLIES
      methods(c)(m) IMPLIES
        wf_Method(m)

  wf_method_has_wf_stmt : LEMMA
    FORALL (m : Method) :
      wf_Method(m) IMPLIES
        wf_Stmt(pre_set(m)) AND
        wf_Stmt(post_set(m)) AND
        wf_Stmt(exc_set(m)) AND
        wf_Stmt(body(m))

  wf_Stmt_has_wf_substmt : LEMMA
    FORALL (c1, c2 : Stmt) :
      wf_Stmt(c2) IMPLIES
%      c1 << c2 IMPLIES
      subterm(c1, c2) IMPLIES
        wf_Stmt(c1)

  % By requiring subterm not to be reflexive or symmetric we avoid some
  % infinite statements like c1 = Sequence(c1, c2)
%   wf_Stmt_implies_finite_subterm : LEMMA
%     FORALL (c1, c2 : Stmt) :
%       wf_Stmt(c2) IMPLIES
%       c1 << c2 IMPLIES
%         NOT c1 = c2 AND NOT c2 << c1

  wf_Stmt_implies_finite_subterm : LEMMA
    FORALL (c1, c2 : Stmt) :
      wf_Stmt(c2) IMPLIES
      subterm(c1, c2) IMPLIES
        NOT c1 = c2 AND NOT subterm(c2, c1)


END WellFormedProgram


% We name only the type constraints needed for the proofs.
WellTypedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedProgram[Name]

  invariants_are_booleans(p : Program) : boolean =
    FORALL (c : Class) :
      classes(p)(c) IMPLIES
        BExpr?(inv(c))

  %method_names(p, down(get_class(p)(tgt)))(mn)

  % See also get_dynamic_type_name_correctness in Evaluation (Semantics.pvs)
  well_typed_Program(p : Program) : boolean =
    wf_Program(p) AND
    invariants_are_booleans(p)


END WellTypedProgram
