% Section 3.1 Abstract Syntax of Program

% Simplifications:
% Just sequential programs
% We don't model types and interfaces
% Methods have just one parameter
% No arrays
% Initial values for fields are Val, not Expr. This is because otherwise we have
%   to define an order to evaluate those expressions and avoid recursive 
%   initializations
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then
% We have a store for the whole program, thus fields and ghost vars names
%   contain the class name they belong to. Local vars and formal args contain
%   also their method names
% No static fields nor static methods
% No return instruction. Methods have a result component that is an expression
%   whose value is the value to be returned

% Our additions
% CaseJML: allows to do a case distiction on the value of a ghost var
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?      % Integers
  BoolType : BoolType?    % Booleans
  Void : Void?            % Void
  RefType : RefType?      % References


END JType


% Numerical expressions
% They are parameterized with a variable name to handle the case of variable evaluation
NumExpr[Name : TYPE+] : DATATYPE
BEGIN

  Int(i : int) : Int?
  Plus(b1, b2 : NumExpr) : Plus?
  Minus(b1, b2 : NumExpr) : Minus?
  Times(b1, b2 : NumExpr) : Times?
  Div(b1, b2 : NumExpr) : Div?
  NumVarEval(varname : Name) : VarEval?


END NumExpr


% Boolean expressions
BoolExpr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING NumExpr[Name]

  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?
  FF : FF?
  Neg(b : BoolExpr) : Neg?
  Conj(b1, b2 : BoolExpr) : Conj?
  Disj(b1, b2 : BoolExpr) : Disj?
  Lt (b1, b2 : NumExpr) : Lt?
  Le (b1, b2 : NumExpr) : Le?
  Eq (b1, b2 : NumExpr) : Eq?
  Neq (b1, b2 : NumExpr) : Neq?
  Ge (b1, b2 : NumExpr) : Ge?
  Gt (b1, b2 : NumExpr) : Gt?
  BoolVarEval(varname : Name) : VarEval?


END BoolExpr


% Reference expressions
RefExpr[Name : TYPE+] : DATATYPE
BEGIN

  Null : Null?
  RefVarEval(varname : Name) : RefVarEval?


END RefExpr


% Program's expressions
Expr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING BoolExpr[Name],
            NumExpr[Name],
            RefExpr[Name]

  Assign(target : Name, source : Expr) : Assign?
  BExpr(b : BoolExpr) : BExpr?
  CondExpr(test : Expr, then_expr : Expr, else_expr : Expr) : CondExpr?
  MethodCall(tgt : Expr, name : Name, arg : Expr) : MethodCall?
  NExpr(n : NumExpr) : NExpr?
  RExpr(r : RefExpr) : RExpr?


END Expr


% Program's statements
Stmt[Name : TYPE+] : DATATYPE
BEGIN
  
  IMPORTING Expr[Name]

  CaseJML(branches : list[[Expr, Stmt]]) : CaseJML?
  IfThenElse(test : Expr, then_stmt : Stmt, else_stmt : Stmt) : IfThenElse?
  Sequence(s1, s2 : Stmt) : Sequence?
  Set(target : Name, source : Expr) : Set?
  Skip : Skip?
  StmtExpr(expr : Expr) : StmtExpr?
  Throw : Throw?
  TryCatch(try : Stmt, catch : Stmt, finally : Stmt) : TryCatch?
  While(test : Expr, body : Stmt) : While?


END Stmt


Program[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING JType,
            Val,
            Stmt[Name],
            Expr[Name]
  
  main : Name

  This, Super : Name

  % NOTE: it is not correct to have Val in programs because they belong to the
  % semantic domain, however, we do so to simplify the definition of the initial
  % state (otherwise we would have to define an order of initialization).
  GhostVarDecl : TYPE = [# jtype : JType, 
                           name : Name,
                           init_val : Val #]

  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : Val #]

  ArgDecl : TYPE = [# jtype : JType,
                      name : Name #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     arg : ArgDecl,
                     pre : Expr,
                     post : Expr,
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt,
                     pre_set : Stmt,
                     post_set : Stmt,
                     exc_set : Stmt,
                     res : Expr,
                     res_type : JType #]

  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : Expr,
                    ghost_vars : finite_set[GhostVarDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  Program : TYPE = [# classes : finite_set[Class] #]


%  get_FieldDecls_Class(n : Name, c : Class) : list[FieldDecl] = 
%    set2list(fields(c))

%  get_FieldDecls(n : Name, classes : list[Class]) : RECURSIVE list[FieldDecl] =
%     CASES classes OF
%       null : null,
%       cons(c, cs) : append(get_FieldsDecls_Class(c), get_FieldsDecls(cs))
%     ENDCASES
%     MEASURE length(classes(cs))
%    concat(map(get_FieldsDecls_Class)(classes))

  get_FieldDecl(n : Name, p : Program) : lift[FieldDecl]

  get_LocalVarDecl(n : Name, p : Program) : lift[FieldDecl]

  get_GhostVarDecl(n : Name, p : Program) : lift[FieldDecl]


END Program


% Program requirements (see the assumptions at the beginning of the file)
% NOTE: Since the declarations are sets we can avoid some duplicate tests.
% We include only the requirements needed for the proofs
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name]

  % Used variable names
  % NOTE: we can't say that the result is a finite set because the statement
  % may not be well formed. If we defined wf_Stmt then we can say that
  % wf_Stmt(c) IMPLIES is_finite?(var_names(c))

  var_names(ne : NumExpr) : set[Name] =
    reduce[Name, set[Name]](
      LAMBDA (i : int) : emptyset,
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (n : Name) : singleton(n))(ne)

  var_names(be : BoolExpr) : set[Name] =
    reduce[Name, set[Name]](
      emptyset,
      emptyset,
      id,
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (n : Name) : singleton(n))(be)

  var_names(re : RefExpr) : set[Name] = 
    reduce[Name, set[Name]](
      emptyset,                                                     % Null
      LAMBDA (n : Name) : singleton(n))(re)                         % RefVarEval

  var_names(e : Expr) : set[Name] =
    reduce[Name, set[Name]](
      LAMBDA (t : Name, s : set[Name]) : add(t, s),                 % Assign
      LAMBDA (b : BoolExpr) : var_names(b),                         % BExpr
      LAMBDA (s1, s2, s3 : set[Name]) : union(s1, union(s2, s3)),   % CondExpr
      LAMBDA (e : set[Name], m : Name, a : set[Name]) : union(e, a),% MethodCall
      LAMBDA (ne : NumExpr) : var_names(ne),                        % NExpr
      LAMBDA (re : RefExpr) : var_names(re))(e)                     % RExpr

  var_names(s : Stmt) : set[Name] =
    reduce[Name, set[Name]](
      LAMBDA (branches : list[[Expr, set[Name]]]) :                 % CaseJML
        Union({ns : Name | EXISTS (x : [Expr, set[Name]]) :
               member(x, branches) AND  ns = var_names(proj_1(x)) OR
               ns = proj_2(x)}),
      LAMBDA (b : Expr, s1, s2 : set[Name]) :                       % IfThenElse
        union(var_names(b), union(s1, s2)),
      LAMBDA (s1, s2 : set[Name]) : union(s1, s2),                  % Sequence
      LAMBDA (target : Name, source : Expr[Name]) :                 % Set
        add(target, var_names(source)),
      emptyset,                                                     % Skip
      LAMBDA (expr : Expr) : var_names(expr),                       % StmtExpr
      emptyset,                                                     % Throw
      LAMBDA (t, c, f : set[Name]) : union(t, union(c, f)),         % TryCatch
      LAMBDA (b : Expr, ns : set[Name]) :                           % While
        union(var_names(b), ns))(s)

  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | ns = var_names(pre(m)) OR ns = var_names(post(m)) OR
      ns = var_names(body(m)) OR ns = var_names(pre_set(m)) OR 
      ns = var_names(post_set(m)) OR ns = var_names(exc_set(m))})

  var_names(c : Class) : set[Name] = 
    Union({ns : set[Name] | EXISTS (m : Method) :
      methods(c)(m) AND ns = var_names(m)})

  var_names(p : Program) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})


  is_declared_as_field(p : Program)(vn : Name) : boolean =
    EXISTS (c : Class, fd : FieldDecl) :
      classes(p)(c) AND fields(c)(fd) AND name(fd) = vn

  is_declared_as_ghost(p : Program)(vn : Name) : boolean =
    EXISTS (c : Class, gd : GhostVarDecl) :
      classes(p)(c) AND fields(c)(gd) AND name(gd) = vn

  is_declared_as_arg(p : Program)(vn : Name) : boolean =
    EXISTS (ad : ArgDecl, c : Class, m : Method) :
      classes(p)(c) AND methods(c)(m) AND arg(m)(ad) AND name(ad) = vn

  is_declared_as_local(p : Program)(vn : Name) : boolean =
    EXISTS (c : Class, m : Method, ld : LocalVarDecl) :
      classes(p)(c) AND methods(c)(m) AND lvars(m)(ld) AND name(ld) = vn


  % Names of classes are unique within a program
  unique_class_names(p : Program) : boolean =
    FORALL (c1, c2 : Class) :
      classes(p)(c1) AND 
      classes(p)(c2) AND 
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_Class(c : Class) : boolean

  wf_Program(p : Program) : boolean

  AUTO_REWRITE- wf_Program, var_names

  % Properties needed of well-formed programs

  wf_program_has_unique_class_names : LEMMA
    FORALL (p : Program, c1, c2 : Class) :
      wf_Program(p) IMPLIES
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_has_wf_classes : LEMMA
    FORALL (p : Program, c : Class) :
      wf_Program(p) IMPLIES
      classes(p)(c) IMPLIES
        wf_Class(c)

  wf_class_has_unique_method_names : LEMMA
    FORALL (c : Class, m1, m2 : Method) :
      wf_Class(c) IMPLIES
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2


END WellFormedProgram
