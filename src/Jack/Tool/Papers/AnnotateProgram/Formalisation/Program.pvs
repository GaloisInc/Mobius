% This file defines abstract syntax of programs

% Some remarks:
% Only sequential programs
% No arrays and interfaces 
% Methods have only one parameter
% Initial values for fields are of type Val, not Expr. (This avoids having to
% define an evaluation order on those)
% Only two types of exceptions can occur in program (text): 
%   Throwable and NullPointer. 
% Local variables are declared at beginning of body (like in Pascal)
% Inheritance and overloading of methods, shadowing of fields not modelled 
% ?? (their names can
%   be "mangled", .i.e the contain the information to disambiguate then
% No static fields or static methods
% No return instruction. Methods have a result component, containing an 
% expression. Evaluation of this expression computes value to be returned

% Runtime checker can also throw JML exceptions
% Assert and Set annotations modelled as part of programming language

% Our additions:
% CaseJML: allows to do a case distiction on the value of a ghost variable
% Methods have a pre_set, post_set and exc_set clause




% Abstract Syntax of program instructions (called Body)
% Every expression can be used as statement
Body[Name : TYPE+] : DATATYPE
                         WITH SUBTYPES Expr, Stmt
BEGIN

  IMPORTING Excpt, ValProp[Name]

  % Numerical expressions. 
  Plus(b1, b2 : Expr) : Plus?                       : Expr
  NumVarEval(varname : Name) : NumVarEval?          : Expr

  % Boolean expressions
  Neg(b : Expr) : Neg?                              : Expr
  Conj(b1, b2 : Expr) : Conj?                       : Expr
  Eq (b1, b2 : Expr) : Eq?                          : Expr
  BoolVarEval(varname : Name) : BoolVarEval?        : Expr

  % Reference expressions
  RefVarEval(varname : Name) : RefVarEval?          : Expr

  % Program expressions
  Assign(target : Name, source : Expr) : Assign?    : Expr
  CondExpr(test : Expr, then_expr : Expr, 
           else_expr : Expr) : CondExpr?            : Expr
  MethodCall(tgt : Expr, name : Name, 
             arg : Expr) : MethodCall?              : Expr
  Const(v : (defined?)) : Const?                    : Expr


  % Program statements
  CaseJML(branches : list[[Expr, Stmt]]) : CaseJML? : Stmt
  IfThenElse(test : Expr, then_stmt : Stmt, 
             else_stmt : Stmt) : IfThenElse?        : Stmt
  Sequence(s1, s2 : Stmt) : Sequence?               : Stmt
  Set(target : Name, source : Expr) : Set?          : Stmt
  Skip : Skip?                                      : Stmt
  StmtExpr(expr : Expr) : StmtExpr?                 : Stmt
  Throw(exc : Excpt) : Throw?                       : Stmt
  TryCatch(try : Stmt, exc : Excpt, catch : Stmt, 
           finally : Stmt) : TryCatch?              : Stmt
  While(test : Expr, body : Stmt) : While?          : Stmt
  Assert(expr : Expr) : Assert?                     : Stmt


END Body

% Basic functions over datatype Body
BodyFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Body[Name]
  IMPORTING list_of_set_funcs[Name], 
            listfuncs[[Expr, Stmt]],
            listsum,
            list_map_funcs

  % size of instruction, counting number of constructors 
  size(b : Body) : nat = 
    reduce_nat(
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Plus
       LAMBDA(n : Name) : 1, % NumVarEval
       LAMBDA(n : nat) : n + 1, % Neg
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Conj
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Eq
       LAMBDA(n : Name) : 1, % BoolVarEval
       LAMBDA(n : Name) : 1, % RefVarEval
       LAMBDA(nm : Name, n : nat) : n + 1, % Assign
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % CondExpr
       LAMBDA(n1 : nat, nm : Name, n2 : nat) : n1 + n2 + 1, % MethodCall
       LAMBDA(v : (defined?)) : 1, % Const
       LAMBDA(l : list[[nat, nat]]) : 
         sum(map[[nat, nat], nat](LAMBDA(n1, n2 : nat) : n1 + n2 + 1)(l)) + 1, % CaseJML
       LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1, % IfThenElse
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % Sequence
       LAMBDA(nm : Name, n : nat) : n + 1, % Set
       1, % Skip
       LAMBDA(n : nat) : n + 1, % StmtExpr
       LAMBDA(e : Excpt) : 1, % Throw
       LAMBDA(n1 : nat, e : Excpt, n2, n3 : nat) : n1 + n2 + n3 + 1, % TryCatchFinally
       LAMBDA(n1, n2 : nat) : n1 + n2 + 1, % While
       LAMBDA(n : nat) : n + 1 % Assert
       )(b) 


END BodyFunctions


% Syntax of programs
Program[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ValProp[Name],
            Body[Name],
            ValOrExcpt[Name], 
            BodyFunctions[Name]


  % Java reserved words. Below, we only use This, the others are given as
  % examples. 
  This, Super, rsIf, rsThen, rsElse : Name

  reserved_words : finite_set[Name] =
    {n : Name | n = This OR n = Super OR n = rsIf OR n = rsThen OR n = rsElse}

  % To simplify semantics, initial values are defined as Val, not with
  % expression. This avoids need to define evaluation order for initialisation.
  % Variable declarations contain type, name and initial value
  Decl : TYPE = [# jtype : JType,
                   name : Name,
                   init_val : (defined?) #]

  % Method contains 
  % name, 
  % classname to which method belongs
  % declaration of formal parameter (arg)
  % pre and postcondition 
  % (precondition parametrised with argument expression (actual parameter)
  %  postcondition parametrised with return value expression)
  % local variable declaration
  % method body
  % pre_set, post_set and exc_set annotations
  % (pre_set parametrised with actual parameter, 
  %  post_set parametrised with return value, 
  %  exc_set parametrised with return exception)
  % res: expression to compute return value
  % res_type: return type of method
  Method : TYPE = [# name : Name,
                     classname : Name,
                     arg : Decl,
                     pre : [Expr -> Expr],
                     post : [Expr -> Expr],
                     lvars : finite_set[Decl],
                     body : Stmt,
                     pre_set : [Expr -> Stmt],
                     post_set : [Expr -> Stmt],
                     exc_set : [Excpt -> Stmt],
                     res : Expr,
                     res_type : JType #]

  % Class contains 
  % name
  % name of superclass (bottom for class Object)
  % class invariant (supposed to contain also inherited invariants from 
  %                  superclasses)
  % set of ghost variable declarations
  % field declarations
  % methods
  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : Expr,
                    ghost_vars : finite_set[Decl],
                    fields : finite_set[Decl],
                    methods : finite_set[Method] #]

  % Program is a list of classes
  % since we only want to treat wellformed classes, here we define
  % type PreProgram, below Program is defined as a subtype satisfying
  % the wellformedness predicate
  PreProgram : TYPE = [# classes : non_empty_finite_set[Class] #]


END Program


% Several utility functions for programs and program parts
ProgramFunctions[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING Program[Name],
            %% Used for proving TCCs
            finite_sets@finite_sets_inductions[Class],
            finite_sets@finite_sets_inductions[Method]

  % Used variable names

%  NOTE: There seems to be a problem with the definition of some in the 
%  CaseJML case. If we define:
%   var_names(b : Body) : set[Name] =
%     {n : Name | some(LAMBDA (m : Name) : m = n)(b)}
%
%  Then it can proved that:
%   problem_with_var_names : LEMMA
%     FORALL(x : list[[Expr, Stmt]]) :
%       var_names(CaseJML(x)) = emptyset

  IMPORTING list_of_set_funcs[Name], 
            listfuncs[[Expr, Stmt]],
            listsum,
            list_map_funcs, 
            BodyFunctions[Name]

  % variable names occurring in program instruction
  var_names(b : Body) : RECURSIVE [Name -> boolean] =
    CASES b OF    
       Plus(b1, b2) : union(var_names(b1), var_names(b2)),
       NumVarEval(varname) : singleton(varname),
       Neg(b) : var_names(b),
       Conj(b1, b2) : union(var_names(b1), var_names(b2)),
       Eq (b1, b2) : union(var_names(b1), var_names(b2)),
       BoolVarEval(varname) : singleton(varname),
       RefVarEval(varname) : singleton(varname),
       Assign(target, source) : add(target, var_names(source)),
       CondExpr(test, then_expr, else_expr) : 
         union(var_names(test), 
         union(var_names(then_expr), var_names(else_expr))),
       MethodCall(tgt, name, arg) :
         union(var_names(tgt), var_names(arg)),
       Const(v) : emptyset[Name],
       CaseJML(branches) : 
        IF null?(branches)
        THEN emptyset[Name]
        ELSE union(var_names(proj_1(car(branches))),
             union(var_names(proj_2(car(branches))),
                   var_names(CaseJML(cdr(branches)))))
        ENDIF,
       IfThenElse(test, then_stmt, else_stmt) :
         union(var_names(test), 
         union(var_names(then_stmt), var_names(else_stmt))),
       Sequence(s1, s2) : union(var_names(s1), var_names(s2)),
       Set(target, source) : add(target, var_names(source)),
       Skip : emptyset[Name],
       StmtExpr(expr) : var_names(expr),
       Throw(exc) : emptyset[Name],
       TryCatch(try, exc, catch, finally) : 
         union(var_names(try), union(var_names(catch), var_names(finally))),
       While(test, body) : union(var_names(test), var_names(body)),
       Assert(expr) : var_names(expr)
    ENDCASES
  MEASURE size(b)

  % var_names in set of variable declarations
  var_names(fs : finite_set[Decl]) : finite_set[Name] =
    {n : Name |EXISTS (f : Decl) : fs(f) AND name(f) = n}

  % var_names in method are the var_names in pre- and postcondition,
  % pre-, post- and exc-set anntations, method body, local variables and
  % formal parameter
  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | 
      ns = var_names(pre(m)(Const(Unit))) OR 
      ns = var_names(post(m)(Const(Unit))) OR
      ns = var_names(body(m)) OR 
      ns = var_names(pre_set(m)(Const(Unit))) OR 
      ns = var_names(post_set(m)(Const(Unit))) OR 
      ns = var_names(exc_set(m)(Throwable)) OR 
      ns = var_names(lvars(m)) OR ns = var_names(res(m)) OR
      ns = singleton(name(arg(m)))})

  % var_names in class are var_names in all methods, fields, ghost variables
  % and class invariants
  var_names(c : Class) : set[Name] = 
    union(Union({ns : set[Name] | EXISTS (m : Method) :
                 methods(c)(m) AND ns = var_names(m)}),
    union(var_names(fields(c)), 
    union(var_names(ghost_vars(c)), var_names(inv(c)))))

  % var_names in program are var_names of all classes
  var_names(p : PreProgram) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})


  var_names_union : LEMMA % :-)
    FORALL (fs1, fs2 : finite_set[Decl]) :
      var_names(union(fs1, fs2)) = union(var_names(fs1), var_names(fs2))

  IMPORTING WF_Card[[Expr, Stmt]], set2list[[Expr, Stmt]] 

  var_names_CaseJML_set2list : LEMMA % :-)
    FORALL (s : finite_set[[Expr, Stmt]], n : Name) :
      var_names(CaseJML(set2list(s)))(n) =
        EXISTS(x : [Expr, Stmt]) :
          s(x) AND union(var_names(proj_1(x)), var_names(proj_2(x)))(n)


  var_names_CaseJML_branches : LEMMA % :-)
    FORALL (branches : list[[Expr, Stmt]], x : [Expr, Stmt], 
            n : Name) :
      member(x, branches) IMPLIES
      (var_names(proj_1(x))(n) OR var_names(proj_2(x))(n)) IMPLIES
      var_names(CaseJML(branches))(n)


  % Declared variable names

  % all declared field names in program
  getFieldDecls(p : PreProgram) : finite_set[Decl] =
    {f : Decl | EXISTS (c : Class) : classes(p)(c) AND 
                                          fields(c)(f)}

  % declared local variables in a class, including formal parameters
  getLocalDecls(c : Class) : finite_set[Decl] =
    {l : Decl | EXISTS (m : Method) : 
                          methods(c)(m) AND                      
                          (lvars(m)(l) OR l = arg(m))}

  % local variables declared in program
  getLocalDecls(p : PreProgram) : finite_set[Decl] =
    {l : Decl | EXISTS (c : Class) : 
                        classes(p)(c) AND getLocalDecls(c)(l)}

  % formal parameter names are always in set of declared local variables
  arg_in_getLocalDecls : LEMMA % :-)
    FORALL(p : PreProgram, c : Class, m : Method) :
      classes(p)(c) IMPLIES
      methods(c)(m) IMPLIES
      getLocalDecls(p)(arg(m))

  % all declared ghost variable names in program
  getGhostDecls(p : PreProgram) : finite_set[Decl] =
    {g : Decl | EXISTS (c : Class) :  classes(p)(c) AND ghost_vars(c)(g)}


  % lookup local variable declaration with name n
  get_LocalDecl(n : Name, p : PreProgram) : lift[Decl] =
    LET ng = {l : Decl | getLocalDecls(p)(l) AND name(l) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  % lookup field declaration with name n
  get_FieldDecl(n : Name, p : PreProgram) : lift[Decl] =
    LET ng = {f : Decl | getFieldDecls(p)(f) AND name(f) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  % lookup ghost variable declaration with name n
  get_GhostDecl(n : Name, p : PreProgram) : lift[Decl] =
    LET ng = {g : Decl | getGhostDecls(p)(g) AND name(g) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  % all variable names declared in program (fields, ghost and local var.)
  declared_var_names(p : PreProgram) : finite_set[Name] =
    {n : Name | var_names(getFieldDecls(p))(n) OR
                var_names(getLocalDecls(p))(n) OR
                var_names(getGhostDecls(p))(n)}

  % all declared variable names, plus reserved name This
  ext_declared_var_names(p : PreProgram) : finite_set[Name] =
    union({n : Name | var_names(getFieldDecls(p))(n) OR
                      var_names(getLocalDecls(p))(n) OR
                      var_names(getGhostDecls(p))(n)},
          {n : Name | n = This})

  % all class names used in program
  class_names(p : PreProgram) : finite_set[Name] =
    {n : Name | EXISTS (c : Class) : classes(p)(c) AND name(c) = n}

  % names of methods defined in program
  method_names(p : PreProgram, c : Class) : finite_set[Name] =
    {n : Name | EXISTS (m : Method) : classes(p)(c) AND methods(c)(m) AND
                                      name(m) = n}

  % all methods defined in program
  methods(p : PreProgram) : finite_set[Method] =
    {m : Method |EXISTS (c : Class) : classes(p)(c) AND methods(c)(m)}

  % if tgt is a reference, and the class name occurs in the program
  % then return the class (otherwise bottom)
  get_class(p : PreProgram)(tgt : Val) : lift[Class] =
    IF Reference?(tgt) AND class_names(p)(class_name(tgt))
    THEN up(choose({c : Class | classes(p)(c) AND name(c) = class_name(tgt)}))
    ELSE bottom
    ENDIF

  % class returned by get_class occurs in the program
  get_class_in_classes : LEMMA % :-)
    FORALL(p : PreProgram)(tgt : Val) :
      up?(get_class(p)(tgt)) IMPLIES
        classes(p)(down(get_class(p)(tgt)))

  % if tgt is a reference to a class in the program, and mn is 
  % declared in this class, return the method (otherwise bottom)
  lookup_mthd(p : PreProgram, tgt : Val, mn : Name) : lift[(methods(p))] =
    IF up?(get_class(p)(tgt)) AND method_names(p, down(get_class(p)(tgt)))(mn)
    THEN up(choose({m : Method | classes(p)(down(get_class(p)(tgt))) AND 
                                 methods(down(get_class(p)(tgt)))(m)
                                 AND name(m) = mn}))
    ELSE bottom
    ENDIF

  % lookup_mthd returns method in the class
  lookup_mthd_in_methods_class : LEMMA % :-)
     FORALL(p : PreProgram, tgt : Val, mn : Name) :
       up?(get_class(p)(tgt)) IMPLIES
       up?(lookup_mthd(p, tgt, mn)) IMPLIES
         methods(down(get_class(p)(tgt)))(down(lookup_mthd(p, tgt, mn)))


  % NOTE: We assume that the invariant contains the conjunction of the 
  %       invariants of the the parent classes.
  % if tgt is reference to a class of the program, return invariant
  % for convenience, if tgt does not point to a class, just return True
  lookup_inv(p : PreProgram, tgt : Val) : Expr =
    IF up?(get_class(p)(tgt))
    THEN inv(down(get_class(p)(tgt)))
    ELSE Const(Bool(True))
    ENDIF


  % look up value of variable n, knowing that it is of type t
  var_lookup(n : Name)(t : JType) : Expr =
    CASES t OF
      IntType : NumVarEval(n),
      BoolType : BoolVarEval(n),
      RefType : RefVarEval(n),
      Void : Const(Unit)
    ENDCASES


  % Proper subtern (<<) properties

  proper_subterm_set_clause(s : Stmt, m : Method) : boolean =
    s << pre_set(m)(Const(Unit)) OR s << post_set(m)(Const(Unit)) OR 
    s << exc_set(m)(Throwable)

  IMPORTING listfuncs

  proper_subterm_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, c3 : Body) :
      Sequence(c1, c2) << c3 IMPLIES 
        c1 << c3 AND c2 << c3

  proper_subterm_set_clause_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, m : Method) :
      proper_subterm_set_clause(Sequence(c1, c2), m) IMPLIES 
        proper_subterm_set_clause(c1, m) AND proper_subterm_set_clause(c2, m)

  proper_subterm_is_transitive : LEMMA % :-)
    FORALL (c1, c2, c3 : Body) :
      c1 << c2 AND c2 << c3 IMPLIES c1 << c3


  subterm_subset_varnames : LEMMA % :-)
    FORALL (b1, b2 : Body) :
      b1 << b2 IMPLIES subset?(var_names(b1), var_names(b2))

  subterm_subset_varnames2 : LEMMA % :-)
    FORALL (b1, b2 : Body) :
      subterm(b1, b2) IMPLIES subset?(var_names(b1), var_names(b2))

  subterm_subset_of_var : LEMMA % :-)
    FORALL (b1, b2 : Body, v : set[Name]) :
      subset?(var_names(b1), v) IMPLIES
        b2 << b1 IMPLIES subset?(var_names(b2), v)


  proper_subterm_implies_subterm : LEMMA % :-)
    FORALL (b1, b2 : Body) : 
      b1 << b2 IMPLIES subterm(b1, b2) 

  subterm_transitive : LEMMA % :-)
    FORALL (b1, b2, b3 : Body) :
      subterm(b1, b2) IMPLIES
        subterm(b2, b3) IMPLIES
          subterm(b1, b3)

  subterm_CaseJML_set2list : LEMMA % :-)
    FORALL (s : finite_set[[Expr, Stmt]], b : Body) :
      Set?(b) IMPLIES
      subterm(b, CaseJML(set2list(s))) =
        (EXISTS(x : [Expr, Stmt]) : 
           s(x) AND (subterm(b, proj_1(x)) OR subterm(b, proj_2(x))))



END ProgramFunctions


% Functions to apply a predicate to each part of a program or a method
ProgramRestriction[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name]

  % pred: predicate over program and body
  % apply pred to 
  % methods pre- and postcondition
  % body
  % pre-, post- and exc-set
  % return expression
  method_pred(p : PreProgram)(m : Method)
             (pred : [PreProgram -> [Body -> bool]]) : bool =
    (FORALL (v : Expr) : pred(p)(pre(m)(v))) AND 
    (FORALL (v : Expr) : pred(p)(post(m)(v))) AND
    pred(p)(body(m)) AND 
    (FORALL (v : Expr) : pred(p)(pre_set(m)(v))) AND
    (FORALL (v : Expr) : pred(p)(post_set(m)(v))) AND 
    (FORALL (e : Excpt) : pred(p)(exc_set(m)(e))) AND
    pred(p)(res(m))

  % pred: predicate over program and body
  % apply pred to
  % all class invariants
  % all methods (using method_pred above)
  program_pred(p : PreProgram)
              (pred : [PreProgram -> [Body -> bool]]) : bool =
    FORALL (c : Class) :
      classes(p)(c) IMPLIES
        pred(p)(inv(c)) AND
        FORALL (m : Method) :
          methods(c)(m) IMPLIES method_pred(p)(m)(pred)

  % pred: predicate over methods
  % apply pred to all methods in program
  program_method_pred(p : PreProgram)(pred : [Method -> bool]) : bool =
    FORALL (c : Class) :
      classes(p)(c) IMPLIES
        FORALL (m : Method) :
          methods(c)(m) IMPLIES pred(m)


END ProgramRestriction


% Functions to apply a predicate to each part of a program or a method
% Repeat definitions from ProgramPred, but with parameter FullProgram,
% instead of PreProgram
FullProgramRestriction[Name : TYPE+, FullProgram : TYPE,
                       (IMPORTING Program[Name])
                       program : [FullProgram -> PreProgram]] : THEORY
BEGIN

  % pred: predicate over program and body
  % apply pred to 
  % methods pre- and postcondition
  % body
  % pre-, post- and exc-set
  % return expression
  method_pred(p : FullProgram)(m : Method)
             (pred : [FullProgram -> [Body -> bool]]) : bool =
    (FORALL (v : Expr) : pred(p)(pre(m)(v))) AND 
    (FORALL (v : Expr) : pred(p)(post(m)(v))) AND
    pred(p)(body(m)) AND 
    (FORALL (v : Expr) : pred(p)(pre_set(m)(v))) AND
    (FORALL (v : Expr) : pred(p)(post_set(m)(v))) AND 
    (FORALL (e : Excpt) : pred(p)(exc_set(m)(e))) AND
    pred(p)(res(m))

  % pred: predicate over program and body
  % apply pred to
  % all class invariants
  % all methods (using method_pred above)
  program_pred(p : FullProgram)
              (pred : [FullProgram -> [Body -> bool]]) : bool =
    FORALL (c : Class) :
      classes(program(p))(c) IMPLIES
        pred(p)(inv(c)) AND
        FORALL (m : Method) :
          methods(c)(m) IMPLIES method_pred(p)(m)(pred)

END FullProgramRestriction


% Wellformedness conditions of program
% We include only the requirements needed for this formalisation
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ProgramFunctions[Name],
            ProgramRestriction[Name]

  % program instructions only contain declared variable names
  % target of set annotation is always a ghost variable
  wf_Body(p : PreProgram)(b : Body) : boolean = 
    (FORALL(v : Name) : var_names(b)(v) IMPLIES ext_declared_var_names(p)(v))
    AND
    (FORALL(b1 : Body) : Set?(b1) IMPLIES 
                         subterm(b1, b) IMPLIES 
                         var_names(getGhostDecls(p))(target(b1)))

  wf_Body_preserved_by_proper_subterm : LEMMA % :-)
    FORALL(p : PreProgram)(b1, b2 : Body) :
      wf_Body(p)(b1) IMPLIES
      b2 << b1 IMPLIES
        wf_Body(p)(b2)

  % wf_Body and e is an expression
  wf_Expr(p : PreProgram)(e : Expr) : boolean =
     wf_Body(p)(e)

  % wf_Body and s is a statement
  wf_Stmt(p : PreProgram)(s : Stmt) : boolean =
    wf_Body(p)(s)

  % check wf_Body for all branches of CaseJML instruction
  wf_Branches(p : PreProgram)(l : list[[Expr, Stmt]]) : boolean =
    every(LAMBDA(x : [[Expr, Stmt]]) : 
      wf_Body(p)(proj_1(x)) AND wf_Body(p)(proj_2(x)))(l)

  wf_Body_CaseJML : LEMMA % :-)
    FORALL(p : PreProgram, l : list[[Expr, Stmt]]) :
      wf_Body(p)(CaseJML(l)) = wf_Branches(p)(l)

  wf_Body_While : LEMMA % :-)
    FORALL(p : PreProgram, b : (wf_Body(p))) :
      While?(b) IMPLIES
        wf_Body(p)(IfThenElse(test(b), b, Skip))

  wf_Body_CaseJML_branches : LEMMA
    FORALL(p : PreProgram, b : (wf_Body(p))) :
      CaseJML?(b) IMPLIES
        NOT null?(branches(b)) IMPLIES
        wf_Body(p)(IfThenElse
               (PROJ_1(car(branches(b))),
                PROJ_2(car(branches(b))),
                CaseJML(cdr(branches(b)))))


  % within a method, all local variables have different names
  wf_method_all_lvars_disjoint(m : Method) : boolean =
    FORALL(x, y : Decl) :
      lvars(m)(x) IMPLIES
      lvars(m)(y) IMPLIES
      name(x) = name(y) IMPLIES x = y
  
  % methods: all instructions and (incl. specification) should satisfy wf_Body
  wf_Method(p : PreProgram)(m : Method) : boolean =
    method_pred(p)(m)(wf_Body) AND
    wf_method_all_lvars_disjoint(m)    

  % all methods in class should be wf_Method
  % in addition: every method name occurs only once in class
  % classname in method is class method belongs too
  wf_Class(p : PreProgram)(c : Class) : boolean =
    (FORALL (m1, m2 : Method) :
       methods(c)(m1) IMPLIES
       methods(c)(m2) IMPLIES
       name(m1) = name(m2) IMPLIES
         m1 = m2) 
     AND
    (FORALL (m : Method) : methods(c)(m) IMPLIES classname(m) = name(c))

  % all classes in program should satisfy wf_Class
  wf_Classes(p : PreProgram) : boolean =
    FORALL (c : Class) : classes(p)(c) IMPLIES wf_Class(p)(c)

  % fields, local and ghost variables should have disjoint name sets
  % Needed, since we model the heap as a flat Store 
  wf_program_variables_disjoint_def(p : PreProgram) : boolean =
    LET fname = var_names(getFieldDecls(p)),
        lname = var_names(getLocalDecls(p)),
        gname = var_names(getGhostDecls(p)) IN
    disjoint?(fname, lname) AND
    disjoint?(lname, gname) AND
    disjoint?(fname, gname)

  % program variable names are not reserved words
  wf_program_variables_not_reserved_words_def(p : PreProgram) : boolean =
    disjoint?(declared_var_names(p), reserved_words)

  % class names are unique
  wf_program_has_unique_class_names_def(p : PreProgram) : boolean =
    FORALL (c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  % every method belongs to one class
  wf_program_methods_only_in_one_class(p : PreProgram) : boolean =
    FORALL (c1, c2 : Class, m : Method) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      methods(c1)(m) IMPLIES
      methods(c2)(m) IMPLIES
        c1 = c2



  % NOTE: In a complete specification, wf_Program would include only syntactic
  % requirements and then we would define well_typed_Program. Since we don't
  % have many type requirements, it doesn't make sense to have two different
  % notions.
  wf_Program(p : PreProgram) : boolean =
    wf_program_variables_disjoint_def(p) AND
    wf_program_variables_not_reserved_words_def(p) AND
    wf_program_has_unique_class_names_def(p) AND
    wf_Classes(p)AND
    program_pred(p)(wf_Body)

  % Below, we only consider wellformed programs
  Program : TYPE = (wf_Program)

  AUTO_REWRITE- wf_Program

  % Properties about well-formed programs

  wf_program_variables_disjoint : LEMMA % :-)
     FORALL (p : Program) :
       LET fname = var_names(getFieldDecls(p)),
           lname = var_names(getLocalDecls(p)),
           gname = var_names(getGhostDecls(p)) IN
       disjoint?(fname, lname) AND
       disjoint?(lname, gname) AND
       disjoint?(fname, gname)

  wf_program_variables_not_reserved_words : LEMMA % :-)
    FORALL(p : Program) : 
      disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names : LEMMA % :-)
    FORALL (p : Program, c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_has_wf_classes : LEMMA % :-)
    FORALL (p : Program, c : Class) :
      classes(p)(c) IMPLIES
        wf_Class(p)(c)

  wf_class_has_unique_method_names : LEMMA % :-)
    FORALL (p : Program, c : Class, m1, m2 : Method) :
      wf_Class(p)(c) IMPLIES
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2

  wf_program_methods_only_in_one_class : LEMMA % :-)
    FORALL (p : Program) :
      wf_program_methods_only_in_one_class(p)

  wf_program_var_names_declared : LEMMA % :-)
    FORALL (p : Program, n : Name) :
      var_names(p)(n) IMPLIES ext_declared_var_names(p)(n)


END WellFormedProgram
