% Section 3.1 Abstract Syntax of Program

% Simplifications:
% Just sequential programs
% We don't model types and interfaces
% Methods have just one parameter
% No arrays
% Initial values for fields are Val, not Expr. This is because otherwise we have
%   to define an order to evaluate those expressions and avoid recursive 
%   initializations
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then
% We have a store for the whole program, thus fields and ghost vars names
%   contain the class name they belong to. Local vars and formal args contain
%   also their method names

% Our additions
% CaseJML: allows to do a case distiction on the value of a ghost var
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?      % Integers
  BoolType : BoolType?    % Booleans
  Void : Void?            % Void
  RefType : RefType?      % References

END JType


% Numerical expressions
% They are parameterized with a variable name to handle the case of variable evaluation
NumExpr[Name : TYPE+] : DATATYPE
BEGIN

  Int(i : int) : Int?
  Plus(b1, b2 : NumExpr) : Plus?
  Minus(b1, b2 : NumExpr) : Minus?
  Times(b1, b2 : NumExpr) : Times?
  Div(b1, b2 : NumExpr) : Div?
  NumVarEval(varname : Name) : VarEval?

END NumExpr

% Boolean expressions
BoolExpr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING NumExpr[Name]

  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?
  FF : FF?
  Neg(b : BoolExpr) : Neg?
  Conj(b1, b2 : BoolExpr) : Conj?
  Disj(b1, b2 : BoolExpr) : Disj?
  Lt (b1, b2 : NumExpr) : Lt?
  Le (b1, b2 : NumExpr) : Le?
  Eq (b1, b2 : NumExpr) : Eq?
  Neq (b1, b2 : NumExpr) : Neq?
  Ge (b1, b2 : NumExpr) : Ge?
  Gt (b1, b2 : NumExpr) : Gt?
  BoolVarEval(varname : Name) : VarEval?

END BoolExpr


Expr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING BoolExpr[Name],
            NumExpr[Name]

  Assign(target : Name, source : Expr) : Assign?
  BExpr(b : BoolExpr) : BExpr?
  CondExpr(test : BoolExpr, then_expr : Expr, else_expr : Expr) : CondExpr?
  MethodCall(tgt : Expr, name : Name, arg : Expr) : MethodCall?
  NExpr(n : NumExpr) : NExpr?
%  QAssign(tgt : Expr, target : Name, source : Expr) : QAssign?

END Expr


Stmt[Name : TYPE+] : DATATYPE
BEGIN
  
  IMPORTING Expr[Name]

  % renamed IfJML to CaseJML. Have to constrain the statements in body
  % I also must say that the list is finite
%  Access(n : Name) : Access?
  CaseJML(case : list[[BoolExpr, Stmt]]) : CaseJML?
  IfThenElse(test : BoolExpr, then_stmt : Stmt, else_stmt : Stmt) : IfThenElse?
%  Lit(v : Val) : Lit?
  Sequence(s1, s2 : Stmt) : Sequence?
  Set(target : Name, source : Expr) : Set?
  Skip : Skip?
  StmtExpr (expr : Expr) : StmtExpr?
  Throw : Throw?
  % optional catch and finally modelled by lifting types
  TryCatch (try : Stmt, catch : Stmt, finally : Stmt) : TryCatch?
  While(test : BoolExpr, body : Stmt) : While?

END Stmt

SizeFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING NumExpr[Name],
            BoolExpr[Name],
            Expr[Name],
            Stmt[Name]

  size(n : NumExpr) : nat = 
    reduce_nat(LAMBDA(x : int) : 0, 
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(vn : Name) : 0)(n)

  size(b : BoolExpr) : nat =
    reduce_nat(0, 
               0,
               LAMBDA(n : nat) : 1 + n,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(vn : Name) : 0)(b)

  sum(l : list[nat]) : RECURSIVE nat =
    CASES l OF
      null : 0,
      cons(n, l) : n + sum(l)
    ENDCASES
  MEASURE length(l)

  size(e : Expr) : nat =
    reduce_nat(LAMBDA(e : Name, n : nat) : n + 1, % Assign
               LAMBDA(b : BoolExpr) : size(b),    % BExpr
               LAMBDA(b : BoolExpr, n1, n2 : nat) : size(b) + n1 + n2 + 1, %Cond
               LAMBDA(n1 : nat, e : Name, n2 : nat) : 1 + n1 + n2, % MethodCall
               LAMBDA(n : NumExpr) : size(n))(e)  % NExpr
 
  size(s : Stmt) : nat = 
    reduce_nat(LAMBDA(l: list[[BoolExpr, nat]]) : 
                 sum(map(LAMBDA (c: [BoolExpr, nat]): 
                   size(proj_1(c)) + proj_2(c), l)),               % CaseJML
               LAMBDA(e : BoolExpr, n1, n2 : nat) : size(e) + n1 + n2 + 1, % If
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,                 % Sequence
               LAMBDA(e : Name, e : Expr) : size(e) + 1,           % Set
               0,                                                  % Skip
               LAMBDA(e : Expr) : size(e) + 1,                     % StmtExpr
               0,                                                  % Throw
               LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1,        % TryCatch
               LAMBDA(b : BoolExpr, n : nat) : size(b) + n + 1)(s) % While

               
END SizeFunctions


Program[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING JType,
            Val,
            Stmt[Name],
            Expr[Name]
  
  main : Name

  This, Super : Name

  GhostVarDecl : TYPE = [# jtype : JType, 
                           name : Name,
                           init_val : Val #]

  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : Val #]

  ArgDecl : TYPE = [# jtype : JType,
                      name : Name #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     arg : ArgDecl,
                     pre : BoolExpr,
                     post : BoolExpr,
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt,
                     pre_set : Stmt,
                     post_set : Stmt,
                     exc_set : Stmt,
                     res : Expr,
                     res_type : JType #]

  % change from original document:
  % superClass is just a name, not a class
  % This avoid that Class is a recursive record definition
  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : BoolExpr,
                    ghost_vars : finite_set[GhostVarDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  Program : TYPE = [# classes : finite_set[Class],
                      main : Method #]

  % TODO: define (long!)
  var_names(p : Program) : finite_set[Name]

  %
  % Program requirements (see the assumptions at the beginning of the file)
  % NOTE: Since the declarations are sets we can avoid some duplicate tests.
  % We include only the requirements needed for the proofs
  %

  % The main method is one of the methods of the program
  valid_main(p : Program) : boolean = 
    EXISTS (m : Method) : main(p) = m AND EXISTS (c : Class) :
      classes(p)(c) AND methods(c)(m)

  % Every variable used has a declaration
  unique_declarations(p : Program) : boolean =
    FORALL (n : Name) : var_names(p)(n) IMPLIES
      (EXISTS (fd : FieldDecl, c : Class) :
        classes(p)(c) AND fields(c)(fd) AND name(fd) = n) OR
      (EXISTS (gd : GhostVarDecl, c : Class) :
        classes(p)(c) AND ghost_vars(c)(gd) AND name(gd) = n) OR
      (EXISTS (ad : ArgDecl, c : Class, m : Method) :
        classes(p)(c) AND methods(c)(m) AND arg(m)(ad) AND name(ad) = n) OR
      (EXISTS (ld : LocalVarDecl, c : Class, m : Method) :
        classes(p)(c) AND methods(c)(m) AND lvars(m)(ld) AND name(ld) = n)

  % Variable names are unique
  % NOTE: The parser complains if the closing brackets are together: }}
  % We have reported this bug
  unique_var_names(p : Program) : boolean =
    LET fdss = {nss : setofsets[Name] | EXISTS (c : Class, fds : set[FieldDecl]) :
          classes(p)(c) AND fields(c) = fds AND
          FORALL (ns : set[Name]) : nss(ns) IMPLIES
            ns = {n : Name | EXISTS (fd : FieldDecl) : fds(fd) AND name(fd) = n} },
        gdss = {nss : setofsets[Name] | EXISTS (c : Class, gds : set[GhostVarDecl]) :
          classes(p)(c) AND ghost_vars(c) = gds AND
          FORALL (ns : set[Name]) : nss(ns) IMPLIES
            ns = {n : Name | EXISTS (gd : GhostVarDecl) : 
              gds(gd) AND name(gd) = n} },
        ldss = {nss : setofsets[Name] | EXISTS (c : Class, ms : set[Method]) :
          classes(p)(c) AND methods(c) = ms AND
          FORALL (ns : Name) : nss(ns) IMPLIES
            ns = {n : Name | EXISTS (m : Method, ld : LocalVarDecl) : 
              ms(m) AND lvars(m)(ld) AND name(ld) = n} },
        ads  = {ns : set[Name] | EXISTS (c : Class, ms : set[Method]) :
          classes(p)(c) AND methods(c) = ms AND
          FORALL (n : Name) : ns(n) IMPLIES
            EXISTS (m : Method, ad : ArgDecl) : 
              ms(m) AND arg(m) = ad AND name(ad) = n}
    IN
    empty?(Intersection({ns : set[Name] | fdss(ns) OR gdss(ns) OR 
                                          ns = ads OR ldss(ns)}))

%    valid_method_call

  % TODO:
  % Well-formed CaseJML
  % Type checks: assignments, method calls, etc, etc
  valid_Program(p : Program) : boolean =
    valid_main(p) AND
    unique_declarations(p) AND
    unique_var_names(p)

END Program
