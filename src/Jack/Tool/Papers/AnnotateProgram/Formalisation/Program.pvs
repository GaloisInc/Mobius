% Simplifications in the modeling of (the syntax of) programs:
% Just sequential programs
% We don't model arrays and interfaces
% Methods have just one parameter
% Initial values for fields are Val, not Expr. This is to avoid defining an
%   order of evaluation of those expressions.
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then

% No static fields nor static methods
% No return instruction. Methods have a result component that is an expression
%   whose value is the value to be returned

% Our additions:
% CaseJML: allows to do a case distiction on the value of a ghost variable
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?            % Integers
  BoolType : BoolType?          % Booleans
  Void : Void?                  % Void
  RefType : RefType?            % References


END JType


Excpt : DATATYPE
BEGIN

  Throwable : Throwable?
  NullPointer : NullPointer?
  JMLExc : JMLExc?


END Excpt

Body[Name : TYPE+] : DATATYPE
                         WITH SUBTYPES Expr, NumExpr, BoolExpr, RefExpr, Stmt
BEGIN

% Numerical expressions. They are parameterized with a variable name to handle
%  the case of variable evaluation.

  Int(i : int) : Int?                     : NumExpr
  Plus(b1, b2 : Expr) : Plus?             : NumExpr
%  Minus(b1, b2 : Expr) : Minus?           : NumExpr
%  Times(b1, b2 : Expr) : Times?           : NumExpr
%  Div(b1, b2 : Expr) : Div?               : NumExpr
  NumVarEval(varname : Name) : NumVarEval?: NumExpr


  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?                                : BoolExpr
  FF : FF?                                : BoolExpr
  Neg(b : Expr) : Neg?                    : BoolExpr
  Conj(b1, b2 : Expr) : Conj?             : BoolExpr
%  Disj(b1, b2 : Expr) : Disj?             : BoolExpr
%  Lt (b1, b2 : Expr) : Lt?                : BoolExpr
%  Le (b1, b2 : Expr) : Le?                : BoolExpr
%  Eq (b1, b2 : Expr) : Eq?                : BoolExpr
%  Neq (b1, b2 : Expr) : Neq?              : BoolExpr
%  Ge (b1, b2 : Expr) : Ge?                : BoolExpr
%  Gt (b1, b2 : Expr) : Gt?                : BoolExpr
  BoolVarEval(varname : Name) : BoolVarEval? : BoolExpr


% Reference expressions
  Null : Null?                            : RefExpr
  RefVarEval(varname : Name) : RefVarEval?: RefExpr


% Program's expressions
  Assign(target : Name, source : Expr) : Assign? : Expr
  BExpr(b : BoolExpr) : BExpr?                   : Expr
  CondExpr(test : Expr, then_expr : Expr, 
           else_expr : Expr) : CondExpr?         : Expr
  MethodCall(tgt : Expr, name : Name, 
             arg : Expr) : MethodCall?           : Expr
  NExpr(n : NumExpr) : NExpr?                    : Expr
  RExpr(r : RefExpr) : RExpr?                    : Expr


% Program's statements

  CaseJML(branches : list[[BoolExpr, Stmt]]) : CaseJML? : Stmt
  IfThenElse(test : BoolExpr, then_stmt : Stmt, 
             else_stmt : Stmt) : IfThenElse?        : Stmt
  Sequence(s1, s2 : Stmt) : Sequence?               : Stmt
  Set(target : Name, source : Expr) : Set?          : Stmt
  Skip : Skip?                                      : Stmt
  StmtExpr(expr : Expr) : StmtExpr?                 : Stmt
  Throw : Throw?                                    : Stmt
  TryCatch(try : Stmt, catch : Stmt, 
           finally : Stmt) : TryCatch?              : Stmt
  While(test : BoolExpr, body : Stmt) : While?      : Stmt


END Body


% Syntax of programs
Program[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING ValProp[Name],
            Body[Name]
            
  This : Name

  % Other reserved words given as examples
  Super, rsIf, rsThen, rsElse : Name

  % Java reserved words. We only need to mention This, the other are given as
  % examples. 
  reserved_words : finite_set[Name] =
    {n : Name | n = This OR n = Super OR n = rsIf OR n = rsThen OR n = rsElse}

  % NOTE: It is not correct to have Val in programs because they belong to the
  % semantic domain, however, we do so to simplify the definition of the initial
  % state (otherwise we would have to define an order of initialization).
  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : (defined?) #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     arg : LocalVarDecl,
                     pre : BoolExpr,
                     post : BoolExpr,
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt,
                     pre_set : Stmt,
                     post_set : Stmt,
                     exc_set : Stmt,
                     res : Expr,
                     res_type : JType #]

  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : BoolExpr,
                    ghost_vars : finite_set[FieldDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  Program : TYPE = [# classes : finite_set[Class] #]


END Program


% Functions that manipulate programs or program parts
ProgramFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name],
            %% Used for proving TCCs
            FiniteSetInduction[Class],
            FiniteSetInduction[Method]

  % Used variable names

  var_names(ne : NumExpr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(ne)}

  var_names(be : BoolExpr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(be)}

  var_names(re : RefExpr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(re)}

  var_names(e : Expr) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(e)}

  var_names(s : Stmt) : set[Name] =
    {n : Name | some(LAMBDA (m : Name) : m = n)(s)}

  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | ns = var_names(pre(m)) OR ns = var_names(post(m)) OR
      ns = var_names(body(m)) OR ns = var_names(pre_set(m)) OR 
      ns = var_names(post_set(m)) OR ns = var_names(exc_set(m))})

  var_names(c : Class) : set[Name] = 
    Union({ns : set[Name] | EXISTS (m : Method) :
      methods(c)(m) AND ns = var_names(m)})

  var_names(p : Program) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})

  var_names(fs : finite_set[FieldDecl]) : finite_set[Name] =
    {n : Name |EXISTS (f : FieldDecl) : fs(f) AND name(f) = n}

  var_names(ls : finite_set[LocalVarDecl]) : finite_set[Name] =
    {n : Name |EXISTS (l : LocalVarDecl) : ls(l) AND name(l) = n}


  % Declared variable names

  getFieldDecls(p : Program) : finite_set[FieldDecl] =
    {f : FieldDecl | EXISTS (c : Class) : classes(p)(c) AND 
                                          fields(c)(f)}

  getLocalDecls(p : Program) : finite_set[LocalVarDecl] =
    {l : LocalVarDecl | EXISTS (c : Class, m : Method) : 
                        classes(p)(c) AND 
                        methods(c)(m) AND
                        (lvars(m)(l) OR l = arg(m))}

  getGhostDecls(p : Program) : finite_set[FieldDecl] =
    {g : FieldDecl | EXISTS (c : Class) :  classes(p)(c) AND ghost_vars(c)(g)}


  get_LocalDecl(n : Name, p : Program) : lift[LocalVarDecl] =
    LET ng = {l : LocalVarDecl | getLocalDecls(p)(l) AND name(l) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_FieldDecl(n : Name, p : Program) : lift[FieldDecl] =
    LET ng = {f : FieldDecl | getFieldDecls(p)(f) AND name(f) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  get_GhostDecl(n : Name, p : Program) : lift[FieldDecl] =
    LET ng = {g : FieldDecl | getGhostDecls(p)(g) AND name(g) = n} IN
    IF nonempty?(ng)
    THEN up(choose(ng))
    ELSE bottom
    ENDIF

  declared_var_names(p : Program) : finite_set[Name] =
    {n : Name | var_names(getFieldDecls(p))(n) OR
                var_names(getLocalDecls(p))(n) OR
                var_names(getGhostDecls(p))(n)}


  class_names(p : Program) : finite_set[Name] =
    {n : Name | EXISTS (c : Class) : classes(p)(c) AND name(c) = n}

  method_names(p : Program, c : Class) : finite_set[Name] =
    {n : Name | EXISTS (m : Method) : classes(p)(c) AND methods(c)(m) AND
                                      name(m) = n}

  methods(p : Program) : finite_set[Method] =
    {m : Method |EXISTS (c : Class) : classes(p)(c) AND methods(c)(m)}

  get_class(p : Program)(tgt : Val) : lift[Class] =
    IF Reference?(tgt) AND class_names(p)(class_name(tgt))
    THEN up(choose({c : Class | classes(p)(c) AND name(c) = class_name(tgt)}))
    ELSE bottom
    ENDIF

  % TODO: This specification is not correct because we can not return any method
  % in the program that has the required name, we should return the first in the
  % hierarchy of classes of the dynamic type of tgt.
  % Probably the best thing to do is to leave it undefined.
  lookup_mthd(p : Program, tgt : Val, mn : Name) : lift[(methods(p))] %=
%    IF up?(get_class(p)(tgt)) AND method_names(p, down(get_class(p)(tgt)))(mn)
%    THEN up(choose({m : Method | classes(p)(down(get_class(p)(tgt))) AND 
%                                 methods(down(get_class(p)(tgt)))(m)
%                                 AND name(m) = mn}))
%    ELSE bottom
%    ENDIF

  % TODO: Maybe this function should be left undefined since it should also
  % return the conjunction of the invariant of the the parent classes
  % If it can't find an invariant in tgt it just returns TRUE
  lookup_inv(p : Program, tgt : Val) : BoolExpr %=
%    IF up?(get_class(p)(tgt))
%    THEN inv(down(get_class(p)(tgt)))
%    ELSE BExpr(TT)
%    ENDIF


  proper_subterm_set_clause(s : Stmt, m : Method) : boolean =
    s << pre_set(m) OR s << post_set(m) OR s << exc_set(m)


%  program_code(p : Program)(s : Stmt) : boolean =
%    EXISTS(c : Class, m : Method) :
%      classes(p)(c) AND
%      methods(c)(m) AND
%      s << body(m)

%  direct_sub_expr(s : Stmt) : RECURSIVE list[Expr] =
%    CASES s OF
%      CaseJML(branches) : append(map(proj_1)(branches),
%                                 map(direct_sub_expr o proj_2)(branches)),
%      IfThenElse(c, t, e) : cons(c, append(direct_sub_expr(t), 
%                                           direct_sub_expr(e))),
%      Sequence(s1, s2) : append(direct_sub_expr(s1), direct_sub_expr(s2)),
%      Set(target, source) : cons(source, null),
%      Skip : null
%      StmtExpr(expr) : cons(expr, null),
%      Throw : null,
%      TryCatch(t, c, f) : TryCatch?
%  While(test : Expr, body : Stmt) : While?

%  program_code(p : Program)(e : Expr) : boolean =
%    EXISTS(c : Class, m : Method) :
%      classes(p)(c) AND
%      methods(c)(m) AND
%      e << body(m)

END ProgramFunctions


% Program's syntax requirements.
% We include only the requirements needed for the proofs.
% NOTE: Since the declarations are sets we can avoid some duplicate tests.
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING ProgramFunctions[Name]

  wf_Class(c : Class) : boolean =
    FORALL (m1, m2 : Method) :
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2

  wf_Classes(p : Program) : boolean =
    FORALL (c : Class) : classes(p)(c) IMPLIES wf_Class(c)
    
  wf_program_variables_disjoint_def(p : Program) : boolean =
    LET fname = var_names(getFieldDecls(p)),
        lname = var_names(getLocalDecls(p)),
        gname = var_names(getGhostDecls(p)) IN
    disjoint?(fname, lname) AND
    disjoint?(lname, gname) AND
    disjoint?(fname, gname)

  wf_program_variables_not_reserved_words_def(p : Program) : boolean =
    disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names_def(p : Program) : boolean =
    FORALL (c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_all_variables_declared(p : Program) : boolean =
    FORALL(v : Name) : var_names(p)(v) IMPLIES declared_var_names(p)(v)
    
%  % Basic type information
%  invariants_are_bool_expr(p : Program) : boolean =
%    FORALL (c : Class) :
%      classes(p)(c) IMPLIES
%        BExpr?(inv(c))

  % TODO: review this definition
  % NOTE: In a complete specification, wf_Program would include only syntactic
  % requirements and then we would define well_typed_Program. Since we don't
  % have many type requirements, it doesn't make sense to have two different
  % notions.
  wf_Program(p : Program) : boolean =
    wf_program_variables_disjoint_def(p) AND
    wf_program_variables_not_reserved_words_def(p) AND
    wf_program_has_unique_class_names_def(p) AND
    wf_Classes(p) AND
    wf_program_all_variables_declared(p)
%    invariants_are_bool_expr(p)

  AUTO_REWRITE- wf_Program


  % Properties needed of well-formed programs

  % Because we model the heap as a flat Store here we need to require that
  % variables have a unique name within the program.
  wf_program_variables_disjoint : LEMMA % :-)
     FORALL(p : Program) :
       wf_Program(p) IMPLIES
       LET fname = var_names(getFieldDecls(p)),
           lname = var_names(getLocalDecls(p)),
           gname = var_names(getGhostDecls(p)) IN
       disjoint?(fname, lname) AND
       disjoint?(lname, gname) AND
       disjoint?(fname, gname)

  wf_program_variables_not_reserved_words : LEMMA % :-)
    FORALL(p : Program) : 
      wf_Program(p) IMPLIES disjoint?(declared_var_names(p), reserved_words)

  wf_program_has_unique_class_names : LEMMA % :-)
    FORALL (p : Program, c1, c2 : Class) :
      wf_Program(p) IMPLIES
      classes(p)(c1) IMPLIES
      classes(p)(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c1 = c2

  wf_program_has_wf_classes : LEMMA % :-)
    FORALL (p : Program, c : Class) :
      wf_Program(p) IMPLIES
      classes(p)(c) IMPLIES
        wf_Class(c)

  wf_class_has_unique_method_names : LEMMA % :-)
    FORALL (c : Class, m1, m2 : Method) :
      wf_Class(c) IMPLIES
      methods(c)(m1) IMPLIES
      methods(c)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m1 = m2

  % This misses that the set statement actually occurs in the program
  wf_program_all_variables_declared : LEMMA
    FORALL(p : Program, v : Name) : 
      wf_Program(p) IMPLIES
        var_names(p)(v) IMPLIES
        declared_var_names(p)(v)


END WellFormedProgram
