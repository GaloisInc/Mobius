% Section 3.1 Abstract Syntax of Program

% Simplifications:
% Just sequential programs
% We don't model types and interfaces
% Methods have just one parameter
% No arrays
% Initial values for fields are Val, not Expr. This is because otherwise we have
%   to define an order to evaluate those expressions and avoid recursive 
%   initializations
% Only two types of exceptions: Throwable and NullPointer. We also model JML 
%   exceptions
% Local variables are declared at the beginning of the body (like in Pascal)
% We do not model inheritance and static overloading of methods (their names can
%   be "mangled", .i.e the contain the information to disambiguate then
% We have a store for the whole program, thus fields and ghost vars names
%   contain the class name they belong to. Local vars and formal args contain
%   also their method names
% No static fields nor static methods
% No return instruction. Methods have a result component that is an expression
%   whose value is the value to be returned

% Our additions
% CaseJML: allows to do a case distiction on the value of a ghost var
% Methods have a pre_set, post_set and exc_set clause


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?      % Integers
  BoolType : BoolType?    % Booleans
  Void : Void?            % Void
  RefType : RefType?      % References


END JType


% Numerical expressions
% They are parameterized with a variable name to handle the case of variable evaluation
NumExpr[Name : TYPE+] : DATATYPE
BEGIN

  Int(i : int) : Int?
  Plus(b1, b2 : NumExpr) : Plus?
  Minus(b1, b2 : NumExpr) : Minus?
  Times(b1, b2 : NumExpr) : Times?
  Div(b1, b2 : NumExpr) : Div?
  NumVarEval(varname : Name) : VarEval?


END NumExpr


% Boolean expressions
BoolExpr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING NumExpr[Name]

  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?
  FF : FF?
  Neg(b : BoolExpr) : Neg?
  Conj(b1, b2 : BoolExpr) : Conj?
  Disj(b1, b2 : BoolExpr) : Disj?
  Lt (b1, b2 : NumExpr) : Lt?
  Le (b1, b2 : NumExpr) : Le?
  Eq (b1, b2 : NumExpr) : Eq?
  Neq (b1, b2 : NumExpr) : Neq?
  Ge (b1, b2 : NumExpr) : Ge?
  Gt (b1, b2 : NumExpr) : Gt?
  BoolVarEval(varname : Name) : VarEval?


END BoolExpr


% Reference expressions
RefExpr[Name : TYPE+] : DATATYPE
BEGIN

  Null : Null?
  RefVarEval(varname : Name) : RefVarEval?


END RefExpr


% Program's expressions
Expr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING BoolExpr[Name],
            NumExpr[Name],
            RefExpr[Name]

  Assign(target : Name, source : Expr) : Assign?
  BExpr(b : BoolExpr) : BExpr?
  CondExpr(test : BoolExpr, then_expr : Expr, else_expr : Expr) : CondExpr?
  MethodCall(tgt : Expr, name : Name, arg : Expr) : MethodCall?
  NExpr(n : NumExpr) : NExpr?
  RExpr(r : RefExpr) : RExpr?


END Expr


% Program's statements
Stmt[Name : TYPE+] : DATATYPE
BEGIN
  
  IMPORTING Expr[Name]

  CaseJML(branches : list[[BoolExpr, Stmt]]) : CaseJML?
  IfThenElse(test : BoolExpr, then_stmt : Stmt, else_stmt : Stmt) : IfThenElse?
  Sequence(s1, s2 : Stmt) : Sequence?
  Set(target : Name, source : Expr) : Set?
  Skip : Skip?
  StmtExpr (expr : Expr) : StmtExpr?
  Throw : Throw?
  % optional catch and finally modelled by lifting types
  TryCatch (try : Stmt, catch : Stmt, finally : Stmt) : TryCatch?
  While(test : BoolExpr, body : Stmt) : While?


END Stmt


SizeFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Expr[Name],
            Stmt[Name]

  size(n : NumExpr) : nat = 
    reduce_nat(LAMBDA(x : int) : 0, 
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(vn : Name) : 0)(n)

  size(b : BoolExpr) : nat =
    reduce_nat(0, 
               0,
               LAMBDA(n : nat) : 1 + n,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(vn : Name) : 0)(b)

  size(r : RefExpr) : nat = 1

  sum(l : list[nat]) : RECURSIVE nat =
    CASES l OF
      null : 0,
      cons(n, l) : n + sum(l)
    ENDCASES
  MEASURE length(l)

  size(e : Expr) : nat =
    reduce_nat(LAMBDA(e : Name, n : nat) : n + 1, % Assign
               LAMBDA(b : BoolExpr) : size(b),    % BExpr
               LAMBDA(b : BoolExpr, n1, n2 : nat) : size(b) + n1 + n2 + 1, %Cond
               LAMBDA(n1 : nat, e : Name, n2 : nat) : 1 + n1 + n2,  % MethodCall
               LAMBDA(n : NumExpr) : size(n),     % NExpr
               LAMBDA(r : RefExpr) : size(r))(e)  % RExpr
 
  size(s : Stmt) : nat = 
    reduce_nat(LAMBDA(l : list[[BoolExpr, nat]]) : 
                 sum(map(LAMBDA (c : [BoolExpr, nat]) :
                   size(proj_1(c)) + proj_2(c), l)),               % CaseJML
               LAMBDA(e : BoolExpr, n1, n2 : nat) : size(e) + n1 + n2 + 1, % If
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,                 % Sequence
               LAMBDA(e : Name, e : Expr) : size(e) + 1,           % Set
               0,                                                  % Skip
               LAMBDA(e : Expr) : size(e) + 1,                     % StmtExpr
               0,                                                  % Throw
               LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1,        % TryCatch
               LAMBDA(b : BoolExpr, n : nat) : size(b) + n + 1)(s) % While

               
END SizeFunctions


Program[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING JType,
            Val,
            Stmt[Name],
            Expr[Name]
  
  main : Name

  This, Super : Name

  GhostVarDecl : TYPE = [# jtype : JType, 
                           name : Name,
                           init_val : Val #]

  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : Val #]

  ArgDecl : TYPE = [# jtype : JType,
                      name : Name #]

  LocalVarDecl : TYPE = [# jtype : JType,
                           name : Name #]

  Method : TYPE = [# name : Name,
                     arg : ArgDecl,
                     pre : Expr,
                     post : Expr,
                     lvars : finite_set[LocalVarDecl],
                     body : Stmt,
                     pre_set : Stmt,
                     post_set : Stmt,
                     exc_set : Stmt,
                     res : Expr,
                     res_type : JType #]

  % change from original document:
  % superClass is just a name, not a class
  % This avoid that Class is a recursive record definition
  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : Expr,
                    ghost_vars : finite_set[GhostVarDecl],
                    fields : finite_set[FieldDecl],
                    methods : finite_set[Method] #]

  Program : TYPE = [# classes : finite_set[Class] #]


  % Functions whose existence we assume
  % Parameters: program, target object, method name, actual parameter
  % NOTE: This is a simplification, we should use the types of the expressions,
  % not their values, but we are not modeling types.
  lookup_mthd : [Program, Val, Name, Expr -> lift[Method]]

  % Parameters: program, target object
  lookup_inv : [Program, Val -> lift[Expr]]


  get_FieldDecl(n : Name, p : Program) : lift[FieldDecl] =
    LET fds = {fd : FieldDecl | EXISTS (c : Class) : classes(p)(c) AND
                                  fields(c)(fd) AND name(fd) = n} IN
      IF empty?(fds)
      THEN bottom
      ELSE up(choose(fds))
      ENDIF

  get_GhostVarDecl(n : Name, p : Program) : lift[GhostVarDecl] =
    LET gds = {gd : GhostVarDecl | EXISTS (c : Class) : classes(p)(c) AND
                                     ghost_vars(c)(gd) AND name(gd) = n} IN
      IF empty?(gds)
      THEN bottom
      ELSE up(choose(gds))
      ENDIF

  get_LocalVarDecl(n : Name, p : Program) : lift[LocalVarDecl] =
    LET lds = {ld : LocalVarDecl | EXISTS (c : Class, m : Method) : 
                                     classes(p)(c) AND methods(c)(m) AND 
                                     lvars(m)(ld) AND name(ld) = n} IN
      IF empty?(lds)
      THEN bottom
      ELSE up(choose(lds))
      ENDIF


END Program


% Program requirements (see the assumptions at the beginning of the file)
% NOTE: Since the declarations are sets we can avoid some duplicate tests.
% We include only the requirements needed for the proofs
WellFormedProgram[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name]

  % Used variable names
  % NOTE: we can't say that the result is a finite set because the statement
  % may not be well formed. If we defined wf_Stmt then we can say that
  % wf_Stmt(c) IMPLIES is_finite?(var_names(c))

  var_names(ne : NumExpr) : set[Name] =
    reduce[Name, set[Name]](
      LAMBDA (i : int) : emptyset,
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (n : Name) : singleton(n))(ne)

  var_names(be : BoolExpr) : set[Name] =
    reduce[Name, set[Name]](
      emptyset,
      emptyset,
      id,
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ns1, ns2 : set[Name]) : union(ns1, ns2),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (ne1, ne2 : NumExpr) : union(var_names(ne1), var_names(ne2)),
      LAMBDA (n : Name) : singleton(n))(be)

  var_names(re : RefExpr) : set[Name] = 
    reduce[Name, set[Name]](
      emptyset,                                                     % Null
      LAMBDA (n : Name) : singleton(n))(re)                         % RefVarEval

  var_names(e : Expr) : set[Name] =
    reduce[Name, set[Name]](
      LAMBDA (t : Name, s : set[Name]) : add(t, s),                 % Assign
      LAMBDA (b : BoolExpr) : var_names(b),                         % BExpr
      LAMBDA (b : BoolExpr, s1, s2 : set[Name]) :
        union(var_names(b), union(s1, s2)),                         % CondExpr
      LAMBDA (e : set[Name], m : Name, a : set[Name]) : union(e, a),% MethodCall
      LAMBDA (ne : NumExpr) : var_names(ne),                        % NExpr
      LAMBDA (re : RefExpr) : var_names(re))(e)                     % RExpr

  var_names(s : Stmt) : set[Name] =
    reduce[Name, set[Name]](
      LAMBDA (branches : list[[BoolExpr, set[Name]]]) :             % CaseJML
        Union({ns : Name | EXISTS (x : [BoolExpr, set[Name]]) :
               member(x, branches) AND  ns = var_names(proj_1(x)) OR
               ns = proj_2(x)}),
      LAMBDA (b : BoolExpr, s1, s2 : set[Name]) :                   % IfThenElse
        union(var_names(b), union(s1, s2)),
          LAMBDA (s1, s2 : set[Name]) : union(s1, s2),              % Sequence
      LAMBDA (target : Name, source : Expr[Name]) :                 % Set
        add(target, var_names(source)),
      emptyset,                                                     % Skip
      LAMBDA (expr : Expr) : var_names(expr),                       % StmtExpr
      emptyset,                                                     % Throw
      LAMBDA (t, c, f : set[Name]) : union(t, union(c, f)),         % TryCatch
      LAMBDA (b : BoolExpr, ns : set[Name]) :                       % While
        union(var_names(b), ns))(s)

  var_names(m : Method) : set[Name] =
    Union({ns : set[Name] | ns = var_names(pre(m)) OR ns = var_names(post(m)) OR
      ns = var_names(body(m)) OR ns = var_names(pre_set(m)) OR 
      ns = var_names(post_set(m)) OR ns = var_names(exc_set(m))})

  var_names(c : Class) : set[Name] = 
    Union({ns : set[Name] | EXISTS (m : Method) :
      methods(c)(m) AND ns = var_names(m)})

  var_names(p : Program) : set[Name] =
    Union({ns : set[Name] | EXISTS (c : Class) :
      classes(p)(c) AND ns = var_names(c)})


  % Names of classes are unique within a program
  unique_class_names(p : Program) : boolean =
    FORALL (c1, c2 : Class) :
      classes(p)(c1) AND 
      classes(p)(c2) AND 
      name(c1) = name(c2) IMPLIES
        c1 = c2

  % Variable names are unique
  % NOTE: The parser complains if the closing brackets are together: }}
  % We have reported this bug
  unique_var_names(p : Program) : boolean =
    LET fdss = {nss : setofsets[Name] | EXISTS (c : Class, fds : set[FieldDecl]) :
          classes(p)(c) AND fields(c) = fds AND
          FORALL (ns : set[Name]) : nss(ns) IMPLIES
            ns = {n : Name | EXISTS (fd : FieldDecl) : fds(fd) AND name(fd) = n} },
        gdss = {nss : setofsets[Name] | EXISTS (c : Class, gds : set[GhostVarDecl]) :
          classes(p)(c) AND ghost_vars(c) = gds AND
          FORALL (ns : set[Name]) : nss(ns) IMPLIES
            ns = {n : Name | EXISTS (gd : GhostVarDecl) :
              gds(gd) AND name(gd) = n} },
        ldss = {nss : setofsets[Name] | EXISTS (c : Class, ms : set[Method]) :
          classes(p)(c) AND methods(c) = ms AND
          FORALL (ns : Name) : nss(ns) IMPLIES
            ns = {n : Name | EXISTS (m : Method, ld : LocalVarDecl) :
              ms(m) AND lvars(m)(ld) AND name(ld) = n} },
        ads  = {ns : set[Name] | EXISTS (c : Class, ms : set[Method]) :
          classes(p)(c) AND methods(c) = ms AND
          FORALL (n : Name) : ns(n) IMPLIES
            EXISTS (m : Method, ad : ArgDecl) : 
              ms(m) AND arg(m) = ad AND name(ad) = n}
    IN
    empty?(Intersection({ns : set[Name] | fdss(ns) OR gdss(ns) OR 
                                          ns = ads OR ldss(ns)}))

  % Every variable used has a declaration
  vars_are_declared(p : Program) : boolean =
    FORALL (n : Name) : var_names(p)(n) IMPLIES
      (EXISTS (fd : FieldDecl, c : Class) :
        classes(p)(c) AND fields(c)(fd) AND name(fd) = n) OR
      (EXISTS (gd : GhostVarDecl, c : Class) :
        classes(p)(c) AND ghost_vars(c)(gd) AND name(gd) = n) OR
      (EXISTS (ad : ArgDecl, c : Class, m : Method) :
        classes(p)(c) AND methods(c)(m) AND arg(m)(ad) AND name(ad) = n) OR
      (EXISTS (ld : LocalVarDecl, c : Class, m : Method) :
        classes(p)(c) AND methods(c)(m) AND lvars(m)(ld) AND name(ld) = n)

  % TODO: Con esto no necesito vars_are_declared
  % Hacer algo similar para las otras variables
  field_declarations_are_unique(p : Program) : boolean =
    FORALL (n : Name) :
      var_names(p)(n) IMPLIES
      EXISTS (fd : FieldDecl, c : Class) :
        classes(p)(c) AND fields(c)(fd) AND name(fd) = n AND
        FORALL (c1 : Class, m : Method) : classes(p)(c1) AND methods(c1)(m) AND
        (FORALL (fd1 : FieldDecl) :
          fields(c1)(fd1) AND name(fd1) = n IMPLIES fd = fd1 AND c = c1) AND
        (FORALL (gd : GhostVarDecl) :
          ghost_vars(c1)(gd) IMPLIES name(gd) /= n) AND
        (FORALL (ad : ArgDecl) :
          arg(m)(ad) IMPLIES name(ad) /= n) AND
        (FORALL (ld : LocalVarDecl) :
          lvars(m)(ld) IMPLIES name(ld) /= n)

  ghost_declarations_are_unique(p : Program) : boolean =
    FORALL (n : Name) :
      var_names(p)(n) IMPLIES
      EXISTS (gd : GhostVarDecl, c : Class) :
        classes(p)(c) AND ghost_vars(c)(gd) AND name(gd) = n AND
        FORALL (c1 : Class, m : Method) : classes(p)(c1) AND methods(c1)(m) AND
        (FORALL (fd : FieldDecl) :
          fields(c1)(fd) IMPLIES name(fd) /= n) AND
        (FORALL (gd1 : GhostVarDecl) :
          ghost_vars(c1)(gd1) AND name(gd1) = n IMPLIES gd = gd1 AND c = c1) AND
        (FORALL (ad : ArgDecl) :
          arg(m)(ad) IMPLIES name(ad) /= n) AND
        (FORALL (ld : LocalVarDecl) :
          lvars(m)(ld) IMPLIES name(ld) /= n)

  arg_declarations_are_unique(p : Program) : boolean =
    FORALL (n : Name) :
      var_names(p)(n) IMPLIES
      EXISTS (ad : ArgDecl, c : Class, m : Method) :
        classes(p)(c) AND methods(c)(m) AND lvars(m)(ad) AND name(ad) = n AND
        FORALL (c1 : Class, m1 : Method) : classes(p)(c1) AND methods(c1)(m1) AND
        (FORALL (fd : FieldDecl) :
          fields(c1)(fd) IMPLIES name(fd) /= n) AND
        (FORALL (gd : GhostVarDecl) :
          ghost_vars(c1)(gd) IMPLIES name(gd) /= n) AND
        (FORALL (ad1 : ArgDecl) :
          arg(m1)(ad1) AND name(ad1) = n IMPLIES ad = ad1 AND m = m1 AND c = c1) AND
        (FORALL (ld : LocalVarDecl) :
          lvars(m)(ld) IMPLIES name(ld) /= n)

  local_declarations_are_unique(p : Program) : boolean =
    FORALL (n : Name) :
      var_names(p)(n) IMPLIES
      EXISTS (ld : LocalVarDecl, c : Class, m : Method) :
        classes(p)(c) AND methods(c)(m) AND lvars(m)(ld) AND name(ld) = n AND
        FORALL (c1 : Class, m1 : Method) : classes(p)(c1) AND methods(c1)(m1) AND
        (FORALL (fd : FieldDecl) :
          fields(c1)(fd) IMPLIES name(fd) /= n) AND
        (FORALL (gd : GhostVarDecl) :
          ghost_vars(c1)(gd) IMPLIES name(gd) /= n) AND
        (FORALL (ad : ArgDecl) :
          arg(m)(ad) IMPLIES name(ad) /= n) AND
        (FORALL (ld1 : LocalVarDecl) :
          lvars(m1)(ld1) AND name(ld1) = n IMPLIES ld = ld1 AND m = m1 AND c = c1)

  % We require vars to have different names, even if they are in different 
  % classes
  declarations_are_unique(p : Program) : boolean =
    field_declarations_are_unique(p) AND
    ghost_declarations_are_unique(p) AND
    arg_declarations_are_unique(p) AND
    local_declarations_are_unique(p)


  % A CaseJML is well formed if the list of braches is finite and the stmts are
  % composed only by set stmts or other CaseJML.
  % THINK: Should it be recursive?
  wf_CaseJML(c : Stmt) : boolean =
    CaseJML?(c) AND
    (EXISTS (n : nat) : length(branches(c)) = n) AND
    FORALL (x : [BoolExpr, Stmt]) :
      member(x, branches(c)) IMPLIES
        Set?(proj_2(x)) OR CaseJML?(proj_2(x))


  % TODO:
  % Well-formed CaseJML (the list must be finite)
  % Type checks: assignments, method calls, etc, etc
  % Assertions (pre, post, inv) are boolean expressions
  wf_Program(p : Program) : boolean =
    unique_class_names(p) AND
    unique_var_names(p) AND
    vars_are_declared(p) AND   % This is redundant with declarations_are unique 
    declarations_are_unique(p) % but is convenient to find a declaration

  AUTO_REWRITE- wf_Program, var_names


  get_FieldDecl_is_determ : LEMMA
    FORALL (n : Name, p : (wf_Program)) :
    LET fds = {fd : FieldDecl | EXISTS (c : Class) : classes(p)(c) AND
                                  fields(c)(fd) AND name(fd) = n}
    IN
      nonempty?(fds) IMPLIES singleton?(fds)

  get_GhostVarDecl_is_determ : LEMMA
    FORALL (n : Name, p : (wf_Program)) :
    LET gds = {gd : GhostVarDecl | EXISTS (c : Class) : classes(p)(c) AND
                                     ghost_vars(c)(gd) AND name(gd) = n}
    IN
      nonempty?(gds) IMPLIES singleton?(gds)

  get_LocalVarDecl_is_determ : LEMMA
    FORALL (n : Name, p : (wf_Program)) :
    LET lds = {ld : LocalVarDecl | EXISTS (c : Class, m : Method) : 
                                     classes(p)(c) AND methods(c)(m) AND
                                     lvars(m)(ld) AND name(ld) = n}
    IN
      nonempty?(lds) IMPLIES singleton?(lds)


END WellFormedProgram
