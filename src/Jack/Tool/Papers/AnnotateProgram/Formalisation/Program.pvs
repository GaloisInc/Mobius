% Section 3.1 Abstract Syntax of Program
% Simplifications:
% We don't model types and interfaces
% Just sequential programs
% Methods have just one parameter
% No arrays


% JType instead of Type, because Type is a reserved keyword in PVS
JType : DATATYPE
BEGIN

  IntType : IntType?      % Integers
  BoolType : BoolType?    % Booleans
  Void : Void?            % Void
  RefType : RefType?      % References

END JType


% Numerical expressions
% They are parameterized with a variable name to handle the case of variable evaluation
NumExpr[Name : TYPE+] : DATATYPE
BEGIN

  Int(i : int) : Int?
  Plus(b1, b2 : NumExpr) : Plus?
  Minus(b1, b2 : NumExpr) : Minus?
  Times(b1, b2 : NumExpr) : Times?
  Div(b1, b2 : NumExpr) : Div?
  NumVarEval(varname : Name) : VarEval?

END NumExpr

% Boolean expressions
BoolExpr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING NumExpr[Name]

  % True, False, not, and, or are reserved keywords in PVS
  TT : TT?
  FF : FF?
  Neg(b : BoolExpr) : Neg?
  Conj(b1, b2 : BoolExpr) : Conj?
  Disj(b1, b2 : BoolExpr) : Disj?
  Lt (b1, b2 : NumExpr) : Lt?
  Le (b1, b2 : NumExpr) : Le?
  Eq (b1, b2 : NumExpr) : Eq?
  Neq (b1, b2 : NumExpr) : Neq?
  Ge (b1, b2 : NumExpr) : Ge?
  Gt (b1, b2 : NumExpr) : Gt?
  BoolVarEval(varname : Name) : VarEval?

END BoolExpr


Expr[Name : TYPE+] : DATATYPE
BEGIN

  IMPORTING BoolExpr[Name],
            NumExpr[Name]

  Assign(target : Name, source : Expr) : Assign?
  BExpr(b : BoolExpr) : BExpr?
  CondExpr(test : BoolExpr, then_expr : Expr, else_expr : Expr) : CondExpr?
  MethodCall(tgt : Expr, name : Name, arg : Expr) : MethodCall?
  NExpr(n : NumExpr) : NExpr?
%  QAssign(tgt : Expr, target : Name, source : Expr) : QAssign?

END Expr


Stmt[Name : TYPE+] : DATATYPE
BEGIN
  
  IMPORTING Expr[Name]

  % renamed IfJML to CaseJML. Have to constrain the statements in body
  % I also must say that the list is finite
  CaseJML(case : list[[BoolExpr, Stmt]]) : CaseJML?
  IfThenElse(test : BoolExpr, then_stmt : Stmt, else_stmt : Stmt) : IfThenElse?
  Sequence(s1, s2 : Stmt) : Sequence?
  Set(target : Name, source : Expr) : Set?
  Skip : Skip?
  StmtExpr (expr : Expr) : StmtExpr?
  Throw : Throw?
  % optional catch and finally modelled by lifting types
  TryCatch (try : Stmt, catch : Stmt, finally : Stmt) : TryCatch?
  While(test : BoolExpr, body : Stmt) : While?

END Stmt

SizeFunctions[Name : TYPE+] : THEORY
BEGIN

  IMPORTING NumExpr[Name],
            BoolExpr[Name],
            Expr[Name],
            Stmt[Name]

  size(n : NumExpr) : nat = 
    reduce_nat(LAMBDA(x : int) : 0, 
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(vn : Name) : 0)(n)

  size(b : BoolExpr) : nat =
    reduce_nat(0, 
               0,
               LAMBDA(n : nat) : 1 + n,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(n1, n2 : NumExpr) : size(n1) + size(n2) + 1,
               LAMBDA(vn : Name) : 0)(b)

  sum(l : list[nat]) : RECURSIVE nat =
    CASES l OF
      null : 0,
      cons(n, l) : n + sum(l)
    ENDCASES
  MEASURE length(l)

  size(e : Expr) : nat =
    reduce_nat(LAMBDA(e : Name, n : nat) : n + 1, % Assign
               LAMBDA(b : BoolExpr) : size(b),    % BExpr
               LAMBDA(b : BoolExpr, n1, n2 : nat) : size(b) + n1 + n2 + 1, %Cond
               LAMBDA(n1 : nat, e : Name, n2 : nat) : 1 + n1 + n2, % MethodCall
               LAMBDA(n : NumExpr) : size(n))(e)  % NExpr
 
  size(s : Stmt) : nat = 
    reduce_nat(LAMBDA(l: list[[BoolExpr, nat]]) : 
                 sum(map(LAMBDA (c: [BoolExpr, nat]): 
                   size(proj_1(c)) + proj_2(c), l)),               % CaseJML
               LAMBDA(e : BoolExpr, n1, n2 : nat) : size(e) + n1 + n2 + 1, % If
               LAMBDA(n1, n2 : nat) : n1 + n2 + 1,                 % Sequence
               LAMBDA(e : Name, e : Expr) : size(e) + 1,           % Set
               0,                                                  % Skip
               LAMBDA(e : Expr) : size(e) + 1,                     % StmtExpr
               0,                                                  % Throw
               LAMBDA(n1, n2, n3 : nat) : n1 + n2 + n3 + 1,        % TryCatch
               LAMBDA(b : BoolExpr, n : nat) : size(b) + n + 1)(s) % While

               
END SizeFunctions


Program[Name : TYPE+] : THEORY
BEGIN
  
  IMPORTING JType,
            Stmt[Name],
            Expr[Name]
  
  This, Super : Name

  GhostVarDecl : TYPE = [# jtype : JType, 
                           name : Name,
                           init_val : Expr #]

  FieldDecl : TYPE = [# jtype : JType,
                        name : Name,
                        init_val : Expr #]

  ArgDecl : TYPE = [# jtype : JType,
                      name : Name #]

  Method : TYPE = [# name : Name,
                     arg : ArgDecl,
                     pre : BoolExpr,
                     post : BoolExpr,
                     body : Stmt,
                     pre_set : Stmt,
                     post_set : Stmt,
                     exc_set : Stmt,
                     res : Expr,
                     res_type : JType #]

  % change from original document:
  % superClass is just a name, not a class
  % This avoid that Class is a recursive record definition
  Class : TYPE = [# name : Name,
                    super_class : lift[Name],
                    inv : BoolExpr,
                    ghost_vars : finite_set[GhostVarDecl],
                    fields : list[FieldDecl],
                    methods : finite_set[Method] #]

  Program : TYPE = [# classes : finite_set[Class] #]

END Program
