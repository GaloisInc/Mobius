% NOTE: Bottom is used to model the partiality of Store. We may define Store as
% Store(ns : set[Name]) : TYPE [{n : Name | ns(n)} -> Val], but then the names
% for which it is defined will be in the type. That would be inconvenient,
% specially for programs, which have three stores (and the values for which lvs
% is defined change over time).
% Do not confuse Bottom (a Val) with bottom, a constructor of the lift datatype
Val[Name : TYPE+] : DATATYPE 
BEGIN

  Bool(b : bool) : Bool?
  Bottom : Bottom?    % undefined value
  Int(i : int) : Int?
  Null : Null?
  % a is the memory address and class_name is the dynamic type of the object
  Reference(a : int, class_name : Name) : Reference?
  Unit : Unit?        % dummy value returned by void functions


END Val


ValProp[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Val[Name], JType

  defined?(v : Val) : boolean = NOT Bottom?(v)

  default_value(t : JType) : (defined?) =
    CASES t OF
      IntType : Int(0),
      BoolType : Bool(FALSE),
      Void : Unit,
      RefType : Null
    ENDCASES

  welltyped?(v : Val, t : JType) : boolean =
    CASES v OF
      Bool(b) : t = BoolType,
      Bottom : TRUE,
      Int(i) : t = IntType,
      Null : t = RefType,
      Reference(a, c) : t = RefType,
      Unit : t = Void
    ENDCASES

END ValProp

