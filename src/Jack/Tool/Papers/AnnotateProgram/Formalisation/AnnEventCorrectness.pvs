AnnEventPreservesMPModeled[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    IMPORTING ValProp[Name]

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

  ENDASSUMING


  IMPORTING RelatedStatesProperties[CP, Name],
            APSemanticsProperties,
            listfuncs

  mp : VAR (wf_and_complete_MP)


  % Preservation of MP_modeled by the new set annotations that are generated
  % to capture the transition of the MVA

  % Executing an action <a> in the MVA modifies the MVA variables 
  % in the same way as the execution of the annotations in the annotated
  % program representing <a> (ann_action(a)) modifies the ghost variables 
  % corresponding to the MVA variables. 
  % Thus: If MP_modeled? holds for the initial states, it also
  % holds for the final states
  % NOTE: For proof-technical reasons, we generalise the theorem over 
  % action <a>. This allows to apply induction on <a>.
  ann_action_preserves_MP_modeled : LEMMA % :-)
    FORALL (t : Transition, a : Action, n : nat)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      wf_state(mp)(sMP1) IMPLIES
      wf_state(ann_program(mp))(sAP1) IMPLIES
      MP_modeled?(mp)(sMP1, sAP1) IMPLIES
      a = action(t) IMPLIES
      wf_Action(mva(mp))(a) IMPLIES
      (EXISTS (t1 : Transition) : 
         ts(mva(mp))(t1) AND suffix(action(t), action(t1))) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))(ann_action(a), sAP1, Unit, sAP2)(n) IMPLIES
      sMP2 = (# astate := (# cp := cp(astate(sMP1)),
                             stA := execute_action(a)(stA(astate(sMP1)),
                                                          fvs(st(pstate(sMP1))))
                           #),
                stuck := stuck(sMP1),
                pstate := pstate(sMP1),
                gvs := gvs(sMP1) #) IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

  % Executing a transition <t> in the MVA modifies the MVAState in the same
  % way as the execution of the representation of this transition in the 
  % annotated program (update_vars(t)) modifies the annotated program state.
  % Thus: if the initial states are related, then the final states are related.
  update_vars_preserves_MP_modeled : LEMMA % :-)
    FORALL (t : Transition, n : nat)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      ts(mva(mp))(t) IMPLIES
      sMP2 = (# astate := (# cp := tcp(t),
                             stA := execute_action(action(t))(stA(astate(sMP1)),
                                                              fvs(st(pstate(sMP1))))
                           #),
                stuck := stuck(sMP1),
                pstate := pstate(sMP1),
                gvs := gvs(sMP1) #) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))(update_vars(mp)(t), sAP1, Unit, sAP2)(n) IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

  % Executing a transition for event <et> and method <m> (i.e. 
  % on_method_MVA(et)(mp, m)) in the monitored program modifies the
  % state in the same way as the annotations representing this automaton
  % step in the annotated program (ann_event(filter_event(et), m)).
  % Notice that ann_event does not verify whether halted is reached, thus
  % it will not throw a JMLException.
  % Therefore: if initial states sMP1 and sAP1 are related stated, 
  % then the final states sMP2 and sAP2 are related by MP_modeled?. 
  ann_event_preserves_MP_modeled : LEMMA % :-)
    FORALL (m : (wf_Method(program(mp))), et : EventType,  n : nat)
           (v : ValOrExcpt, sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      methods(get_monitored_class(mp))(m) IMPLIES
      sMP2 = on_method_MVA(et)(mp, m)(v)(sMP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))
        (ann_event(mp)(filter_event(mva(mp))(et)(name(m)))(v),
                              sAP1, Unit, sAP2)(n) IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

  % ann_event does not throw an exception and it returns the value Unit
  ann_event_does_not_throw_exception : LEMMA % :-)
    FORALL (m : (wf_Method(program(mp))), et : EventType,  v : Val, n : nat)
           (arg : ValOrExcpt, sAP1, sAP2 : APState) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))
            (ann_event(mp)(filter_event(mva(mp))(et)(name(m)))(arg),
            sAP1, v, sAP2)(n) IMPLIES
        NOT up?(ex(pstate(sAP2))) AND v = Unit


END AnnEventPreservesMPModeled
