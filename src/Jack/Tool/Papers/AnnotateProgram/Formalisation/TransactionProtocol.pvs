TransactionProtocol : THEORY
BEGIN

  CP : TYPE

  IMPORTING WellFormedMVA[CP, string],
            Semantics

%  EXPORTING transaction_protocol

  % Control points
  no_trans, in_trans : CP

  cps : set[CP] = {q : CP | q = no_trans OR q = in_trans}

  % Events
  bt_called : Event = (# etype := Entry, mname := "beginTransaction" #)

  at_called : Event = (# etype := Entry, mname := "abortTransaction" #)

  ct_called : Event = (# etype := Entry, mname := "commitTransaction" #)

  evs : set[Event] = {e : Event | 
    e = bt_called OR e = at_called OR e = ct_called }

  % OneActions
  inc_T : OneAction = (# target := "T", 
                         source := NExpr(Plus(NumVarEval("T"), Int(1))) #)

  dec_T : OneAction = (# target := "T", 
                         source := NExpr(Minus(NumVarEval("T"), Int(1))) #)

  % MVA Variables
  T_VarDecl : MVAVarDecl = (# name := "T", jtype := IntType, init_val := Int(0) #)

  vdsA : set[MVAVarDecl] = singleton(T_VarDecl)

  % Program Variables
  vdsP : set[ProgVarDecl] = emptyset

  % Guards
  T_is_one : Guard = 
    LAMBDA (stA : Store, stP : PSt) : val2int(stA("T")) = 1

  T_gt_one : Guard = 
    LAMBDA (stA : Store, stP : PSt) : val2int(stA("T")) > 1

  TRUE_guard : Guard = 
    LAMBDA (stA : Store, stP : PSt) : TRUE

  % Transitions
  t1 : Transition = (# scp := no_trans,
                       event := bt_called,
                       guard := TRUE_guard,
                       action := (: inc_T :),
                       tcp := in_trans #)

  t2 : Transition = (# scp := in_trans,
                       event := bt_called,
                       guard := TRUE_guard,
                       action := (: inc_T :),
                       tcp := in_trans #)

  t3 : Transition = (# scp := in_trans,
                       event := at_called,
                       guard := T_gt_one,
                       action := (: dec_T :),
                       tcp := in_trans #)

  t4 : Transition = (# scp := in_trans,
                       event := ct_called,
                       guard := T_gt_one,
                       action := (: dec_T :),
                       tcp := in_trans #)

  t5 : Transition = (# scp := in_trans,
                       event := at_called,
                       guard := T_is_one,
                       action := (: dec_T :),
                       tcp := no_trans #)

  t6 : Transition = (# scp := in_trans,
                       event := at_called,
                       guard := T_is_one,
                       action := (: dec_T :),
                       tcp := no_trans #)

  ts : set[Transition] = {t : Transition |  
    t = t1 OR t = t2 OR t = t3 OR t = t4 OR t = t5 OR t = t6}


  % MVA
  transaction_protocol : MVA =
    (# name := "transaction_protocol",
       class_name := "Transactions.java",
       cps := cps,
       init_cp := no_trans,
       evs := evs,
       vdsA := vdsA,
       vdsP := vdsP,
       ts := ts
    #)

  % well-formedness proofs
  wf_inc_T : LEMMA wf_Action(transaction_protocol)((: inc_T :)) % :-)

  wf_dec_T : LEMMA wf_Action(transaction_protocol)((: dec_T :)) % :-)

  wf_T_gt_one : LEMMA wf_Guard(transaction_protocol)(T_gt_one) % :-)

  wf_T_is_one : LEMMA wf_Guard(transaction_protocol)(T_is_one) % :-)

  transaction_protocol_is_well_formed : LEMMA % :-)
    wf_MVA(transaction_protocol)


END TransactionProtocol
