State[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Excpt,
            WellFormedProgram[Name],
            Val,
            ValProp

  % A store is a mapping from names to values. Undefined locations map to 
  % the value Bottom
  Store : TYPE = [Name -> Val]

  update_store(n : Name, v : Val)(s : Store) : Store =
    s WITH [n := v]

  % PSt: Fields and local variables
  PSt : TYPE = [# fvs, lvs : Store #]

  % A program state contains PSt (fields + local variables) +
  % exception state (bottom = no exception)
  PState : TYPE = [# ex : lift[Excpt],
                     st : PSt #]

  % convenience functions

  % is vn local variable?
  is_local(vn : Name, sigma : PState) : boolean =
    defined?(lvs(st(sigma))(vn)) 

  % is vn field?
  is_field(vn : Name, sigma : PState) : boolean =
    defined?(fvs(st(sigma))(vn))

  % lookup local variable vn
  lookup_local(vn : Name, sigma : PState) : Val =
    lvs(st(sigma))(vn)

  % lookup field vn
  lookup_field(vn : Name, sigma : PState) : Val =
    fvs(st(sigma))(vn)

  % update local variable vn to v
  update_local(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)),
                lvs := lvs(st(sigma)) WITH [vn := v] #) #)

  % update set of local variables V
  update_locals(V : finite_set[[Name, Val]])(sigma : PState) : 
               RECURSIVE PState =
    IF empty?(V)
    THEN sigma
    ELSE LET x = choose(V) IN
         update_locals(rest(V))(update_local(x)(sigma))
    ENDIF
  MEASURE card(V)

  % update field vn to v
  update_field(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)) WITH [vn := v],
                lvs := lvs(st(sigma)) #) #)


  % lookup variable vn, vn could be local or field
  lookup(vn : Name, sigma : PState) : Val =
    IF is_local(vn, sigma)
    THEN lookup_local(vn, sigma)
    ELSE lookup_field(vn, sigma)
    ENDIF

  % update variable vn to v, vn could be local or field
  update(vn : Name, v : Val)(sigma : PState) : PState =
    IF is_local(vn, sigma)
    THEN update_local(vn, v)(sigma)
    ELSIF is_field(vn, sigma)
    THEN update_field(vn, v)(sigma)
    ELSE sigma
    ENDIF

  % set exception exc, i.e., raise exception
  raise(exc : Excpt)(sigma : PState) : PState =
    sigma WITH [ex := up(exc)]

  % set exception state to bottom, i.e., catch exception
  catch(sigma : PState) : PState =
    sigma WITH [ex := bottom]

  % unpack integer value from Int value
  val2int(v : Val) : int =
    IF Int?(v)
    THEN i(v)
    ELSE 0
    ENDIF

  % unpack boolean value from Bool value
  val2bool(v : Val) : bool =
    IF Bool?(v)
    THEN b(v)
    ELSE FALSE
    ENDIF

  % initial program state:
  % all declared fields are set to their initial values
  % all declared local variables are set to default value of their type
  % all undeclared variable names map to Bottom
  % ex = bottom, i.e., state is normal
  initial_Program_state(p : Program)(this_val : Val) : PState =
    (# ex := bottom,
       st :=
         (# fvs := LAMBDA (n : Name) :
              LET fd = get_FieldDecl(n, p) IN
              IF bottom?(fd)
              THEN Bottom
              ELSE init_val(down(fd))
              ENDIF,
            lvs := LAMBDA (n : Name) :
              IF n = This
              THEN this_val
              ELSE LET ld = get_LocalDecl(n, p) IN
              IF bottom?(ld)
              THEN Bottom
              ELSE default_value(jtype(down(ld)))
              ENDIF
              ENDIF
         #)
    #)


  % Well formed state definition:
  % all declared fields have a defined value,
  % all local fields, including This have a defined value
  wf_state(p : Program)(s : PState) : boolean =
    FORALL (vn : Name) :
      (is_field(vn, s) IFF var_names(getFieldDecls(p))(vn)) AND
      (is_local(vn, s) IFF (var_names(getLocalDecls(p))(vn) OR vn = This))


  % Well formed state properties

  % initial states are wellformed
  wf_initial_Program_state : LEMMA % :-)
    FORALL (p : Program)(this_val : (defined?)) :
      wf_Program(p) IMPLIES wf_state(p)(initial_Program_state(p)(this_val))

  % in wellformed state, local variables are not fields and vice versa
  % (since declared fields and local variables are disjoint)
  wf_state_vars_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : PState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
        ((is_field(vn, s) IMPLIES NOT is_local(vn, s)) AND
         (is_local(vn, s) IMPLIES NOT is_field(vn, s)))

  % wf_state preserved by update_local
  wf_state_update_local : LEMMA % :-)
    FORALL(p : Program, s : PState, vn : Name, v : (defined?)) :
      wf_state(p)(s) IMPLIES
      is_local(vn, s) IMPLIES
        wf_state(p)(update_local(vn, v)(s))

  IMPORTING WF_Card[[Name, Val]]

  % wf_state preserved by update_locals
  wf_state_update_locals : LEMMA % :-)
    FORALL(p : Program, s : PState, V : finite_set[[Name, Val]]) :
      wf_state(p)(s) IMPLIES
      (FORALL(v : [Name, Val]) : 
         V(v) IMPLIES is_local(proj_1(v), s) AND
                      defined?(proj_2(v))) IMPLIES
        wf_state(p)(update_locals(V)(s))

            
  IMPORTING finite_sets@finite_sets_inductions[[Name, Val]]

  % exception state not affected by update_locals
  ex_update_locals : LEMMA % :-)
    FORALL(s : PState, V : finite_set[[Name, Val]]) :
      ex(update_locals(V)(s)) = ex(s)

  % fields not affected by update_locals
  fvs_update_locals : LEMMA % :-)
    FORALL(s : PState, V : finite_set[[Name, Val]]) :
      fvs(st(update_locals(V)(s))) = fvs(st(s))


  % update_locals in equal program state result in equal states
  st_update_locals : LEMMA % :-)
    FORALL(s1, s2 : PState, V : finite_set[[Name, Val]]) :
      st(s1) = st(s2) IMPLIES
        st(update_locals(V)(s1)) = st(update_locals(V)(s2))

  % if V only contains defined values, then defined after update_locals
  % if defined before, or if in V
  defined?_update_locals : LEMMA % :-)
    FORALL(s : PState, V : finite_set[[Name, Val]], n : Name) :
      (FORALL(x : [[Name, Val]]) : V(x) IMPLIES defined?(proj_2(x))) IMPLIES
        defined?(lvs(st(update_locals(V)(s)))(n)) = 
          (defined?(lvs(st(s))(n)) OR EXISTS (v : Val) : V(n,v))

  % local variable n equal after update_locals if in V, or if equal before
  lvs_update_locals : LEMMA % :-)
    FORALL(s1, s2 : PState, V : finite_set[[Name, Val]], n : Name) :
      (lvs(st(s1))(n) = lvs(st(s2))(n) OR
       EXISTS (v : Val) : V(n,v)) IMPLIES
      lvs(st(update_locals(V)(s1)))(n) = lvs(st(update_locals(V)(s2)))(n)

  % wf_state preserved by update
  wf_state_update : LEMMA % :-) 
    FORALL(p : Program, s : PState, vn : Name, v : (defined?)) :
      wf_state(p)(s) IMPLIES
        wf_state(p)(update(vn, v)(s))

  % wf_state preserved by raising exception
  wf_state_raise : LEMMA % :-)
    FORALL(p : Program, s : PState, exc : Excpt) :
      wf_state(p)(s) IMPLIES
        wf_state(p)(raise(exc)(s))

  % wf_state preserved by catching exception
  wf_state_catch : LEMMA % :-)
    FORALL(p : Program, s : PState) :
      wf_state(p)(s) IMPLIES
        wf_state(p)(catch(s))

  % in wf_state, formal parameter of method is local variable
  wf_state_arg_is_local : LEMMA % :-)
    FORALL(p : Program, s : PState, c : Class, m : Method) :
      wf_state(p)(s) IMPLIES
      classes(p)(c) IMPLIES
      methods(c)(m) IMPLIES
        is_local(name(arg(m)), s)

  % wf_store wrt set V: exactly all vn in V are defined in store s
  wf_store(s : Store)(V : finite_set[Name]) : boolean =
    FORALL(vn : Name) : defined?(s(vn)) IFF V(vn)

  % wf_store preserved by update_store
  update_yields_wf_store : LEMMA % :-)
    FORALL (st : Store, n : Name, v : (defined?), V : finite_set[Name]) :
      wf_store(st)(V) IMPLIES
        V(n) IMPLIES
        wf_store(update_store(n, v)(st))(V)
 
  % wf_store can be used to state alternative definition of wf_state
  % main interest is that it is also used to describe wellformed state of MVA
  wf_state_alternative_def : LEMMA % :-)
    FORALL(p : Program, s : PState) :
      wf_state(p)(s) =
        (wf_store(fvs(st(s)))(var_names(getFieldDecls(p))) AND
         wf_store(lvs(st(s)))(add(This, var_names(getLocalDecls(p)))))


END State
