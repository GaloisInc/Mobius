State[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Excpt,
            WellFormedProgram[Name],
            Val,
            ValProp

  % A store is a mapping from names to values. Partial mappings are represented
  % using the value Bottom.
  Store : TYPE = [Name -> Val]

  update_store(n : Name, v : Val)(s : Store) : Store =
    s WITH [n := v]

  % Field and local variables.
  PSt : TYPE = [# fvs, lvs : Store #]

  PState : TYPE = [# ex : lift[Excpt],
                     st : PSt #]

  is_local(vn : Name, sigma : PState) : boolean =
    defined?(lvs(st(sigma))(vn)) 

  is_field(vn : Name, sigma : PState) : boolean =
    defined?(fvs(st(sigma))(vn))

  lookup_local(vn : Name, sigma : PState) : Val =
    lvs(st(sigma))(vn)

  lookup_field(vn : Name, sigma : PState) : Val =
    fvs(st(sigma))(vn)

  update_local(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)),
                lvs := lvs(st(sigma)) WITH [vn := v] #) #)

  update_locals(V : finite_set[[Name, Val]])(sigma : PState) : 
               RECURSIVE PState =
    IF empty?(V)
    THEN sigma
    ELSE LET x = choose(V) IN
         update_locals(rest(V))(update_local(x)(sigma))
    ENDIF
  MEASURE card(V)

  update_field(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)) WITH [vn := v],
                lvs := lvs(st(sigma)) #) #)


  lookup(vn : Name, sigma : PState) : Val =
    IF is_local(vn, sigma)
    THEN lookup_local(vn, sigma)
    ELSE lookup_field(vn, sigma)
    ENDIF

  update(vn : Name, v : Val)(sigma : PState) : PState =
    IF is_local(vn, sigma)
    THEN update_local(vn, v)(sigma)
    ELSIF is_field(vn, sigma)
    THEN update_field(vn, v)(sigma)
    ELSE sigma
    ENDIF

  raise(exc : Excpt)(sigma : PState) : PState =
    sigma WITH [ex := up(exc)]

  catch(sigma : PState) : PState =
    sigma WITH [ex := bottom]

  val2int(v : Val) : int =
    IF Int?(v)
    THEN i(v)
    ELSE 0
    ENDIF

  val2bool(v : Val) : bool =
    IF Bool?(v)
    THEN b(v)
    ELSE FALSE
    ENDIF

  initial_Program_state(p : Program)(this_val : Val) : PState =
    (# ex := bottom,
       st :=
         (# fvs := LAMBDA (n : Name) :
              LET fd = get_FieldDecl(n, p) IN
              IF bottom?(fd)
              THEN Bottom
              ELSE init_val(down(fd))
              ENDIF,
            lvs := LAMBDA (n : Name) :
              IF n = This
              THEN this_val
              ELSE LET ld = get_LocalDecl(n, p) IN
              IF bottom?(ld)
              THEN Bottom
              ELSE default_value(jtype(down(ld)))
              ENDIF
              ENDIF
         #)
    #)

  % Well formed state definition
  wf_state(p : Program)(s : PState) : boolean =
    FORALL (vn : Name) :
      (is_field(vn, s) IFF var_names(getFieldDecls(p))(vn)) AND
      (is_local(vn, s) IFF (var_names(getLocalDecls(p))(vn) OR vn = This)) 


  % Well formed state properties

  wf_initial_Program_state : LEMMA % :-)
    FORALL (p : Program)(this_val : (defined?)) :
      wf_Program(p) IMPLIES wf_state(p)(initial_Program_state(p)(this_val))

  wf_state_vars_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : PState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
        ((is_field(vn, s) IMPLIES NOT is_local(vn, s)) AND
         (is_local(vn, s) IMPLIES NOT is_field(vn, s)))

  wf_state_update_local : LEMMA % :-)
    FORALL(p : Program, s : PState, vn : Name, v : (defined?)) :
      wf_state(p)(s) IMPLIES
      is_local(vn, s) IMPLIES
        wf_state(p)(update_local(vn, v)(s))

%  AT: Check that the following import is not needed
%  IMPORTING FiniteSetInduction[[Name, Val]]

  % FIXME
  wf_state_update_locals : LEMMA %
    FORALL(p : Program, s : PState, V : finite_set[[Name, Val]]) :
      wf_state(p)(s) IMPLIES
      (FORALL(v : [Name, Val]) : 
         V(v) IMPLIES is_local(proj_1(v), s) AND
                      defined?(proj_2(v))) IMPLIES
        wf_state(p)(update_locals(V)(s))

  wf_state_update : LEMMA % :-) 
    FORALL(p : Program, s : PState, vn : Name, v : (defined?)) :
      wf_state(p)(s) IMPLIES
        wf_state(p)(update(vn, v)(s))


  wf_state_raise : LEMMA % :-)
    FORALL(p : Program, s : PState, exc : Excpt) :
      wf_state(p)(s) IMPLIES
        wf_state(p)(raise(exc)(s))

  wf_state_catch : LEMMA % :-)
    FORALL(p : Program, s : PState) :
      wf_state(p)(s) IMPLIES
        wf_state(p)(catch(s))


  wf_state_arg_is_local : LEMMA % :-)
    FORALL(p : Program, s : PState, c : Class, m : Method) :
      wf_state(p)(s) IMPLIES
      classes(p)(c) IMPLIES
      methods(c)(m) IMPLIES
        is_local(name(arg(m)), s)

END State
