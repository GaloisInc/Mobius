CompleteMonitor[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgramSemantics[CP, Name],
            MVACompletion[CP, Name]

  mp : VAR (wf_and_partial_MP)

  complete_MP(mp) : MonitoredProgram =
    (# mva := complete_MVA(mva(mp)),
       program := program(mp) #)

  complete_MP_wf_and_complete : JUDGEMENT % :-)
    complete_MP(mp) HAS_TYPE (wf_and_complete_MP)
  

  complete_MP_preserves_wf_body : LEMMA
    FORALL (b : (wf_Body(program(mp)))) : % :-)
      wf_Body(program(complete_MP(mp)))(b)

  complete_MP_preserves_wf_method : LEMMA % :-)
    FORALL (m : (wf_Method(program(mp)))) :
      wf_Method(program(complete_MP(mp)))(m)


  monitor_related_astates(sA1, sA2 : AState, stuck1 : boolean) : boolean =
    IF stuck1 THEN cp(sA2) = halted ELSE cp(sA1) = cp(sA2) ENDIF AND
    stA(sA1) = stA(sA2)


  monitor_related_states(mp)(s1, s2 : MPState) : boolean =
    monitor_related_astates(astate(s1), astate(s2), stuck(s1)) AND
    NOT stuck(s2) AND
    wf_state(mp)(s1) AND
    wf_state(complete_MP(mp))(s2) AND
    pstate(s1) = pstate(s2) AND
    gvs(s1) = gvs(s2)

  monitor_related_astates_consequence : LEMMA % :-)
    FORALL(s1, s2 : MPState) :
    monitor_related_states(mp)(s1, s2) IMPLIES
      (stuck(s1) IFF cp(astate(s2)) = halted)

  existence_state_partial_monitor : LEMMA % :-)
    FORALL(s : MPState) :
      wf_state(complete_MP(mp))(s) IMPLIES
      NOT stuck(s) IMPLIES
      EXISTS (s1 : MPState) : monitor_related_states(mp)(s1, s)

  get_address_same_in_monitor_related_states : LEMMA % :-)
    FORALL(vn : Name, s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        get_address(vn, s1) = get_address(vn, s2)

  get_dynamic_type_name_same_in_monitor_related_states : LEMMA % :-)
    FORALL(vn : Name, s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        get_dynamic_type_name(vn, s1) = get_dynamic_type_name(vn, s2)


  monitor_related_states_implies_same_exception : LEMMA % :-)
    FORALL (s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES 
        ex(pstate(s1)) = ex(pstate(s2))

  monitor_related_states_implies_same_lookup : LEMMA % :-)
    FORALL (s1, s2 : MPState, n : Name) :
      monitor_related_states(mp)(s1, s2) IMPLIES 
        lookup(n, s1) = lookup(n, s2)

  monitor_related_states_preserved_by_update_local : LEMMA % :-)
    FORALL (s1, s2 : MPState)(vn : Name, v : (defined?)) :
      monitor_related_states(mp)(s1, s2) IMPLIES
      is_local(vn, pstate(s2)) IMPLIES
        monitor_related_states(mp)(update_PState(s1, update_local(vn, v)), 
                               update_PState(s2, update_local(vn, v)))

  monitor_related_states_preserved_by_catch : LEMMA % :-)
    FORALL (s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        monitor_related_states(mp)(update_PState(s1, catch), 
                               update_PState(s2, catch))

  monitor_related_states_preserved_by_raise : LEMMA % :-)
    FORALL (s1, s2 : MPState, e : Excpt) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        monitor_related_states(mp)(update_PState(s1, raise(e)), 
                               update_PState(s2, raise(e)))

  monitor_related_states_preserved_by_update_stack : LEMMA % :-)
    FORALL (sMP1, sMP2 : MPState,
            this_val : Val, arg :  (getLocalDecls(program(mp))), 
            param_val : Val, lvds : finite_set[Decl]) :
      monitor_related_states(mp)(sMP1, sMP2) IMPLIES
      (FORALL (l : Decl) : lvds(l) IMPLIES 
                                   getLocalDecls(program(mp))(l)) IMPLIES
        monitor_related_states(mp)(update_stack(this_val, arg, param_val,
                                                lvds, sMP1),
                                   update_stack(this_val, arg, param_val,
                                                lvds, sMP2))

  monitor_related_astates_preserved_by_on_method_MVA : LEMMA % :-)
    FORALL(s1, s2 : MPState, etype : EventType,
           md : (wf_Method(program(mp))), arg : ValOrExcpt) :
      monitor_related_astates(astate(s1), astate(s2), stuck(s1)) IMPLIES
      wf_state(mp)(s1) IMPLIES
      wf_state(complete_MP(mp))(s2) IMPLIES
      pstate(s1) = pstate(s2) IMPLIES
      NOT stuck(s2) IMPLIES
        monitor_related_astates
          (astate(on_method_MVA(etype)(mp, md)(arg)(s1)), 
           astate(on_method_MVA(etype)(complete_MP(mp), md)(arg)(s2)),
           stuck(on_method_MVA(etype)(mp, md)(arg)(s1)))

  monitor_related_states_initial_MP_states : LEMMA  % :-)
    FORALL (root_object : (defined?)) :
    monitor_related_states(mp)(initial_MP_state(mp)(root_object), 
                           initial_MP_state(complete_MP(mp))(root_object))

  monitor_related_states_preserved_by_derive : LEMMA % :-)
    FORALL (b : (wf_Body(program(mp))), v1, v2 : Val)
           (s1a, s1b, s2a, s2b : MPState) 
           (n1, n2 : nat) :
      monitor_related_states(mp)(s1a, s1b) IMPLIES
      derive(mp)(b, s1a, v1, s2a)(n1) IMPLIES
      derive(complete_MP(mp))(b, s1b, v2, s2b)(n2) IMPLIES
        monitor_related_states(mp)(s2a, s2b) AND v1 = v2 


 monitor_related_states_implies_derive : LEMMA % :-)
   FORALL (b : (wf_Body(program(mp))), v : Val)
          (s1a, s1b, s2a : MPState) 
          (n1 : nat) :
     monitor_related_states(mp)(s1a, s1b) IMPLIES
     derive(mp)(b, s1a, v, s2a)(n1) IMPLIES
     EXISTS (s2b : MPState, n2 : nat) : 
     derive(complete_MP(mp))(b, s1b, v, s2b)(n2) 

 monitor_related_states_implies_derive_converse : LEMMA % :-)
   FORALL (b : (wf_Body(program(mp))), v : Val)
          (s1a, s1b, s2a : MPState) 
          (n1 : nat) :
     monitor_related_states(mp)(s1b, s1a) IMPLIES
     derive(complete_MP(mp))(b, s1a, v, s2a)(n1) IMPLIES
     EXISTS (s2b : MPState, n2 : nat) : 
     derive(mp)(b, s1b, v, s2b)(n2)
 

 % Correctness of the first step of the translation
 correctness_of_complete_MP : THEOREM % :-)
   FORALL (main : Name, arg : int)(root_object : (defined?))
          (s1, s2 : MPState) :
     run_monitored_program(mp)(main, arg)(root_object)(s1) IMPLIES
     EXISTS (s2 : MPState) : 
       run_monitored_program(complete_MP(mp))(main, arg)(root_object)(s2) AND
       monitor_related_states(mp)(s1, s2)

 correctness_of_complete_MP_converse : THEOREM % :-)
   FORALL (main : Name, arg : int)(root_object : (defined?))
          (s1, s2 : MPState) :
     run_monitored_program(complete_MP(mp))(main, arg)(root_object)(s1) 
     IMPLIES
     EXISTS (s2 : MPState) : 
       run_monitored_program(mp)(main, arg)(root_object)(s2) AND
       monitor_related_states(mp)(s2, s1)


END CompleteMonitor
