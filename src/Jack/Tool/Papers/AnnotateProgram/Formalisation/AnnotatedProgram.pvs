AnnotatedProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name]

  APState : TYPE = [# gvs : Store, pstate : PState #]
%  APState : TYPE = PState WITH [# gvs : Store #]

  IMPORTING SemanticsTypes[Name, Program, APState,
                           LAMBDA (s : APState) : pstate(s)],
            SemanticsJMLTypes[Name, APState, LAMBDA (s : APState) : gvs(s)]

  update_PState : (update_PState_type) = 
    LAMBDA (s : APState, upd : [PState -> PState]) :     
      s WITH [pstate := upd(pstate(s))]

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : APState, upd : [Store -> Store])  : 
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, Program, APState, id,
                         LAMBDA (s : APState) : pstate(s),
                         update_PState,
                         LAMBDA (s : APState) : gvs(s),
                         update_GhostVars],
            Semantics[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  wf_state(p : Program)(sigma : APState) : boolean =
    wf_state(p)(pstate(sigma)) AND
    wf_ghoststate(p)(sigma)

  initial_AP_state(p : Program)(this_val : Val) : APState =
    (# pstate := initial_Program_state(p)(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, p) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_annotated_program(p : Program)(main : Method, arg : int)
                       (this_val : Val)(final : APState) : boolean =
    run_FullProgram(p)(main, arg)(initial_AP_state(p)(this_val), final)


  IMPORTING SemanticsProofs[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]


  % Well-formedness properties

  wf_state_vars_tricotomy : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      declared_var_names(p)(vn) IMPLIES
        is_ghost(vn, s) OR
        is_field(vn, pstate(s)) OR
        is_local(vn, pstate(s))

  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
      is_ghost(vn, s) IMPLIES 
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))

   wf_update_PState : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(p)(pstate(s1)) IMPLIES wf_state(p)(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  wf_state_update_stack : LEMMA % :-)
    FORALL(p : Program, this_val : Val, arg : (getLocalDecls(p)), 
           param_val : Val, lvds : finite_set[LocalVarDecl], s : APState) : 
      wf_state(p)(s) IMPLIES
      (FORALL (l : LocalVarDecl) : lvds(l) IMPLIES getLocalDecls(p)(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  wf_initial_AP_state : LEMMA % :-)
    FORALL (p : Program)(this_val : (defined?)) :
      wf_Program(p) IMPLIES wf_state(p)(initial_AP_state(p)(this_val))


%  deriv_expr_yields_wf_state_AP : LEMMA % :-)
%    FORALL (p : Program, e : Expr, v : Val)
%           (sigma1, sigma2 : APState, n : nat) :
%      wf_Program(p) IMPLIES
%      (FORALL (c : Stmt)(tau1, tau2 : APState)(m : below(n)) :
%          wf_state(p)(tau1) IMPLIES
%          deriv_stmt(p)(c, tau1, tau2)(m) IMPLIES
%            wf_state(p)(tau2)) IMPLIES
%      wf_state(p)(sigma1) IMPLIES
%      deriv_expr(p)(e, sigma1, v, sigma2)(n) IMPLIES
%        wf_state(p)(sigma2)

%  % Proven, but assumption about target of set statements not very nicely 
%  % phrased.
%  deriv_stmt_yields_wf_state_AP : LEMMA % :-)
%    FORALL (p : Program, c : Stmt, sigma1, sigma2 : APState, n : nat) :
%      wf_Program(p) IMPLIES
%      wf_state(p)(sigma1) IMPLIES
%      deriv_stmt(p)(c, sigma1, sigma2)(n) IMPLIES
%        wf_state(p)(sigma2)

  derive_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, b : Body, v : Val)
           (sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
        wf_state(p)(sigma2)


  % The following are adapted versions for AP to avoid having to give all the 
  % theory parameters to uniquely identify them.

 on_method_entry_AP : (on_method_event_type) =
   LAMBDA (p : Program, md : Method, a : Val, s1, s2 : APState, n : nat,
           derive_rec : derive_rec_type(n)) :
   on_method_entry(p, md, a, s1, s2, n, derive_rec)

  determ_step_AP : LEMMA % :-)
    FORALL (p : Program)(n1, n2 : nat)(b : Body)
           (v1, v2 : Val, sigma, sigma1, sigma2 : APState) :
        derive(p)(b, sigma, v1, sigma1)(n1) IMPLIES
        derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
           v1 = v2 AND sigma1 = sigma2 AND n1 = n2

  derive_bottom_iff_exception_step_AP : LEMMA % :-)
    FORALL (p : Program)(b : Body)
           (sigma1, sigma2 : APState, v : Val, n : nat) :
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
      Bottom?(v) = up?(ex(pstate(sigma2)))

  derive_boolean_expr_type_AP : LEMMA % :-)
    FORALL (p : Program)(b : BoolExpr)
           (sigma1, sigma2 : APState, v : Val, n : nat) :
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
      NOT up?(ex(pstate(sigma2))) IMPLIES
      Bool?(v)


END AnnotatedProgramSemantics


APSemanticsProperties[Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            listfuncs

  % Properties of subterms

  proper_subterm_sequence : LEMMA % :-)
    FORALL (c1, c2, c3 : Stmt) :
      Sequence(c1, c2) << c3 IMPLIES 
        c1 << c3 AND c2 << c3

  proper_subterm_set_clause_sequence : LEMMA % :-)
    FORALL (c1, c2 : Stmt, m : Method) :
      proper_subterm_set_clause(Sequence(c1, c2), m) IMPLIES 
        proper_subterm_set_clause(c1, m) AND proper_subterm_set_clause(c2, m)

  stmt_proper_subterm_is_transitive : LEMMA % :-)
    FORALL (c1, c2, c3 : Stmt) :
      c1 << c2 AND c2 << c3 IMPLIES c1 << c3

  % The execution of a set statement that does not have vn as target and whose
  % source expression has no side-effects, does not change the value of vn.
  non_interference_of_set_stmt : LEMMA % :-)
    FORALL (p : Program, c : Stmt, s1, s2 : APState, v : Val, 
            n : nat, vn : Name) :
      Set?(c) AND
      NOT target(c) = vn IMPLIES
      spec_expr_has_no_side_effects(p)(source(c)) IMPLIES
      derive(p)(c, s1, v, s2)(n) IMPLIES
        gvs(s1)(vn) = gvs(s2)(vn)

  % Consider the evaluation of a CaseJML on a non-exceptional state for which 
  % there is a branch b1 whose condition has no side-effects and holds and all
  % the other branches have no side-effect and do not hold. 
  % The state resulting from the evaluation of such CaseJML will be equal to the
  % state after the execution of the statement associated with b1.
  CaseJML_exclusive_branches_semantics : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2, tau : APState,
            v1, v2 : Val, n1, n : nat, b1 : [Expr, Stmt]) :
      NOT up?(ex(pstate(s1))) IMPLIES
      n > 0 IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (derive(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [Expr, Stmt], tau : APState, v : Val, m2 : below(n)) :
        member(b2, bs) IMPLIES
        NOT b1 = b2 IMPLIES
        (derive(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          s1 = tau AND v = Bool(FALSE))) IMPLIES
        derive(p)(PROJ_2(b1), s1, v1, tau)(n1) IMPLIES
        derive(p)(CaseJML(bs), s1, v2, s2)(n) IMPLIES
          s2 = tau

  % TODO: 
  % A CaseJML for which there is a branch b1 that has no side-effects and holds
  % and for which all the branches preceding b1 have no side-effects (and hence
  % do not throw exceptions) and do not hold, will eventually evaluate the
  % statement associated with b1.
  CaseJML_evaluates_true_stmt : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2 : APState, 
            v : Val, n : nat, b1 : [Expr, Stmt]) :
      NOT up?(ex(pstate(s1))) IMPLIES
      n > 0 IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (derive(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [Expr, Stmt], tau : APState, v : Val, m2 : below(n)) :
        member(b2, bs) IMPLIES
        before(b2, b1, bs) IMPLIES
        (derive(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
%          NOT up?(ex(pstate(tau))) AND  % This can be deduced!!
          s1 = tau AND v = Bool(FALSE))) IMPLIES
      derive(p)(CaseJML(bs), s1, v, s2)(n) IMPLIES
        EXISTS (tau : APState, n1 : nat, v1 : Val) : 
          derive(p)(PROJ_2(b1), s1, v1, tau)(n1)


END APSemanticsProperties
