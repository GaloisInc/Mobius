AnnotatedProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name]

  APState : TYPE = [# gvs : Store, pstate : PState #]

  IMPORTING SemanticsTypes[Name, Program, APState,
                           id, LAMBDA (s : APState) : pstate(s)],
            SemanticsJMLTypes[Name, APState, LAMBDA (s : APState) : gvs(s)]

  update_PState : (update_PState_type) = 
    LAMBDA (s : APState, upd : [PState -> PState]) :     
      s WITH [pstate := upd(pstate(s))]

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : APState, upd : [Store -> Store])  : 
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, Program, APState, id,
                         LAMBDA (s : APState) : pstate(s),
                         update_PState,
                         LAMBDA (s : APState) : gvs(s),
                         update_GhostVars],
            Semantics[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  wf_state(p : Program)(sigma : APState) : boolean =
    wf_state(p)(pstate(sigma)) AND
    wf_ghoststate(p)(sigma)

  initial_AP_state(p : Program)(this_val : Val) : APState =
    (# pstate := initial_Program_state(p)(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, p) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  body_has_no_side_effects(p : Program)(b : (wf_Body(p))) : boolean =
    FORALL (s1, s2 : APState, v : Val, n : nat) :
      wf_state(p)(s1) IMPLIES
      derive(p)(b, s1, v, s2)(n) IMPLIES
        s1 = s2

  run_annotated_program(p : Program)(main : Name, arg : int)
                       (this_val : Val)(final : APState) : boolean =
    run_FullProgram(p)(main, arg)(initial_AP_state(p)(this_val), final)


  IMPORTING SemanticsProofs[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]


  % Well-formedness properties

  wf_state_vars_tricotomy : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      ext_declared_var_names(p)(vn) IMPLIES
        is_ghost(vn, s) OR
        is_field(vn, pstate(s)) OR
        is_local(vn, pstate(s))

  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
      is_ghost(vn, s) IMPLIES 
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))

   wf_update_PState : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(p)(pstate(s1)) IMPLIES wf_state(p)(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  wf_state_update_stack : LEMMA % :-)
    FORALL(p : Program, this_val : Val, arg : (getLocalDecls(p)), 
           param_val : Val, lvds : finite_set[LocalVarDecl], s : APState) : 
      wf_state(p)(s) IMPLIES
      (FORALL (l : LocalVarDecl) : lvds(l) IMPLIES getLocalDecls(p)(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  wf_initial_AP_state : LEMMA % :-)
    FORALL (p : Program)(this_val : (defined?)) :
      wf_Program(p) IMPLIES wf_state(p)(initial_AP_state(p)(this_val))


  derive_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, b : (wf_Body(p)), v : Val)
           (sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
        wf_state(p)(sigma2)

  on_method_entry_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, m : (wf_Method(p)), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
        on_method_entry(p, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(p : Program)
               (b : (wf_Body(p)), sigma1 : APState, v : Val, 
                sigma2 : APState)(m : below(k)) :
               derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(p)(sigma2)

  on_method_exit_normal_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, m : (wf_Method(p)), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : APState, n : nat) : 
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
        on_method_exit_normal(p, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(p : Program)
               (b : (wf_Body(p)), sigma1 : APState, v : Val, 
                sigma2 : APState)(m : below(k)) :
               derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES

        wf_state(p)(sigma2)

  on_method_exit_exceptional_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, m : (wf_Method(p)), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : APState, n : nat) : 
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
        on_method_exit_exceptional(p, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(p : Program)
               (b : (wf_Body(p)), sigma1 : APState, v : Val, 
                sigma2 : APState)(m : below(k)) :
               derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(p)(sigma2)


  % The following are adapted versions for AP to avoid having to give all the 
  % theory parameters to uniquely identify them.

  on_method_entry_AP : (on_method_event_type) =
    LAMBDA (p : Program, md : (wf_Method(p)), a : Val, 
            arg : ValOrExcpt, s1, s2 : APState, n : nat,
            derive_rec : derive_rec_type(n)) :
      on_method_entry(p, md, a, arg, s1, s2, n, derive_rec)

  determ_step_AP : LEMMA % :-)
    FORALL (p : Program)(n1, n2 : nat)(b : (wf_Body(p)))
           (v1, v2 : Val, sigma, sigma1, sigma2 : APState) :
      derive(p)(b, sigma, v1, sigma1)(n1) IMPLIES
      derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
        v1 = v2 AND sigma1 = sigma2 AND n1 = n2

  derive_bottom_iff_exception_step_AP : LEMMA % :-)
    FORALL (p : Program)(b : (wf_Body(p)))
           (sigma1, sigma2 : APState, v : Val, n : nat) :
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
      Bottom?(v) = up?(ex(pstate(sigma2)))

%  derive_boolean_expr_type_AP : LEMMA % :-)
%    FORALL (p : Program)(b : (wf_Expr(p)))
%           (sigma1, sigma2 : APState, v : Val, n : nat) :
%      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
%      NOT up?(ex(pstate(sigma2))) IMPLIES
%      Bool?(v)


END AnnotatedProgramSemantics


APSemanticsProperties[Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            listfuncs

  % The execution of a set statement that does not have vn as target and whose
  % source expression has no side-effects, does not change the value of vn.
  non_interference_of_set_stmt : LEMMA % :-)
    FORALL (p : Program, c : (Set?)) 
           (s1, s2 : APState, v : Val, n : nat)
           (vn : Name) :
      wf_Body(p)(c) IMPLIES
      wf_state(p)(s1) IMPLIES
      body_has_no_side_effects(p)(source(c)) IMPLIES
      derive(p)(c, s1, v, s2)(n) IMPLIES
      NOT target(c) = vn IMPLIES
        gvs(s1)(vn) = gvs(s2)(vn)

  % Consider the evaluation of a CaseJML on a non-exceptional state for which
  % there is a branch b1 whose condition has no side-effects and holds, and all
  % the branches before b1 have no side-effect (and hence do not throw exceptions),
  % and do not hold.
  % Then the statement associated with b1 will be eventually evaluated and the
  % resulting state and value (Unit) will be the same as the respective state and
  % value for the whole CaseJML statement.
  CaseJML_exclusive_branches_semantics : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2 : APState,
            v : Val, n : nat, b1 : [(wf_Expr(p)), (wf_Stmt(p))]) :
      wf_Branches(p)(bs) IMPLIES
      NOT up?(ex(pstate(s1))) IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (derive(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [(wf_Expr(p)), (wf_Stmt(p))], tau : APState, 
               v : Val, m2 : below(n)) :
        before(b2, b1, bs) IMPLIES
        (derive(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          s1 = tau AND v = Bool(FALSE))) IMPLIES
        derive(p)(CaseJML(bs), s1, v, s2)(n) IMPLIES
          EXISTS (n1 : nat) :
            derive(p)(PROJ_2(b1), s1, v, s2)(n1)


END APSemanticsProperties
