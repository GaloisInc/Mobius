AnnotatedProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name]

  APState : TYPE = [# gvs : Store, pstate : PState #]

  IMPORTING SemanticsTypes[Name, Program, APState,
                           LAMBDA (s : APState) : pstate(s)],
            SemanticsJMLTypes[Name, APState, LAMBDA (s : APState) : gvs(s)]

  update_PState : (update_PState_type) =
    LAMBDA (s : APState, upd : [PState -> PState]) : 
      IF up?(ex(pstate(s)))
      THEN s
      ELSE s WITH [pstate := upd(pstate(s))]
      ENDIF

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : APState, upd : [Store -> Store]) : 
      IF up?(ex(pstate(s)))
      THEN s
      ELSE s WITH [gvs := upd(gvs(s))]
      ENDIF

  IMPORTING SemanticsJML[Name, Program, APState, id,
                         LAMBDA (s : APState) : pstate(s),
                         update_PState,
                         LAMBDA (s : APState) : gvs(s),
                         update_GhostVars],
            Semantics[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  wf_ghoststate(p : Program)(sigma : APState) : boolean =
    FORALL (vn : Name) :
      is_ghost(vn, sigma) IFF var_names(getGhostDecls(p))(vn)

  wf_state(p : Program)(sigma : APState) : boolean =
    wf_state(p)(pstate(sigma)) AND
    wf_ghoststate(p)(sigma)

  initial_AP_state(p : Program)(this_val : Val) : APState =
    (# pstate := initial_Program_state(p)(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, p) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_annotated_program(p : Program)(main : Method, arg : int)
                       (this_val : Val)(final : APState)(n : nat) : boolean =
    run_FullProgram(p)(main, arg)(initial_AP_state(p)(this_val), final)(n)


  % The following are adapted versions for AP to avoid having to give all the 
  % theory parameters to uniquely identify them

 on_method_entry_AP : (on_method_event_type) =
   LAMBDA (p : Program, md : Method, a : Val, s1, s2 : APState, n : nat,
           deriv_stmt_rec : deriv_stmt_rec_type(n),
           deriv_expr_rec : deriv_expr_rec_type(n)) :
   on_method_entry(p, md, a, s1, s2, n, deriv_stmt_rec, deriv_expr_rec)


  IMPORTING SemanticsProofs[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  stmt_determ_step_AP : LEMMA % :-)
    FORALL (p : Program, n1, n2 : nat, c : Stmt, sigma : APState,
            sigma1, sigma2 : APState) :
        deriv_stmt(p)(c, sigma, sigma1)(n1) AND
        deriv_stmt(p)(c, sigma, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND n1 = n2

  set_subterm_AP(s : Stmt, m : Method) : boolean =
    set_subterm(s, m)


  % Well-formedness properties

  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
      is_ghost(vn, s) IMPLIES 
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))

   wf_update_PState : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(p)(pstate(s1)) IMPLIES wf_state(p)(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  wf_state_update_stack : LEMMA % :-)
    FORALL(p : Program, this_val : (defined?), arg : (getLocalDecls(p)), 
           param_val : (defined?),
           lvds : finite_set[(getLocalDecls(p))], s : APState) : 
      wf_state(p)(s) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  wf_initial_AP_state : LEMMA % :-)
    FORALL (p : Program)(this_val : (defined?)) :
      wf_Program(p) IMPLIES wf_state(p)(initial_AP_state(p)(this_val))


  % TODO: prove!
  deriv_expr_yields_wf_state_AP : LEMMA
    FORALL (p : Program, e : Expr, v : Val)
           (sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      (FORALL (c : Stmt)(tau1, tau2 : APState)(m : below(n)) :
          wf_state(p)(tau1) IMPLIES
          deriv_stmt(p)(c, tau1, tau2)(m) IMPLIES
            wf_state(p)(tau2)) IMPLIES
      wf_state(p)(sigma1) IMPLIES
      deriv_expr(p)(e, sigma1, v, sigma2)(n) IMPLIES
        wf_state(p)(sigma2)

  % TODO: prove!
  deriv_stmt_yields_wf_state_AP : LEMMA
    FORALL (p : Program, c : Stmt, sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
      deriv_stmt(p)(c, sigma1, sigma2)(n) IMPLIES
        wf_state(p)(sigma2)


END AnnotatedProgramSemantics


APSemanticsProperties[Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            listfuncs

  non_interference_of_set_stmt : LEMMA % :-)
    FORALL (p : Program, c : Stmt, s1, s2 : APState, n : nat, vn : Name) :
      Set?(c) AND
      NOT target(c) = vn IMPLIES
      (FORALL (tau1, tau2 : APState, v : Val, n2 : nat) :
        deriv_expr(p)(source(c), tau1, v, tau2)(n2) IMPLIES tau1 = tau2)
      IMPLIES
      deriv_stmt(p)(c, s1, s2)(n) IMPLIES
        gvs(s1)(vn) = gvs(s2)(vn)

  CaseJML_exclusive_branches_semantics : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2, tau : APState,
            n1, n : nat, b1 : [Expr, Stmt]) :
      NOT up?(ex(pstate(s1))) IMPLIES
      n > 0 IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (deriv_expr(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [Expr, Stmt], tau : APState, v : Val, m2 : below(n)) :
        member(b2, bs) IMPLIES
        NOT b1 = b2 IMPLIES
        (deriv_expr(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          s1 = tau AND v = Bool(FALSE))) IMPLIES
        deriv_stmt(p)(PROJ_2(b1), s1, tau)(n1) IMPLIES
        deriv_stmt(p)(CaseJML(bs), s1, s2)(n) IMPLIES
          s2 = tau

  CaseJML_evalueates_true_stmt : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2 : APState, n : nat,
            b1 : [Expr, Stmt]) :
      NOT up?(ex(pstate(s1))) IMPLIES
      n > 0 IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (deriv_expr(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [Expr, Stmt], tau : APState, v : Val, m2 : below(n)) :
        member(b2, bs) IMPLIES
        before(b2, b1, bs) IMPLIES
        (deriv_expr(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          NOT up?(ex(pstate(tau))) AND
          s1 = tau AND v = Bool(FALSE))) IMPLIES
      deriv_stmt(p)(CaseJML(bs), s1, s2)(n) IMPLIES
        EXISTS (tau : APState, n1 : nat) : 
          deriv_stmt(p)(PROJ_2(b1), s1, tau)(n1)


END APSemanticsProperties
