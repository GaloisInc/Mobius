MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name],
            WellFormedProgram[Name]

  MonitoredProgram : TYPE =
    [# mva : MVA[CP, Name],
       program : Program[Name]
    #]

  % NOTE: We restrict ourselves to the case where the automaton monitors at least
  % one of the classes of the program.
  % Requirements:
  % Variables in vdsP must be fields in the program
  % Every method mentioned in the events must be in the class
  compatible(mp : MonitoredProgram) : boolean =  
    LET a = mva(mp), p = program(mp) IN
    EXISTS (c : Class) :
      classes(p)(c) AND 
      name(c) = class_name(a) AND
      (FORALL (v : ProgVarDecl) :
        vdsP(a)(v) IMPLIES
          EXISTS (fd : FieldDecl) : fields(c)(fd) AND name(v) = name(fd)) AND
      (FORALL (ev : Event, n : Name) :
        evs(a)(ev) IMPLIES
        mname(ev) = n IMPLIES
          EXISTS (m : Method) : methods(c)(m) AND name(m) = n)

  % Syntactic constraints on MPs
  wf_MP(mp : MonitoredProgram) : boolean =
    wf_MVA(mva(mp)) AND
    wf_Program(program(mp)) AND
    compatible(mp)


END MonitoredProgram


% The semantics of MonitoredPrograms assumes that the program is annotated, thus
% this can be thought as MonitoredAnnotatedProgramSemantics
MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            MVASemantics[CP, Name]

  % Monitored Program State
  MPState : TYPE =
    [# astate : AState[CP, Name],
       pstate : PState[Name],
       gvs : Store
    #]

  IMPORTING SemanticsTypes[Name, MonitoredProgram, MPState, 
                           LAMBDA (s : MPState) : pstate(s)],
            SemanticsJMLTypes[Name, MPState, LAMBDA (s : MPState) : gvs(s)]

  update_PState : (update_PState_type) =
    LAMBDA (s : MPState, upd : [PState -> PState]) : 
      s WITH [pstate := upd(pstate(s))]

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : MPState, upd : [Store -> Store]) : 
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, MonitoredProgram, MPState,
                         LAMBDA (mp : MonitoredProgram) : program(mp),
                         LAMBDA (s : MPState) : pstate(s),
                         update_PState,
                         LAMBDA (s : MPState) : gvs(s),
                         update_GhostVars]

  wf_state(mp : MonitoredProgram)(sigma : MPState) : boolean =
    wf_AState(mva(mp))(astate(sigma)) AND
    wf_state(program(mp))(pstate(sigma)) AND
    FORALL (vn : Name) :
      is_ghost(vn, sigma) IFF var_names(getGhostDecls(program(mp)))(vn)

  % Instantiation of its semantics

  on_method_MVA(etype : EventType)
               (mp : (wf_MP), md : Method, s : (wf_state(mp))) : AState =
    IF (evs(mva(mp)))((# etype := etype, mname := name(md) #))
    THEN step(mva(mp))(astate(s), (# stP := st(pstate(s)),
                                     event := (# etype := etype,
                                                 mname := name(md) #)
                                  #))
    ELSE astate(s)
    ENDIF

  on_method_entry_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    NOT cp(astate(s1)) = halted AND
    astate(s2) = on_method_MVA(Entry)(mp, md, s1)  AND
    on_method_entry(mp, md, a, s1, s2, n, deriv_stmt_rec, deriv_expr_rec)

  on_method_exit_normal_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    astate(s2) = on_method_MVA(ExitNormal)(mp, md, s1)  AND
    on_method_exit_normal(mp, md, a, s1, s2, n, deriv_stmt_rec, deriv_expr_rec)

  on_method_exit_exceptional_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    astate(s2) = on_method_MVA(ExitExceptional)(mp, md, s1)  AND
    on_method_exit_exceptional(mp, md, a, s1, s2, n, 
                               deriv_stmt_rec, deriv_expr_rec)

  IMPORTING Semantics[Name, MonitoredProgram, MPState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]


  initial_MP_state(mp : MonitoredProgram)(this_val : Val) : MPState =
    (# astate := initial_MVA_state(mva(mp)),
       pstate := initial_Program_state(program(mp))(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_monitored_program(mp : MonitoredProgram)(main : Method, arg : int)
                       (this_val : Val)(final : MPState)(n : nat) : boolean =
    run_FullProgram(mp)(main, arg)(initial_MP_state(mp)(this_val), final)(n)


  % Well-formedness properties

  wf_initial_MP_state : LEMMA
    FORALL (mp : MonitoredProgram)(this_val : (defined?)) :
      wf_MP(mp) IMPLIES wf_state(mp)(initial_MP_state(mp)(this_val))

  deriv_expr_yields_wf_state_MP : LEMMA
    FORALL (mp : MonitoredProgram, e : Expr, v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      deriv_expr(mp)(e, sigma1, v, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)

  deriv_stmt_yields_wf_state_MP : LEMMA
    FORALL (mp : MonitoredProgram, c : Stmt, sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      deriv_stmt(mp)(c, sigma1, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)

  wf_state_implies_wf_PSt : LEMMA % :->
    FORALL (mp : MonitoredProgram, s : MPState) :
      wf_MP(mp) IMPLIES
      wf_state(program(mp))(pstate(s)) IMPLIES
        wf_PSt(mva(mp))(st(pstate(s)))


END MonitoredProgramSemantics
