MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, Name],
            WellFormedProgram[Name]

  MonitoredProgramPre : TYPE =
    [# mva : (complete[CP, Name]),
       program : Program[Name]
    #]

  % NOTE: We restrict ourselves to the case where the automaton monitors at least
  % one of the classes of the program.
  % Requirements:
  % Variables in vdsP must be fields in the program
  % Every method mentioned in the events must be in the class
  compatible(mp : MonitoredProgramPre) : boolean =  
    LET a = mva(mp), p = program(mp) IN
    EXISTS (c : Class) :
      classes(p)(c) AND 
      name(c) = class_name(a) AND
      (FORALL (v : ProgVarDecl) :
        vdsP(a)(v) IMPLIES
          EXISTS (fd : FieldDecl) : fields(c)(fd) AND name(v) = name(fd)) AND
      (FORALL (ev : Event, n : Name) :
        evs(a)(ev) IMPLIES
        mname(ev) = n IMPLIES
          EXISTS (m : Method) : methods(c)(m) AND name(m) = n)


  % Syntactic constraints on MPs
  wf_MP(mp : MonitoredProgramPre) : boolean =
    wf_MVA(mva(mp)) AND
    wf_Program(program(mp))

  MonitoredProgram : TYPE = (compatible)

END MonitoredProgram


% The semantics of MonitoredPrograms assumes that the program is annotated, 
% thus this can be thought as MonitoredAnnotatedProgramSemantics
MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            MVASemantics[CP, Name]

  % Monitored Program State
  MPState : TYPE =
    [# astate : AState[CP, Name],
       pstate : PState[Name],
       gvs : Store
    #]

  IMPORTING SemanticsTypes[Name, MonitoredProgram, MPState, 
                           LAMBDA (s : MPState) : pstate(s)],
            SemanticsJMLTypes[Name, MPState, LAMBDA (s : MPState) : gvs(s)]

  update_PState : (update_PState_type) =
    LAMBDA (s : MPState, upd : [PState -> PState]) : 
      s WITH [pstate := upd(pstate(s))]

  update_AState(s : MPState, upd : [MPState -> AState]) : MPState =
      s WITH [astate := upd(s)]

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : MPState, upd : [Store -> Store]) : 
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, MonitoredProgram, MPState,
                         LAMBDA (mp : MonitoredProgram) : program(mp),
                         LAMBDA (s : MPState) : pstate(s),
                         update_PState,
                         LAMBDA (s : MPState) : gvs(s),
                         update_GhostVars]

  wf_state(mp : MonitoredProgram)(sigma : MPState) : boolean =
    wf_AState(mva(mp))(astate(sigma)) AND
    wf_state(program(mp))(pstate(sigma)) AND
    wf_ghoststate(mp)(sigma)

  wf_state_implies_wf_PSt : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState) :
      wf_state(program(mp))(pstate(s)) IMPLIES
        wf_PSt(vdsP(mva(mp)))(st(pstate(s)))


  % Instantiation of its semantics

  on_method_MVA(etype : EventType)
               (mp : MonitoredProgram, md : Method)(s : MPState) : AState =
    IF wf_state(mp)(s) AND
       evs(mva(mp))((# etype := etype, mname := name(md) #))
    THEN step(mva(mp))(astate(s), (# stP := st(pstate(s)),
                                     event := (# etype := etype,
                                                 mname := name(md) #)
                                  #))
    ELSE astate(s)
    ENDIF

  on_method_entry_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    NOT cp(astate(s1)) = halted AND
    IF up?(ex(pstate(s1)))
    THEN s1 = s2 AND n = 0
    ELSE
      astate(s2) = on_method_MVA(Entry)(mp, md)(s1) AND
      EXISTS (s3 : MPState) : 
        pstate(s3) = pstate(s2) AND
        gvs(s3) = gvs(s2) AND
        on_method_entry(mp, md, a, s1, s3, n, deriv_stmt_rec, deriv_expr_rec)
    ENDIF

  on_method_exit_normal_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    astate(s2) = on_method_MVA(Entry)(mp, md)(s1) AND
    EXISTS (s3 : MPState) : 
      pstate(s3) = pstate(s2) AND
      gvs(s3) = gvs(s2) AND
      on_method_exit_normal(mp, md, a, s1, s3, n, 
                            deriv_stmt_rec, deriv_expr_rec)

  on_method_exit_exceptional_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    astate(s2) = on_method_MVA(Entry)(mp, md)(s1) AND
    EXISTS (s3 : MPState) : 
      pstate(s3) = pstate(s2) AND
      gvs(s3) = gvs(s2) AND
      on_method_exit_exceptional(mp, md, a, s1, s3, n, 
                                 deriv_stmt_rec, deriv_expr_rec)

  IMPORTING Semantics[Name, MonitoredProgram, MPState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]


  initial_MP_state(mp : MonitoredProgram)(this_val : Val) : MPState =
    (# astate := initial_MVA_state(mva(mp)),
       pstate := initial_Program_state(program(mp))(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_monitored_program(mp : MonitoredProgram)(main : Method, arg : int)
                       (this_val : Val)(final : MPState) : boolean =
    run_FullProgram(mp)(main, arg)(initial_MP_state(mp)(this_val), final)


  IMPORTING SemanticsProofs[Name, MonitoredProgram, MPState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]

  stmt_determ_step_MP : LEMMA % :-)
    FORALL (p : MonitoredProgram, n1, n2 : nat, c : Stmt, sigma : MPState,
            sigma1, sigma2 : MPState) :
        deriv_stmt(p)(c, sigma, sigma1)(n1) AND
        deriv_stmt(p)(c, sigma, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND n1 = n2

  % Well-formedness properties

  wf_initial_MP_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(this_val : (defined?)) :
      wf_MP(mp) IMPLIES wf_state(mp)(initial_MP_state(mp)(this_val))

   wf_update_PState : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState, 
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(program(p))(pstate(s1)) IMPLIES 
           wf_state(program(p))(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState, 
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  wf_state_update_stack : LEMMA %:-)
    FORALL(p : MonitoredProgram, this_val : Val, 
           arg : (getLocalDecls(program(p))), 
           param_val : Val, lvds : finite_set[LocalVarDecl], s : MPState) : 
      wf_state(p)(s) IMPLIES
      (FORALL (l : LocalVarDecl) : 
         lvds(l) IMPLIES getLocalDecls(program(p))(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  deriv_expr_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, e : Expr, v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      (FORALL (c : Stmt)(tau1, tau2 : MPState)(m : below(n)) :
          wf_state(mp)(tau1) IMPLIES
          deriv_stmt(mp)(c, tau1, tau2)(m) IMPLIES
            wf_state(mp)(tau2)) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      deriv_expr(mp)(e, sigma1, v, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)

  deriv_stmt_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, c : Stmt, sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      deriv_stmt(mp)(c, sigma1, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)


END MonitoredProgramSemantics
