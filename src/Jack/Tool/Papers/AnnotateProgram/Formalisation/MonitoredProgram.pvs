MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name],
            MVA[CP, Name]

  MonitoredProgram : TYPE =
    [# mva : MVA[CP, Name],
       program : Program[Name]
    #]


END MonitoredProgram


WellFormedMonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            WellFormedMVA[CP, Name],
            WellFormedProgram[Name]

  
  % NOTE: We restrict to the case where the automaton monitors at least one of
  % classes of the program.
  % Notice that the program does not need to have ghost variables modelling the
  % automata
  % Requirements:
  % Variables in vdsP must be fields
  % Every method mentioned in the events must be in the class
  wf_MP(MP : MonitoredProgram) : boolean =
    LET a = mva(MP), p = program(MP) IN
    complete(a) AND
    wf_Program(p) AND
    EXISTS (c : Class) :
      classes(p)(c) AND 
      name(c) = class_name(a) AND
      (FORALL (v : ProgVarDecl) :
        vdsP(a)(v) IMPLIES
          EXISTS (fd : FieldDecl) : fields(c)(fd) AND name(v) = name(fd)) AND
      (FORALL (ev : Event, n : Name) :
        evs(a)(ev) IMPLIES
        mname(ev) = n IMPLIES
          EXISTS (m : Method) : methods(c)(m) AND name(m) = n)


END WellFormedMonitoredProgram


MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMonitoredProgram[CP, Name],
            MVASemantics[CP, Name]

  % Monitored Program State
  MState : TYPE =
    [# astate : AState[CP, Name],
       pstate : PState[Name],
       gvs : Store
    #]


  % Instantiation of its semantics

  execute_set(vn : Name, v : Val, s : MState) : MState =
    IF up?(ex(pstate(s)))
    THEN s
    ELSE s WITH [gvs := gvs(s) WITH [vn := v]]
    ENDIF

  execute_assert(b : boolean, s : MState) : MState =
    IF b
    THEN s
    ELSE s WITH [pstate := pstate(s) WITH [ex := up(JMLExc)]]
    ENDIF

  on_method_entry(md : Method, mp : MonitoredProgram, s : MState) : MState = 
    (# astate := IF evs(mva(mp))((# etype := Entry, mname := name(md) #))
                 THEN step(mva(mp))(astate(s), 
                                    (# stP := st(pstate(s)),
                                       event := (# etype := Entry, 
                                                   mname := name(md) #)
                                    #))
                 ELSE astate(s)
                 ENDIF,
       pstate := pstate(s),
       gvs := gvs(s)
    #)


  on_method_exit(etype : EventType)(md : Method, mp : MonitoredProgram, 
                 s : MState) : MState =
    (# astate := IF (evs(mva(mp)))((# etype := etype, mname := name(md) #))
                 THEN step(mva(mp))(astate(s),
                                    (# stP := st(pstate(s)),
                                       event := (# etype := etype,
                                                   mname := name(md) #)
                                    #))
                 ELSE astate(s)
                 ENDIF,
       pstate := pstate(s),
       gvs := gvs(s)
    #)

  on_method_exit_normal : [[Method, MonitoredProgram, MState] -> MState] =
    on_method_exit(ExitNormal)

  on_method_exit_exceptional : [[Method, MonitoredProgram, MState] -> MState] =
    on_method_exit(ExitExceptional)

  IMPORTING Semantics[Name, MonitoredProgram, MState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MState) : pstate(s),
                      LAMBDA (upd : [PState -> PState], s : MState) :
                        s WITH [pstate := upd(pstate(s))],
                      execute_set,
                      execute_assert,
                      execute_assert,
                      execute_assert,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]
                       

  initial_MP_state(mp : MonitoredProgram) : MState =
    (# astate := initial_MVA_state(mva(mp)),
       pstate := initial_Program_state(mp),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostVarDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_MonitoredProgram(mp : (wf_MP))(main : Method, arg : int)
                      (s2 : MState)(n : nat) : boolean =
    LET p  = program(mp),
        s1 = initial_MP_state(mp),
        c  = StmtExpr(MethodCall(RExpr(RefVarEval(This)), 
                                 name(main), 
                                 NExpr(Int(arg))))
    IN
      deriv_stmt(mp)(c, s1, s2)(n)


END MonitoredProgramSemantics
