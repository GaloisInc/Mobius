MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVAProperties[CP, Name],
            WellFormedProgram[Name]

  % a wellformed MVA is suitable for monitoring if it is partial or complete
  good_for_monitoring(a : (wf_MVA)) : boolean = partial(a) OR complete(a)

  % first we define the type MonitoredProgramPre
  % this is a record of an MVA and a program
  % below we define several conditions on the monitor in relation with the
  % program (or in fact, with the class being monitored): 
  % a MonitoredProgram is the subtype of MonitoredProgramPre that 
  % satisfies these conditions
  MonitoredProgramPre : TYPE =
    [# mva : (good_for_monitoring[CP, Name]),
       program : Program[Name]
    #]

  % Conditions:

  % all declared program variables in the MVA are declared as fields in the
  % class
  MVA_prog_vars_are_fields(mp : MonitoredProgramPre, c : Class) : boolean =
    FORALL (v : Decl) :
      classes(program(mp))(c) IMPLIES
      vdsP(mva(mp))(v) IMPLIES
        EXISTS (fd : Decl) : fields(c)(fd) AND name(v) = name(fd)


  % all names of monitor variables in the MVA are disjoint from the
  % variable names used in the program
  MVA_aut_vars_are_not_prog_vars(mp : MonitoredProgramPre) : boolean =
    FORALL (v : Decl) :
      vdsA(mva(mp))(v) IMPLIES
        NOT ext_declared_var_names(program(mp))(name(v))

  % all events in the MVA correspond to a method in the class c
  MVA_events_correspond_to_methods(mp : MonitoredProgramPre,
                                   c : Class) : boolean =
    FORALL (ev : Event, n : Name) :
      classes(program(mp))(c) IMPLIES
      evs(mva(mp))(ev) IMPLIES
      mname(ev) = n IMPLIES
        EXISTS (m : Method) : methods(c)(m) AND name(m) = n

  % NOTE: We restrict ourselves to the case where the automaton monitors
  % one of the classes of the program.
  % MVA is compatible with the program, if three conditions above hold
  compatible(mp : MonitoredProgramPre) : boolean =
    MVA_aut_vars_are_not_prog_vars(mp) AND
    EXISTS (c : Class) :
      classes(program(mp))(c) AND
      name(c) = class_name(mva(mp)) AND
      MVA_prog_vars_are_fields(mp, c) AND
      MVA_events_correspond_to_methods(mp, c)

  % we only consider compatible monitored programs
  MonitoredProgram : TYPE = (compatible)

  % auxiliary function: return monitored class
  get_monitored_class(mp : MonitoredProgram) : Class =
    choose({c : Class | classes(program(mp))(c) AND
                        name(c) = class_name(mva(mp))})

  % name of monitored class coincide with class_name mentioned in MVA
  name_get_monitored_class : LEMMA % :-)
    FORALL(mp : MonitoredProgram) :
      name(get_monitored_class(mp)) = class_name(mva(mp))

  % monitored class is class in program
  get_monitored_class_in_classes : LEMMA % :-)
    FORALL(mp : MonitoredProgram) :
      classes(program(mp))(get_monitored_class(mp))

  % a monitored program is wellformed if both MVA and program are wellformed
  wf_MP(mp : MonitoredProgram) : boolean =
    wf_MVA(mva(mp)) AND
    wf_Program(program(mp))

  wf_and_complete_MP(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND complete(mva(mp))

  wf_and_partial_MP(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND partial(mva(mp))

  % for every wellformed monitored program, there is only one monitored class
  get_monitored_class_unique_for_wf_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram) :
      wf_MP(mp) IMPLIES
        get_monitored_class(mp) = the({c : Class | classes(program(mp))(c) AND
                                                   name(c) = class_name(mva(mp))})


END MonitoredProgram


% The semantics of MonitoredPrograms assumes that the program is annotated,
% thus this can be thought as MonitoredAnnotatedProgramSemantics

% One could imagine that MPState would be parametrised with the type of 
% State, which could be for an basic or annotated program
% For simplicity, we choose not to do this
MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            MVAPartialSemantics[CP, Name]

  % Monitored Program State
  % contains: 
  % automaton state,
  % flag stuck, denoting whether the MVA has a transition enable
  % pstate: program state
  % gvs: ghost variables
  MPState : TYPE =
    [# astate : AState[CP, Name],
       stuck : boolean,
       pstate : PState[Name],
       gvs : Store
    #]

  
  IMPORTING SemanticsTypes[Name, MonitoredProgram, MPState,
                           LAMBDA (mp : MonitoredProgram) : program(mp),
                           LAMBDA (s : MPState) : pstate(s)],
            SemanticsJMLTypes[Name, MPState, LAMBDA (s : MPState) : gvs(s)]

  % lifting of program state update
  update_PState : (update_PState_type) =
    LAMBDA (s : MPState, upd : [PState -> PState]) :
      s WITH [pstate := upd(pstate(s))]

  % lifting of automaton state update
  update_AState(s : MPState, upd : [MPState -> AState]) : MPState =
      s WITH [astate := upd(s)]

  % lifting of ghost state update 
 update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : MPState, upd : [Store -> Store]) :
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, MonitoredProgram, MPState,
                         LAMBDA (mp : MonitoredProgram) : program(mp),
                         LAMBDA (s : MPState) : pstate(s),
                         update_PState,
                         LAMBDA (s : MPState) : gvs(s),
                         update_GhostVars]

  % monitored program state wellformed if
  % automaton state, program state and ghost state wellformed
  wf_state(mp : MonitoredProgram)(sigma : MPState) : boolean =
    wf_AState(mva(mp))(astate(sigma)) AND
    wf_state(program(mp))(pstate(sigma)) AND
    wf_ghoststate(mp)(sigma)

  wf_ap_state(mp : MonitoredProgram)(sigma : MPState) : boolean =
    wf_state(program(mp))(pstate(sigma)) AND
    wf_ghoststate(mp)(sigma)

  % any wf_state is also a wf_ap_state
  wf_state_implies_wf_ap_state : LEMMA % :-)
    FORALL(mp : MonitoredProgram, s : MPState) :
      wf_state(mp)(s) IMPLIES wf_ap_state(mp)(s)

  % wf_state implies that program state is wellformed wrt monitoring MVA
  % i.e., all program variables declared in automaton are defined
  wf_state_implies_wf_PSt : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState) :
      wf_state(program(mp))(pstate(s)) IMPLIES
        wf_PSt(fvs(st(pstate(s))))(var_names(vdsP(mva(mp))))

  % all declared variables are either ghost, local or field
  wf_state_vars_tricotomy : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, vn : Name) :
      wf_state(mp)(s) IMPLIES
      ext_declared_var_names(program(mp))(vn) IMPLIES
        is_ghost(vn, s) OR
        is_field(vn, pstate(s)) OR
        is_local(vn, pstate(s))

  % ghost variables are not local or fields
  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, vn : Name) :
      wf_state(mp)(s) IMPLIES
      wf_Program(program(mp)) IMPLIES
      is_ghost(vn, s) IMPLIES
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))


  % Instantiation of semantics

  % action of monitor upon method entry/exit
  % using partial step relation
  % if the class is being monitored, and the event is being monitored
  % then if a new state can be reached via step relation
  % then make this step
  % otherwise, set stuck flag to signal that monitor blocks
  % (external mechanism should stop program now as quickly as possible)
  on_method_MVA(etype : EventType)
               (mp : MonitoredProgram, md : (wf_Method(program(mp))))
               (arg : ValOrExcpt)(s : MPState) : MPState =
    IF wf_state(mp)(s) AND 
       NOT stuck(s) AND
       methods(get_monitored_class(mp))(md) AND
       evs(mva(mp))((# etype := etype, mname := name(md) #)) 
    THEN IF up?(step(mva(mp))(astate(s), (# stP := fvs(st(pstate(s))),
                                            event := (# etype := etype,
                                                        mname := name(md) #),
                                                        arg := arg 
                                                     #)))
         THEN s WITH [astate := down(step(mva(mp))(astate(s), 
                                         (# stP := fvs(st(pstate(s))),
                                            event := (# etype := etype,
                                                        mname := name(md) #),
                                                        arg := arg 
                                                     #)))]
         ELSE s WITH [stuck := TRUE]
         ENDIF
    ELSE s
    ENDIF

  % upon method entry 
  % monitored program should first evaluate preconditon and invariant,
  % and execute post_set annotation (via on_method_entry) 
  % followed by step in monitor
  on_method_entry_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : (wf_Method(program(mp))), a : Val,
            arg : ValOrExcpt, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    EXISTS(s_new : MPState) :
      on_method_entry(mp, md, a, arg, s1, s_new, n, derive_rec) AND
      IF up?(ex(pstate(s_new)))
      THEN s2 = s_new
      ELSE s2 = on_method_MVA(Entry)(mp, md)(arg)(s_new)
      ENDIF


  % upon normal method exit
  % monitored program should first evaluate post_set annotation
  % then let monitor take step
  % then evaluate invariant and postcondition
  % (particular order ensures that correctness proof can be established)
  on_method_exit_normal_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : (wf_Method(program(mp))), a : Val,
            arg : ValOrExcpt, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1)))
    THEN s1 = s2 AND n = 0
    ELSE
    EXISTS (m1, m2, m3 : nat, tau1, tau2, tau3 : MPState, v : Val,
            inv : (wf_Expr(program(mp)))) :
      n = m1 + m2 + m3 + 1 AND
      val?(arg) AND
      derive_rec(n)(mp)(post_set(md)(v(arg)), s1, v, tau1)(m1) AND
      v = return_of_stmt(tau1) AND
      tau2 = on_method_MVA(ExitNormal)(mp, md)(arg)(tau1)  AND
      inv = lookup_inv(program(mp), a) AND
      check_assertion(mp)(inv, tau2, tau3)(m2)(derive_rec(m2)) AND
      check_assertion(mp)(post(md)(v(arg)), tau3, s2)(m3)
                         (derive_rec(m3)) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  % upon exceptional method exit
  % monitored program should first evaluate exc_set annotation
  % then let monitor take step
  % then evaluate invariant
  % (particular order ensures that correctness proof can be established)
  on_method_exit_exceptional_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : (wf_Method(program(mp))), a : Val,
            arg : ValOrExcpt, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) AND NOT down(ex(pstate(s1))) = JMLExc
    THEN
    EXISTS (m1, m2 : nat, tau1, tau2, tau3 : MPState, v : Val,
            inv : (wf_Expr(program(mp)))) :
      n = m1 + m2 + 1 AND
      excpt?(arg) AND
      derive_rec(n)(mp)(exc_set(md)(e(arg)), 
                        update_PState(s1, catch), v, tau1)(m1) AND
      v = return_of_stmt(tau1) AND
      tau2 = on_method_MVA(ExitExceptional)(mp, md)(arg)(tau1) AND
      inv = lookup_inv(program(mp), a) AND
      check_assertion(mp)(inv, tau2, tau3)(m2)(derive_rec(m2)) AND
      s2 = (IF up?(ex(pstate(tau3)))
            THEN tau3
            ELSE update_PState(tau3, raise(down(ex(pstate(s1)))))
            ENDIF) AND
      st(pstate(s1)) = st(pstate(s2))
    ELSE s1 = s2 AND n = 0
    ENDIF


  % instantiate semantics appropriately for monitored program
  IMPORTING Semantics[Name, MonitoredProgram, MPState,
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]


  % initial program state for monitored program:
  % automaton state is initial automaton state
  % stuck flag not set
  % program state and ghost variable state is for annotated program
  initial_MP_state(mp : MonitoredProgram)(this_val : Val) : MPState =
    (# astate := initial_MVA_state(mva(mp)),
       stuck := FALSE,
       pstate := initial_Program_state(program(mp))(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  % running monitored program: run main method, starting in 
  % initial monitored program state
  run_monitored_program(mp : MonitoredProgram)(main : Name, arg : int)
                       (this_val : Val)(final : MPState) : boolean =
    run_FullProgram(mp)(main, arg)(initial_MP_state(mp)(this_val), final)


  IMPORTING SemanticsProofs[Name, MonitoredProgram, MPState,
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]

  determ_step_MP : LEMMA % :-)
    FORALL (p : MonitoredProgram, n1, n2 : nat, b : (wf_Body(program(p))), sigma : MPState,
            sigma1, sigma2 : MPState, v1, v2 : Val) :
        derive(p)(b, sigma, v1, sigma1)(n1) AND
        derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND v1 = v2 AND n1 = n2


  % Well-formedness properties

  % initial state of monitored program wellformed
  wf_initial_MP_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(this_val : (defined?)) :
      wf_MP(mp) IMPLIES wf_state(mp)(initial_MP_state(mp)(this_val))

  % wf_state preserved by update of program state
  wf_update_PState : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState,
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(program(p))(pstate(s1)) IMPLIES
           wf_state(program(p))(pstate(s2))) IMPLIES
       wf_state(p)(s2)

  % wf_state preserved by update of ghost variables
  wf_update_GhostVars : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState,
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  % wf_state preserved by update of stack upon method entyr
  wf_state_update_stack : LEMMA % :-)
    FORALL(p : MonitoredProgram, this_val : Val,
           arg : (getLocalDecls(program(p))),
           param_val : Val, lvds : finite_set[Decl], s : MPState) :
      wf_state(p)(s) IMPLIES
      (FORALL (l : Decl) :
         lvds(l) IMPLIES getLocalDecls(program(p))(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  % transition function automaton preserves wellformedness of automaton state
  on_method_MVA_yields_wf_AState : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, m : (wf_Method(program(mp))),
            et : EventType, arg : ValOrExcpt) :
      wf_state(mp)(s) IMPLIES
        wf_AState(mva(mp))(astate(on_method_MVA(et)(mp, m)(arg)(s)))

  % transition function automaton preserve wf_state
  on_method_MVA_yields_wf_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, m : (wf_Method(program(mp))),
            et : EventType, arg : ValOrExcpt) :
      wf_state(mp)(s) IMPLIES
        wf_state(mp)(on_method_MVA(et)(mp, m)(arg)(s))

  % derive preserves wf_state
  derive_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)

  % for complete MVA, halted state is never left, once it is reached
  on_method_MVA_never_leaves_halted : LEMMA % :-)
     FORALL (etype : EventType)
            (mp : MonitoredProgram, md : (wf_Method(program(mp))))
            (arg : ValOrExcpt, s : MPState) :
       complete(mva(mp)) IMPLIES
       cp(astate(s)) = halted IMPLIES
       cp(astate(on_method_MVA(etype)(mp, md)(arg)(s))) = halted

  derive_never_leaves_halted : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      cp(astate(sigma1)) = halted IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        cp(astate(sigma2)) = halted

  % once MVA state is stuck (ie stuck flag set), it remains stuck
  on_method_MVA_never_leaves_stuck : LEMMA % :-)
     FORALL (etype : EventType)
            (mp : MonitoredProgram, md : (wf_Method(program(mp))))
            (arg : ValOrExcpt, s : MPState) :
       stuck(s) IMPLIES
       stuck(on_method_MVA(etype)(mp, md)(arg)(s))

  derive_never_leaves_stuck : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      stuck(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        stuck(sigma2)

  % partial MVA will never reach halted (as it does not contain such a control
  % point)
  partial_MVA_never_in_halted_in_wf_state : LEMMA % :-)
     FORALL (mp : MonitoredProgram, s : MPState) :
       partial(mva(mp)) IMPLIES
       wf_state(mp)(s) IMPLIES
       NOT cp(astate(s)) = halted

  % a complete MVA will never get stuck
  complete_MVA_never_stuck_after_on_method_MVA : LEMMA % :-)
     FORALL (etype : EventType)
            (mp : MonitoredProgram, md : (wf_Method(program(mp))))
            (arg : ValOrExcpt, s : MPState) :
       NOT stuck(s) IMPLIES
       complete(mva(mp)) IMPLIES
       wf_state(mp)(s) IMPLIES
       NOT stuck(on_method_MVA(etype)(mp, md)(arg)(s))

  complete_MVA_never_stuck_after_derive : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      NOT stuck(sigma1) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        NOT stuck(sigma2)

  % wf_state preserved by on_method_entry
  on_method_entry_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_entry_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(mp)(sigma2)

  % wf_state preserved by on_method_exit
  on_method_exit_normal_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) : 
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_normal_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(mp)(sigma2)

  % wf_state preserved by on_method_exit_exceptional
  on_method_exit_exceptional_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) : 
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_exceptional_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(mp)(sigma2)

  % Convenience lemmas about complete monitors never getting stuck

  % a complete monitor never gets stuck after on_method_entry_MP
  complete_MVA_never_stuck_after_on_method_entry_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_entry_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
       NOT stuck(sigma1) IMPLIES
       NOT stuck(sigma2)

  % a complete monitor never gets stuck after on_method_exit_normal_MP
  complete_MVA_never_stuck_after_on_method_exit_normal_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_normal_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
       NOT stuck(sigma1) IMPLIES
       NOT stuck(sigma2)

  % a complete monitor never gets stuck after on_method_exit_exceptional_MP
  complete_MVA_never_stuck_after_on_method_exit_exceptional_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_exceptional_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
       NOT stuck(sigma1) IMPLIES
       NOT stuck(sigma2)

END MonitoredProgramSemantics


