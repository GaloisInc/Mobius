MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, Name],
            WellFormedProgram[Name]

  MonitoredProgramPre : TYPE =
    [# mva : (complete[CP, Name]),
       program : Program[Name]
    #]


  MVA_prog_vars_are_fields(mp : MonitoredProgramPre, c : Class) : boolean =
    FORALL (v : ProgVarDecl) :
      classes(program(mp))(c) IMPLIES
      vdsP(mva(mp))(v) IMPLIES
        EXISTS (fd : FieldDecl) : fields(c)(fd) AND name(v) = name(fd)


  MVA_aut_vars_are_not_prog_vars(mp : MonitoredProgramPre) : boolean =
    FORALL (v : MVAVarDecl) :
      vdsA(mva(mp))(v) IMPLIES
        NOT declared_var_names(program(mp))(name(v))

  MVA_events_correspond_to_methods(mp : MonitoredProgramPre, 
                                   c : Class) : boolean =
    FORALL (ev : Event, n : Name) :
      classes(program(mp))(c) IMPLIES
      evs(mva(mp))(ev) IMPLIES
      mname(ev) = n IMPLIES
        EXISTS (m : Method) : methods(c)(m) AND name(m) = n

  % NOTE: We restrict ourselves to the case where the automaton monitors 
  % one of the classes of the program.
  % Requirements:
  % Variables in vdsP must be fields in the program
  % Every method mentioned in the events must be in the class
  compatible(mp : MonitoredProgramPre) : boolean =
    MVA_aut_vars_are_not_prog_vars(mp) AND
    EXISTS (c : Class) :
      classes(program(mp))(c) AND
      name(c) = class_name(mva(mp)) AND
      MVA_prog_vars_are_fields(mp, c) AND
      MVA_events_correspond_to_methods(mp, c)

  MonitoredProgram : TYPE = (compatible)

  get_monitored_class(mp : MonitoredProgram) : Class =
    choose({c : Class | classes(program(mp))(c) AND 
                        name(c) = class_name(mva(mp))})

  name_get_monitored_class : LEMMA % :-)
    FORALl(mp : MonitoredProgram) :
      name(get_monitored_class(mp)) = class_name(mva(mp))

  get_monitored_class_in_classes : LEMMA % :-)
    FORALl(mp : MonitoredProgram) :
      classes(program(mp))(get_monitored_class(mp))

  wf_MP(mp : MonitoredProgram) : boolean =
    wf_MVA(mva(mp)) AND
    wf_Program(program(mp))

  get_monitored_class_unique_for_wf_MP : LEMMA
    FORALL (mp : MonitoredProgram) :
      wf_MP(mp) IMPLIES
        get_monitored_class(mp) = the({c : Class | classes(program(mp))(c) AND 
                                                   name(c) = class_name(mva(mp))})


END MonitoredProgram


% The semantics of MonitoredPrograms assumes that the program is annotated, 
% thus this can be thought as MonitoredAnnotatedProgramSemantics
MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            MVASemantics[CP, Name]

  % Monitored Program State
  MPState : TYPE =
    [# astate : AState[CP, Name],
       pstate : PState[Name],
       gvs : Store
    #]

  IMPORTING SemanticsTypes[Name, MonitoredProgram, MPState, 
                           LAMBDA (s : MPState) : pstate(s)],
            SemanticsJMLTypes[Name, MPState, LAMBDA (s : MPState) : gvs(s)]

  update_PState : (update_PState_type) =
    LAMBDA (s : MPState, upd : [PState -> PState]) : 
      s WITH [pstate := upd(pstate(s))]

  update_AState(s : MPState, upd : [MPState -> AState]) : MPState =
      s WITH [astate := upd(s)]

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : MPState, upd : [Store -> Store]) : 
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, MonitoredProgram, MPState,
                         LAMBDA (mp : MonitoredProgram) : program(mp),
                         LAMBDA (s : MPState) : pstate(s),
                         update_PState,
                         LAMBDA (s : MPState) : gvs(s),
                         update_GhostVars]

  wf_state(mp : MonitoredProgram)(sigma : MPState) : boolean =
    wf_AState(mva(mp))(astate(sigma)) AND
    wf_state(program(mp))(pstate(sigma)) AND
    wf_ghoststate(mp)(sigma)

  wf_state_implies_wf_PSt : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState) :
      wf_state(program(mp))(pstate(s)) IMPLIES
        wf_PSt(vdsP(mva(mp)))(st(pstate(s)))

  wf_state_vars_tricotomy : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, vn : Name) :
      wf_state(mp)(s) IMPLIES
      ext_declared_var_names(program(mp))(vn) IMPLIES
        is_ghost(vn, s) OR
        is_field(vn, pstate(s)) OR
        is_local(vn, pstate(s))

  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, vn : Name) :
      wf_state(mp)(s) IMPLIES
      wf_Program(program(mp)) IMPLIES
      is_ghost(vn, s) IMPLIES 
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))


  % Instantiation of its semantics

  % TODO: We must add constrain saying that the method belongs to the monitored
  % class. To get the monitored class we could use get_monitored_class(mp), the
  % problem is how to get the class of the method.
  on_method_MVA(etype : EventType)
               (mp : MonitoredProgram, md : Method)(s : MPState) : AState =
    IF wf_state(mp)(s) AND
       methods(get_monitored_class(mp))(md) AND
       evs(mva(mp))((# etype := etype, mname := name(md) #))
    THEN step(mva(mp))(astate(s), (# stP := st(pstate(s)),
                                     event := (# etype := etype,
                                                 mname := name(md) #)
                                  #))
    ELSE astate(s)
    ENDIF

  on_method_entry_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    NOT cp(astate(s1)) = halted AND
    EXISTS(s_new : MPState) : 
      on_method_entry(mp, md, a, s1, s_new, n, derive_rec) AND
      IF up?(ex(pstate(s_new)))
      THEN s2 = s_new
      ELSE s2 = (# astate := on_method_MVA(Entry)(mp, md)(s_new),
                   pstate := pstate(s_new),
                   gvs := gvs(s_new) #)
      ENDIF


  on_method_exit_normal_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    NOT cp(astate(s1)) = halted AND
    EXISTS(s_new : MPState) : 
      on_method_exit_normal(mp, md, a, s1, s_new, n, derive_rec) AND
      IF up?(ex(pstate(s_new)))
      THEN s2 = s_new
      ELSE s2 = (# astate := on_method_MVA(ExitNormal)(mp, md)(s_new),
                   pstate := pstate(s_new),
                   gvs := gvs(s_new) #)
      ENDIF

  on_method_exit_exceptional_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    NOT cp(astate(s1)) = halted AND
    EXISTS(s_new : MPState) : 
      on_method_exit_exceptional(mp, md, a, s1, s_new, n, derive_rec) AND
      IF up?(ex(pstate(s1))) AND up?(ex(pstate(s_new))) AND 
         down(ex(pstate(s1))) = down(ex(pstate(s_new)))
      THEN s2 = (# astate := on_method_MVA(ExitExceptional)(mp, md)(s_new),
                   pstate := pstate(s_new),
                   gvs := gvs(s_new) #)
      ELSE s2 = s_new
      ENDIF

  IMPORTING Semantics[Name, MonitoredProgram, MPState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]


  initial_MP_state(mp : MonitoredProgram)(this_val : Val) : MPState =
    (# astate := initial_MVA_state(mva(mp)),
       pstate := initial_Program_state(program(mp))(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_monitored_program(mp : MonitoredProgram)(main : Method, arg : int)
                       (this_val : Val)(final : MPState) : boolean =
    run_FullProgram(mp)(main, arg)(initial_MP_state(mp)(this_val), final)


  IMPORTING SemanticsProofs[Name, MonitoredProgram, MPState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]

  determ_step_MP : LEMMA % :-)
    FORALL (p : MonitoredProgram, n1, n2 : nat, b : Body, sigma : MPState,
            sigma1, sigma2 : MPState, v1, v2 : Val) :
        derive(p)(b, sigma, v1, sigma1)(n1) AND
        derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND v1 = v2 AND n1 = n2

  % Well-formedness properties

  wf_initial_MP_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(this_val : (defined?)) :
      wf_MP(mp) IMPLIES wf_state(mp)(initial_MP_state(mp)(this_val))

   wf_update_PState : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState, 
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(program(p))(pstate(s1)) IMPLIES 
           wf_state(program(p))(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState, 
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  wf_state_update_stack : LEMMA %:-)
    FORALL(p : MonitoredProgram, this_val : Val, 
           arg : (getLocalDecls(program(p))), 
           param_val : Val, lvds : finite_set[LocalVarDecl], s : MPState) : 
      wf_state(p)(s) IMPLIES
      (FORALL (l : LocalVarDecl) : 
         lvds(l) IMPLIES getLocalDecls(program(p))(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  derive_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : Body, v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)

  IMPORTING AnnotatedProgramSemantics[Name]

  % method call case not finished
  derive_MP_from_derive_AP : LEMMA
    FORALL(mp : MonitoredProgram, b : Body, v : Val)
          (sMP1 : MPState)(sAP1, sAP2 : APState)(n : nat) :
      pstate(sMP1) = pstate(sAP1) IMPLIES
      gvs(sMP1) = gvs(sAP1) IMPLIES
      derive(program(mp))(b, sAP1, v, sAP2)(n) IMPLIES
      EXISTS (sMP2 : MPState) :
        pstate(sMP2) = pstate(sAP2) AND
        gvs(sMP2) = gvs(sAP2) AND
        derive(mp)(b, sMP1, v, sMP2)(n)

END MonitoredProgramSemantics
