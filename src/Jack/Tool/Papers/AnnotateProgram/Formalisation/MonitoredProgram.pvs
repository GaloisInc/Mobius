MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name],
            MVA[CP, Name]

  MonitoredProgram : TYPE =
    [# mva : MVA[CP, Name],
       program : Program[Name]
    #]


END MonitoredProgram


WellFormedMonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            WellFormedMVA[CP, Name],
            WellFormedProgram[Name]

  
  % NOTE: We restrict to the case where the automaton monitors at least one of
  % classes of the program.
  % Notice that the program does not need to have ghost variables modelling the
  % automata
  % Requirements:
  % Variables in vdsP must be fields
  % Every method mentioned in the events must be in the class
  wf_MP(MP : MonitoredProgram) : boolean =
    LET a = mva(MP), p = program(MP) IN
    complete(a) AND
    wf_Program(p) AND
    EXISTS (c : Class) :
      classes(p)(c) AND 
      name(c) = class_name(a) AND
      (FORALL (v : ProgVarDecl) :
        vdsP(a)(v) IMPLIES
          EXISTS (fd : FieldDecl) : fields(c)(fd) AND name(v) = name(fd)) AND
      (FORALL (ev : Event, n : Name) :
        evs(a)(ev) IMPLIES
        mname(ev) = n IMPLIES
          EXISTS (m : Method) : methods(c)(m) AND name(m) = n)


END WellFormedMonitoredProgram


% The semantics of MonitoredPrograms assumes that the program is annotated, thus
% this can be thought as MonitoredAnnotatedProgramSemantics
MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            MVASemantics[CP, Name]

  % Monitored Program State
  MState : TYPE =
    [# astate : AState[CP, Name],
       pstate : PState[Name],
       gvs : Store
    #]

  IMPORTING SemanticsTypes[Name, MonitoredProgram, MState, 
                           LAMBDA (s : MState) : pstate(s)]

  update_state : (update_FullState_type) =
    LAMBDA (upd : [PState -> PState], s : MState) :
      s WITH [pstate := upd(pstate(s))]

  IMPORTING SemanticsCommon[Name, MonitoredProgram, MState, 
                            LAMBDA (s : MState) : pstate(s),
                            update_state]

  % Instantiation of its semantics

  execute_set : (execute_set_type) =
    LAMBDA (mp : MonitoredProgram, vn : Name, e : Expr, s1, s2 : MState,
            n : nat,
            deriv_stmt : [MonitoredProgram -> [Stmt, MState, MState ->
                                              [below(n + 1) -> bool]]],
            deriv_expr : [MonitoredProgram -> [Expr, MState, Val, MState ->
                                              [below(n + 1) -> bool]]]) :
      EXISTS (tau : MState, v : Val) :
        deriv_expr(mp)(e, s1, v, tau)(n - 1) AND
        s2 = IF up?(ex(pstate(s1)))
             THEN s1
             ELSE s1 WITH [gvs := gvs(s1) WITH [vn := v]]
             ENDIF

  on_method_MVA(etype : EventType)
               (mp : MonitoredProgram, md : Method, s : MState) : AState =
    IF (evs(mva(mp)))((# etype := etype, mname := name(md) #))
    THEN step(mva(mp))(astate(s), (# stP := st(pstate(s)),
                                     event := (# etype := etype,
                                                 mname := name(md) #)
                                  #))
    ELSE astate(s)
    ENDIF

  on_method_entry : (on_method_entry_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MState,
            n : nat,
            deriv_stmt : [MonitoredProgram -> [Stmt, MState, MState ->
                                     [below(n + 1) -> bool]]],
            deriv_expr : [MonitoredProgram -> [Expr, MState, Val, MState ->
                                     [below(n + 1) -> bool]]]) :
    astate(s2) = on_method_MVA(Entry)(mp, md, s1)  AND
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : MState, inv : Expr) :
      n = m1 + m2 + m3 AND
      inv = down(lookup_inv(program(mp), a)) AND
      check_assertion(mp)(inv, s1, tau1)(m1)(deriv_expr) AND
      check_assertion(mp)(pre(md), tau1, tau2)(m2)(deriv_expr) AND
      deriv_stmt(mp)(pre_set(md), tau2, s2)(m3) AND
      st(pstate(s1)) = st(pstate(s2))
      
  on_method_exit_normal : (on_method_exit_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MState,
            n : nat,
            deriv_stmt : [MonitoredProgram -> [Stmt, MState, MState ->
                                     [below(n + 1) -> bool]]],
            deriv_expr : [MonitoredProgram -> [Expr, MState, Val, MState ->
                                     [below(n + 1) -> bool]]]) :
    astate(s2) = on_method_MVA(ExitNormal)(mp, md, s1)  AND
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : MState, inv : Expr) :
      n = m1 + m2 + m3 AND
      deriv_stmt(mp)(post_set(md), s1, tau1)(m1) AND
      check_assertion(mp)(post(md), tau1, tau2)(m1)(deriv_expr) AND
      inv = down(lookup_inv(program(mp), a)) AND
      check_assertion(mp)(inv, tau2, s2)(m2)(deriv_expr) AND
      st(pstate(s1)) = st(pstate(s2))

  on_method_exit_exceptional : (on_method_exit_type) =
    LAMBDA (mp : MonitoredProgram, md : Method, a : Val, s1, s2 : MState,
            n : nat,
            deriv_stmt : [MonitoredProgram -> [Stmt, MState, MState ->
                                     [below(n + 1) -> bool]]],
            deriv_expr : [MonitoredProgram -> [Expr, MState, Val, MState ->
                                     [below(n + 1) -> bool]]]) :
    astate(s2) = on_method_MVA(ExitExceptional)(mp, md, s1)  AND
    EXISTS (m1, m2 : nat, tau1, tau2 : MState, inv : Expr) :
      n = m1 + m2 AND
      deriv_stmt(mp)(exc_set(md), s1, tau1)(m1) AND
      inv = down(lookup_inv(program(mp), a)) AND
      check_assertion(mp)(inv, tau1, s2)(m2)(deriv_expr) AND
      st(pstate(s1)) = st(pstate(s2))


  IMPORTING Semantics[Name, MonitoredProgram, MState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MState) : pstate(s),
                      update_state,
                      execute_set,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]


  initial_MP_state(mp : MonitoredProgram) : MState =
    (# astate := initial_MVA_state(mva(mp)),
       pstate := initial_Program_state(mp),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostVarDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_monitored_program(mp : MonitoredProgram)(main : Method, arg : int)
                      (s2 : MState)(n : nat) : boolean =
    run_FullProgram(mp)(main, arg)(initial_MP_state(mp), s2)(n)


END MonitoredProgramSemantics
