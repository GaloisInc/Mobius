MonitoredProgram[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVAProperties[CP, Name],
            WellFormedProgram[Name]

  good_for_monitoring(a : (wf_MVA)) : boolean = partial(a) OR complete(a)

  MonitoredProgramPre : TYPE =
    [# mva : (good_for_monitoring[CP, Name]),
       program : Program[Name]
    #]


  MVA_prog_vars_are_fields(mp : MonitoredProgramPre, c : Class) : boolean =
    FORALL (v : ProgVarDecl) :
      classes(program(mp))(c) IMPLIES
      vdsP(mva(mp))(v) IMPLIES
        EXISTS (fd : FieldDecl) : fields(c)(fd) AND name(v) = name(fd)


  MVA_aut_vars_are_not_prog_vars(mp : MonitoredProgramPre) : boolean =
    FORALL (v : MVAVarDecl) :
      vdsA(mva(mp))(v) IMPLIES
        NOT ext_declared_var_names(program(mp))(name(v))

  MVA_events_correspond_to_methods(mp : MonitoredProgramPre,
                                   c : Class) : boolean =
    FORALL (ev : Event, n : Name) :
      classes(program(mp))(c) IMPLIES
      evs(mva(mp))(ev) IMPLIES
      mname(ev) = n IMPLIES
        EXISTS (m : Method) : methods(c)(m) AND name(m) = n

  % NOTE: We restrict ourselves to the case where the automaton monitors
  % one of the classes of the program.
  % Requirements:
  % Variables in vdsP must be fields in the program
  % Every method mentioned in the events must be in the class
  compatible(mp : MonitoredProgramPre) : boolean =
    MVA_aut_vars_are_not_prog_vars(mp) AND
    EXISTS (c : Class) :
      classes(program(mp))(c) AND
      name(c) = class_name(mva(mp)) AND
      MVA_prog_vars_are_fields(mp, c) AND
      MVA_events_correspond_to_methods(mp, c)

  MonitoredProgram : TYPE = (compatible)

  get_monitored_class(mp : MonitoredProgram) : Class =
    choose({c : Class | classes(program(mp))(c) AND
                        name(c) = class_name(mva(mp))})

  name_get_monitored_class : LEMMA % :-)
    FORALl(mp : MonitoredProgram) :
      name(get_monitored_class(mp)) = class_name(mva(mp))

  get_monitored_class_in_classes : LEMMA % :-)
    FORALl(mp : MonitoredProgram) :
      classes(program(mp))(get_monitored_class(mp))

  wf_MP(mp : MonitoredProgram) : boolean =
    wf_MVA(mva(mp)) AND
    wf_Program(program(mp))

  wf_and_complete_MP(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND complete(mva(mp))

  wf_and_partial_MP(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND partial(mva(mp))

  get_monitored_class_unique_for_wf_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram) :
      wf_MP(mp) IMPLIES
        get_monitored_class(mp) = the({c : Class | classes(program(mp))(c) AND
                                                   name(c) = class_name(mva(mp))})


END MonitoredProgram


% The semantics of MonitoredPrograms assumes that the program is annotated,
% thus this can be thought as MonitoredAnnotatedProgramSemantics
MonitoredProgramSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, Name],
            MVAPartialSemantics[CP, Name]

  % Monitored Program State
  MPState : TYPE =
    [# astate : AState[CP, Name],
       stuck : boolean,
       pstate : PState[Name],
       gvs : Store
    #]

  
  IMPORTING SemanticsTypes[Name, MonitoredProgram, MPState,
                           LAMBDA (mp : MonitoredProgram) : program(mp),
                           LAMBDA (s : MPState) : pstate(s)],
            SemanticsJMLTypes[Name, MPState, LAMBDA (s : MPState) : gvs(s)]

  update_PState : (update_PState_type) =
    LAMBDA (s : MPState, upd : [PState -> PState]) :
      s WITH [pstate := upd(pstate(s))]

  update_AState(s : MPState, upd : [MPState -> AState]) : MPState =
      s WITH [astate := upd(s)]

  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : MPState, upd : [Store -> Store]) :
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, MonitoredProgram, MPState,
                         LAMBDA (mp : MonitoredProgram) : program(mp),
                         LAMBDA (s : MPState) : pstate(s),
                         update_PState,
                         LAMBDA (s : MPState) : gvs(s),
                         update_GhostVars]

  wf_state(mp : MonitoredProgram)(sigma : MPState) : boolean =
    wf_AState(mva(mp))(astate(sigma)) AND
    wf_state(program(mp))(pstate(sigma)) AND
    wf_ghoststate(mp)(sigma)

  wf_state_implies_wf_PSt : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState) :
      wf_state(program(mp))(pstate(s)) IMPLIES
        wf_PSt(vdsP(mva(mp)))(st(pstate(s)))

  wf_state_vars_tricotomy : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, vn : Name) :
      wf_state(mp)(s) IMPLIES
      ext_declared_var_names(program(mp))(vn) IMPLIES
        is_ghost(vn, s) OR
        is_field(vn, pstate(s)) OR
        is_local(vn, pstate(s))

  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, vn : Name) :
      wf_state(mp)(s) IMPLIES
      wf_Program(program(mp)) IMPLIES
      is_ghost(vn, s) IMPLIES
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))


  % Instantiation of its semantics

  on_method_MVA(etype : EventType)
               (mp : MonitoredProgram, md : (wf_Method(program(mp))))
               (arg : ValOrExcpt)(s : MPState) : MPState =
    IF wf_state(mp)(s) AND 
       NOT stuck(s) AND
       methods(get_monitored_class(mp))(md) AND
       evs(mva(mp))((# etype := etype, mname := name(md) #)) 
    THEN IF up?(step(mva(mp))(astate(s), (# stP := st(pstate(s)),
                                            event := (# etype := etype,
                                                        mname := name(md) #),
                                                        arg := arg 
                                                     #)))
         THEN s WITH [astate := down(step(mva(mp))(astate(s), 
                                         (# stP := st(pstate(s)),
                                            event := (# etype := etype,
                                                        mname := name(md) #),
                                                        arg := arg 
                                                     #)))]
         ELSE s WITH [stuck := TRUE]
         ENDIF
    ELSE s
    ENDIF

  on_method_entry_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : (wf_Method(program(mp))), a : Val,
            arg : ValOrExcpt, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    EXISTS(s_new : MPState) :
      on_method_entry(mp, md, a, arg, s1, s_new, n, derive_rec) AND
      IF up?(ex(pstate(s_new)))
      THEN s2 = s_new
      ELSE s2 = on_method_MVA(Entry)(mp, md)(arg)(s_new)
      ENDIF


  on_method_exit_normal_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : (wf_Method(program(mp))), a : Val,
            arg : ValOrExcpt, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1)))
    THEN s1 = s2 AND n = 0
    ELSE
    EXISTS (m1, m2, m3 : nat, tau1, tau2, tau3 : MPState, v : Val,
            inv : (wf_Expr(program(mp)))) :
      n = m1 + m2 + m3 + 1 AND
      val?(arg) AND
      derive_rec(n)(mp)(post_set(md)(v(arg)), s1, v, tau1)(m1) AND
      v = return_of_stmt(tau1) AND
      tau2 = on_method_MVA(ExitNormal)(mp, md)(arg)(tau1)  AND
      inv = lookup_inv(program(mp), a) AND
      check_assertion(mp)(inv, tau2, tau3)(m2)(derive_rec(m2)) AND
      check_assertion(mp)(post(md)(v(arg)), tau3, s2)(m3)
                         (derive_rec(m3)) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  on_method_exit_exceptional_MP : (on_method_event_type) =
    LAMBDA (mp : MonitoredProgram, md : (wf_Method(program(mp))), a : Val,
            arg : ValOrExcpt, s1, s2 : MPState,
            n : nat, derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) AND NOT down(ex(pstate(s1))) = JMLExc
    THEN
    EXISTS (m1, m2 : nat, tau1, tau2, tau3 : MPState, v : Val,
            inv : (wf_Expr(program(mp)))) :
      n = m1 + m2 + 1 AND
      excpt?(arg) AND
      derive_rec(n)(mp)(exc_set(md)(e(arg)), 
                        update_PState(s1, catch), v, tau1)(m1) AND
      v = return_of_stmt(tau1) AND
      tau2 = on_method_MVA(ExitExceptional)(mp, md)(arg)(tau1) AND
      inv = lookup_inv(program(mp), a) AND
      check_assertion(mp)(inv, tau2, tau3)(m2)(derive_rec(m2)) AND
      s2 = (IF up?(ex(pstate(tau3)))
            THEN tau3
            ELSE update_PState(tau3, raise(down(ex(pstate(s1)))))
            ENDIF) AND
      st(pstate(s1)) = st(pstate(s2))
    ELSE s1 = s2 AND n = 0
    ENDIF


  IMPORTING Semantics[Name, MonitoredProgram, MPState,
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]


  initial_MP_state(mp : MonitoredProgram)(this_val : Val) : MPState =
    (# astate := initial_MVA_state(mva(mp)),
       stuck := FALSE,
       pstate := initial_Program_state(program(mp))(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, program(mp)) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_monitored_program(mp : MonitoredProgram)(main : Name, arg : int)
                       (this_val : Val)(final : MPState) : boolean =
    run_FullProgram(mp)(main, arg)(initial_MP_state(mp)(this_val), final)


  IMPORTING SemanticsProofs[Name, MonitoredProgram, MPState,
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]

  determ_step_MP : LEMMA % :-)
    FORALL (p : MonitoredProgram, n1, n2 : nat, b : (wf_Body(program(p))), sigma : MPState,
            sigma1, sigma2 : MPState, v1, v2 : Val) :
        derive(p)(b, sigma, v1, sigma1)(n1) AND
        derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND v1 = v2 AND n1 = n2


  % Well-formedness properties

  wf_initial_MP_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(this_val : (defined?)) :
      wf_MP(mp) IMPLIES wf_state(mp)(initial_MP_state(mp)(this_val))

   wf_update_PState : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState,
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(program(p))(pstate(s1)) IMPLIES
           wf_state(program(p))(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : MonitoredProgram, s1 : MPState,
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  wf_state_update_stack : LEMMA % :-)
    FORALL(p : MonitoredProgram, this_val : Val,
           arg : (getLocalDecls(program(p))),
           param_val : Val, lvds : finite_set[LocalVarDecl], s : MPState) :
      wf_state(p)(s) IMPLIES
      (FORALL (l : LocalVarDecl) :
         lvds(l) IMPLIES getLocalDecls(program(p))(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  on_method_MVA_yields_wf_AState : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, m : (wf_Method(program(mp))),
            et : EventType, arg : ValOrExcpt) :
      wf_state(mp)(s) IMPLIES
        wf_AState(mva(mp))(astate(on_method_MVA(et)(mp, m)(arg)(s)))

  on_method_MVA_yields_wf_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, m : (wf_Method(program(mp))),
            et : EventType, arg : ValOrExcpt) :
      wf_state(mp)(s) IMPLIES
        wf_state(mp)(on_method_MVA(et)(mp, m)(arg)(s))

  derive_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        wf_state(mp)(sigma2)


  on_method_MVA_never_leaves_halted : LEMMA % :-)
     FORALL (etype : EventType)
            (mp : MonitoredProgram, md : (wf_Method(program(mp))))
            (arg : ValOrExcpt, s : MPState) :
       complete(mva(mp)) IMPLIES
       cp(astate(s)) = halted IMPLIES
       cp(astate(on_method_MVA(etype)(mp, md)(arg)(s))) = halted

  derive_never_leaves_halted : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      cp(astate(sigma1)) = halted IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        cp(astate(sigma2)) = halted

  on_method_MVA_never_leaves_stuck : LEMMA % :-)
     FORALL (etype : EventType)
            (mp : MonitoredProgram, md : (wf_Method(program(mp))))
            (arg : ValOrExcpt, s : MPState) :
       stuck(s) IMPLIES
       stuck(on_method_MVA(etype)(mp, md)(arg)(s))

  derive_never_leaves_stuck : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      stuck(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        stuck(sigma2)

  partial_MVA_never_in_halted_in_wf_state : LEMMA % :-)
     FORALL (mp : MonitoredProgram, s : MPState) :
       partial(mva(mp)) IMPLIES
       wf_state(mp)(s) IMPLIES
       NOT cp(astate(s)) = halted

  complete_MVA_never_stuck_after_on_method_MVA : LEMMA % :-)
     FORALL (etype : EventType)
            (mp : MonitoredProgram, md : (wf_Method(program(mp))))
            (arg : ValOrExcpt, s : MPState) :
       NOT stuck(s) IMPLIES
       complete(mva(mp)) IMPLIES
       wf_state(mp)(s) IMPLIES
       NOT stuck(on_method_MVA(etype)(mp, md)(arg)(s))

  complete_MVA_never_stuck_after_derive : LEMMA % :-)
    FORALL (mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
           (sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      NOT stuck(sigma1) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
      derive(mp)(b, sigma1, v, sigma2)(n) IMPLIES
        NOT stuck(sigma2)

  on_method_entry_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_entry_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(mp)(sigma2)

  on_method_exit_normal_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) : 
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_normal_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(mp)(sigma2)

  on_method_exit_exceptional_yields_wf_state_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) : 
      wf_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_exceptional_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(mp)(sigma2)

  complete_MVA_never_stuck_after_on_method_entry_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_entry_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
       NOT stuck(sigma1) IMPLIES
       NOT stuck(sigma2)

  complete_MVA_never_stuck_after_on_method_exit_normal_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_normal_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
       NOT stuck(sigma1) IMPLIES
       NOT stuck(sigma2)

  complete_MVA_never_stuck_after_on_method_exit_exceptional_MP : LEMMA % :-)
    FORALL (mp : MonitoredProgram, m : (wf_Method(program(mp))), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : MPState, n : nat) :
      wf_and_complete_MP(mp) IMPLIES
      wf_state(mp)(sigma1) IMPLIES
        on_method_exit_exceptional_MP(mp, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(mp : MonitoredProgram)
               (b : (wf_Body(program(mp))), sigma1 : MPState, v : Val, 
                sigma2 : MPState)(m : below(k)) :
               derive(mp)(b, sigma1, v, sigma2)(m)) IMPLIES
       NOT stuck(sigma1) IMPLIES
       NOT stuck(sigma2)

END MonitoredProgramSemantics


MonitoredProgramCompletessRelation[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgramSemantics[CP, Name],
            MVACompletion[CP, Name]

  mp : VAR (wf_and_partial_MP)

  complete_MP(mp) : MonitoredProgram =
    (# mva := complete_MVA(mva(mp)),
       program := program(mp) #)

  complete_MP_wf_and_complete : JUDGEMENT % :-)
    complete_MP(mp) HAS_TYPE (wf_and_complete_MP)
  

  complete_MP_preserves_wf_body : LEMMA
    FORALL (b : (wf_Body(program(mp)))) : % :-)
      wf_Body(program(complete_MP(mp)))(b)

  complete_MP_preserves_wf_method : LEMMA % :-)
    FORALL (m : (wf_Method(program(mp)))) :
      wf_Method(program(complete_MP(mp)))(m)


  monitor_related_astates(sA1, sA2 : AState, stuck1 : boolean) : boolean =
    IF stuck1 THEN cp(sA2) = halted ELSE cp(sA1) = cp(sA2) ENDIF AND
    stA(sA1) = stA(sA2)


  monitor_related_states(mp)(s1, s2 : MPState) : boolean =
    monitor_related_astates(astate(s1), astate(s2), stuck(s1)) AND
    NOT stuck(s2) AND
    wf_state(mp)(s1) AND
    wf_state(complete_MP(mp))(s2) AND
    pstate(s1) = pstate(s2) AND
    gvs(s1) = gvs(s2)

  monitor_related_astates_consequence : LEMMA % :-)
    FORALL(s1, s2 : MPState) :
    monitor_related_states(mp)(s1, s2) IMPLIES
      (stuck(s1) IFF cp(astate(s2)) = halted)
      

  get_address_same_in_monitor_related_states : LEMMA % :-)
    FORALL(vn : Name, s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        get_address(vn, s1) = get_address(vn, s2)

  get_dynamic_type_name_same_in_monitor_related_states : LEMMA % :-)
    FORALL(vn : Name, s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        get_dynamic_type_name(vn, s1) = get_dynamic_type_name(vn, s2)


  monitor_related_states_implies_same_exception : LEMMA % :-)
    FORALL (s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES 
        ex(pstate(s1)) = ex(pstate(s2))

  monitor_related_states_implies_same_lookup : LEMMA % :-)
    FORALL (s1, s2 : MPState, n : Name) :
      monitor_related_states(mp)(s1, s2) IMPLIES 
        lookup(n, s1) = lookup(n, s2)

  monitor_related_states_preserved_by_update_local : LEMMA % :-)
    FORALL (s1, s2 : MPState)(vn : Name, v : (defined?)) :
      monitor_related_states(mp)(s1, s2) IMPLIES
      is_local(vn, pstate(s2)) IMPLIES
        monitor_related_states(mp)(update_PState(s1, update_local(vn, v)), 
                               update_PState(s2, update_local(vn, v)))

  monitor_related_states_preserved_by_catch : LEMMA % :-)
    FORALL (s1, s2 : MPState) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        monitor_related_states(mp)(update_PState(s1, catch), 
                               update_PState(s2, catch))

  monitor_related_states_preserved_by_raise : LEMMA % :-)
    FORALL (s1, s2 : MPState, e : Excpt) :
      monitor_related_states(mp)(s1, s2) IMPLIES
        monitor_related_states(mp)(update_PState(s1, raise(e)), 
                               update_PState(s2, raise(e)))

  monitor_related_states_preserved_by_update_stack : LEMMA % :-)
    FORALL (sMP1, sMP2 : MPState,
            this_val : Val, arg :  (getLocalDecls(program(mp))), 
            param_val : Val, lvds : finite_set[LocalVarDecl]) :
      monitor_related_states(mp)(sMP1, sMP2) IMPLIES
      (FORALL (l : LocalVarDecl) : lvds(l) IMPLIES 
                                   getLocalDecls(program(mp))(l)) IMPLIES
        monitor_related_states(mp)(update_stack(this_val, arg, param_val,
                                                lvds, sMP1),
                                   update_stack(this_val, arg, param_val,
                                                lvds, sMP2))

  monitor_related_astates_preserved_by_on_method_MVA : LEMMA % :-)
    FORALL(s1, s2 : MPState, etype : EventType,
           md : (wf_Method(program(mp))), arg : ValOrExcpt) :
      monitor_related_astates(astate(s1), astate(s2), stuck(s1)) IMPLIES
      wf_state(mp)(s1) IMPLIES
      wf_state(complete_MP(mp))(s2) IMPLIES
      pstate(s1) = pstate(s2) IMPLIES
      NOT stuck(s2) IMPLIES
        monitor_related_astates
          (astate(on_method_MVA(etype)(mp, md)(arg)(s1)), 
           astate(on_method_MVA(etype)(complete_MP(mp), md)(arg)(s2)),
           stuck(on_method_MVA(etype)(mp, md)(arg)(s1)))

  monitor_related_states_initial_MP_states : LEMMA  % :-)
    FORALL (root_object : (defined?)) :
    monitor_related_states(mp)(initial_MP_state(mp)(root_object), 
                           initial_MP_state(complete_MP(mp))(root_object))

  monitor_related_states_preserved_by_derive : LEMMA % :-)
    FORALL (b : (wf_Body(program(mp))), v1, v2 : Val)
           (s1a, s1b, s2a, s2b : MPState) 
           (n1, n2 : nat) :
      monitor_related_states(mp)(s1a, s1b) IMPLIES
      derive(mp)(b, s1a, v1, s2a)(n1) IMPLIES
      derive(complete_MP(mp))(b, s1b, v2, s2b)(n2) IMPLIES
        monitor_related_states(mp)(s2a, s2b) AND v1 = v2 

  % in method call case
 monitor_related_states_implies_derive : LEMMA % :-)
    FORALL (b : (wf_Body(program(mp))), v : Val)
           (s1a, s1b, s2a : MPState) 
           (n1 : nat) :
      monitor_related_states(mp)(s1a, s1b) IMPLIES
      derive(mp)(b, s1a, v, s2a)(n1) IMPLIES
      EXISTS (s2b : MPState, n2 : nat) : 
      derive(complete_MP(mp))(b, s1b, v, s2b)(n2) 

 monitor_related_states_implies_derive_converse : LEMMA % :-)
    FORALL (b : (wf_Body(program(mp))), v : Val)
           (s1a, s1b, s2a : MPState) 
           (n1 : nat) :
      monitor_related_states(mp)(s1b, s1a) IMPLIES
      derive(complete_MP(mp))(b, s1a, v, s2a)(n1) IMPLIES
      EXISTS (s2b : MPState, n2 : nat) : 
      derive(mp)(b, s1b, v, s2b)(n2)
  
  correctness_of_complete_MP : THEOREM % :-)
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (s1, s2 : MPState) :
      run_monitored_program(mp)(main, arg)(root_object)(s1) IMPLIES
      EXISTS (s2 : MPState) : 
        run_monitored_program(complete_MP(mp))(main, arg)(root_object)(s2) AND
        monitor_related_states(mp)(s1, s2)

END MonitoredProgramCompletessRelation
