AnnGenerationLemmas[CP : TYPE+] : THEORY
BEGIN

  IMPORTING APSemanticsProperties[string],
            MonitoredProgramSemantics[CP, string],
            AnnotateProgramProperties[CP, string],
            listfuncs,
            WFProperties

  % Says if an MVA state is modeled by a state of an annotated program
  MVA_modeled?(a : MVA)(sA : AState, sAP : APState) : boolean =
    (Int(unique(cp(sA))) = gvs(sAP)(cp)) AND
    (FORALL (q : CP) : cps(a)(q) IMPLIES
      Int(unique(q)) = gvs(sAP)(name_of(q))) AND
    (FORALL (n : string) : NOT Bottom?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n))

  halted_implies_JMLExc(sA : AState, sAP : APState) : boolean =
    cp(sA) = halted IMPLIES
      up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc

  % Says if sAP is a super state of sMP
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND
    FORALL (n : string) : NOT Bottom?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(mp : MonitoredProgram, ap : Program)
             (sMP : MPState, sAP : APState) : boolean =
    ann_program_pre(mp) AND
    ap = ann_program(mp) AND
    wf_state(mp)(sMP) AND
    wf_state(ap)(sAP) AND
    MVA_modeled?(mva(mp))(astate(sMP), sAP) AND
    halted_implies_JMLExc(astate(sMP), sAP) AND
    Program_modeled?(sMP, sAP)

  specification_requirements(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND
    complete(mva(mp)) AND
    well_typed_Program(mp) AND
    ann_program_pre(mp) AND
    well_behaved_MP(mp)


  ann_action_is_sequence_of_sets : LEMMA % :-)
    FORALL (a : Action) :
      sequence_of_sets(ann_action(a))

  % PROVE: One case left (CaseJML with every and some)
  stmt_subterm_is_transitive : LEMMA
    FORALL (c1, c2, c3 : Stmt) :
      c1 << c2 AND c2 << c3 IMPLIES c1 << c3

  sequence_of_sets_have_no_side_effects : LEMMA % :-)
    FORALL (p : Program, a : Class, m : Method, c  : Stmt, t : Transition) :
      assertions_have_no_side_effects(p) IMPLIES
      classes(p)(a) IMPLIES
      methods(a)(m) IMPLIES
      set_subterm_AP(update_vars(t), m) IMPLIES
      c << update_vars(t) IMPLIES
        Skip?(c) OR
        (Set?(c) IMPLIES
          FORALL (tau1, tau2 : APState, v : Val, n2 : nat) :
            deriv_expr(p)(source(c), tau1, v, tau2)(n2) IMPLIES tau1 = tau2)

%   ann_action_sets_mva_vars : LEMMA
%     FORALL (vn : Name, c : Stmt, a : MVA, t : Transition) :
%       wf_MVA(a) IMPLIES
%       ts(a)(t) IMPLIES
%       c << ann_action(action(t)) IMPLIES

  ann_action_correcteness : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program,
            a : Class, m : Method, t : Transition,  n : nat,
            sMVA : AState, sMP : MPState, sAP1, sAP2 : APState) :
      specification_requirements(mp) IMPLIES
      MP_modeled?(mp, ap)(sMP, sAP1) IMPLIES
      classes(ap)(a) IMPLIES
      methods(a)(m) IMPLIES
      set_subterm_AP(update_vars(t), m) IMPLIES
      ts(mva(mp))(t) IMPLIES
      sMVA = (# cp := tcp(t),
                stA := execute_action(action(t))(stA(astate(sMP)),
                                                 st(pstate(sMP)))
             #) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      deriv_stmt(ap)(update_vars(t), sAP1, sAP2)(n) IMPLIES
        MVA_modeled?(mva(mp))(sMVA, sAP2)

  % This can not be proved without having an explicit way of translating a
  % guard into an expression. Here is where the assumption that guards can be
  % translated into Java expressions
  guard_to_expr_exists : AXIOM
    FORALL (mp : MonitoredProgram, t : Transition) :
      ts(mva(mp))(t) IMPLIES
      nonempty?({e: Expr |
                  FORALL (stA: (wf_Store[CP, string](mva(mp))),
                          stP: (wf_PSt[CP, string](mva(mp))))
                         (sMP1, sMP2: MPState, v: Val, n: nat):
                    pstate(sMP1) = (# ex := bottom, st := stP #) IMPLIES
                    deriv_expr(mp)(e, sMP1, v, sMP2)(n) IMPLIES 
                    Bool?(v) IMPLIES b(v) = guard(t)(stA, stP)})

  ann_guard_actions_not_empty : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ts : finite_set[Transition],
            q : CP, e : Event) :
      wf_MP(mp) IMPLIES
      NOT empty?(ts) IMPLIES
      ts = {t : Transition | ts(mva(mp))(t) AND scp(t) = q AND event(t) = e}
      IMPLIES
        NOT null?(ann_guard_actions(mp)(ts))

  MP_modeled_preserved_by_ann_event : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, m1 : Method)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n : nat, ts : set[Transition], et : EventType) :
      MP_modeled?(mp, ap)(sMP1, sAP1) IMPLIES
      astate(sMP2) = on_method_MVA(et)(mp, m1, sMP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      ts = filter_event(mva(mp))(et)(name(m1)) IMPLIES
      deriv_stmt(ap)(ann_event(mp)(ts), sAP1, sAP2)(n) IMPLIES
        MVA_modeled?(mva(mp))(astate(sMP2), sAP2)
 

END AnnGenerationLemmas
