AnnGenerationLemmas[CP : TYPE+] : THEORY
BEGIN

  ASSUMING
    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)
  ENDASSUMING

  IMPORTING Equivalence[CP],
            listfuncs


  exists_MVAVarDecl : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : MPState, n : string) :
      wf_state(mp)(s) IMPLIES
      NOT Bottom?(stA(astate(s))(n)) IMPLIES
        EXISTS (va : MVAVarDecl) : vdsA(mva(mp))(va) AND name(va) = n

  execute_action_correctness : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, c : Class, m : Method,
            a : Action, vn : string, n : nat, 
            sMVA : AState, sMP : MPState, sAP1, sAP2 : APState) :
      specification_requirements(mp) IMPLIES
      related_states(mp, ap)(sMP, sAP1) IMPLIES
      classes(ap)(c) IMPLIES
      methods(c)(m) IMPLIES
      set_subterm_AP(ann_action(a), m) IMPLIES
      wf_Action(mva(mp))(a) IMPLIES
      deriv_stmt(ap)(ann_action(a), sAP1, sAP2)(n) IMPLIES
      stA(sMVA) = execute_action(a)(stA(astate(sMP)), st(pstate(sMP))) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      NOT Bottom?(stA(astate(sMP))(vn)) IMPLIES
        stA(sMVA)(vn) = gvs(sAP2)(vn)

  stmt_subterm_is_transitive : LEMMA % :-)
    FORALL (c1, c2, c3 : Stmt) :
      c1 << c2 AND c2 << c3 IMPLIES c1 << c3

  sub_set_stmt(c : Stmt, a : Action) : RECURSIVE boolean =
    CASES a OF
      null : FALSE,
      cons(x, xs) : c = Set(target(x), source(x)) OR sub_set_stmt(c, xs)
    ENDCASES
    MEASURE length(a)

  sub_set_stmt_ann_action_is_subterm : LEMMA % :-)
    FORALL (c : Stmt, a : Action) :
      sub_set_stmt(c, a) IMPLIES c << ann_action(a)

  non_interference_of_sets_in_ann_actions : LEMMA % :-)
    FORALL (p : Program, a : Action, s1, s2 : APState,
            n : nat, vn : string) :
      (FORALL (c : Stmt) :
        sub_set_stmt(c, a) IMPLIES
        Set?(c) IMPLIES
          NOT target(c) = vn AND
          FORALL (tau1, tau2 : APState, v : Val, n2 : nat) :
            deriv_expr(p)(source(c), tau1, v, tau2)(n2) IMPLIES tau1 = tau2)
      IMPLIES
      deriv_stmt(p)(ann_action(a), s1, s2)(n) IMPLIES
        gvs(s1)(vn) = gvs(s2)(vn)

  ann_action_sets_mva_vars : LEMMA % :-)
    FORALL (vn : string, c : Stmt, a : MVA, l : Action) :
      wf_Action(a)(l) IMPLIES
      Set?(c) IMPLIES
      sub_set_stmt(c, l) IMPLIES
      vn = target(c) IMPLIES
        var_names(vdsA(a))(vn)

  sequence_of_sets_have_no_side_effects : LEMMA % :-)
    FORALL (p : Program, a : Class, m : Method, c  : Stmt, t : Transition) :
      assertions_have_no_side_effects(p) IMPLIES
      classes(p)(a) IMPLIES
      methods(a)(m) IMPLIES
      set_subterm_AP(update_vars(t), m) IMPLIES
      c << update_vars(t) IMPLIES
        Skip?(c) OR
        (Set?(c) IMPLIES
          FORALL (tau1, tau2 : APState, v : Val, n2 : nat) :
            deriv_expr(p)(source(c), tau1, v, tau2)(n2) IMPLIES tau1 = tau2)

  % TODO Adapt the proof:
  % execute_action_correctness has changed
  % related_states now includes specification_requirements
  % use wf_program_variables_disjoint instead of 
  % wf_program_has_unique_ghost_var_decl
  update_vars_correctness : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program,
            a : Class, m : Method, t : Transition,  n : nat,
            sMVA : AState, sMP : MPState, sAP1, sAP2 : APState) :
%      specification_requirements(mp) IMPLIES
      related_states(mp, ap)(sMP, sAP1) IMPLIES
      classes(ap)(a) IMPLIES
      methods(a)(m) IMPLIES
      set_subterm_AP(update_vars(t), m) IMPLIES
      ts(mva(mp))(t) IMPLIES
      sMVA = (# cp := tcp(t),
                stA := execute_action(action(t))(stA(astate(sMP)),
                                                 st(pstate(sMP)))
             #) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      deriv_stmt(ap)(update_vars(t), sAP1, sAP2)(n) IMPLIES
        MVA_modeled?(mva(mp))(sMVA, sAP2)

  % This can not be proved without having an explicit way of translating a
  % guard into an expression. Here is where the assumption that guards can be
  % translated into Java expressions
  guard_to_expr_exists : AXIOM
    FORALL (mp : MonitoredProgram, t : Transition) :
      ts(mva(mp))(t) IMPLIES
      nonempty?({e: Expr |
                  FORALL (stA: (wf_Store[CP, string](mva(mp))),
                          stP: (wf_PSt[CP, string](mva(mp))))
                         (sMP1, sMP2: MPState, v: Val, n: nat):
                    pstate(sMP1) = (# ex := bottom, st := stP #) IMPLIES
                    deriv_expr(mp)(e, sMP1, v, sMP2)(n) IMPLIES 
                    Bool?(v) IMPLIES b(v) = guard(t)(stA, stP)})

  ann_guard_actions_not_empty : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ts : finite_set[Transition],
            q : CP, e : Event) :
      wf_MP(mp) IMPLIES
      NOT empty?(ts) IMPLIES
      ts = {t : Transition | ts(mva(mp))(t) AND scp(t) = q AND event(t) = e}
      IMPLIES
        NOT null?(ann_guard_actions(mp)(ts))

  % Rename to ann_event_correctness
  MP_modeled_preserved_by_ann_event : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, m1 : Method)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n : nat, ts : set[Transition], et : EventType) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      astate(sMP2) = on_method_MVA(et)(mp, m1, sMP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      ts = filter_event(mva(mp))(et)(name(m1)) IMPLIES
      deriv_stmt(ap)(ann_event(mp)(ts), sAP1, sAP2)(n) IMPLIES
        MVA_modeled?(mva(mp))(astate(sMP2), sAP2)

 
END AnnGenerationLemmas
