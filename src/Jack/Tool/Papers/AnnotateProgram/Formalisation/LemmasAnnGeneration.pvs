AnnGenerationLemmas[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, string],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string],
            AnnotateProgram[CP],
            AnnotateProgramProperties[CP, string],
            listfuncs

  % Says if an MVA state is modeled by a state of an annotated program
  MVA_modeled?(a : MVA)(sA : AState, sAP : APState) : boolean =
    (Int(unique(cp(sA))) = gvs(sAP)(cp)) AND
    (FORALL (q : CP) : cps(a)(q) IMPLIES
      Int(unique(q)) = gvs(sAP)(name_of(q))) AND
    (FORALL (n : string) : NOT Bottom?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)) AND
    (cp(sA) = halted IMPLIES
      up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc)

  % Says if sAP is a super state of sMP
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND
    FORALL (n : string) : NOT Bottom?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(mp : MonitoredProgram, ap : Program)
             (sMP : MPState, sAP : APState) : boolean =
    ann_program_pre(mp) AND
    ap = ann_program(mp) AND
    wf_state(mp)(sMP) AND
    wf_state(ap)(sAP) AND
    MVA_modeled?(mva(mp))(astate(sMP), sAP) AND
    Program_modeled?(sMP, sAP)

  non_interference_of_set_stmt : LEMMA % :-)
    FORALL (p : Program, c : Stmt, s1, s2 : APState, n : nat, vn : string) :
      Set?(c) AND
      NOT target(c) = vn IMPLIES
      (FORALL (tau1, tau2 : APState, v : Val, n2 : nat) :
        deriv_expr(p)(source(c), tau1, v, tau2)(n2) IMPLIES tau1 = tau2)
      IMPLIES
      deriv_stmt(p)(c, s1, s2)(n) IMPLIES
        gvs(s1)(vn) = gvs(s2)(vn)

  sequence_of_sets(c : Stmt) : RECURSIVE boolean =
    Skip?(c) OR Sequence?(c) AND Set?(s1(c)) AND sequence_of_sets(s2(c))
    MEASURE c BY <<

  ann_action_is_sequence_of_sets : LEMMA % :-)
    FORALL (a : Action) :
      sequence_of_sets(ann_action(a))

  non_interference_of_set_stmt_sequence : LEMMA % :-)
    FORALL (p : Program, sets : (sequence_of_sets), s1, s2 : APState, 
            n : nat, vn : string) :
      (FORALL (c : Stmt) :
        c << sets IMPLIES
          Skip(c) OR
          (Set?(c) IMPLIES
            NOT target(c) = vn AND
            FORALL (tau1, tau2 : APState, v : Val, n2 : nat) :
              deriv_expr(p)(source(c), tau1, v, tau2)(n2) IMPLIES tau1 = tau2))
        IMPLIES
        deriv_stmt(p)(sets, s1, s2)(n) IMPLIES
          gvs(s1)(vn) = gvs(s2)(vn)

  ann_action_correcteness : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, 
            t : Transition, c : Class, m : Method,
            sMVA : AState, sMP : MPState, sAP1, sAP2 : APState,  n : nat) :
      assertions_have_no_side_effect(ap) IMPLIES
      MP_modeled?(mp, ap)(sMP, sAP1) IMPLIES
      ts(mva(mp))(t) IMPLIES
      classes(program(mp))(c) IMPLIES
      name(c) = class_name(mva(mp)) IMPLIES
      sMVA = (# cp := tcp(t),
                stA := execute_action(action(t))(stA(astate(sMP)), 
                                                 st(pstate(sMP)))
             #) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      deriv_stmt(ap)(update_vars(t), sAP1, sAP2)(n) IMPLIES
        MVA_modeled?(mva(mp))(sMVA, sAP2)

  % This can not be proved without having an explicit way of translating a
  % guard into an expression. Here is where the assumption that guards can be
  % translated into Java expressions
  guard_to_expr_exists : AXIOM
    FORALL (mp : MonitoredProgram, t : Transition) :
      ts(mva(mp))(t) IMPLIES
      nonempty?({e: Expr |
                  FORALL (stA: (wf_Store[CP, string](mva(mp))),
                          stP: (wf_PSt[CP, string](mva(mp))))
                         (sMP1, sMP2: MPState, v: Val, n: nat):
                    pstate(sMP1) = (# ex := bottom, st := stP #) IMPLIES
                    deriv_expr(mp)(e, sMP1, v, sMP2)(n) IMPLIES 
                    Bool?(v) IMPLIES b(v) = guard(t)(stA, stP)})

  ann_guard_actions_not_empty : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ts : finite_set[Transition],
            q : CP, e : Event) :
      wf_MP(mp) IMPLIES
      NOT empty?(ts) IMPLIES
      ts = {t : Transition | ts(mva(mp))(t) AND scp(t) = q AND event(t) = e}
      IMPLIES
        NOT null?(ann_guard_actions(mp)(ts))

  CaseJML_exclusive_branches_semantics : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2, tau : APState,
            n1, n : nat, b1 : [Expr, Stmt]) :
      NOT up?(ex(pstate(s1))) IMPLIES
      n > 0 IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (deriv_expr(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [Expr, Stmt], tau : APState, v : Val, m2 : below(n)) :
        member(b2, bs) IMPLIES
        NOT b1 = b2 IMPLIES
        (deriv_expr(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          s1 = tau AND v = Bool(FALSE))) IMPLIES
        deriv_stmt(p)(PROJ_2(b1), s1, tau)(n1) IMPLIES
        deriv_stmt(p)(CaseJML(bs), s1, s2)(n) IMPLIES
          s2 = tau

  CaseJML_evalueates_true_stmt : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2 : APState, n : nat,
            b1 : [Expr, Stmt]) :
      NOT up?(ex(pstate(s1))) IMPLIES
      n > 0 IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (deriv_expr(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [Expr, Stmt], tau : APState, v : Val, m2 : below(n)) :
        member(b2, bs) IMPLIES
        before(b2, b1, bs) IMPLIES
        (deriv_expr(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          NOT up?(ex(pstate(tau))) AND
          s1 = tau AND v = Bool(FALSE))) IMPLIES
      deriv_stmt(p)(CaseJML(bs), s1, s2)(n) IMPLIES
        EXISTS (tau : APState, n1 : nat) : 
          deriv_stmt(p)(PROJ_2(b1), s1, tau)(n1)

  MP_modeled_preserved_by_ann_event : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, m1 : Method)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n : nat, ts : set[Transition], et : EventType) :
      MP_modeled?(mp, ap)(sMP1, sAP1) IMPLIES
      astate(sMP2) = on_method_MVA(et)(mp, m1, sMP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      ts = filter_event(mva(mp))(et)(name(m1)) IMPLIES
      deriv_stmt(ap)(ann_event(mp)(ts), sAP1, sAP2)(n) IMPLIES
        MVA_modeled?(mva(mp))(astate(sMP2), sAP2)
 

END AnnGenerationLemmas
