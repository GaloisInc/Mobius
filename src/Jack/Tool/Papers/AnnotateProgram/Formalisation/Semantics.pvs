% Operational semantics, section 3.2

Excpt : DATATYPE
BEGIN

  Throwable : Throwable?
  NullPointer : NullPointer?
  JMLExc : JMLExc?


END Excpt


% NOTE: Bottom is used to model the partiality of Store. We may define Store as
% Store(ns : set[Name]) : TYPE [{n : Name | ns(n)} -> Val], but then the names
% for which it is defined will be in the type. That would be inconvenient,
% specially for programs, which have three stores (and the values for which lvs
% is defined change over time).
% Do not confuse Bottom (a Val) with bottom, a constructor of the lift datatype
Val : DATATYPE 
BEGIN

  Int(i : int) : Int?
  Bool(b : bool) : Bool?
  Null : Null?
  RefType(a : int) : RefType?
  Unit : Unit?        % dummy value returned to void functions
  Bottom : Bottom?    % undefined value


END Val


State[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Excpt,
            WellFormedProgram[Name],
            Val

  % Functions whose existence we assume
  % Parameters: program, target object, method name, actual parameter
  % NOTE: This is a simplification, we should use the types of the expressions,
  % not their values, but we are not modeling types.
  lookup_mthd : [Program, Val, Name, Expr -> lift[Method]]

  % Parameters: program, target object
  lookup_inv : [Program, Val -> lift[BoolExpr]]


  Store : TYPE = [Name -> Val]

  % Field, ghost and local variables
  % fvs, gvs and lvs are partial functions from name to values
  % Values are integers
  % If it supposed to be a boolean, <= 0 = False, > 0 = True
  PSt : TYPE = [# fvs, lvs : Store #]

  PState : TYPE = [# ex : lift[Excpt],
                     st : PSt #]

  lift_PSt(p : PSt) : PState =
    (# ex := bottom, st := p #)

  CONVERSION lift_PSt

  % So far, I'm not modelling that the sets are disjoint
  % This would imply adding a test to update, that vn is in the domain

  is_local(vn : Name, sigma : PState) : bool =
    NOT Bottom?(lvs(st(sigma))(vn))

  is_field(vn : Name, sigma : PState) : bool =
    NOT Bottom?(fvs(st(sigma))(vn))

  lookup_local(vn : Name, sigma : PState) : Val =
    lvs(st(sigma))(vn)

  lookup_field(vn : Name, sigma : PState) : Val =
    fvs(st(sigma))(vn)

  update_local(vn : Name, v : Val, sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)),
                lvs := lvs(st(sigma)) WITH [vn := v] #) #)

  % Used in the general semantics (consider removing the other later)
  update_local(vn : Name, v : Val)(sigma : PState) : PState =
    update_local(vn, v, sigma)
                
  update_field(vn : Name, v : Val, sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)) WITH [vn := v],
                lvs := lvs(st(sigma)) #) #)

  update_field(vn : Name, v : Val)(sigma : PState) : PState =
    update_field(vn, v, sigma)

  lookup(vn : Name, sigma : PState) : Val =
    IF is_local(vn, sigma)
    THEN lookup_local(vn, sigma)
    ELSE lookup_field(vn, sigma)
    ENDIF

  update(vn : Name, v : Val, sigma : PState) : PState =
    IF is_local(vn, sigma)
    THEN update_local(vn, v, sigma)
    ELSE update_field(vn, v, sigma)
    ENDIF
 

  val2int(v : Val) : int = 
    IF Int?(v) 
    THEN i(v) 
    ELSE 0 
    ENDIF

  val2bool(v : Val) : bool =
    IF Bool?(v)
    THEN b(v)
    ELSE FALSE
    ENDIF


END State


Evaluation[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name],
            SizeFunctions[Name]

  % I'm evaluating division by 0 to 0, I do not want to care about 
  % modeling that exception here
  % the result is floored (this should actually be analysed, sometimes floor, 
  % sometimes ceil)

  % also, looking up a non-existing variable just returns 0
  eval(n : NumExpr)(sigma : PState) : RECURSIVE int =
    CASES n OF
      Int(i) : i,
      Plus(n1, n2) : eval(n1)(sigma) + eval(n2)(sigma),
      Minus(n1, n2) : eval(n1)(sigma) - eval(n2)(sigma),
      Times(n1, n2) : eval(n1)(sigma) * eval(n2)(sigma),
      Div(n1, n2) : IF eval(n2)(sigma) = 0 
                    THEN 0
                    ELSE floor(eval(n1)(sigma) / eval(n2)(sigma))
                    ENDIF,
      NumVarEval(vn) : val2int(lookup(vn, sigma))
    ENDCASES
  MEASURE size(n)

  eval(b : BoolExpr)(sigma : PState) : RECURSIVE bool =
    CASES b OF
      TT : TRUE,
      FF : FALSE,
      Neg(b) : NOT eval(b)(sigma),
      Conj(b1, b2) : eval(b1)(sigma) AND eval(b2)(sigma),
      Disj(b1, b2) : eval(b1)(sigma) OR eval(b2)(sigma),
      Lt(b1, b2) : eval(b1)(sigma) < eval(b2)(sigma),
      Le(b1, b2) : eval(b1)(sigma) <= eval(b2)(sigma),
      Eq(b1, b2) : eval(b1)(sigma) = eval(b2)(sigma),
      Neq(b1, b2) : eval(b1)(sigma) /= eval(b2)(sigma),
      Gt(b1, b2) : eval(b1)(sigma) > eval(b2)(sigma),
      Ge(b1, b2) : eval(b1)(sigma) >= eval(b2)(sigma),
      BoolVarEval(vn) : val2bool(lookup(vn, sigma))
    ENDCASES
  MEASURE size(b)

END Evaluation


Semantics[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING Program) program : [FullProgram -> Program[Name]],
          (IMPORTING State)  pstate : [FullState -> PState[Name]],
          update_FullState : {f : [[PState[Name] -> PState[Name]], FullState 
              -> FullState] |
            FORALL (s1, s2 : FullState, upd : [PState[Name] -> PState[Name]]) :
              f(upd, s1) = s2 IMPLIES pstate(s2) = upd(pstate(s1))},
          execute_set : {f : [[Name, Val, FullState] -> FullState] |
             FORALL (vn : Name, v : Val, s1, s2 : FullState) :
               f(vn, v, s1) = s2 IMPLIES pstate(s1) = pstate(s2)},
          execute_pre, execute_post, execute_inv : 
            [[boolean, FullState] -> FullState],
%             {f : [[Val, FullState] -> FullState] |
%               FORALL (v : Val, s1, s2 : FullState) :
%                 f(v, s1) = s2 IMPLIES pstate(s1) = pstate(s2)},
          on_method_entry, on_method_exit_normal, on_method_exit_exceptional :
            {f : [Method[Name], FullProgram, FullState -> FullState] | 
              FORALL (md : Method[Name], p : FullProgram, s1, s2 : FullState) : 
                f(md, p, s1) = s2 IMPLIES pstate(s1) = pstate(s2)}
         ] : THEORY
BEGIN

  IMPORTING Evaluation[Name]

  default_value(t : JType) : Val =
    CASES t OF
      IntType : Int(0),
      BoolType : Bool(FALSE),
      Void : Unit,
      RefType : Null
    ENDCASES

  initial_Program_state(p : FullProgram) : PState =
    (# ex := bottom,
       st :=
         (# fvs := LAMBDA (n : Name) :
              LET fd = get_FieldDecl(n, program(p)) IN
              IF bottom?(fd)
              THEN Bottom
              ELSE init_val(down(fd))
              ENDIF,
            lvs := LAMBDA (n : Name) :
              LET ld = get_LocalVarDecl(n, program(p)) IN
              IF bottom?(ld)
              THEN Bottom
              ELSE default_value(jtype(down(ld)))
              ENDIF
         #)
    #)


  deriv_expr(p : FullProgram)
            (c : Expr, sigma1 : FullState, v : Val, sigma2 : FullState)
            (n : nat)
            (deriv_stmt : [FullProgram -> [Stmt, FullState, FullState -> 
              [below(n) -> bool]]]) : RECURSIVE bool =
    LET deriv_stmt_rec = 
      LAMBDA(k : below(n)) :
        LAMBDA(p : FullProgram)(s : Stmt, sigma1, sigma2 : FullState)
              (m : below(k)) : deriv_stmt(p)(s, sigma1, sigma2)(m)
    IN
    IF up?(ex(pstate(sigma1)))
    % sigma1 is an exceptional state
    % exceptions are simply propagated
    THEN sigma1 = sigma2 AND v = Bottom AND n = 0
    ELSE % sigma1 is a normal state
    CASES c OF
      Assign(vn, e) :
        is_local(vn, pstate(sigma1)) AND
        NOT Bottom?(v) AND
        n > 0 AND
        (EXISTS (tau : FullState) : 
           deriv_expr(p)(e, sigma1, v, tau)(n - 1)(deriv_stmt_rec(n - 1)) AND
           sigma2 = (IF up?(ex(pstate(tau)))
                     THEN tau
                     ELSE update_FullState(update_local(vn, v), tau)
                     ENDIF)),
      BExpr(b) :
        sigma1 = sigma2 AND 
        NOT Bottom?(v) AND
        v = Bool(eval(b)(pstate(sigma1))) AND
        n = 0,
      CondExpr(c, t, e) :
        n > 0 AND
        IF eval(c)(pstate(sigma1))
        THEN deriv_expr(p)(t, sigma1, v, sigma2)(n - 1)(deriv_stmt_rec(n - 1))
        ELSE deriv_expr(p)(e, sigma1, v, sigma2)(n - 1)(deriv_stmt_rec(n - 1))
        ENDIF,
      MethodCall(e, mn, p) :
        EXISTS (m1, m2, m3, m4, m5 : nat)
               (a, pv : Val)
               (tau1, tau2, tau3, tau4, tau5, tau6,
                tau7, tau8, tau9, tau10 : FullState)
               (old_val_arg : Val)(md : Method)(inv : BoolExpr) :
          n = m1 + m2 + m3 + m4 + m5 + 1 AND
          deriv_expr(p)(e, sigma1, a, tau1)(m1)(deriv_stmt_rec(m1)) AND
          deriv_expr(p)(p, tau1, pv, tau2)(m2)(deriv_stmt_rec(m2)) AND
          (tau3 = (IF up?(ex(pstate(tau1))) AND Null?(a)
                   THEN update_FullState(LAMBDA (s : PState) : s WITH 
                                           [ex := up(NullPointer)], tau2)
                   ELSE tau2
                   ENDIF)) AND
          md = down(lookup_mthd(program(p), a, mn, p)) AND
          inv = down(lookup_inv(program(p), a)) AND
          eval(inv)(pstate(tau3)) AND
          tau4 = execute_inv(eval(inv)(pstate(tau3)), tau3) AND
          tau5 = execute_pre(eval(pre(md))(pstate(tau4)), tau4) AND
          old_val_arg = lookup_local(name(arg(md)), pstate(tau5)) AND
          tau6 = update_FullState(update_local(name(arg(md)), pv), tau5) AND
          tau7 = on_method_entry(md, p, tau6) AND
          deriv_stmt(p)(body(md), tau7, tau8)(m4) AND
          deriv_expr(p)(res(md), tau8, v, tau9)(m5)(deriv_stmt_rec(m5)) AND
          tau10 = IF bottom?(ex(pstate(tau9)))
                  THEN on_method_exit_normal(md, p, tau9)
                  ELSE on_method_exit_exceptional(md, p, tau9)
                  ENDIF AND
          sigma2 = update_FullState(update_local(name(arg(md)), old_val_arg),
                                    tau10) AND
          eval(inv)(pstate(sigma2)) AND
          eval(post(md))(pstate(sigma2)),
      NExpr(n) : 
        sigma1 = sigma2 AND
        NOT Bottom?(v) AND
        v = Int(eval(n)(pstate(sigma1))) AND
        n = 0
    ENDCASES
    ENDIF
  MEASURE n
    

  deriv_stmt(p : FullProgram)(c : Stmt, sigma1, sigma2 : FullState)
            (n : nat) : RECURSIVE bool =
    LET deriv_stmt_rec = 
        LAMBDA(k : below(n)) : 
          LAMBDA(p : FullProgram)(s : Stmt, sigma1, sigma2 : FullState)
                (m : below(k)) : deriv_stmt(p)(s, sigma1, sigma2)(m)
    IN
    IF up?(ex(pstate(sigma1)))
    % sigma1 is an exceptional state
    % exceptions are simply propagated
    THEN sigma1 = sigma2 AND n = 0
    ELSE % sigma1 is a normal state
    CASES c OF
      CaseJML(l) :
         CASES l OF
         null : sigma1 = sigma2 AND n = 0,
         cons(x, xs) : deriv_stmt(p)
                                 (IfThenElse(proj_1(x), proj_2(x), CaseJML(xs)),
                                   sigma1, sigma2)
                                 (n - 1)
                       AND n > 0
         ENDCASES,
      IfThenElse(e, c1, c2) :
          n > 0 AND
          deriv_stmt(p)(IF eval(e)(pstate(sigma1)) THEN c1 ELSE c2 ENDIF,
                           sigma1, sigma2)(n - 1),
      Sequence(c1, c2) :
         EXISTS(m1, m2 : nat)(tau : FullState) :
           n = m1 + m2 + 1 AND
           deriv_stmt(p)(c1, sigma1, tau)(m1) AND
           deriv_stmt(p)(c2, tau, sigma2)(m2),
      Set(vn, e) :
         n > 0 AND
         EXISTS (tau : FullState)(v : Val) :
           deriv_expr(p)(e, sigma1, v, tau)(n - 1)(deriv_stmt_rec(n - 1)) AND
           sigma2 = execute_set(vn, v, tau),
      Skip : sigma1 = sigma2 AND n = 0,
      StmtExpr(e) :
         n > 0 AND
         EXISTS (v : Val) :
           deriv_expr(p)(e, sigma1, v, sigma2)(n - 1)(deriv_stmt_rec(n - 1)),
      Throw: 
        sigma2 = update_FullState(LAMBDA (s : PState) : 
                                    s WITH [ex := up(Throwable)],
                                  sigma1) AND
        n = 0,
      TryCatch(c1, c2, c3) :
        EXISTS(m1, m2, m3 : nat)(tau1, tau2, tau3 : FullState) :
          n = m1 + m2 + m3 + 1 AND
          deriv_stmt(p)(c1, sigma1, tau1)(m1) AND
          deriv_stmt(p)(IF up?(ex(pstate(tau1))) THEN c2 ELSE Skip ENDIF,
                        update_FullState(LAMBDA (s : PState) : 
                                           s WITH [ex := bottom], tau1),
                        tau2)(m2) AND
          deriv_stmt(p)(c3, update_FullState(LAMBDA (s : PState) : 
                                           s WITH [ex := bottom], tau2),
                        tau3)(m3) AND
          sigma2 = update_FullState(LAMBDA (s : PState) :
                                      IF up?(ex(pstate(tau2)))
                                      THEN s WITH [ex := ex(pstate(tau2))]
                                      ELSE s WITH [ex := ex(pstate(tau3))]
                                      ENDIF,
                                    tau3),
      While(e, c) : 
        n > 0 AND
        deriv_stmt(p)(IfThenElse(e, While(e, c), Skip), sigma1, sigma2)(n - 1)

    ENDCASES
  ENDIF
  MEASURE n


  derives(p : FullProgram)
         (e : Expr, sigma1 : FullState)(v : Val, sigma2 : FullState) : bool =
    EXISTS (n : nat) : deriv_expr(p)(e, sigma1, v, sigma2)(n)
      (LAMBDA(p : FullProgram)(s : Stmt, sigma1, sigma2 : FullState)
             (m : below(n)) : deriv_stmt(p)(s, sigma1, sigma2)(m))

  derives(p : FullProgram)
         (s : Stmt, sigma1 : FullState)(sigma2 : FullState) : bool =
    EXISTS (n : nat) : deriv_stmt(p)(s, sigma1, sigma2)(n)


  IMPORTING WF[nat, nat]

  % TODO: Write similar lemmas and adapt the proofs
  % I should say that the function given as parameters are deterministic

  expr_determ_step : LEMMA % :-)
    FORALL (p : FullProgram)(n1, n2 : nat)(e : Expr)(sigma : FullState) :
    LET deriv_stmt_rec = 
        LAMBDA (k : nat) : 
          LAMBDA (p : FullProgram)(c : Stmt, sigma1, sigma2 : FullState)
                 (m : below(k)) : deriv_stmt(p)(c, sigma1, sigma2)(m)
    IN
      FORALL (v1, v2 : Val, sigma1, sigma2 : FullState) :
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (m1 : below(n1), m2 : below(n2)) :
          deriv_stmt_rec(n1)(p)(c, sigma, sigma1)(m1) AND
          deriv_stmt_rec(n2)(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2)
        IMPLIES
          deriv_expr(p)(e, sigma, v1, sigma1)(n1)(deriv_stmt_rec(n1)) AND
          deriv_expr(p)(e, sigma, v2, sigma2)(n2)(deriv_stmt_rec(n2)) IMPLIES
            v1 = v2 AND sigma1 = sigma2 AND n1 = n2

  stmt_determ_step : LEMMA % :-)
    FORALL (p : FullProgram)(n1, n2 : nat)(c : Stmt)(sigma : FullState) :
      FORALL (sigma1, sigma2 : FullState) :
        deriv_stmt(p)(c, sigma, sigma1)(n1) AND
        deriv_stmt(p)(c, sigma, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND n1 = n2
  
  expr_determ : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState)(e : Expr) :
      FORALL (v1, v2 : Val, sigma1, sigma2 : FullState) :
        derives(p)(e, sigma)(v1, sigma1) AND
        derives(p)(e, sigma)(v2, sigma2) IMPLIES
          v1 = v2 AND sigma1 = sigma2

  stmt_determ : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState)(c : Stmt) :
      FORALL (sigma1, sigma2 : FullState) :
        derives(p)(c, sigma)(sigma1) AND
        derives(p)(c, sigma)(sigma2) IMPLIES
          sigma1 = sigma2


END Semantics


ProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name]

  execute_set(vn : Name, v : Val, s : PState) : PState = s

  execute_assert(b : boolean, s : PState) : PState = s

  on_method_entry(md : Method, p : Program, s : PState) : PState = s
%    EXISTS (n : nat) : deriv_stmt(p)(pre_set(md), s1, s2)(n)

  on_method_exit_normal(md : Method, p : Program, s : PState) : PState = s
%    EXISTS (n : nat) : deriv_stmt(p)(post_set(md), s1, s2)(n)

  on_method_exit_exceptional(md : Method, p : Program, s : PState) : PState = s
%     EXISTS (n : nat) : deriv_stmt(p)(exc_set(md), s1 WITH [ex := bottom],
%                                                   s2 WITH [ex := bottom])(n)
%     AND ex(s1) = ex(s2)


  IMPORTING Semantics[Name, Program, PState, id, id,
                      LAMBDA (upd : [PState -> PState], s : PState) : upd(s),
                      execute_set,
                      execute_assert,
                      execute_assert,
                      execute_assert,
                      on_method_entry, 
                      on_method_exit_normal,
                      on_method_exit_exceptional]


  eval_expr(p : (wf_Program))(e : Expr, s1 : PState)(n : nat) : [Val, PState] =
    choose({v_s2 : [Val, PState] | 
      deriv_expr(p)(e, s1, proj_1(v_s2), proj_2(v_s2))(n)(deriv_stmt)})

  exec_stmt(p : (wf_Program))(c : Stmt, s1 : PState)(n : nat) : PState =
    choose({s2 : PState | deriv_stmt(p)(c, s1, s2)(n)})


  % Executes n steps of the program p with argument a
  run_Program(p : (wf_Program))(main : Method, arg : int)
             (s2 : PState)(n : nat) : boolean =
    LET s1 = initial_Program_state(p),
        c  = StmtExpr(MethodCall(RExpr(RefVarEval(This)),
                                 name(main),
                                 NExpr(Int(arg))))
    IN
      deriv_stmt(p)(c, s1, s2)(n)


END ProgramSemantics


AnnotatedProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name]

  APState : TYPE = [# gvs : Store, pstate : PState #]

  execute_set(vn : Name, v : Val, s : APState) : APState =
    IF up?(ex(pstate(s)))
    THEN s
    ELSE s WITH [gvs := gvs(s) WITH [vn := v]]
    ENDIF

  execute_assert(b : boolean, s : APState) : APState =
    IF b
    THEN s
    ELSE s WITH [pstate := pstate(s) WITH [ex := up(JMLExc)]]
    ENDIF

  on_method_entry(md : Method, p : Program, s : APState) : APState = s
%    EXISTS (n : nat) : deriv_stmt(p)(pre_set(md), s1, s2)(n)

  on_method_exit_normal(md : Method, p : Program, s : APState) : APState = s
%    EXISTS (n : nat) : deriv_stmt(p)(post_set(md), s1, s2)(n)

  on_method_exit_exceptional(md : Method, p : Program, s : APState) : APState = s
%     EXISTS (n : nat) : deriv_stmt(p)(exc_set(md), s1 WITH [ex := bottom],
%                                                   s2 WITH [ex := bottom])(n)
%     AND ex(s1) = ex(s2)


  IMPORTING Semantics[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      LAMBDA (upd : [PState -> PState], s : APState) : 
                        s WITH [pstate := upd(pstate(s))],
                      execute_set,
                      execute_assert,
                      execute_assert,
                      execute_assert,
                      on_method_entry, 
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  initial_AP_state(p : Program) : APState =
    (# pstate := initial_Program_state(p),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostVarDecl(n, p) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)

  run_Program(p : Program)(main : Method, arg : int)
             (s2 : APState)(n : nat) : boolean =
    LET s1 = initial_AP_state(p),
        c  = StmtExpr(MethodCall(RExpr(RefVarEval(This)),
                                 name(main),
                                 NExpr(Int(arg))))
    IN
      deriv_stmt(p)(c, s1, s2)(n)


END AnnotatedProgramSemantics
