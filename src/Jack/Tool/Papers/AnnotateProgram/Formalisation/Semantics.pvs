ReferenceFunctions[Name : TYPE+, Store : TYPE] : THEORY
BEGIN

  % Functions whose existence we assume
  get_address(vn : Name, sigma : Store) : int

  get_dynamic_type_name(vn : Name, sigma : Store) : Name


END ReferenceFunctions


SemanticsTypes[Name : TYPE+,
               FullProgram, FullState : TYPE,
               (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
               (IMPORTING State[Name]) pstate : [FullState -> PState]] : THEORY
BEGIN

  IMPORTING WellFormedProgram[Name],
            ValOrExcpt[Name]

  derive_type(n : nat) : TYPE =
    [p : FullProgram ->
    [(wf_Body(program(p))), FullState, Val, FullState -> [below(n) -> bool]]]

  derive_rec_type(n : nat) : TYPE = [k : upto(n) -> derive_type(k)]

  update_PState_type(f : [FullState, [PState -> PState] -> FullState]) :
    boolean =
    FORALL (s1, s2 : FullState, upd : [PState -> PState]) :
      f(s1, upd) = s2 IMPLIES pstate(s2) = upd(pstate(s1))

  execute_set_type
    (f : [p : FullProgram, Name,
          (wf_Expr(program(p))), FullState, FullState, n : nat,
          derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, vn : Name, e : (wf_Expr(program(p))),
            s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) :
      f(p, vn, e, s1, s2, n, d) IMPLIES pstate(s2) = pstate(s1)

  execute_CaseJML_type
    (f : [p : FullProgram, (wf_Branches(program(p))),
          FullState, FullState, Val, n : nat,
         derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram,
            branches : (wf_Branches(program(p))),
            s1, s2 : FullState, v : Val, 
            n : nat, d : derive_rec_type(n)) :
      f(p, branches, s1, s2, v, n, d) IMPLIES pstate(s2) = pstate(s1)

  execute_assert_type
    (f : [p : FullProgram, (wf_Expr(program(p))),
          FullState, FullState, n : nat,
          derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, e : (wf_Expr(program(p))),
            s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) :
      f(p, e, s1, s2, n, d) IMPLIES
        st(pstate(s1)) = st(pstate(s2)) AND
        (up?(ex(pstate(s1))) IMPLIES up?(ex(pstate(s2))))


  % We allow on_method_event to throw an exception if an assertion failed
  on_method_event_type
    (f : [p : FullProgram, (wf_Method(program(p))), Val,
          ValOrExcpt, FullState, FullState, n : nat,
         derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, md : (wf_Method(program(p))),
            a : Val, arg : ValOrExcpt, s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) :
      f(p, md, a, arg, s1, s2, n, d) IMPLIES
        st(pstate(s1)) = st(pstate(s2)) AND
        (up?(ex(pstate(s1))) IMPLIES up?(ex(pstate(s2))))


END SemanticsTypes




SemanticsJMLTypes[Name : TYPE+,
                  FullState : TYPE,
                  (IMPORTING State[Name]) gvs : [FullState -> Store]] : THEORY
BEGIN

  update_GhostVars_type(f : [FullState, [Store -> Store] -> FullState]) :
    boolean =
    FORALL (s1, s2 : FullState, upd : [Store -> Store]) :
      f(s1, upd) = s2 IMPLIES gvs(s2) = upd(gvs(s1))


END SemanticsJMLTypes


Semantics[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
          (IMPORTING State[Name]) pstate : [FullState -> PState],
          lookup : [Name, FullState -> Val],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState,
                                    program, pstate])
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_assert : (execute_assert_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN

  IMPORTING ReferenceFunctions[Name, Store]

  get_address(vn : Name, sigma : FullState) : int =
    get_address(vn, fvs(st(pstate(sigma))))

  get_dynamic_type_name(vn : Name, sigma : FullState) : Name =
    get_dynamic_type_name(vn, fvs(st(pstate(sigma))))

  IMPORTING WellFormedProgram[Name]

  get_dynamic_type_name_correctness : AXIOM
    FORALL (p : Program, vn : Name, sigma : FullState) :
      wf_Program(p) IMPLIES
        class_names(p)(get_dynamic_type_name(vn, sigma))


  update_stack(this_val : Val, arg : LocalVarDecl, param_val : Val,
               lvds : finite_set[LocalVarDecl], s : FullState) : FullState =
    IF defined?(this_val) AND defined?(param_val)
    THEN
    LET new_pstate =
      (update_local(This, this_val)) o
        (update_local(name(arg), param_val)) o
           (update_locals({x : [Name, Val] | EXISTS (l : LocalVarDecl) :
                               lvds(l) AND name(l) = proj_1(x) AND
                               default_value(jtype(l)) = proj_2(x)}))
    IN update_PState(s, new_pstate)
    ELSE s
    ENDIF

  return_of_stmt(sigma2 : FullState) : Val =
    IF up?(ex(pstate(sigma2))) THEN Bottom ELSE Unit ENDIF

  check_for_exception(intermed, final : FullState,
                      v : Val, otherwise : bool) : bool =
    IF up?(ex(pstate(intermed)))
    THEN v = Bottom AND intermed = final
    ELSE otherwise
    ENDIF

  check_for_exception_final(final : FullState,
                            v : Val, otherwise : bool) : bool =
    check_for_exception(final, final, v, otherwise)


  derive(p : FullProgram)
        (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
        (n : nat) : RECURSIVE bool =
   LET derive_rec =
        LAMBDA (k : upto(n))(p : FullProgram)
               (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          derive(p)(b, sigma1, v, sigma2)(m),
       bounded_derive_rec =
        LAMBDA (i : upto(n))(k : upto(i))(p : FullProgram)
               (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          derive(p)(b, sigma1, v, sigma2)(m) IN
    IF up?(ex(pstate(sigma1)))
    % sigma1 is an exceptional state, exceptions are simply propagated
    THEN sigma1 = sigma2 AND v = Bottom AND n = 0
    ELSE % sigma1 is a normal state
    CASES b OF
      % Numerical expressions
      Plus(e1, e2) :
        EXISTS (tau : FullState, v1, v2 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(e1, sigma1, v1, tau)(m1) AND
          derive(p)(e2, tau, v2, sigma2)(m2) AND
          check_for_exception_final(sigma2, v,
                Int?(v1) AND Int?(v2) AND v = Int(i(v1) + i(v2))),
      NumVarEval(vn) : sigma1 = sigma2 AND n = 0 AND
                       v = Int(val2int(lookup(vn, sigma1))),
      % Boolean expressions
      Neg(e) : n > 0 AND
               EXISTS(v1 : Val) :
                 derive(p)(e, sigma1, v1, sigma2)(n - 1) AND
                 check_for_exception_final(sigma2, v,
                       Bool?(v1) AND v = Bool(NOT b(v1))),
      Conj(e1, e2) :
        EXISTS (tau : FullState, v1, v2 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(e1, sigma1, v1, tau)(m1) AND
          check_for_exception(tau, sigma2, v,
            IF Bool?(v1) AND b(v1)
            THEN derive(p)(e2, tau, v2, sigma2)(m2) AND
                 check_for_exception_final(sigma2, v,
                                           Bool?(v2) AND v = Bool(b(v2)))
            ELSE v = Bool(FALSE) AND sigma2 = tau AND m2 = 0
            ENDIF) AND
          (up?(ex(pstate(tau))) IMPLIES m2 = 0),
      Eq(e1, e2) :
        EXISTS (tau : FullState, v1, v2 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(e1, sigma1, v1, tau)(m1) AND
          derive(p)(e2, tau, v2, sigma2)(m2) AND
          check_for_exception_final(sigma2, v, v = Bool(v1 = v2)),
      BoolVarEval(vn) : sigma1 = sigma2 AND n = 0 AND
                       v = Bool(val2bool(lookup(vn, sigma1))),
      % Reference expressions
      RefVarEval(vn) : sigma1 = sigma2 AND n = 0 AND
                       v = Reference(get_address(vn, sigma1),
                                 get_dynamic_type_name(vn, sigma1)),
      % Program's expressions
      Assign(vn, e) :
        n > 0 AND
        (EXISTS (tau : FullState) :
           derive(p)(e, sigma1, v, tau)(n - 1) AND
           sigma2 = (IF up?(ex(pstate(tau)))
                     THEN tau
                     ELSE update_PState(tau, update(vn, v))
                     ENDIF)),
      CondExpr(c, t, e) :
        EXISTS (tau : FullState, v1 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(c, sigma1, v1, tau)(m1) AND
          check_for_exception(tau, sigma2, v,
                Bool?(v1) AND
                derive(p)(IF b(v1) THEN t ELSE e ENDIF, tau, v, sigma2)(m2))
          AND
          (up?(ex(pstate(tau))) IMPLIES m2 = 0),
      MethodCall(e, mn, pr) :
        EXISTS (m1, m2, m3, m4, m5, m6 : nat)
               (tau1, tau2, tau3, tau4, tau5, tau6, tau7 : FullState)
               (a, pv, w, x : Val)(old_lvs : Store)
               (md : (wf_Method(program(p)))) :
          n = m1 + m2 + m3 + m4 + m5 + m6 + 1 AND
          % evaluate the receiver object
          derive(p)(e, sigma1, a, tau1)(m1) AND
          % evaluate the parameter
          derive(p)(pr, tau1, pv, tau2)(m2) AND
          % if the receiver is null and no other exception was raisen, raise a
          % NullPointer exception
          IF bottom?(ex(pstate(tau2))) AND Null?(a)
          THEN sigma2 = update_PState(tau2,  raise(NullPointer)) AND
               v = Bottom AND
               m3 = 0 AND m4 = 0 AND m5 = 0 AND m6 = 0
          % if the evaluation of the target or the argument threw an exception,
          % propagate it
          ELSIF up?(ex(pstate(tau2))) 
          THEN sigma2 = tau2 AND
               v = Bottom AND
               m3 = 0 AND m4 = 0 AND m5 = 0 AND m6 = 0
          % lookup method definition
          ELSE
          (IF up?(lookup_mthd(program(p), a, mn))
          THEN md = down(lookup_mthd(program(p), a, mn))
          ELSE FALSE % should not happen in a wf_Program
          ENDIF AND
          % remember the local store
          old_lvs = lvs(st(pstate(tau2))) AND
          % update 'this', the argument and initialize local variables
          tau3 = update_stack(a, arg(md), pv, lvars(md), tau2) AND
          % actions taken at the entry of the method (inv, precond, pre_set)
          defined?(pv) AND % condition on pv needed to prove TCCs 
                           % -> is derivable
          on_method_entry(p, md, a, val(Const(pv)), tau3, tau4, m3, 
                          bounded_derive_rec(m3)) AND
          % execute the body
          derive(p)(body(md), tau4, x, tau5)(m4) AND
          % body returns either Unit or Bottom value
          x = return_of_stmt(tau5) AND
          % evaluate the result
          derive(p)(res(md), tau5, w, tau6)(m5)
          AND
          % actions taken at the exit of the method (pos_set, inv, postcond)
          IF bottom?(ex(pstate(tau6))) 
          THEN defined?(w) AND           % condition on w needed to prove TCCs
                                         % -> is derivable
               on_method_exit_normal(p, md, a, val(Const(w)), tau6, tau7, m6,
                                     bounded_derive_rec(m6))
          ELSE on_method_exit_exceptional(p, md, a, 
                                          excpt(down(ex(pstate(tau6)))),
                                          tau6, tau7, m6,
                                          bounded_derive_rec(m6))
          ENDIF AND
          % check whether evaluation of subexpressions was exceptional if so,
          % return bottom value, otherwise return value returned by method body
          IF up?(ex(pstate(tau7)))
          THEN v = Bottom
          ELSE v = w
          ENDIF AND
          % restore the local store (to allow recursion)
          sigma2 = update_PState(tau7,
                                 LAMBDA(pstate : PState) : 
                                   pstate WITH 
                                   [st := st(pstate) WITH [lvs := old_lvs]]))
          ENDIF,
      Const(v1) : 
        n = 0 AND
        v = v1 AND
        sigma1 = sigma2,
      % Program's statements
      CaseJML(l) :
        v = return_of_stmt(sigma2) AND
        execute_CaseJML(p, l, sigma1, sigma2, v, n, derive_rec),
      IfThenElse(e, c1, c2) :
        v = return_of_stmt(sigma2) AND
        EXISTS (tau : FullState, v1 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(e, sigma1, v1, tau)(m1) AND
          check_for_exception(tau, sigma2, v,
                Bool?(v1) AND
                derive(p)(IF b(v1) THEN c1 ELSE c2 ENDIF, tau, v,
                          sigma2)(m2)) AND
          (up?(ex(pstate(tau))) IMPLIES m2 = 0),
      Sequence(c1, c2) :
        v = return_of_stmt(sigma2) AND
         EXISTS(m1, m2 : nat, v1 : Val)(tau : FullState) :
           n = m1 + m2 + 1 AND
           derive(p)(c1, sigma1, v1, tau)(m1) AND
           v1 = return_of_stmt(tau) AND
           derive(p)(c2, tau, v, sigma2)(m2),
      Set(vn, e) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
         execute_set(p, vn, e, sigma1, sigma2, n, derive_rec),
      Skip : sigma1 = sigma2 AND n = 0 AND
        v = return_of_stmt(sigma2),
      StmtExpr(e) :
         n > 0 AND
         v = return_of_stmt(sigma2) AND
         EXISTS (v1 : Val) : derive(p)(e, sigma1, v1, sigma2)(n - 1),
      Throw(e):
        n = 0 AND
        v = return_of_stmt(sigma2) AND
        sigma2 = update_PState(sigma1, raise(e)),
      TryCatch(c1, e, c2, c3) :
        v = return_of_stmt(sigma2) AND
        EXISTS (m1, m2, m3 : nat)(tau1, tau2, tau3 : FullState)
               (v1, v2, v3 : Val) :
          n = m1 + m2 + m3 + 1 AND
          derive(p)(c1, sigma1, v1, tau1)(m1) AND
          v1 = return_of_stmt(tau1) AND
          IF up?(ex(pstate(tau1))) AND down(ex(pstate(tau1))) = e
          THEN derive(p)(c2, update_PState(tau1, catch), v2, tau2)(m2) AND
               v2 = return_of_stmt(tau2) 
          ELSE tau1 = tau2 AND m2 = 0
          ENDIF AND
          derive(p)(c3, update_PState(tau2, catch), v3, tau3)(m3) AND
          v3 = return_of_stmt(tau3) AND
          sigma2 = IF NOT up?(ex(pstate(tau3)))
                   THEN update_PState(tau3, 
                                      LAMBDA (ptau3 : PState) : ptau3 
                                             WITH [ex := ex(pstate(tau2))])
                   ELSE tau3
                   ENDIF,
      While(e, c) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
        derive(p)(IfThenElse(e, While(e, c), Skip),
                  sigma1, v, sigma2)(n - 1),
      Assert(e) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
        execute_assert(p, e, sigma1, sigma2, n, derive_rec)
    ENDCASES
    ENDIF
  MEASURE n


  derives(p : FullProgram)
         (b : (wf_Body(program(p))), sigma1 : FullState)
         (sigma2 : FullState) : bool =
    EXISTS (n : nat, v : Val) :
      derive(p)(b, sigma1, v, sigma2)(n)

  run_FullProgram(p : FullProgram)(main : Name, arg : int)
                 (initial, final : FullState) : boolean =
    LET c  = StmtExpr(MethodCall(RefVarEval(This), main, Const(Int(arg))))
    IN
      derives(p)(c, initial)(final)

  no_change_in_pstate(p : FullProgram)(b : (wf_Body(program(p)))) : boolean =
    FORALL(b1 : (wf_Body(program(p)))) :
      subterm(b1, b) IMPLIES
        FORALL(sigma1, sigma2 : FullState, v : Val, n : nat) :
          derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
            pstate(sigma1) = pstate(sigma2)

END Semantics


% Properties about Semantics (mainly determinism)
SemanticsProofs[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
          (IMPORTING State[Name]) pstate : [FullState -> PState],
          lookup : [Name, FullState -> Val],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState,
                                    program, pstate])
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_assert : (execute_assert_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN
ASSUMING

    IMPORTING Semantics[Name, FullProgram, FullState, program, pstate,
              lookup, update_PState,
              execute_set, execute_assert, execute_CaseJML,
              on_method_entry, on_method_exit_normal,
              on_method_exit_exceptional]

    % AT: It would be nice to simplify these assumptions using
    % deriv_stmt_determ and deriv_expr_determ. I tried it but for instance in
    % expr_determ_step these assumptions are discharged with just an assert
    % but now it doesn't work (even after expanding the definition). It works
    % issuing a grind but the whole proof while take ages. I couldn't find a
    % simple way of proving those branches.

    on_method_entry_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : (wf_Method(program(p))), v : Val,
              arg : ValOrExcpt, s, s1, s2 : FullState, n1, n2 : nat,
              d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      on_method_entry(p, m, v, arg, s, s1, n1, d1) IMPLIES
      on_method_entry(p, m, v, arg, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

    on_method_exit_normal_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : (wf_Method(program(p))), v : Val,
              arg : ValOrExcpt,  s, s1, s2 : FullState, n1, n2 : nat,
              d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      on_method_exit_normal(p, m, v, arg, s, s1, n1, d1) IMPLIES
      on_method_exit_normal(p, m, v, arg, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

    on_method_exit_exceptional_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : (wf_Method(program(p))), v : Val,
              arg : ValOrExcpt, s, s1, s2 : FullState, n1, n2 : nat,
              d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      on_method_exit_exceptional(p, m, v, arg, s, s1, n1, d1) IMPLIES
      on_method_exit_exceptional(p, m, v, arg, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

  execute_CaseJML_deterministic : ASSUMPTION
    FORALL (p : FullProgram,
            branches : (wf_Branches(program(p))),
            s, s1, s2 : FullState, v1, v2 : Val,
            n1, n2 : nat,
            d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
         execute_CaseJML(p, branches, s, s1, v1, n1, d1) IMPLIES
         execute_CaseJML(p, branches, s, s2, v2, n2, d2) IMPLIES
           s1 = s2 AND n1 = n2 AND v1 = v2

  execute_set_deterministic : ASSUMPTION
    FORALL (p : FullProgram, vn : Name, e : (wf_Expr(program(p))),
            s, s1, s2 : FullState,
            n1, n2 : nat,
            d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      execute_set(p, vn, e, s, s1, n1, d1) IMPLIES
      execute_set(p, vn, e, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

  execute_assert_deterministic : ASSUMPTION
    FORALL (p : FullProgram, e : (wf_Expr(program(p))),
            s, s1, s2 : FullState,
            n1, n2 : nat,
            d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      execute_assert(p, e, s, s1, n1, d1) IMPLIES
      execute_assert(p, e, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

ENDASSUMING

  IMPORTING WF[nat, nat] % used in the proofs

  derive_determ_step : LEMMA % :-)
    FORALL (p : FullProgram)(n1, n2 : nat)(b : (wf_Body(program(p))))
           (v1, v2 : Val, sigma, sigma1, sigma2 : FullState) :
        derive(p)(b, sigma, v1, sigma1)(n1) IMPLIES
        derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
           v1 = v2 AND sigma1 = sigma2 AND n1 = n2


  derive_determ : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState)(b : (wf_Body(program(p)))) :
      FORALL (sigma1, sigma2 : FullState) :
        derives(p)(b, sigma)(sigma1) AND
        derives(p)(b, sigma)(sigma2) IMPLIES
          sigma1 = sigma2


  derive_bottom_iff_exception_step : LEMMA % :-)
    FORALL (p : FullProgram)(e : (wf_Body(program(p))))
           (sigma1, sigma2 : FullState, v : Val, n : nat) :
      derive(p)(e, sigma1, v, sigma2)(n) IMPLIES
        Bottom?(v) = up?(ex(pstate(sigma2)))


%  derive_boolean_expr_type : LEMMA % :-)
%    FORALL (p : FullProgram)(b : (wf_Expr(program(p))))
%           (sigma1, sigma2 : FullState, v : Val, n : nat) :
%      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
%      NOT up?(ex(pstate(sigma2))) IMPLIES
%        Bool?(v)

  derive_after_raise : LEMMA % :-)
    FORALL (p : FullProgram)(b : (wf_Body(program(p))))
           (sigma1, sigma2, tau : FullState, v : Val, n : nat, e : Excpt) :
              tau = update_PState(sigma1, raise(e)) IMPLIES
              derive(p)(b, tau, v, sigma2)(n) IMPLIES
              sigma2 = tau AND v = Bottom
                 

  IMPORTING ContainsNoMethodCall[Name]

  derive_does_not_change_unmentioned_var : LEMMA
    FORALL (p : FullProgram)(b : (wf_Body(program(p))), v : Val)
           (sigma1, sigma2 : FullState)(x : Name)
           (n : nat) :
      NOT var_names(b)(x) IMPLIES
      contains_no_method_call(b) IMPLIES
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
      lookup(x, pstate(sigma1)) = lookup(x, pstate(sigma2))

END SemanticsProofs


% Functions related to the semantics of JML needed to instantiate Semantics.
SemanticsJML[Name : TYPE+,
             FullProgram, FullState : TYPE,
             (IMPORTING WellFormedProgram[Name])
                  program : [FullProgram -> Program[Name]],
             (IMPORTING State[Name]) pstate : [FullState -> PState],
             (IMPORTING SemanticsTypes[Name, FullProgram, FullState,
                                       program, pstate])
             update_PState : (update_PState_type),
             gvs : [FullState -> Store[Name]],
             (IMPORTING SemanticsJMLTypes[Name, FullState, gvs])
             update_GhostVars : (update_GhostVars_type)] : THEORY
BEGIN

  is_ghost(vn : Name, sigma : FullState) : boolean =
    defined?(gvs(sigma)(vn))

  lookup(vn : Name, sigma : FullState) : Val =
    IF is_local(vn, pstate(sigma))
    THEN lookup_local(vn, pstate(sigma))
    ELSIF is_field(vn, pstate(sigma))
    THEN lookup_field(vn, pstate(sigma))
    ELSE gvs(sigma)(vn)
    ENDIF

  wf_ghoststate(p : FullProgram)(sigma : FullState) : boolean =
    FORALL (vn : Name) :
      is_ghost(vn, sigma) IFF var_names(getGhostDecls(program(p)))(vn)

  wf_initial_ghost_state : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState) :
      (gvs(sigma) = LAMBDA (n : Name) :
                      LET gd = get_GhostDecl(n, program(p)) IN
                      IF bottom?(gd)
                      THEN Bottom
                      ELSE init_val(down(gd))
                      ENDIF) IMPLIES
      wf_ghoststate(p)(sigma)

  return_of_stmt(sigma2 : FullState) : Val =
    IF up?(ex(pstate(sigma2))) THEN Bottom ELSE Unit ENDIF

  execute_set : (execute_set_type) =
    LAMBDA (p : FullProgram, vn : Name, e : (wf_Expr(program(p))),
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
      EXISTS (tau : FullState, v : Val) :
        n > 0 AND
        derive_rec(n)(p)(e, s1, v, tau)(n - 1) AND
        s2 = IF up?(ex(pstate(tau)))
             THEN tau
             ELSE update_GhostVars(tau, update_store(vn, v))
             ENDIF AND
        pstate(s1) = pstate(s2)

  execute_CaseJML : (execute_CaseJML_type) =
    LAMBDA (p : FullProgram,
            branches : ({l : list[[Expr, Stmt]] | wf_Branches(program(p))(l)}),
            s1, s2 : FullState, v : Val,
            n : nat, derive_rec : derive_rec_type(n)) :
      CASES branches OF
        null : n = 0 AND s1 = s2 AND v = Unit,
        cons(x, xs) : n > 0 AND
                      derive_rec(n)(p)(IfThenElse(proj_1(x), proj_2(x),
                                       CaseJML(xs)), s1, v, s2)(n - 1) AND
                      pstate(s1) = pstate(s2)
      ENDCASES 

  IMPORTING ProgramFunctions[Name]

%  check_assertion(p : FullProgram)
%                 (e : (wf_Expr(program(p))), s1, s2 : FullState)(n : nat)
%                 (derive : derive_type(n)) : boolean =
%    n > 0 AND
%    EXISTS (tau1 : FullState, v : Val) :
%      derive(p)(e, s1, v, tau1)(n - 1) AND
%      s2 = IF Bool?(v) THEN
%             IF b(v)
%             THEN tau1
%             ELSE update_PState(tau1, raise(JMLExc))
%             ENDIF
%           ELSE tau1 % This may happen if v is bottom
%           ENDIF

  check_assertion(p : FullProgram)
                 (e : (wf_Expr(program(p))), s1, s2 : FullState)(n : nat)
                 (derive : derive_type(n)) : boolean =
    n > 0 AND
    EXISTS (tau1 : FullState, v : Val) :
      derive(p)(e, s1, v, tau1)(n - 1) AND
      s2 = IF Bool?(v) AND b(v)
           THEN tau1
           ELSE update_PState(tau1, raise(JMLExc))
           ENDIF


  execute_assert : (execute_assert_type) =
    LAMBDA (p : FullProgram, e : (wf_Expr(program(p))),
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1)))
    THEN s1 = s2 AND n = 0
    ELSE
      check_assertion(p)(e, s1, s2)(n)(derive_rec(n)) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  on_method_entry : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : (wf_Method(program(p))), a : Val,
            arg : ValOrExcpt, s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1)))
    THEN s1 = s2 AND n = 0
    ELSE
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : FullState, v : Val,
            inv : (wf_Expr(program(p)))) :
      n = m1 + m2 + m3 + 1 AND
      val?(arg) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, s1, tau1)(m1)(derive_rec(m1)) AND
      check_assertion(p)(pre(md)(v(arg)), tau1, tau2)(m2)
                                (derive_rec(m2)) AND
      derive_rec(n)(p)(pre_set(md)(v(arg)), tau2, v, s2)(m3) AND
      v = return_of_stmt(s2) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  on_method_exit_normal : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : (wf_Method(program(p))), a : Val,
            arg : ValOrExcpt, s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1)))
    THEN s1 = s2 AND n = 0
    ELSE
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : FullState, v : Val,
            inv : (wf_Expr(program(p)))) :
      n = m1 + m2 + m3 + 1 AND
      val?(arg) AND
      derive_rec(n)(p)(post_set(md)(v(arg)), s1, v, tau1)(m1) AND
      v = return_of_stmt(tau1) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, tau1, tau2)(m2)(derive_rec(m2)) AND
      check_assertion(p)(post(md)(v(arg)), tau2, s2)(m3)
                                 (derive_rec(m3)) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  % If there was an exception, there is no need to chech the postcondition
  % (JML has an exceptional postcondition but we are not modelling it)
  on_method_exit_exceptional : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : (wf_Method(program(p))), a : Val,
            arg : ValOrExcpt, s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) AND NOT down(ex(pstate(s1))) = JMLExc
    THEN
    EXISTS (m1, m2 : nat, tau1, tau2 : FullState, v : Val,
            inv : (wf_Expr(program(p)))) :
      n = m1 + m2 + 1 AND
      excpt?(arg) AND
      derive_rec(n)(p)(exc_set(md)(e(arg)),
                       update_PState(s1, catch), v, tau1)(m1) AND
      v = return_of_stmt(tau1) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, tau1, tau2)(m2)(derive_rec(m2)) AND
      s2 = (IF up?(ex(pstate(tau2)))
            THEN tau2
            ELSE update_PState(tau2, raise(down(ex(pstate(s1)))))
            ENDIF) AND
      st(pstate(s1)) = st(pstate(s2))
    ELSE s1 = s2 AND n = 0
    ENDIF


%  IMPORTING Semantics[Name, FullProgram, FullState, 
%                      program, pstate, lookup, update_PState, 
%                      execute_set, execute_assert, execute_CaseJML,
%                      on_method_entry, on_method_exit_normal, 
%                      on_method_exit_exceptional]


%  on_method_entry_only_throws_JMLExc : LEMMA
%     FORALL(p : FullProgram, md : (wf_Method(program(p))), a : Val,
%            s1, s2 : FullState, n : nat,
%            derive_rec : derive_rec_type(n)) :
%       NOT up?(ex(pstate(s1))) IMPLIES
%       on_method_entry(p, md, a, s1, s2, n,         
%          LAMBDA (k : upto(n))(p : FullProgram)
%               (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
%               (m : below(k)) : derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
%       up?(ex(pstate(s2))) IMPLIES
%         down(ex(pstate(s2))) = JMLExc


END SemanticsJML
