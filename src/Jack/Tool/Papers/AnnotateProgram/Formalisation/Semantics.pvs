ReferenceFunctions[Name : TYPE+, PState : TYPE] : THEORY
BEGIN

  % Functions whose existence we assume
  get_address(vn : Name, sigma : PState) : int

  get_dynamic_type_name(vn : Name, sigma : PState) : Name

END ReferenceFunctions


SemanticsTypes[Name : TYPE+,
               FullProgram, FullState : TYPE,
               (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
               (IMPORTING State[Name]) pstate : [FullState -> PState]] : THEORY
BEGIN
 
  IMPORTING WellFormedProgram[Name]

  derive_type(n : nat) : TYPE =
    [p : FullProgram -> 
    [(wf_Body(program(p))), FullState, Val, FullState -> [below(n) -> bool]]]

  derive_rec_type(n : nat) : TYPE = [k : upto(n) -> derive_type(k)]

  update_PState_type(f : [FullState, [PState -> PState] -> FullState]) :
    boolean =
    FORALL (s1, s2 : FullState, upd : [PState -> PState]) :
      f(s1, upd) = s2 IMPLIES pstate(s2) = upd(pstate(s1))

  execute_set_type
    (f : [p : FullProgram, Name, 
          (wf_Expr(program(p))), FullState, FullState, n : nat,
          derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, vn : Name, e : (wf_Expr(program(p))), 
            s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) : 
      f(p, vn, e, s1, s2, n, d) IMPLIES pstate(s2) = pstate(s1)

  execute_CaseJML_type
    (f : [p : FullProgram, (wf_Branches(program(p))),
          FullState, FullState, n : nat,
         derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, 
            branches : (wf_Branches(program(p))), 
            s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) :
      f(p, branches, s1, s2, n, d) IMPLIES pstate(s2) = pstate(s1)

  execute_assert_type
    (f : [p : FullProgram, (wf_BoolExpr(program(p))), 
          FullState, FullState, n : nat,
          derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, e : (wf_BoolExpr(program(p))), 
            s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) : 
      f(p, e, s1, s2, n, d) IMPLIES 
        st(pstate(s1)) = st(pstate(s2)) AND
        (up?(ex(pstate(s1))) IMPLIES up?(ex(pstate(s2))))


  % We allow on_method_event to throw an exception if an assertion failed
  on_method_event_type
    (f : [p : FullProgram, (wf_Method(program(p))), Val, 
          FullState, FullState, n : nat,
         derive_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, md : (wf_Method(program(p))), 
            a : Val, s1, s2 : FullState,
            n : nat, d : derive_rec_type(n)) : 
      f(p, md, a, s1, s2, n, d) IMPLIES 
        st(pstate(s1)) = st(pstate(s2)) AND
        (up?(ex(pstate(s1))) IMPLIES up?(ex(pstate(s2))))


END SemanticsTypes




SemanticsJMLTypes[Name : TYPE+,
                  FullState : TYPE,
                  (IMPORTING State[Name]) gvs : [FullState -> Store]] : THEORY
BEGIN

%  IMPORTING Program[Name]

  update_GhostVars_type(f : [FullState, [Store -> Store] -> FullState]) :
    boolean =
    FORALL (s1, s2 : FullState, upd : [Store -> Store]) :
      f(s1, upd) = s2 IMPLIES gvs(s2) = upd(gvs(s1))


END SemanticsJMLTypes


Semantics[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
          (IMPORTING State[Name]) pstate : [FullState -> PState],
          lookup : [Name, FullState -> Val],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState, 
                                    program, pstate])
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_assert : (execute_assert_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN

  IMPORTING ReferenceFunctions[Name, PState]

  get_address(vn : Name, sigma : FullState) : int =
    get_address(vn, pstate(sigma))

  get_dynamic_type_name(vn : Name, sigma : FullState) : Name =
    get_dynamic_type_name(vn, pstate(sigma))

  IMPORTING WellFormedProgram[Name]

  get_dynamic_type_name_correctness : AXIOM
    FORALL (p : Program, vn : Name, sigma : FullState) :
      wf_Program(p) IMPLIES 
        class_names(p)(get_dynamic_type_name(vn, sigma))



  update_stack(this_val : Val, arg : LocalVarDecl, param_val : Val,
               lvds : finite_set[LocalVarDecl], s : FullState) : FullState =
    IF defined?(this_val) AND defined?(param_val) 
    THEN 
    LET new_pstate =
      (update_local(This, this_val)) o
        (update_local(name(arg), param_val)) o
           (update_locals({x : [Name, Val] | EXISTS (l : LocalVarDecl) :
                               lvds(l) AND name(l) = proj_1(x) AND
                               default_value(jtype(l)) = proj_2(x)}))
    IN update_PState(s, new_pstate)
    ELSE s
    ENDIF


  return_of_stmt(sigma2 : FullState) : Val =
    IF up?(ex(pstate(sigma2))) THEN Bottom ELSE Unit ENDIF


  check_for_exception(intermed, final : FullState,
                      v : Val, otherwise : bool) : bool =
    IF up?(ex(pstate(intermed)))
    THEN v = Bottom AND intermed = final
    ELSE otherwise
    ENDIF

  check_for_exception_final(final : FullState,
                            v : Val, otherwise : bool) : bool =
    check_for_exception(final, final, v, otherwise)

  derive(p : FullProgram)
        (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
        (n : nat) : RECURSIVE bool =
   LET derive_rec =
        LAMBDA (k : upto(n))(p : FullProgram)
               (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          derive(p)(b, sigma1, v, sigma2)(m),
       bounded_derive_rec =
        LAMBDA (i : upto(n))(k : upto(i))(p : FullProgram)
               (b : (wf_Body(program(p))), sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          derive(p)(b, sigma1, v, sigma2)(m) IN
    IF up?(ex(pstate(sigma1)))
    % sigma1 is an exceptional state, exceptions are simply propagated
    THEN sigma1 = sigma2 AND v = Bottom AND n = 0
    ELSE % sigma1 is a normal state
    CASES b OF
      % Numerical expressions
      Int(i) : sigma1 = sigma2 AND n = 0 AND v = Int(i),
      Plus(e1, e2) : 
        EXISTS (tau : FullState, v1, v2 : Val, m1, m2 : nat) : 
          n = m1 + m2 + 1 AND
          derive(p)(e1, sigma1, v1, tau)(m1) AND
          derive(p)(e2, tau, v2, sigma2)(m2) AND
          check_for_exception_final(sigma2, v,
                Int?(v1) AND Int?(v2) AND v = Int(i(v1) + i(v2))),
      NumVarEval(vn) : sigma1 = sigma2 AND n = 0 AND 
                       v = Int(val2int(lookup(vn, sigma1))),
      % Boolean expressions
      TT : sigma1 = sigma2 AND n = 0 AND v = Bool(TRUE),
      FF : sigma1 = sigma2 AND n = 0 AND v = Bool(FALSE),
      Neg(e) : n > 0 AND
               EXISTS(v1 : Val) :
                 derive(p)(e, sigma1, v1, sigma2)(n - 1) AND
                 check_for_exception_final(sigma2, v,
                       Bool?(v1) AND v = Bool(NOT b(v1))),
      Conj(e1, e2) :
        EXISTS (tau : FullState, v1, v2 : Val, m1, m2 : nat) : 
          n = m1 + m2 + 1 AND
          derive(p)(e1, sigma1, v1, tau)(m1) AND
          derive(p)(e2, tau, v2, sigma2)(m2) AND
          check_for_exception_final(sigma2, v,
                Bool?(v1) AND Bool?(v2) AND v = Bool(b(v1) AND b(v2))),
      Eq(e1, e2) :
        EXISTS (tau : FullState, v1, v2 : Val, m1, m2 : nat) : 
          n = m1 + m2 + 1 AND
          derive(p)(e1, sigma1, v1, tau)(m1) AND
          derive(p)(e2, tau, v2, sigma2)(m2) AND
          check_for_exception_final(sigma2, v, v = Bool(v1 = v2)),
      BoolVarEval(vn) : sigma1 = sigma2 AND n = 0 AND 
                       v = Bool(val2bool(lookup(vn, sigma1))),
      % Reference expressions
      Null : sigma1 = sigma2 AND n = 0 AND v = Null,
      RefVarEval(vn) : sigma1 = sigma2 AND n = 0 AND 
                       v = Reference(get_address(vn, sigma1), 
                                 get_dynamic_type_name(vn, sigma1)),
      % Program's expressions
      Assign(vn, e) :
        n > 0 AND
        (EXISTS (tau : FullState) :
           derive(p)(e, sigma1, v, tau)(n - 1) AND
           sigma2 = (IF up?(ex(pstate(tau)))
                     THEN tau
                     ELSE update_PState(tau, update(vn, v))
                     ENDIF)),
      BExpr(b) :
        n > 0 AND
        derive(p)(b, sigma1, v, sigma2)(n - 1),
      CondExpr(c, t, e) :
        EXISTS (tau : FullState, v1 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(c, sigma1, v1, tau)(m1) AND
          check_for_exception(tau, sigma2, v,
                Bool?(v1) AND
                derive(p)(IF b(v1) THEN t ELSE e ENDIF, tau, v, sigma2)(m2)),
      MethodCall(e, mn, pr) :
        EXISTS (m1, m2, m3, m4, m5, m6 : nat)
               (tau1, tau2, tau3, tau4, tau5, tau6, tau7, tau8 : FullState)
               (a, pv, old_val_arg, w : Val)(md : (wf_Method(program(p))))
               (inv : (wf_BoolExpr(program(p)))) :
          n = m1 + m2 + m3 + m4 + m5 + m6 + 1 AND
          % evaluate the receiver object
          derive(p)(e, sigma1, a, tau1)(m1) AND
          % evaluate the parameter
          derive(p)(pr, tau1, pv, tau2)(m2) AND
          % see if the receiver is null (and there were no previous exceptions)
          tau3 = IF bottom?(ex(pstate(tau2))) AND Null?(a)
                 THEN update_PState(tau2,  raise(NullPointer))
                 ELSE tau2
                 ENDIF AND
          % lookup method definition
          IF up?(lookup_mthd(program(p), a, mn))
          THEN md = down(lookup_mthd(program(p), a, mn))
          ELSE FALSE % should not happen in a wf_Program
          ENDIF AND
          % actions taken at the entry of the method
          on_method_entry(p, md, a, tau3, tau4, m3, bounded_derive_rec(m3)) AND
          % give a name the value of the argument before the call,
          old_val_arg = lookup_local(name(arg(md)), pstate(tau4)) AND
          % update the value of this, the argument and initialize the local vars
          tau5 = update_stack(a, arg(md), pv, lvars(md), tau4) AND
          % execute the body
          derive(p)(body(md), tau5, Unit, tau6)(m4) AND
          % evaluate the result
          IF Void?(res_type(md))
          THEN tau7 = tau6 AND w = Unit AND m5 = 0
          ELSE derive(p)(res(md), tau6, w, tau7)(m5)
          ENDIF AND
          % actions taken at the exit of the method
          IF bottom?(ex(pstate(tau7)))
          THEN on_method_exit_normal(p, md, a, tau7, tau8, m6,
                                     bounded_derive_rec(m6))
          ELSE on_method_exit_exceptional(p, md, a, tau7, tau8, m6,
                                          bounded_derive_rec(m6))
          ENDIF AND
          % check whether evaluation of subexpressions was exceptional if so, 
          % return bottom value, otherwise return value returned by method body
          IF up?(ex(pstate(tau8)))
          THEN v = Bottom
          ELSE v = w
          ENDIF AND
          % restore the value of the argument
          sigma2 = update_PState(tau8, 
                                 update_local(name(arg(md)), old_val_arg)),
      NExpr(n) :
        n > 0 AND
        derive(p)(n, sigma1, v, sigma2)(n - 1),
      RExpr(r) :
        n > 0 AND
        derive(p)(r, sigma1, v, sigma2)(n - 1),
      % Program's statements
      CaseJML(l) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
        execute_CaseJML(p, l, sigma1, sigma2, n, derive_rec),
      IfThenElse(e, c1, c2) :
        v = return_of_stmt(sigma2) AND
        EXISTS (tau : FullState, v1 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          derive(p)(e, sigma1, v1, tau)(m1) AND
          check_for_exception(tau, sigma2, v, 
                Bool?(v1) AND
                derive(p)(IF b(v1) THEN c1 ELSE c2 ENDIF, tau, Unit, 
                          sigma2)(m2)),
      Sequence(c1, c2) :
        v = return_of_stmt(sigma2) AND
         EXISTS(m1, m2 : nat)(tau : FullState) :
           n = m1 + m2 + 1 AND
           derive(p)(c1, sigma1, Unit, tau)(m1) AND
           derive(p)(c2, tau, Unit, sigma2)(m2),
      Set(vn, e) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
         execute_set(p, vn, e, sigma1, sigma2, n, derive_rec),
      Skip : sigma1 = sigma2 AND n = 0 AND 
        v = return_of_stmt(sigma2), 
      StmtExpr(e) :
         n > 0 AND
         v = return_of_stmt(sigma2) AND
         EXISTS (v1 : Val) : derive(p)(e, sigma1, v1, sigma2)(n - 1),
      Throw: 
        n = 0 AND
        v = return_of_stmt(sigma2) AND
        sigma2 = update_PState(sigma1, raise(Throwable)),
      TryCatch(c1, c2, c3) :
        v = return_of_stmt(sigma2) AND
        EXISTS (m1, m2, m3 : nat)(tau1, tau2, tau3 : FullState) :
          n = m1 + m2 + m3 + 1 AND
          derive(p)(c1, sigma1, Unit, tau1)(m1) AND
          derive(p)(IF up?(ex(pstate(tau1))) THEN c2 ELSE Skip ENDIF,
                    update_PState(tau1, catch), Unit, tau2)(m2) AND
          derive(p)(c3, update_PState(tau2, catch), Unit, tau3)(m3) AND
          sigma2 = IF up?(ex(pstate(tau2)))
                   THEN update_PState(tau3, raise(down(ex(pstate(tau2)))))
                   ELSE tau3 % update_PState(tau3, raise(down(ex(pstate(tau3)))))
                   ENDIF,
      While(e, c) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
        derive(p)(IfThenElse(e, While(e, c), Skip), 
                  sigma1, Unit, sigma2)(n - 1),
      Assert(e) :
        n > 0 AND
        v = return_of_stmt(sigma2) AND
         execute_assert(p, e, sigma1, sigma2, n, derive_rec)
    ENDCASES
    ENDIF
  MEASURE n



  derives(p : FullProgram)
         (b : (wf_Body(program(p))), sigma1 : FullState)(v : Val, sigma2 : FullState) : bool =
    EXISTS (n : nat) :
      derive(p)(b, sigma1, v, sigma2)(n)


  spec_expr_has_no_side_effects(p : FullProgram)(e : (wf_Body(program(p)))) : boolean =
    FORALL (s1, s2 : FullState, v : Val, n : nat) :
      derive(p)(e, s1, v, s2)(n) IMPLIES s1 = s2


  run_FullProgram(p : FullProgram)(main : (wf_Method(program(p))), arg : int)
                 (initial, final : FullState) : boolean =
    LET c  = StmtExpr(MethodCall(RExpr(RefVarEval(This)),
                                 name(main),
                                 NExpr(Int(arg))))
    IN
      derives(p)(c, initial)(Unit, final)


END Semantics


% Properties about Semantics (mainly determinism)
SemanticsProofs[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
          (IMPORTING State[Name]) pstate : [FullState -> PState],
          lookup : [Name, FullState -> Val],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState, 
                                    program, pstate])
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_assert : (execute_assert_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN
ASSUMING

    IMPORTING Semantics[Name, FullProgram, FullState, program, pstate,
              lookup, update_PState, 
              execute_set, execute_assert, execute_CaseJML,
              on_method_entry, on_method_exit_normal,
              on_method_exit_exceptional]

    % AT: It would be nice to simplify these assumptions using 
    % deriv_stmt_determ and deriv_expr_determ. I tried it but for instance in
    % expr_determ_step these assumptions are discharged with just an assert
    % but now it doesn't work (even after expanding the definition). It works
    % issuing a grind but the whole proof while take ages. I couldn't find a
    % simple way of proving those branches.

    on_method_entry_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : (wf_Method(program(p))), v : Val,
              s, s1, s2 : FullState, n1, n2 : nat,
              d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      on_method_entry(p, m, v, s, s1, n1, d1) IMPLIES
      on_method_entry(p, m, v, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2 

    on_method_exit_normal_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : (wf_Method(program(p))), v : Val,
              s, s1, s2 : FullState, n1, n2 : nat,
              d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) : 
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      on_method_exit_normal(p, m, v, s, s1, n1, d1) IMPLIES
      on_method_exit_normal(p, m, v, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

    on_method_exit_exceptional_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : (wf_Method(program(p))), v : Val, 
              s, s1, s2 : FullState, n1, n2 : nat,
              d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) : 
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      on_method_exit_exceptional(p, m, v, s, s1, n1, d1) IMPLIES
      on_method_exit_exceptional(p, m, v, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

  execute_CaseJML_deterministic : ASSUMPTION
    FORALL (p : FullProgram, 
            branches : (wf_Branches(program(p))), 
            s, s1, s2 : FullState,
            n1, n2 : nat, 
            d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
         execute_CaseJML(p, branches, s, s1, n1, d1) IMPLIES 
         execute_CaseJML(p, branches, s, s2, n2, d2) IMPLIES 
           s1 = s2 AND n1 = n2

  execute_set_deterministic : ASSUMPTION
    FORALL (p : FullProgram, vn : Name, e : (wf_Expr(program(p))), 
            s, s1, s2 : FullState,
            n1, n2 : nat, 
            d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      execute_set(p, vn, e, s, s1, n1, d1) IMPLIES
      execute_set(p, vn, e, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

  execute_assert_deterministic : ASSUMPTION
    FORALL (p : FullProgram, e : (wf_BoolExpr(program(p))), 
            s, s1, s2 : FullState,
            n1, n2 : nat, 
            d1 : derive_rec_type(n1), d2 : derive_rec_type(n2)) :
        (FORALL (b : (wf_Body(program(p))))(v1, v2 : Val)
                (sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          d1(k1)(p)(b, sigma, v1, sigma1)(m1) AND
          d2(k2)(p)(b, sigma, v2, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2 AND v1 = v2) IMPLIES
      execute_assert(p, e, s, s1, n1, d1) IMPLIES
      execute_assert(p, e, s, s2, n2, d2) IMPLIES
        s1 = s2 AND n1 = n2

ENDASSUMING

  IMPORTING WF[nat, nat] % used in the proofs

  derive_determ_step : LEMMA % 
    FORALL (p : FullProgram)(n1, n2 : nat)(b : (wf_Body(program(p))))
           (v1, v2 : Val, sigma, sigma1, sigma2 : FullState) :
        derive(p)(b, sigma, v1, sigma1)(n1) IMPLIES
        derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
           v1 = v2 AND sigma1 = sigma2 AND n1 = n2

  
  derive_determ : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState)(b : (wf_Body(program(p)))) :
      FORALL (v1, v2 : Val, sigma1, sigma2 : FullState) :
        derives(p)(b, sigma)(v1, sigma1) AND
        derives(p)(b, sigma)(v2, sigma2) IMPLIES
          v1 = v2 AND sigma1 = sigma2


  derive_bottom_iff_exception_step : LEMMA % :-)
    FORALL (p : FullProgram)(e : (wf_Body(program(p))))
           (sigma1, sigma2 : FullState, v : Val, n : nat) :
      derive(p)(e, sigma1, v, sigma2)(n) IMPLIES
        Bottom?(v) = up?(ex(pstate(sigma2)))


  derive_boolean_expr_type : LEMMA % :-)
    FORALL (p : FullProgram)(b : (wf_BoolExpr(program(p))))
           (sigma1, sigma2 : FullState, v : Val, n : nat) :
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
      NOT up?(ex(pstate(sigma2))) IMPLIES
        Bool?(v)


END SemanticsProofs


% Functions related to the semantics of JML needed to instantiate Semantics.
SemanticsJML[Name : TYPE+,
             FullProgram, FullState : TYPE,
             (IMPORTING WellFormedProgram[Name]) 
                  program : [FullProgram -> Program[Name]],
             (IMPORTING State[Name]) pstate : [FullState -> PState],
             (IMPORTING SemanticsTypes[Name, FullProgram, FullState, 
                                       program, pstate])
             update_PState : (update_PState_type),
             gvs : [FullState -> Store[Name]],
             (IMPORTING SemanticsJMLTypes[Name, FullState, gvs])
             update_GhostVars : (update_GhostVars_type)] : THEORY
BEGIN

  is_ghost(vn : Name, sigma : FullState) : boolean =
    defined?(gvs(sigma)(vn))

  lookup(vn : Name, sigma : FullState) : Val =
    IF is_local(vn, pstate(sigma))
    THEN lookup_local(vn, pstate(sigma))
    ELSIF is_field(vn, pstate(sigma))
    THEN lookup_field(vn, pstate(sigma))
    ELSE gvs(sigma)(vn)
    ENDIF

  wf_ghoststate(p : FullProgram)(sigma : FullState) : boolean =
    FORALL (vn : Name) :
      is_ghost(vn, sigma) IFF var_names(getGhostDecls(program(p)))(vn)

  wf_initial_ghost_state : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState) :
      (gvs(sigma) = LAMBDA (n : Name) :
                      LET gd = get_GhostDecl(n, program(p)) IN
                      IF bottom?(gd)
                      THEN Bottom
                      ELSE init_val(down(gd))
                      ENDIF) IMPLIES
      wf_ghoststate(p)(sigma)

  execute_set : (execute_set_type) =
    LAMBDA (p : FullProgram, vn : Name, e : (wf_Expr(program(p))), 
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
      EXISTS (tau : FullState, v : Val) :
        n > 0 AND
        derive_rec(n)(p)(e, s1, v, tau)(n - 1) AND
        s2 = IF up?(ex(pstate(tau)))
             THEN tau
             ELSE update_GhostVars(tau, update_store(vn, v))
             ENDIF AND
        pstate(s1) = pstate(s2)

  % TODO: See execute_CaseJML_TCC4
  execute_CaseJML : (execute_CaseJML_type) =
    LAMBDA (p : FullProgram, 
            branches : ({l : list[[BoolExpr, Stmt]] | wf_Branches(program(p))(l)}), 
            s1, s2 : FullState,
            n : nat, derive_rec : derive_rec_type(n)) :
      CASES branches OF
        null : n = 0 AND s1 = s2,
        cons(x, xs) : n > 0 AND
                      % MH: HACK Needed: this looks like PVS bug to me
                      % If we replace the s by the CaseJML(xs), it does not
                      % type check
                      LET s : Stmt = CaseJML(xs) IN
                      derive_rec(n)(p)(IfThenElse(proj_1(x), proj_2(x), s),
                                       s1, Unit, s2)(n - 1) AND
                      pstate(s1) = pstate(s2)
      ENDCASES

  IMPORTING ProgramFunctions[Name]

  check_assertion(p : FullProgram)
                 (e : (wf_BoolExpr(program(p))), s1, s2 : FullState)(n : nat)
                 (derive : derive_type(n)) : boolean =
    n > 0 AND
    EXISTS (tau1 : FullState, v : Val) :
      derive(p)(e, s1, v, tau1)(n - 1) AND
      s2 = IF Bool?(v) THEN
             IF b(v)
             THEN tau1
             ELSE update_PState(tau1, raise(JMLExc))
             ENDIF
           ELSE tau1 % This won't happen in a well typed program
           ENDIF

  execute_assert : (execute_assert_type) =
    LAMBDA (p : FullProgram, e : (wf_BoolExpr(program(p))), 
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) 
    THEN s1 = s2 AND n = 0
    ELSE 
      check_assertion(p)(e, s1, s2)(n)(derive_rec(n)) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  on_method_entry : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : (wf_Method(program(p))), a : Val, 
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) 
    THEN s1 = s2 AND n = 0
    ELSE 
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : FullState, 
            inv : (wf_BoolExpr(program(p)))) :
      n = m1 + m2 + m3 + 1 AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, s1, tau1)(m1)(derive_rec(m1)) AND
      check_assertion(p)(pre(md), tau1, tau2)(m2)(derive_rec(m2)) AND
      derive_rec(n)(p)(pre_set(md), tau2, Unit, s2)(m3) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  on_method_exit_normal : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : (wf_Method(program(p))), a : Val, 
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) 
    THEN s1 = s2 AND n = 0
    ELSE 
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : FullState, 
            inv : (wf_BoolExpr(program(p)))) :
      n = m1 + m2 + m3 + 1 AND
      derive_rec(n)(p)(post_set(md), s1, Unit, tau1)(m1) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, tau1, tau2)(m2)(derive_rec(m2)) AND
      check_assertion(p)(post(md), tau2, s2)(m3)(derive_rec(m3)) AND
      st(pstate(s1)) = st(pstate(s2))
    ENDIF

  % If there was an exception, there is no need to chech the postcondition
  % (JML has an exceptional postcondition but we are not modelling it)
  on_method_exit_exceptional : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : (wf_Method(program(p))), a : Val, 
            s1, s2 : FullState, n : nat,
            derive_rec : derive_rec_type(n)) :
    IF up?(ex(pstate(s1))) 
    THEN 
    EXISTS (m1, m2 : nat, tau1, tau2 : FullState, 
            inv : (wf_BoolExpr(program(p)))) :
      n = m1 + m2 + 1 AND
      derive_rec(n)(p)(exc_set(md), update_PState(s1, catch), Unit, tau1)(m1) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, tau1, tau2)(m2)(derive_rec(m2)) AND
      s2 = (IF up?(ex(pstate(tau2)))
            THEN tau2 
            ELSE update_PState(tau2, raise(down(ex(pstate(s1)))))
            ENDIF) AND
      st(pstate(s1)) = st(pstate(s2))
    ELSE s1 = s2 AND n = 0
    ENDIF


END SemanticsJML
