Excpt : DATATYPE
BEGIN

  Throwable : Throwable?
  NullPointer : NullPointer?
  JMLExc : JMLExc?


END Excpt


State[Name : TYPE+] : THEORY
BEGIN

  IMPORTING Excpt,
            WellFormedProgram[Name],
            Val,
            ValProp

  % A store is a mapping from names to values. Partial mappings are represented
  % using the value Bottom.
  Store : TYPE = [Name -> Val]

  % Field and local variables.
  PSt : TYPE = [# fvs, lvs : Store #]

  PState : TYPE = [# ex : lift[Excpt],
                     st : PSt #]

  lift_PSt(p : PSt) : PState =
    (# ex := bottom, st := p #)

  CONVERSION lift_PSt

  is_local(vn : Name, sigma : PState) : boolean =
    defined?(lvs(st(sigma))(vn))

  is_field(vn : Name, sigma : PState) : boolean =
    defined?(fvs(st(sigma))(vn))

  lookup_local(vn : Name, sigma : PState) : Val =
    lvs(st(sigma))(vn)

  lookup_field(vn : Name, sigma : PState) : Val =
    fvs(st(sigma))(vn)

  update_local(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)),
                lvs := lvs(st(sigma)) WITH [vn := v] #) #)

  update_field(vn : Name, v : Val)(sigma : PState) : PState =
    (# ex := ex(sigma),
       st := (# fvs := fvs(st(sigma)) WITH [vn := v],
                lvs := lvs(st(sigma)) #) #)

  lookup(vn : Name, sigma : PState) : Val =
    IF is_local(vn, sigma)
    THEN lookup_local(vn, sigma)
    ELSE lookup_field(vn, sigma)
    ENDIF

  update(vn : Name, v : Val)(sigma : PState) : PState =
    IF is_local(vn, sigma)
    THEN update_local(vn, v)(sigma)
    ELSE update_field(vn, v)(sigma)
    ENDIF

  val2int(v : Val) : int =
    IF Int?(v)
    THEN i(v)
    ELSE 0
    ENDIF

  val2bool(v : Val) : bool =
    IF Bool?(v)
    THEN b(v)
    ELSE FALSE
    ENDIF


  % Well formed states definition
  wf_state(p : Program)(s : PState) : boolean =
    FORALL (vn : Name) :
      (is_field(vn, s) IFF var_names(getFieldDecls(p))(vn)) AND
      (is_local(vn, s) IFF var_names(getLocalDecls(p))(vn))

  % Well formed states properties

  wf_state_vars_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : PState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
        ((is_field(vn, s) IMPLIES NOT is_local(vn, s)) AND
         (is_local(vn, s) IMPLIES NOT is_field(vn, s)))


END State


Evaluation[Name : TYPE+, 
           FullState : TYPE,
           (IMPORTING State) pstate : [FullState -> PState[Name]],
           lookup : [Name, FullState -> Val]] : THEORY
BEGIN

  IMPORTING State[Name]

  % NOTE: I'm evaluating division by 0 to 0, I do not want to care about 
  % modeling that exception here. The result is floored (this should actually
  % be analysed, sometimes floor, sometimes ceil).
  % Also, looking up a non-existing variable just returns 0
  eval(n : NumExpr)(sigma : FullState) : RECURSIVE int =
    CASES n OF
      Int(i) : i,
      Plus(n1, n2) : eval(n1)(sigma) + eval(n2)(sigma),
      Minus(n1, n2) : eval(n1)(sigma) - eval(n2)(sigma),
      Times(n1, n2) : eval(n1)(sigma) * eval(n2)(sigma),
      Div(n1, n2) : IF eval(n2)(sigma) = 0 
                    THEN 0
                    ELSE floor(eval(n1)(sigma) / eval(n2)(sigma))
                    ENDIF,
      NumVarEval(vn) : val2int(lookup(vn, sigma))
    ENDCASES
  MEASURE n BY <<

  eval(b : BoolExpr)(sigma : FullState) : RECURSIVE bool =
    CASES b OF
      TT : TRUE,
      FF : FALSE,
      Neg(b) : NOT eval(b)(sigma),
      Conj(b1, b2) : eval(b1)(sigma) AND eval(b2)(sigma),
      Disj(b1, b2) : eval(b1)(sigma) OR eval(b2)(sigma),
      Lt(b1, b2) : eval(b1)(sigma) < eval(b2)(sigma),
      Le(b1, b2) : eval(b1)(sigma) <= eval(b2)(sigma),
      Eq(b1, b2) : eval(b1)(sigma) = eval(b2)(sigma),
      Neq(b1, b2) : eval(b1)(sigma) /= eval(b2)(sigma),
      Gt(b1, b2) : eval(b1)(sigma) > eval(b2)(sigma),
      Ge(b1, b2) : eval(b1)(sigma) >= eval(b2)(sigma),
      BoolVarEval(vn) : val2bool(lookup(vn, sigma))
    ENDCASES
  MEASURE b BY <<

  % Function whose existence we assume
  get_address(vn : Name)(sigma : FullState) : int

  eval(r : RefExpr)(sigma : FullState) : Val =
    IF Null?(r) 
    THEN Null
    ELSE RefType(get_address(varname(r))(sigma))
    ENDIF


END Evaluation


SemanticsTypes[Name : TYPE+,
               FullProgram, FullState : TYPE,
               (IMPORTING State[Name]) pstate : [FullState -> PState],
               gvs : [FullState -> Store]] : THEORY
BEGIN

  IMPORTING Program[Name]

  deriv_expr_type(n : nat) : TYPE =
    [FullProgram -> [Expr, FullState, Val, FullState -> [below(n) -> bool]]]

  deriv_stmt_type(n : nat) : TYPE =
    [FullProgram -> [Stmt, FullState, FullState -> [below(n) -> bool]]]

  deriv_expr_rec_type(n : nat) : TYPE = [k : upto(n) -> deriv_expr_type(k)]

  deriv_stmt_rec_type(n : nat) : TYPE = [k : upto(n) -> deriv_stmt_type(k)]

  update_PState_type(f : [FullState, PState -> FullState]) : boolean =
    FORALL (s1, s2 : FullState, pst : PState) :
      f(s1, pst) = s2 IMPLIES pstate(s2) = pst

  update_GhostVars_type(f : [FullState, Store -> FullState]) : boolean =
    FORALL (s1, s2 : FullState, gvs : Store) :
      f(s1, gvs) = s2 IMPLIES gvs(s2) = gvs

  execute_set_type
    (f : [FullProgram, Name, Expr, FullState, FullState, n : nat,
         deriv_stmt_rec_type(n), deriv_expr_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, vn : Name, e : Expr, s1, s2 : FullState,
            n : nat, ds : deriv_stmt_rec_type(n), de : deriv_expr_rec_type(n)) :
      f(p, vn, e, s1, s2, n, ds, de) IMPLIES pstate(s2) = pstate(s1)

  execute_CaseJML_type
    (f : [FullProgram, list[[Expr, Stmt]], FullState, FullState, n : nat,
         deriv_stmt_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, branches : list[[Expr, Stmt]], s1, s2 : FullState,
            n : nat, ds : deriv_stmt_rec_type(n)) :
      f(p, branches, s1, s2, n, ds) IMPLIES pstate(s2) = pstate(s1)

  % We allow on_method_event to throw an exception if an assertion failed
  on_method_event_type
    (f : [FullProgram, Method[Name], Val, FullState, FullState, n : nat,
         deriv_stmt_rec_type(n), deriv_expr_rec_type(n) -> boolean]) : boolean =
    FORALL (p : FullProgram, md : Method[Name], a : Val, s1, s2 : FullState,
            n : nat, ds : deriv_stmt_rec_type(n), de : deriv_expr_rec_type(n)) :
      f(p, md, a, s1, s2, n, ds, de) IMPLIES st(pstate(s1)) = st(pstate(s2))

  is_ghost(vn : Name, sigma : FullState) : boolean =
    NOT Bottom?(gvs(sigma)(vn))

  lookup(vn : Name, sigma : FullState) : Val =
    IF is_local(vn, pstate(sigma))
    THEN lookup_local(vn, pstate(sigma))
    ELSIF is_field(vn, pstate(sigma))
    THEN lookup_field(vn, pstate(sigma))
    ELSE gvs(sigma)(vn)
    ENDIF


END SemanticsTypes


Semantics[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING Program) program : [FullProgram -> Program[Name]],
          (IMPORTING State) pstate : [FullState -> PState[Name]],
          gvs : [FullState -> Store[Name]],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState, pstate, gvs])
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN

  IMPORTING Evaluation[Name, FullState, pstate, lookup]

  % TODO: adapt (see Marieke's comment)
  update_stack(this_val : Val, param_name : Name, param_val : Val, 
               lvds : set[LocalVarDecl], s : FullState) : FullState %=
%     LET update_state(sP : PState) =
%       sP WITH [st := st(sP) 
%            WITH [lvs := LAMBDA (n : Name) :
%              LET lv = get_LocalVarDecl(n, lvds) IN
%              IF n = This
%              THEN this_val
%              ELSIF n = param_name
%              THEN param_val
%              ELSIF up?(lv)
%              THEN default_value(jtype(down(lv)))
%              ELSE lvs(st(sP))(n)
%              ENDIF]]
%     IN
%       update_FullState(update_state, s)


  deriv_expr(p : FullProgram)
            (c : Expr, sigma1 : FullState, v : Val, sigma2 : FullState)
            (n : nat)(deriv_stmt : deriv_stmt_type(n)) : RECURSIVE bool =
    LET 
      deriv_stmt_rec =
        LAMBDA (k : upto(n))(p : FullProgram)
               (s : Stmt, sigma1, sigma2 : FullState)
               (m : below(k)) :
          deriv_stmt(p)(s, sigma1, sigma2)(m),
      deriv_expr_rec =
        LAMBDA (k : upto(n))(p : FullProgram)
               (c : Expr, sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          deriv_expr(p)(c, sigma1, v, sigma2)(m)(deriv_stmt_rec(m)),
      bounded_deriv_stmt_rec =
        LAMBDA (i : upto(n))(k : upto(i))(p : FullProgram)
               (s : Stmt, sigma1, sigma2 : FullState)
               (m : below(k)) :
          deriv_stmt(p)(s, sigma1, sigma2)(m),
      bounded_deriv_expr_rec =
        LAMBDA (i : upto(n))(k : upto(i))(p : FullProgram)
               (c : Expr, sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          deriv_expr(p)(c, sigma1, v, sigma2)(m)(deriv_stmt_rec(m))
    IN
    IF up?(ex(pstate(sigma1)))
    % sigma1 is an exceptional state, exceptions are simply propagated
    THEN sigma1 = sigma2 AND v = Bottom AND n = 0
    ELSE % sigma1 is a normal state
    CASES c OF
      Assign(vn, e) :
        n > 0 AND
        (EXISTS (tau : FullState) :
           deriv_expr_rec(n)(p)(e, sigma1, v, tau)(n - 1) AND
           sigma2 = (IF up?(ex(pstate(tau)))
                     THEN tau
                     ELSE update_PState(tau, update(vn, v)(pstate(tau)))
                     ENDIF)),
      BExpr(b) :
        sigma1 = sigma2 AND n = 0 AND
        v = Bool(eval(b)(sigma1)),
      CondExpr(c, t, e) :
        EXISTS (tau : FullState, v1 : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          deriv_expr_rec(n)(p)(c, sigma1, v1, tau)(m1) AND
          Bool?(v1) AND
          deriv_expr_rec(n)(p)(IF b(v1) THEN t ELSE e ENDIF, 
                               tau, v, sigma2)(m2),
      MethodCall(e, mn, pr) :
        EXISTS (m1, m2, m3, m4, m5, m6 : nat)
               (tau1, tau2, tau3, tau4, tau5, tau6, tau7, tau8 : FullState)
               (a, pv, old_val_arg : Val)(md : Method)(inv : BoolExpr) :
          n = m1 + m2 + m3 + m4 + m5 + m6 + 1 AND
          % evaluate the receiver object
          deriv_expr_rec(n)(p)(e, sigma1, a, tau1)(m1) AND
          % evaluate the parameter
          deriv_expr_rec(n)(p)(pr, tau1, pv, tau2)(m2) AND
          % see if the receiver is null (and there were no previous exceptions)
          tau3 = IF bottom?(ex(pstate(tau2))) AND Null?(a)
                 THEN update_PState(tau2, 
                                    pstate(tau2) WITH [ex := up(NullPointer)])
                 ELSE tau2
                 ENDIF AND
          % lookup method definition
          IF up?(lookup_mthd(program(p), a, mn))
          THEN md = down(lookup_mthd(program(p), a, mn))
          ELSE FALSE % should not happen in a wf_Program
          ENDIF AND
          % actions taken at the entry of the method
          on_method_entry(p, md, a, tau3, tau4, m3,
                          bounded_deriv_stmt_rec(m3),
                          bounded_deriv_expr_rec(m3)) AND
          % give a name the value of the argument before the call,
          old_val_arg = lookup_local(name(arg(md)), pstate(tau4)) AND
          % update the value of this, the argument and initialize the local vars
          tau5 = update_stack(a, name(arg(md)), pv, lvars(md), tau4) AND
          % execute the body
          deriv_stmt(p)(body(md), tau5, tau6)(m4) AND
          % evaluate the result
          IF Void?(res_type(md))
          THEN tau7 = tau6 AND v = Unit AND m5 = 0
          ELSE deriv_expr_rec(n)(p)(res(md), tau6, v, tau7)(m5)
          ENDIF AND
          % actions taken at the exit of the method
          IF bottom?(ex(pstate(tau7)))
          THEN on_method_exit_normal(p, md, a, tau7, tau8, m6,
                                     bounded_deriv_stmt_rec(m6),
                                     bounded_deriv_expr_rec(m6))
          ELSE on_method_exit_exceptional(p, md, a, tau7, tau8, m6,
                                          bounded_deriv_stmt_rec(m6),
                                          bounded_deriv_expr_rec(m6))
          ENDIF AND
          % restore the value of the argument
          sigma2 = update_PState(tau8, update_local(name(arg(md)),
                                                    old_val_arg)(pstate(tau8))),
      NExpr(n) :
        sigma1 = sigma2 AND n = 0 AND
        v = Int(eval(n)(sigma1)),
      RExpr(r) :
        sigma1 = sigma2 AND n = 0 AND
        v = eval(r)(sigma1)
    ENDCASES
    ENDIF
  MEASURE n
    

  deriv_stmt(p : FullProgram)
            (c : Stmt, sigma1, sigma2 : FullState)
            (n : nat) : RECURSIVE bool =
    LET 
      deriv_stmt_rec =
        LAMBDA (k : upto(n))(p : FullProgram)
               (s : Stmt, sigma1, sigma2 : FullState)(m : below(k)) :
          deriv_stmt(p)(s, sigma1, sigma2)(m),
      deriv_expr_rec =
        LAMBDA (k : upto(n))(p : FullProgram)
               (c : Expr, sigma1 : FullState, v : Val, sigma2 : FullState)
               (m : below(k)) :
          deriv_expr(p)(c, sigma1, v, sigma2)(m)(deriv_stmt_rec(m))
    IN
    IF up?(ex(pstate(sigma1)))
    % sigma1 is an exceptional state, exceptions are simply propagated
    THEN sigma1 = sigma2 AND n = 0
    ELSE % sigma1 is a normal state
    CASES c OF
      CaseJML(l) :
        n > 0 AND
        execute_CaseJML(p, l, sigma1, sigma2, n, deriv_stmt_rec),
      IfThenElse(e, c1, c2) :
        EXISTS (tau : FullState, v : Val, m1, m2 : nat) :
          n = m1 + m2 + 1 AND
          deriv_expr_rec(n)(p)(e, sigma1, v, tau)(m1) AND
          Bool?(v) AND
          deriv_stmt(p)(IF b(v) THEN c1 ELSE c2 ENDIF, tau, sigma2)(m2),
      Sequence(c1, c2) :
         EXISTS(m1, m2 : nat)(tau : FullState) :
           n = m1 + m2 + 1 AND
           deriv_stmt(p)(c1, sigma1, tau)(m1) AND
           deriv_stmt(p)(c2, tau, sigma2)(m2),
      Set(vn, e) :
         n > 0 AND
         execute_set(p, vn, e, sigma1, sigma2, n,
                     deriv_stmt_rec, deriv_expr_rec),
      Skip : sigma1 = sigma2 AND n = 0,
      StmtExpr(e) :
         n > 0 AND
         EXISTS (v : Val) : deriv_expr_rec(n)(p)(e, sigma1, v, sigma2)(n - 1),
      Throw: 
        n = 0 AND
        sigma2 = update_PState(sigma1, pstate(sigma1) WITH [ex := up(Throwable)]),
      TryCatch(c1, c2, c3) :
        EXISTS (m1, m2, m3 : nat)(tau1, tau2, tau3 : FullState) :
          n = m1 + m2 + m3 + 1 AND
          deriv_stmt(p)(c1, sigma1, tau1)(m1) AND
          deriv_stmt(p)(IF up?(ex(pstate(tau1))) THEN c2 ELSE Skip ENDIF,
                        update_PState(tau1, pstate(tau1) WITH [ex := bottom]),
                        tau2)(m2) AND
          deriv_stmt(p)(c3, 
                        update_PState(tau2, pstate(tau2) WITH [ex := bottom]),
                        tau3)(m3) AND
          sigma2 = update_PState(tau3,
                                 IF up?(ex(pstate(tau2)))
                                 THEN pstate(tau3) WITH [ex := ex(pstate(tau2))]
                                 ELSE pstate(tau3) WITH [ex := ex(pstate(tau3))]
                                 ENDIF),
      While(e, c) :
        n > 0 AND
        deriv_stmt(p)(IfThenElse(e, While(e, c), Skip), sigma1, sigma2)(n - 1)
    ENDCASES
  ENDIF
  MEASURE n

  % Version that does not has deriv_stmt as argument
  deriv_expr(p : FullProgram)
            (e : Expr, sigma1 : FullState, v : Val, sigma2 : FullState)
            (n : nat) : bool =
    deriv_expr(p)(e, sigma1, v, sigma2)(n)
              (LAMBDA (p : FullProgram)(c : Stmt, sigma1, sigma2 : FullState)
                      (m : below(n)) :
                 deriv_stmt(p)(c, sigma1, sigma2)(m))

  deriv_expr_rec(n : nat) : deriv_expr_type(n) =
    LAMBDA (p : FullProgram)
           (e : Expr, sigma1 : FullState, v : Val,  sigma2 : FullState)
           (k : below(n)) :
      deriv_expr(p)(e, sigma1, v, sigma2)(k)

  deriv_stmt_rec(n : nat) : deriv_stmt_type(n) =
    LAMBDA (p : FullProgram)
           (c : Stmt, sigma1, sigma2 : FullState)(k : below(n)) :
      deriv_stmt(p)(c, sigma1, sigma2)(k)

  % MH: should this not be n : upto(i)
  bounded_deriv_expr_rec(i : nat) : deriv_expr_rec_type(i) =
    LAMBDA (n : below(i))(p : FullProgram)
           (e : Expr, sigma1 : FullState, v : Val,  sigma2 : FullState)
           (k : below(n)) :
      deriv_expr_rec(n)(p)(e, sigma1, v, sigma2)(k)

  bounded_deriv_stmt_rec(i : nat) : deriv_stmt_rec_type(i) =
    LAMBDA (n : below(i))(p : FullProgram)
           (c : Stmt, sigma1, sigma2 : FullState)(k : below(n)) :
      deriv_stmt_rec(n)(p)(c, sigma1, sigma2)(k)


  derives(p : FullProgram)
         (e : Expr, sigma1 : FullState)(v : Val, sigma2 : FullState) : bool =
    EXISTS (n : nat) :
      deriv_expr(p)(e, sigma1, v, sigma2)(n)

  derives(p : FullProgram)
         (s : Stmt, sigma1 : FullState)(sigma2 : FullState) : bool =
    EXISTS (n : nat) : 
      deriv_stmt(p)(s, sigma1, sigma2)(n)


  % The following expression (that appear only in annotations) should have no
  % side-effects: invariants, preconditions, postconditions, source expression
  % of a set statement.
  well_behaved_Program(p : FullProgram) : boolean =
    FORALL (c : Class) :
      classes(program(p))(c) IMPLIES
        (FORALL (s1, s2 : FullState, v : Val, n : nat) :
          deriv_expr(p)(inv(c), s1, v, s2)(n) IMPLIES s1 = s2) AND
        FORALL (m : Method) :
          methods(c)(m) IMPLIES
            (FORALL (s1, s2 : FullState, v : Val, n : nat) :
              deriv_expr(p)(pre(m), s1, v, s2)(n) IMPLIES s1 = s2) AND
            (FORALL (s1, s2 : FullState, v : Val, n : nat) :
              deriv_expr(p)(post(m), s1, v, s2)(n) IMPLIES s1 = s2) AND
            (FORALL (s : Stmt) :
              set_subterm(s, m) IMPLIES
              Set?(s) IMPLIES
                FORALL (s1, s2 : FullState, v : Val, n : nat) :
                  deriv_expr(p)(source(s), s1, v, s2)(n) IMPLIES s1 = s2)


  run_FullProgram(p : FullProgram)(main : Method, arg : int)
                 (initial, final : FullState)(n : nat) : boolean =
    LET c  = StmtExpr(MethodCall(RExpr(RefVarEval(This)),
                                 name(main),
                                 NExpr(Int(arg))))
    IN
      deriv_stmt(p)(c, initial, final)(n)


END Semantics


% Properties about Semantics
SemanticsProofs[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING Program) program : [FullProgram -> Program[Name]],
          (IMPORTING State) pstate : [FullState -> PState[Name]],
          gvs : [FullState -> Store[Name]],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState, pstate, gvs])
          lookup : [Name, FullState -> Val], 
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN
ASSUMING

    IMPORTING Semantics[Name, FullProgram, FullState, program, pstate, gvs,
              update_PState, execute_set, execute_CaseJML,
              on_method_entry, on_method_exit_normal,
              on_method_exit_exceptional]

    on_method_entry_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : Method[Name], v : Val, 
              s, s1, s2 : FullState, n1, n2 : nat) 
             (ds1 : deriv_stmt_rec_type(n1), de1 : deriv_expr_rec_type(n1),
              ds2 : deriv_stmt_rec_type(n2), de2 : deriv_expr_rec_type(n2)) : 
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          ds1(k1)(p)(c, sigma, sigma1)(m1) AND
          ds2(k2)(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2) IMPLIES
        (FORALL (c : Expr)(v1, v2 : Val)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          de1(k1)(p)(c, sigma, v1, sigma1)(m1) AND
          de2(k2)(p)(c, sigma, v2, sigma2)(m2) IMPLIES
            v1 = v2 AND sigma1 = sigma2 AND m1 = m2) IMPLIES
      on_method_entry(p, m, v, s, s1, n1, ds1, de1) IMPLIES
      on_method_entry(p, m, v, s, s2, n2, ds2, de2) IMPLIES
        s1 = s2 AND n1 = n2

    on_method_exit_normal_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : Method[Name], v : Val, 
              s, s1, s2 : FullState, n1, n2 : nat,
              ds1 : deriv_stmt_rec_type(n1), de1 : deriv_expr_rec_type(n1),
              ds2 : deriv_stmt_rec_type(n2), de2 : deriv_expr_rec_type(n2)) : 
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          ds1(k1)(p)(c, sigma, sigma1)(m1) AND
          ds2(k2)(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2) IMPLIES
        (FORALL (c : Expr)(v1, v2 : Val)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          de1(k1)(p)(c, sigma, v1, sigma1)(m1) AND
          de2(k2)(p)(c, sigma, v2, sigma2)(m2) IMPLIES
            v1 = v2 AND sigma1 = sigma2 AND m1 = m2) IMPLIES
      on_method_exit_normal(p, m, v, s, s1, n1, ds1, de1) IMPLIES
      on_method_exit_normal(p, m, v, s, s2, n2, ds2, de2) IMPLIES
        s1 = s2 AND n1 = n2

    on_method_exit_exceptional_deterministic : ASSUMPTION
      FORALL (p : FullProgram, m : Method[Name], v : Val, 
              s, s1, s2 : FullState, n1, n2 : nat,
              ds1 : deriv_stmt_rec_type(n1), de1 : deriv_expr_rec_type(n1),
              ds2 : deriv_stmt_rec_type(n2), de2 : deriv_expr_rec_type(n2)) : 
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          ds1(k1)(p)(c, sigma, sigma1)(m1) AND
          ds2(k2)(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2) IMPLIES
        (FORALL (c : Expr)(v1, v2 : Val)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          de1(k1)(p)(c, sigma, v1, sigma1)(m1) AND
          de2(k2)(p)(c, sigma, v2, sigma2)(m2) IMPLIES
            v1 = v2 AND sigma1 = sigma2 AND m1 = m2) IMPLIES
      on_method_exit_exceptional(p, m, v, s, s1, n1, ds1, de1) IMPLIES
      on_method_exit_exceptional(p, m, v, s, s2, n2, ds2, de2) IMPLIES
        s1 = s2 AND n1 = n2


  execute_CaseJML_deterministic : ASSUMPTION
    FORALL (p : FullProgram, branches : list[[Expr, Stmt]], 
            s, s1, s2 : FullState,
            n1, n2 : nat, 
            ds1 : deriv_stmt_rec_type(n1), de1 : deriv_expr_rec_type(n1),
            ds2 : deriv_stmt_rec_type(n2), de2 : deriv_expr_rec_type(n2)) :
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          ds1(k1)(p)(c, sigma, sigma1)(m1) AND
          ds2(k2)(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2) IMPLIES
        (FORALL (c : Expr)(v1, v2 : Val)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          de1(k1)(p)(c, sigma, v1, sigma1)(m1) AND
          de2(k2)(p)(c, sigma, v2, sigma2)(m2) IMPLIES
            v1 = v2 AND sigma1 = sigma2 AND m1 = m2) IMPLIES
         execute_CaseJML(p, branches, s, s1, n1, ds1) IMPLIES 
         execute_CaseJML(p, branches, s, s2, n2, ds2) IMPLIES 
%         execute_CaseJML(p, branches, s, s1, n1, ds1, de1) IMPLIES 
%         execute_CaseJML(p, branches, s, s2, n2, ds2, de2) IMPLIES 
           s1 = s2 AND n1 = n2

  execute_set_deterministic : ASSUMPTION
    FORALL (p : FullProgram, vn : Name, e : Expr, s, s1, s2 : FullState,
            n1, n2 : nat, 
            ds1 : deriv_stmt_rec_type(n1), de1 : deriv_expr_rec_type(n1),
            ds2 : deriv_stmt_rec_type(n2), de2 : deriv_expr_rec_type(n2)) :
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          ds1(k1)(p)(c, sigma, sigma1)(m1) AND
          ds2(k2)(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2) IMPLIES
        (FORALL (c : Expr)(v1, v2 : Val)(sigma, sigma1, sigma2 : FullState)
                (k1 : upto(n1), k2 : upto(n2))
                (m1 : below(k1), m2 : below(k2)) :
          de1(k1)(p)(c, sigma, v1, sigma1)(m1) AND
          de2(k2)(p)(c, sigma, v2, sigma2)(m2) IMPLIES
            v1 = v2 AND sigma1 = sigma2 AND m1 = m2) IMPLIES
      execute_set(p, vn, e, s, s1, n1, ds1, de1) IMPLIES
      execute_set(p, vn, e, s, s2, n2, ds2, de2) IMPLIES
        s1 = s2 AND n1 = n2

ENDASSUMING


  IMPORTING WF[nat, nat] % used in the proofs


  expr_determ_step : LEMMA % :-)
    FORALL (p : FullProgram)(n1, n2 : nat)(e : Expr)
           (v1, v2 : Val, sigma, sigma1, sigma2 : FullState) :
        (FORALL (c : Stmt)(sigma, sigma1, sigma2 : FullState)
                (m1 : below(n1), m2 : below(n2)) :
          deriv_stmt(p)(c, sigma, sigma1)(m1) AND
          deriv_stmt(p)(c, sigma, sigma2)(m2) IMPLIES
            sigma1 = sigma2 AND m1 = m2) IMPLIES
        deriv_expr(p)(e, sigma, v1, sigma1)(n1) IMPLIES
        deriv_expr(p)(e, sigma, v2, sigma2)(n2) IMPLIES
           v1 = v2 AND sigma1 = sigma2 AND n1 = n2

  stmt_determ_step : LEMMA % :-)
    FORALL (p : FullProgram)(n1, n2 : nat)(c : Stmt)(sigma : FullState) :
      FORALL (sigma1, sigma2 : FullState) :
        deriv_stmt(p)(c, sigma, sigma1)(n1) AND
        deriv_stmt(p)(c, sigma, sigma2)(n2) IMPLIES
          sigma1 = sigma2 AND n1 = n2
  
  expr_determ : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState)(e : Expr) :
      FORALL (v1, v2 : Val, sigma1, sigma2 : FullState) :
        derives(p)(e, sigma)(v1, sigma1) AND
        derives(p)(e, sigma)(v2, sigma2) IMPLIES
          v1 = v2 AND sigma1 = sigma2

  stmt_determ : LEMMA % :-)
    FORALL (p : FullProgram)(sigma : FullState)(c : Stmt) :
      FORALL (sigma1, sigma2 : FullState) :
        derives(p)(c, sigma)(sigma1) AND
        derives(p)(c, sigma)(sigma2) IMPLIES
          sigma1 = sigma2


END SemanticsProofs


% Functions related to the semantics of JML needed to instantiate Semantics.
SemanticsJML[Name : TYPE+,
                FullProgram, FullState : TYPE,
                (IMPORTING Program) program : [FullProgram -> Program[Name]],
                (IMPORTING State[Name]) pstate : [FullState -> PState],
                gvs : [FullState -> Store[Name]],
                (IMPORTING SemanticsTypes[Name, FullProgram, FullState, pstate, gvs])
                update_PState : (update_PState_type),
                update_GhostVars : (update_GhostVars_type)] : THEORY
BEGIN

  execute_set : (execute_set_type) =
    LAMBDA (p : FullProgram, vn : Name, e : Expr, s1, s2 : FullState, n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
      EXISTS (tau : FullState, v : Val) :
        n > 0 AND
        deriv_expr_rec(n)(p)(e, s1, v, tau)(n - 1) AND
        s2 = IF up?(ex(pstate(tau)))
             THEN tau
             ELSE update_GhostVars(tau, gvs(tau) WITH [vn := v])
             ENDIF AND
        pstate(s1) = pstate(s2)

  execute_CaseJML : (execute_CaseJML_type) =
    LAMBDA (p : FullProgram, branches : list[[Expr, Stmt]], s1, s2 : FullState,
            n : nat, deriv_stmt_rec : deriv_stmt_rec_type(n)) :
      CASES branches OF
        null : n = 0 AND s1 = s2,
        cons(x, xs) : n > 0 AND
                      deriv_stmt_rec(n)(p)(IfThenElse(proj_1(x), proj_2(x),
                                                      CaseJML(xs)),
                                           s1, s2)(n - 1) AND
                      pstate(s1) = pstate(s2)
      ENDCASES

  IMPORTING ProgramFunctions[Name]

  check_assertion(p : FullProgram)
                 (e : Expr, s1, s2 : FullState)(n : nat)
                 (deriv_expr : deriv_expr_type(n)) : boolean =
    n > 0 AND
    EXISTS (tau1 : FullState, v : Val) :
      deriv_expr(p)(e, s1, v, tau1)(n - 1) AND
      s2 = IF Bool?(v) THEN
             IF b(v)
             THEN tau1
             ELSE update_PState(tau1, pstate(tau1) WITH [ex := up(JMLExc)])
             ENDIF
           ELSE tau1 % This won't happen in a well typed program
           ENDIF

  on_method_entry : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : Method, a : Val, s1, s2 : FullState, n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : FullState, inv : Expr) :
      n = m1 + m2 + m3 + 1 AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, s1, tau1)(m1)(deriv_expr_rec(m1)) AND
      check_assertion(p)(pre(md), tau1, tau2)(m2)(deriv_expr_rec(m2)) AND
      deriv_stmt_rec(n)(p)(pre_set(md), tau2, s2)(m3) AND
      st(pstate(s1)) = st(pstate(s2))

  on_method_exit_normal : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : Method, a : Val, s1, s2 : FullState, n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    EXISTS (m1, m2, m3 : nat, tau1, tau2 : FullState, inv : Expr) :
      n = m1 + m2 + m3 + 1 AND
      deriv_stmt_rec(n)(p)(post_set(md), s1, tau1)(m1) AND
      check_assertion(p)(post(md), tau1, tau2)(m2)(deriv_expr_rec(m2)) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, tau2, s2)(m3)(deriv_expr_rec(m3)) AND
      st(pstate(s1)) = st(pstate(s2))

  % If there was an exception, there is no need to chech the postcondition
  % (JML has an exceptional postcondition but we are not modelling it)
  on_method_exit_exceptional : (on_method_event_type) =
    LAMBDA (p : FullProgram, md : Method, a : Val, s1, s2 : FullState, n : nat,
            deriv_stmt_rec : deriv_stmt_rec_type(n),
            deriv_expr_rec : deriv_expr_rec_type(n)) :
    EXISTS (m1, m2 : nat, tau1, tau2 : FullState, inv : Expr) :
      n = m1 + m2 + 1 AND
      deriv_stmt_rec(n)(p)(exc_set(md), s1, tau1)(m1) AND
      inv = lookup_inv(program(p), a) AND
      check_assertion(p)(inv, tau1, s2)(m2)(deriv_expr_rec(m2)) AND
      st(pstate(s1)) = st(pstate(s2))


END SemanticsJML
