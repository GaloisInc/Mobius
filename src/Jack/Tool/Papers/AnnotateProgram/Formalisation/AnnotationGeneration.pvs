AnnotateProgram[CP : TYPE+] : THEORY
BEGIN

  ASSUMING
    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)
  ENDASSUMING

  IMPORTING MonitoredProgramSemantics[CP, string],
            set2list,
            FunProp

  mp : VAR (wf_MP)

  a : VAR (wf_MVA)

  halted : string = name_of(halted)


  % Event annotation

  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)

  update_vars(t : Transition) : Stmt =
    Sequence(Set(cp, NExpr(NumVarEval(name_of(tcp(t))))), 
             ann_action(action(t)))

  ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[Expr, Stmt]] =
    set2list({x : [Expr, Stmt] | EXISTS (t : Transition) :
      ts(t) AND x = (guard_to_expression(mva(mp))(guard(t)), update_vars(t))})

  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) : [Expr, Stmt] =
    (BExpr(Eq(NumVarEval(cp), NumVarEval(name_of(q)))),
     CaseJML(ann_guard_actions(mp)(ts)))


  % Generates annotations to update the control point and the variables when an
  % event occurs
  ann_event(mp)(ts : finite_set[Transition]): Stmt =
    CaseJML(set2list({c : [Expr, Stmt] | EXISTS (q : CP) : 
              cps(mva(mp))(q) AND
              nonempty?({t: Transition | ts(t) AND scp(t) = q}) AND
              c = ann_trans_cp(mp)(q,
                                  {t: Transition | ts(t) AND scp(t) = q})}))


  % Method annotation

  filter_event(a)(et : EventType)(m : string) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType) : 
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))
    IN
    m WITH [pre_set  := Sequence(pre_set(m), ann_event_type(Entry)),
            post_set := Sequence(post_set(m), ann_event_type(ExitNormal)),
            exc_set  := Sequence(exc_set(m), ann_event_type(ExitExceptional))]


  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % Class annotation

  ann_class(mp)(c : Class) : Class =
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN c WITH [inv := BExpr(Conj(b(inv(c)), Neq(NumVarEval(cp), 
                                                  NumVarEval(halted)))),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF


  % Program annotation

  ann_program(mp) : Program = 
    (# classes := {c : Class | EXISTS (c1 : Class) : 
                                 classes(program(mp))(c1) AND 
                                 c = ann_class(mp)(c1)} #)


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING
    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)
  ENDASSUMING

  IMPORTING AnnotateProgram[CP],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string]

  mp : VAR (wf_MP)

  ann_program_class_correspondence : LEMMA % :-)
    FORALL(c : Class) : classes(ann_program(mp))(c) IMPLIES
      EXISTS (c1 : Class) : classes(program(mp))(c1) AND c = ann_class(mp)(c1)
 
  ann_program_method_correspondence : LEMMA % :-)
    FORALL(c : Class, m : Method) :
      classes(ann_program(mp))(c) IMPLIES
      methods(c)(m) IMPLIES
        EXISTS (c1 : Class, m1 : Method) :
          classes(program(mp))(c1) AND 
          methods(c1)(m1) AND 
          (IF name(c1) = class_name(mva(mp))
           THEN m = ann_method(mp)(m1)
            ELSE m = m1
            ENDIF)

  ann_program_preserves_var_decls : LEMMA % :-)
    getFieldDecls(program(mp)) = getFieldDecls(ann_program(mp)) AND
    getLocalDecls(program(mp)) = getLocalDecls(ann_program(mp)) AND
    subset?(getGhostDecls(program(mp)), getGhostDecls(ann_program(mp)))

  ann_program_preserves_var_decl_names : LEMMA % :-)
    FORALL (vn : string) :
      (var_names(getFieldDecls(program(mp)))(vn) IFF
       var_names(getFieldDecls(ann_program(mp)))(vn))
      AND
      (var_names(getGhostDecls(program(mp)))(vn) IMPLIES
       var_names(getGhostDecls(ann_program(mp)))(vn))
      AND
      (var_names(getLocalDecls(program(mp)))(vn) IFF
       var_names(getLocalDecls(ann_program(mp)))(vn))

  ann_program_preserves_wf_state : LEMMA % :-)
    FORALL (s : PState) :
      wf_state(program(mp))(s) IMPLIES
        wf_state(ann_program(mp))(s)


  % THINK: It may be convenient to change the IFF by and =
  ann_program_preserves_pstate_vars : LEMMA % :-)
    FORALL (vn : string)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))

  ann_program_preserves_ghoststate_vars : LEMMA % :-)
    FORALL (vn : string)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_ghost(vn, sMP) IMPLIES is_ghost(vn, sAP))

  % TODO: This is not true! ghost(vn, sAP) IMPLIES ghost(vn, sMP) does not
  % hold for the new variables. Look where this lemma is used and try to use
  % ann_program_preserves_pstate_vars or ann_program_preserves_ghoststate_vars
  ann_program_preserves_state_vars : LEMMA
    FORALL (vn : string)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP))) AND
        (is_ghost(vn, sMP) IFF is_ghost(vn, sAP))


  ann_program_yields_wf_program : LEMMA
    wf_Program(ann_program(mp))

  % PROVE
  % unprovable for the moment
  % one problem: derive(mp)(inv) = derive(ann_program(mp))(inv)
  % should not depend on astate
  ann_program_preserves_well_behaved_Program : LEMMA
    well_behaved_Program(mp) IMPLIES
      well_behaved_Program(ann_program(mp))


  get_class_ann_program : LEMMA % :-)
    FORALL (c1, c2 : Class, s : PState, tgt : Val) :
      up?(get_class(program(mp))(tgt)) IMPLIES
      up?(get_class(ann_program(mp))(tgt)) IMPLIES
      c1 = down(get_class(program(mp))(tgt)) IMPLIES
      c2 = down(get_class(ann_program(mp))(tgt)) IMPLIES
        name(c1) = name(c2)

  same_class_name_ann_class_implies_same_class : LEMMA % :-)
    FORALL (c1, c2 : Class) :
      classes(program(mp))(c1) IMPLIES
      classes(ann_program(mp))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        IF name(c1) = class_name(mva(mp))
        THEN c2 = ann_class(mp)(c1)
        ELSE c2 = c1
        ENDIF

  same_method_name_ann_class_implies_same_method : LEMMA % :-)
    FORALL (c1, c2 : Class, m1, m2 : Method) :
      classes(program(mp))(c1) IMPLIES
      c2 = ann_class(mp)(c1) IMPLIES
      name(c1) = class_name(mva(mp)) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = ann_method(mp)(m1)

  % TODO: If we don't give a definition for lookup_mthd we will have to take
  % this as an axiom.
  lookup_mthd_ann_program : LEMMA
    FORALL (m1, m2 : Method, mn : string, tgt : Val) :
      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
        IF up?(get_class(program(mp))(tgt)) AND
           name(down(get_class(program(mp))(tgt))) = class_name(mva(mp))
        THEN m2 = ann_method(mp)(m1)
        ELSE m2 = m1
        ENDIF


%   TODO: Use the new version and delete this
%   ann_program_defines_MVA_vars2 : LEMMA
%     EXISTS (c : Class) :
%       classes(ann_program(mp))(c) AND 
%       name(c) = class_name(mva(mp)) AND
%       (EXISTS (gd : FieldDecl) :  
%         ghost_vars(c)(gd) AND name(gd) = cp) AND
%       (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
%         EXISTS (gd : FieldDecl) :
%           ghost_vars(c)(gd) AND name(gd) = name_of(q)) AND
%       (FORALL (v : MVAVarDecl) : vdsA(mva(mp))(v) IMPLIES
%         EXISTS (gd : FieldDecl) :
%           ghost_vars(c)(gd) AND name(gd) = name(v))

  % TODO: This has been renamed and rewriten. Delete
%   ann_program_defines_MVA_vars : LEMMA
%     FORALL (s : APState) :
%       wf_state(ann_program(mp))(s) IMPLIES
%         is_ghost(cp, s) AND
%         (FORALL (q : CP) :
%           cps(mva(mp))(q) IMPLIES is_ghost(name_of(q), s)) AND
%         (FORALL (v : MVAVarDecl) :
%           vdsA(mva(mp))(v) IMPLIES is_ghost(name(v), s))

  new_vars_derived_from_mp : LEMMA % :-)
    var_names(new_gvds(mp))(cp) AND
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      var_names(new_gvds(mp))(name_of(q))) AND
    (FORALL (v : MVAVarDecl) : vdsA(mva(mp))(v) IMPLIES
      var_names(new_gvds(mp))(name(v)))

  ann_program_defines_MVA_vars : LEMMA % :-)
    FORALL (n : string) : var_names(new_gvds(mp))(n) IMPLIES
      EXISTS (c : Class, gd : FieldDecl) :
        classes(ann_program(mp))(c) AND 
        name(c) = class_name(mva(mp)) AND
        ghost_vars(c)(gd) AND name(gd) = n

  new_vars_ghost_in_ann_program : LEMMA % :-)
    FORALL (n : string, s : APState) :
      wf_state(ann_program(mp))(s) IMPLIES
      var_names(new_gvds(mp))(n) IMPLIES
        is_ghost(n, s)


END AnnotateProgramProperties
