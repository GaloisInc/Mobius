AnnotateProgram[CP : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMonitoredProgram[CP, string],
            set2list

  mp : VAR (wf_MP)
  a : VAR (wf_MVA)

  unique : (injective?[CP, nat])

  name_of : (injective?[CP, string])


  % Ghost variable declarations

  new_gvds(mp) : finite_set[GhostVarDecl] =
   {gd : GhostVarDecl | jtype(gd) = IntType AND
     (name(gd) = "cp" AND init_val(gd) = Int(unique(init_cp(mva(mp))))) OR
     ((EXISTS (q : (cps(mva(mp)))) : name(gd) = name_of(q) AND 
                                     init_val(gd) = Int(unique(q))) OR
      (EXISTS (v : (vdsA(mva(mp)))) : name(gd) = name(v) AND
                                      init_val(gd) = init_val(v)))}


  % Event annotation

  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)

  upd_vars(t : Transition) : Stmt =
    Sequence(Set("cp", NExpr(NumVarEval(name_of(tcp(t))))), 
             ann_action(action(t)))

  IMPORTING ProgramSemantics[string]

%   ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[Expr, Stmt]] =
%     set2list({x : [Expr, Stmt] | EXISTS (t : Transition) : ts(t) AND
%                            (FORALL (stA : (wf_Store(mva(mp))), 
%                                     stP : (wf_PSt(mva(mp)))) :
%                               eval(proj_1(x))((# ex := bottom, st := stP #)) =
%                               guard(t)(stA, stP)) AND
%                             proj_2(x) = upd_vars(t)})

  ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[Expr, Stmt]] =
    set2list({x : [Expr, Stmt] | EXISTS (t : Transition) :
      ts(t) AND
      (FORALL (stA : (wf_Store(mva(mp))), stP : (wf_PSt(mva(mp))))
              (s : PState, v : Val, n : nat) :
        s = (# ex := bottom, st := stP #) AND
        % guards have no side-effect
        deriv_expr(program(mp))(proj_1(x), s, v, s)(n) IMPLIES
        b(v) = guard(t)(stA, stP)) AND
      proj_2(x) = upd_vars(t)})

  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) : [Expr, Stmt] =
    (BExpr(Eq(NumVarEval("cp"), NumVarEval(name_of(q)))),
     CaseJML(ann_guard_actions(mp)(ts)))

  % Generates annotations to update the control point and the variables when an
  % event occurs
  ann_event(mp)(ts: set[Transition]): Stmt =
    CaseJML(set2list({c : [Expr, Stmt] | EXISTS (q : CP) : 
              cps(mva(mp))(q) AND
              c = ann_trans_cp(mp)(q,
                                  {t: Transition | ts(t) AND scp(t) = q})}))


  % Method annotation

  filter_event(a)(et : EventType)(m : string) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  % THINK: what happes if the program already had a pre_set?
  % Either we should say in ann_program_pre that all methods have Skip as x_set
  % or we should use a Seq here (but the proof will be harder)
  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType) : 
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))
    IN
    m WITH [pre_set  := ann_event_type(Entry),
            post_set := ann_event_type(ExitNormal),
            exc_set  := ann_event_type(ExitExceptional)]


  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % Class annotation

  ann_class(mp)(c : Class) : Class =
    IF name(c) = class_name(mva(mp))
    THEN c WITH [inv := BExpr(Conj(b(inv(c)), Neq(NumVarEval("cp"), 
                                                  NumVarEval("halted")))),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF


  % Program annotation

  % NOTE: The case where there is no class c in p such that 
  % name(c) = class_name(a) is trivial, thus to simplify proofs we restrict
  % ourselves cases where such a class exists
  ann_program_pre(mp): boolean =
    LET a = mva(mp), p = program(mp) IN
    wf_MP(mp) AND
    EXISTS (c: Class):
      classes(p)(c) AND name(c) = class_name(a) AND
      (NOT EXISTS (gv : GhostVarDecl) :
        ghost_vars(c)(gv) AND name(gv) = "cp") AND
      (FORALL (q : (cps(a))) : NOT EXISTS (gd : GhostVarDecl) :
          ghost_vars(c)(gd) AND name(gd) = name_of(q)) AND
      (FORALL (vd : MVAVarDecl) :
        vdsA(a)(vd) IMPLIES NOT EXISTS (gd : GhostVarDecl) :
          ghost_vars(c)(gd) AND name(gd) = name(vd))

  ann_program(mp) : Program = 
    LET p = program(mp) IN
    (# classes := {c : Class | EXISTS (c1 : Class) : 
                     classes(p)(c1) AND c = ann_class(mp)(c1)} #)


  ann_program_yields_wf_program : LEMMA
    FORALL (mp : (ann_program_pre)) :
      wf_Program(ann_program(mp))


  get_annotated_class(mp : (ann_program_pre)) : Class =
    choose({c : Class | classes(ann_program(mp))(c) 
      AND name(c) = class_name(mva(mp))})

  annotated_class_is_unique : LEMMA % :-)
    FORALL (mp : (ann_program_pre)) :
    singleton?({c : Class | classes(ann_program(mp))(c) 
      AND name(c) = class_name(mva(mp))})


  ann_program_preserves_structure : LEMMA % :-)
    FORALL (mp : (ann_program_pre), c : Class) :
      classes(program(mp))(c) IMPLIES
      IF name(c) = class_name(mva(mp)) THEN
        FORALL (m : Method, s : Stmt) :
        LET c1 = ann_class(mp)(c), 
            m1 = ann_method(mp)(m) 
        IN
          methods(c)(m) IMPLIES
           classes(ann_program(mp))(c1) AND
           methods(c1)(m1) AND
           name(m1) = name(m) AND
           body(m1) = body(m) AND
           pre(m1) = pre(m) AND
           post(m1) = post(m) AND
           lvars(m1) = lvars(m) AND
           res(m1) = res(m) AND
           res_type(m1) = res_type(m)
      ELSE
        classes(ann_program(mp))(c)
      ENDIF


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotateProgram[CP],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string]

  ann_program_preserves_var_decls : LEMMA
    FORALL (mp : MonitoredProgram)(vn : string) :
      ann_program_pre(mp) IMPLIES
        (is_declared_as_field(program(mp))(vn) IFF
         is_declared_as_field(ann_program(mp))(vn))
        AND
        (is_declared_as_ghost(program(mp))(vn) IMPLIES
         is_declared_as_ghost(ann_program(mp))(vn))
        AND
        (is_declared_as_arg(program(mp))(vn) IFF
         is_declared_as_arg(ann_program(mp))(vn))
        AND
        (is_declared_as_local(program(mp))(vn) IFF
         is_declared_as_local(ann_program(mp))(vn))

  ann_program_preserves_state_vars : LEMMA
    FORALL (mp : MonitoredProgram)(vn : string)
           (sMP : MPState, sAP : APState) :
      ann_program_pre(mp) IMPLIES
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))


END AnnotateProgramProperties
