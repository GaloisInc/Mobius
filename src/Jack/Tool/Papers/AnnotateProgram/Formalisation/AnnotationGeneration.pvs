VariableNames[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  ENDASSUMING

  IMPORTING MonitoredProgram[CP, Name]

  forbidden_names(mp : MonitoredProgram) : set[Name] =
    union(declared_var_names(program(mp)),
    union(var_names(mva(mp)),
          reserved_words))

  cp(mp : MonitoredProgram) : {n : Name | NOT forbidden_names(mp)(n)}


  legal_names(mp : MonitoredProgram) : set[Name] =
    {n : Name | NOT forbidden_names(mp)(n) AND NOT n = cp(mp)}

END VariableNames

AnnotateProgram[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MonitoredProgramSemantics[CP, Name],
            set2list

  mp : VAR (wf_MP)

  a : VAR (wf_MVA)

  name_of(mp) : (injective?[CP, (legal_names(mp))])

  unique : (injective?[CP, nat])

  halted(mp) : Name = name_of(mp)(halted)


  % Variables that will be added in the annotation process
  new_gvds(mp) : finite_set[FieldDecl] =
   {gd : FieldDecl | jtype(gd) = IntType AND
     (name(gd) = cp(mp) AND init_val(gd) = Int(unique(init_cp(mva(mp))))) OR
     ((EXISTS (q : (cps(mva(mp)))) : name(gd) = name_of(mp)(q) AND 
                                     jtype(gd) = IntType AND
                                     init_val(gd) = Int(unique(q))) OR
      (EXISTS (v : (vdsA(mva(mp)))) : name(gd) = name(v) AND
                                      jtype(gd) = jtype(v) AND
                                      init_val(gd) = init_val(v)))}

  new_gvds_as_union : LEMMA % :-)
    new_gvds(mp) = 
      add((# jtype := IntType, name := cp(mp), 
             init_val := Int(unique(init_cp(mva(mp)))) #),
      union({gd : FieldDecl | EXISTS (q : (cps(mva(mp)))) : 
                                name(gd) = name_of(mp)(q) AND 
                                jtype(gd) = IntType AND
                                init_val(gd) = Int(unique(q))},
            {gd : FieldDecl | EXISTS (v : (vdsA(mva(mp)))) : 
                                name(gd) = name(v) AND
                                jtype(gd) = jtype(v) AND
                                init_val(gd) = init_val(v)}))


  new_vars_derived_from_mp : LEMMA % :-)
    var_names(new_gvds(mp))(cp(mp)) AND
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      var_names(new_gvds(mp))(name_of(mp)(q))) AND
    (FORALL (v : MVAVarDecl) : vdsA(mva(mp))(v) IMPLIES
      var_names(new_gvds(mp))(name(v)))


  % The generated ghost variables must have different names
  wf_new_vars : LEMMA % :-)
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
        NOT name_of(mp)(q) = cp(mp)) AND
    (FORALL (vd : MVAVarDecl) : vdsA(mva(mp))(vd) IMPLIES
        NOT name(vd) = cp(mp)) AND
    (FORALL (q : CP, vd : MVAVarDecl) :
      cps(mva(mp))(q) IMPLIES
      vdsA(mva(mp))(vd) IMPLIES
        NOT name_of(mp)(q) = name(vd)) AND
    disjoint?(var_names(new_gvds(mp)), reserved_words) AND
    disjoint?(var_names(new_gvds(mp)), declared_var_names(program(mp)))




  % Event annotation

  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)

  update_vars(mp)(t : Transition) : Stmt =
    Sequence(Set(cp(mp), NExpr(NumVarEval(name_of(mp)(tcp(t))))), 
             ann_action(action(t)))

  ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[BoolExpr, Stmt]] =
    set2list({x : [BoolExpr, Stmt] | EXISTS (t : Transition) :
      ts(t) AND x = (guard_to_expression(mva(mp))(guard(t)), 
                     update_vars(mp)(t))})

  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) : [BoolExpr, Stmt] =
    (Eq(NExpr(NumVarEval(cp(mp))), 
        NExpr(NumVarEval(name_of(mp)(q)))),
     CaseJML(ann_guard_actions(mp)(ts)))


  % Generates annotations to update the control point and the variables when an
  % event occurs
  ann_event(mp)(ts : finite_set[Transition]): Stmt =
    CaseJML(set2list({c : [BoolExpr, Stmt] | EXISTS (q : CP) : 
              cps(mva(mp))(q) AND
              nonempty?({t: Transition | ts(t) AND scp(t) = q}) AND
              c = ann_trans_cp(mp)(q,
                                  {t: Transition | ts(t) AND scp(t) = q})}))


  % Method annotation

  filter_event(a)(et : EventType)(m : Name) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType) : 
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))
    IN
    m WITH [pre_set  := Sequence(pre_set(m), ann_event_type(Entry)),
            post_set := Sequence(post_set(m), ann_event_type(ExitNormal)),
            exc_set  := Sequence(exc_set(m), ann_event_type(ExitExceptional))]


  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % Class annotation

  ann_class(mp)(c : Class) : Class =
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN c WITH [inv := Conj(BExpr(inv(c)), 
                             BExpr(Neg(BExpr(Eq(NExpr(NumVarEval(cp(mp))), 
                                                NExpr(NumVarEval(halted(mp)))))))),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF


  % Program annotation

  ann_program(mp) : Program = 
    (# classes := {c : Class | EXISTS (c1 : Class) : 
                                 classes(program(mp))(c1) AND 
                                 c = ann_class(mp)(c1)} #)


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateProgram[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name]

  mp : VAR (wf_MP)

  ann_program_class_correspondence : LEMMA % :-)
    FORALL(c : Class) : classes(ann_program(mp))(c) IMPLIES
      EXISTS (c1 : Class) : classes(program(mp))(c1) AND c = ann_class(mp)(c1)
 
  ann_program_method_correspondence : LEMMA % :-)
    FORALL(c : Class, m : Method) :
      classes(ann_program(mp))(c) IMPLIES
      methods(c)(m) IMPLIES
        EXISTS (c1 : Class, m1 : Method) :
          classes(program(mp))(c1) AND 
          methods(c1)(m1) AND 
          (IF name(c1) = class_name(mva(mp))
           THEN m = ann_method(mp)(m1)
            ELSE m = m1
            ENDIF)

  ann_program_preserves_var_decls : LEMMA % :-)
    getFieldDecls(program(mp)) = getFieldDecls(ann_program(mp)) AND
    getLocalDecls(program(mp)) = getLocalDecls(ann_program(mp)) AND
    subset?(getGhostDecls(program(mp)), getGhostDecls(ann_program(mp)))

  ann_program_preserves_var_decl_names : LEMMA % :-)
    FORALL (vn : Name) :
      (var_names(getFieldDecls(program(mp)))(vn) IFF
       var_names(getFieldDecls(ann_program(mp)))(vn))
      AND
      (var_names(getGhostDecls(program(mp)))(vn) IMPLIES
       var_names(getGhostDecls(ann_program(mp)))(vn))
      AND
      (var_names(getLocalDecls(program(mp)))(vn) IFF
       var_names(getLocalDecls(ann_program(mp)))(vn))

  ann_program_add_ghost_var_decls : LEMMA % :-)
    getGhostDecls(ann_program(mp)) =
      union(getGhostDecls(program(mp)), new_gvds(mp))


  ann_program_preserves_wf_state : LEMMA % :-)
    FORALL (s : PState) :
      wf_state(program(mp))(s) IMPLIES
        wf_state(ann_program(mp))(s)


  ann_program_preserves_pstate_vars : LEMMA % :-)
    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))

  ann_program_preserves_ghoststate_vars : LEMMA % :-)
    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_ghost(vn, sMP) IMPLIES is_ghost(vn, sAP))


  ann_program_yields_wf_program : LEMMA
    wf_Program(ann_program(mp))

  % PROVE
  % unprovable for the moment
  % one problem: derive(mp)(inv) = derive(ann_program(mp))(inv)
  % should not depend on astate
  ann_program_preserves_well_behaved_Program : LEMMA
    well_behaved_Program(mp) IMPLIES
      well_behaved_Program(ann_program(mp))


  get_class_ann_program : LEMMA % :-)
    FORALL (c1, c2 : Class, tgt : Val) :
      up?(get_class(program(mp))(tgt)) IMPLIES
      up?(get_class(ann_program(mp))(tgt)) IMPLIES
      c1 = down(get_class(program(mp))(tgt)) IMPLIES
      c2 = down(get_class(ann_program(mp))(tgt)) IMPLIES
        name(c1) = name(c2)

  same_class_name_ann_class_implies_same_class : LEMMA % :-)
    FORALL (c1, c2 : Class) :
      classes(program(mp))(c1) IMPLIES
      classes(ann_program(mp))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        IF name(c1) = class_name(mva(mp))
        THEN c2 = ann_class(mp)(c1)
        ELSE c2 = c1
        ENDIF

  same_method_name_ann_class_implies_same_method : LEMMA % :-)
    FORALL (c1, c2 : Class, m1, m2 : Method) :
      classes(program(mp))(c1) IMPLIES
      c2 = ann_class(mp)(c1) IMPLIES
      name(c1) = class_name(mva(mp)) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = ann_method(mp)(m1)

  lookup_mthd_ann_program : LEMMA
    FORALL (m1, m2 : Method, mn : Name, tgt : Val) :
      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
        IF up?(get_class(program(mp))(tgt)) AND
           name(down(get_class(program(mp))(tgt))) = class_name(mva(mp))
        THEN m2 = ann_method(mp)(m1)
        ELSE m2 = m1
        ENDIF

  ann_program_defines_MVA_vars : LEMMA % :-)
    FORALL (n : Name) : var_names(new_gvds(mp))(n) IMPLIES
      EXISTS (c : Class, gd : FieldDecl) :
        classes(ann_program(mp))(c) AND 
        name(c) = class_name(mva(mp)) AND
        ghost_vars(c)(gd) AND name(gd) = n

  new_vars_ghost_in_ann_program : LEMMA % :-)
    FORALL (n : Name, s : APState) :
      wf_state(ann_program(mp))(s) IMPLIES
      var_names(new_gvds(mp))(n) IMPLIES
        is_ghost(n, s)

     

END AnnotateProgramProperties
