AnnotateProgram[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgram[CP, string]

  MP : VAR (monitored?)
  a : VAR MVA

  unique : (injective?[CP,nat])

  name_of : (injective?[CP,string])

  newGVDs(MP) : finite_set[GhostVarDecl] =
    add((# jtype := IntType, 
           name := "cp", 
           initval := NExpr(NumVarEval(name_of(init_cp(mva(MP))))) #),
    add((# jtype := IntType,
           name := "halted",
           initval := NExpr(Int(-1)) #),
    union({g : GhostVarDecl | jtype(g) = IntType AND
                              EXISTS(cp : CP) : 
                                cps(mva(MP))(cp) AND 
                                name(g) = name_of(cp) AND
                                initval(g) = NExpr(Int(unique(cp)))},
          {g : GhostVarDecl | EXISTS(v : MVA_VarDecl) :
                                vdsA(mva(MP))(v) AND
                                jtype(v) = jtype(g) AND
                                name(v) = name(g) AND
                                ival(v) = initval(g)})))

  lookupMethod(n : string, c : lift[string]) : Method

  overrideMethod(MP)(n : string, c : lift[string]) : Method =
    LET m = lookupMethod(n, c) IN
    LET mc = MethodCall(%Super,  % HACK!!
                        NExpr(Int(0)), name(m), NExpr(NumVarEval(name(arg(m))))) IN
    LET new_body = StmtExpr(mc) IN %IF Void?(resType(m))
%                   THEN StmtExpr(mc) 
%                   ELSE mc % Return(mc) Return not defined
%                   ENDIF IN
    m WITH [body := new_body]

  completeMethods(MP)(ms : finite_set[Method], c : lift[string], 
                      nse : finite_set[Event]) : 
                     finite_set[Method] =
    union(ms, { m : Method | EXISTS (n : string) :
                               m = overrideMethod(MP)(n, c) AND
                               {n : string | EXISTS (e : Event) : nse(e) AND
                                           n = mname(e)}(n) AND
                               NOT {n : string | 
                                           EXISTS (m : Method) : ms(m) AND
                                           n = name(m)}(n)})

  filterEv(a)(et : EventType)(m : string) : finite_set[Transition] =
    {t : Transition |ts(a)(t) AND EType(event(t)) = et AND mname(event(t)) = m}


  IfJML(b : finite_set[[BoolExpr, Stmt]]) : RECURSIVE Stmt =
    IF nonempty?(b)
    THEN LET x = choose(b) IN
         IfThenElse(proj_1(x), proj_2(x), IfJML(remove(x, b)))
    ELSE Skip
    ENDIF
  MEASURE card(b)

  annActions(acs : Action) : RECURSIVE Stmt =
    IF null?(acs)
    THEN Skip
    ELSE Sequence(Set(source(car(acs)), target(car(acs))), 
                  annActions(cdr(acs)))
    ENDIF
  MEASURE length(acs)


  updVars(t : Transition) : Stmt =
    Sequence(Set("cp", NExpr(NumVarEval(name_of(tcp(t))))), 
             annActions(action(t)))

  IMPORTING Evaluation[string]

  annGuardsActions(ts : finite_set[Transition]) : 
                   finite_set[[BoolExpr, Stmt]] =
    { x : [BoolExpr, Stmt] |EXISTS (t : Transition) : ts(t) AND
                             (FORALL(stA : Store, stP : PSt) :
                              eval(proj_1(x))((# ex := bottom, st := stP #)) =
                              guard(t)(stA, stP)) AND
                              proj_2(x) = updVars(t)}

  annTransCP(q : CP, ts : finite_set[Transition]) : [BoolExpr, Stmt] =
    (Eq(NumVarEval("cp"), NumVarEval(name_of(q))),
     IfJML(annGuardsActions(ts)))

  annEvent(ts : finite_set[Transition]) : Stmt =
    LET branches = {x : [BoolExpr, Stmt] |  
                    EXISTS(t : Transition) : ts(t) AND 
                                            x = annTransCP(scp(t), t)}
    IN 
    IfJML(branches)

  annMethod(MP)(m : Method) : Method =
    m WITH [preset := annEvent(filterEv(mva(MP))(Entry)(name(m))),
            postset := annEvent(filterEv(mva(MP))(ExitNormal)(name(m))),
            excset := annEvent(filterEv(mva(MP))(ExitExceptional)(name(m)))]

  annMethods(MP)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = annMethod(MP)(n)}

  annClass(MP)(c : Class) : Class =
    IF name(c) = classname(mva(MP))
    THEN c WITH [inv := Conj(inv(c), 
                        Neq(NumVarEval("cp"), NumVarEval("halted"))),
                 ghostvars := union(ghostvars(c),
                                     newGVDs(MP)),
                 methods := annMethods(MP)(completeMethods(MP)(methods(c),
                                                           superClass(c),
                                                           evs(mva(MP))))]
    ELSE c
    ENDIF

  annProgram(MP) : Program = (# classes := map (annClass(MP)) 
                                           (classes (program(MP))) #)



END AnnotateProgram
