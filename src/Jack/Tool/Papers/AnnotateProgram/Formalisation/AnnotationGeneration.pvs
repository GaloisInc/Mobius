% Specification of step 2 of translation
% Translating monitor into method level set annotations

VariableNames[CP, Name : TYPE+] : THEORY
BEGIN

  % Specify set of legal variable names for new ghost variables

  ASSUMING

    % name space is infinite
    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  ENDASSUMING

  IMPORTING MonitoredProgram[CP, Name],
            MVAMonitoring[CP, Name]

  % Already declared names, monitor variables and reserved words are forbidden
  forbidden_names(mp : MonitoredProgram) : set[Name] =
    union(declared_var_names(program(mp)),
    union(var_names(mva(mp)),
          reserved_words))

  % Name for cp variable
  cp(mp : MonitoredProgram) : {n : Name | NOT forbidden_names(mp)(n)}

  % Remaining legal names: not forbidden, and not representing cp
  legal_names(mp : MonitoredProgram) : set[Name] =
    {n : Name | NOT forbidden_names(mp)(n) AND NOT n = cp(mp)}


END VariableNames


NewVariableDeclarations[CP, Name : TYPE+] : THEORY
BEGIN

  % Declarations of new variables that will be added by translation

  ASSUMING

    % each control point can be mapped to natural number
    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) :
        FORALL(mp : (wf_and_complete_MP)) :
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MonitoredProgramSemantics[CP, Name],
            set2list

  mp : VAR (wf_and_complete_MP)

  % map control points to legal variable names
  name_of(mp) : (injective?[CP, (legal_names(mp))])

  unique : (injective?[CP, nat])

  % constant halted: mapping of halted control point to variable names
  halted(mp) : Name = name_of(mp)(halted)


  % Variables that will be added in the annotation process

  % variable to denote current control point
  % name: cp(mp), integer type, initialised to initial control point
  new_cp_gvd(mp) : Decl =
    (# name := cp(mp),
       jtype := IntType,
       init_val := Int(unique(init_cp(mva(mp)))) #)

  % static final ghost variables encode set of control points 
  % name uses mapping from control points to legal variable names
  % integer type, each variable initialised to unique value
  new_cps_gvds(mp) : finite_set[Decl] =
    {gd : Decl | EXISTS (q : (cps(mva(mp)))) :
                   name(gd) = name_of(mp)(q) AND
                   jtype(gd) = IntType AND
                   init_val(gd) = Int(unique(q))}

  % ghost variable that represent automaton variables
  % name, type and initial value coincide
  new_mva_vars_gvds(mp) : finite_set[Decl] = vdsA(mva(mp))

  % new ghost variable: current control point, control point representations
  % and automaton variables
  new_gvds(mp) : finite_set[Decl] =
    add(new_cp_gvd(mp), union(new_cps_gvds(mp), new_mva_vars_gvds(mp)))


  % names of new variables depend on original monitored program (they are 
  % not constants)
  new_vars_derived_from_mp : LEMMA % :-)
    var_names(new_gvds(mp))(cp(mp)) AND
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      var_names(new_gvds(mp))(name_of(mp)(q))) AND
    (FORALL (v : Decl) : vdsA(mva(mp))(v) IMPLIES
      var_names(new_gvds(mp))(name(v)))


  % The generated ghost variables have different names, disjoint from
  % reserved words and variable names already used in the program
  wf_new_vars : LEMMA % :-)
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
        NOT name_of(mp)(q) = cp(mp)) AND
    (FORALL (vd : Decl) : vdsA(mva(mp))(vd) IMPLIES
        NOT name(vd) = cp(mp)) AND
    (FORALL (q : CP, vd : Decl) :
      cps(mva(mp))(q) IMPLIES
      vdsA(mva(mp))(vd) IMPLIES
        NOT name_of(mp)(q) = name(vd)) AND
    disjoint?(var_names(new_gvds(mp)), reserved_words) AND
    disjoint?(var_names(new_gvds(mp)), declared_var_names(program(mp)))

  % cp(mp) is a new variable name
  cp_new_ghostvar : LEMMA % :-)
    var_names(new_gvds(mp))(cp(mp))

  % halted(mp) is a new variable name
  halted_new_ghostvar : LEMMA % :-)
    var_names(new_gvds(mp))(halted(mp))

  % variable declaration corresponding to control point q
  new_cp_gvd(mp)(q : (cps(mva(mp)))) : Decl =
    (# name := name_of(mp)(q), jtype := IntType, init_val := Int(unique(q)) #)

  % variable declaration encoding q is a new ghost variable
  new_cp_gvd_new_ghostvar : LEMMA % :-)
    FORALL (q : CP) :
      cps(mva(mp))(q) IMPLIES
        new_gvds(mp)(new_cp_gvd(mp)(q))

  % variable decaration corresponding to automaton variable declaration
  new_mva_var_gvd(mp)(vd : (vdsA(mva(mp)))) : Decl = vd

  % automaton variable is a new ghost variable
  new_mva_var_new_ghostvar : LEMMA % :-)
    FORALL (vd : Decl) :
      vdsA(mva(mp))(vd) IMPLIES
        new_gvds(mp)(new_mva_var_gvd(mp)(vd))

  % cp(mp) is different from (constant) ghost variables 
  % representing control points
  cp_not_cps_ghostvar : LEMMA % :-)
    NOT new_cps_gvds(mp)(new_cp_gvd(mp))

  % cp(mp) is different from automaton variables
  cp_not_mva_ghostvar : LEMMA % :-)
    NOT new_mva_vars_gvds(mp)(new_cp_gvd(mp))

  % the variable names used in the monitor are a subset of the newly
  % declared variable names, and the original program variables
  var_names_MVA_subset_var_names_new_gdvs : LEMMA % :-)
    subset?(var_names(mva(mp)),
            union(var_names(program(mp)), var_names(new_gvds(mp))))



END NewVariableDeclarations


AnnotateEvent[CP, Name : TYPE+] : THEORY
BEGIN


  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) :
        FORALL(mp : (wf_and_complete_MP)) :
          injective?(f(mp))

  ENDASSUMING

  IMPORTING NewVariableDeclarations[CP, Name]

  mp : VAR (wf_and_complete_MP)

  a : VAR (wf_MVA)

  % set annotations to encode an action sequence
  % for each single action, generate a Set annotation, assigning source
  % to target
  % combine with Sequence operator
  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)

  % variable names used in generated set annotation are the target of the
  % action, and the variable names used in the source expression
  var_names_ann_action : LEMMA % :-)
    FORALL(a : Action, n : Name) :
      var_names(ann_action(a))(n) =
        EXISTS(oa : OneAction) :
          member(oa, a) AND
          (n = target(oa) OR var_names(source(oa))(n))

  % b is a subterm of a generated set annotation if there is a single action x
  % such that b is a subterm of Set(target(x), source(x))
  subterm_ann_action : LEMMA % :-)
    FORALL(a : Action, b : Body) :
      Set?(b) IMPLIES
        subterm(b, ann_action(a)) =
          (EXISTS(oa : OneAction) :
             member(oa, a) AND
             subterm(b, Set(target(oa), source(oa))))

  % set annotations for a transition t:
  % update current control point and translate actions of transition
  update_vars(mp)(t : Transition) : Stmt =
    Sequence(Set(cp(mp), NumVarEval(name_of(mp)(tcp(t)))),
             ann_action(action(t)))

  % map each transition t in ts to a "guard*action" tuple (expr, stmt)
  % first component represents guard of t (using guard_to_expression)
  % second component are set annotations related with transition
  ann_guard_actions_set(mp)(ts : finite_set[Transition])(v : ValOrExcpt) :
                            finite_set[[Expr, Stmt]] =
     {x : [Expr, Stmt] | EXISTS (t : Transition) :
          ts(t) AND x = (guard_to_expression(mva(mp))(guard(t))(v),
          update_vars(mp)(t))}


  % transform set of guard_action tuples for transitions ts into list
  ann_guard_actions(mp)(ts : finite_set[Transition])
                   (v : ValOrExcpt) : list[[Expr, Stmt]] =
    set2list(ann_guard_actions_set(mp)(ts)(v))

  % for all transitions starting in q, return a tuple:
  % (current control point is q, encoding of transitions starting in q)
  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) 
              (v : ValOrExcpt) : [Expr, Stmt] =
    (Eq(NumVarEval(cp(mp)),
        NumVarEval(name_of(mp)(q))),
     CaseJML(ann_guard_actions(mp)(ts)(v)))

  % for all nonempty set of transitions ts, generate a tuple via ann_trans_cp
  ann_event_set(mp)(ts : finite_set[Transition])(v : ValOrExcpt) :
                         finite_set[[Expr, Stmt]] =
    {c : [Expr, Stmt] | EXISTS (q : CP) :
         cps(mva(mp))(q) AND
         nonempty?({t: Transition | ts(t) AND scp(t) = q}) AND
         c = ann_trans_cp(mp)(q, {t: Transition | ts(t) AND scp(t) = q})(v)}

  % ts: set of transitions with particular event (method entry/exit/exc_exit)
  % compute CaseJML annotation, encoding all possible transitions in ts
  ann_event(mp)(ts : finite_set[Transition])(v : ValOrExcpt) : Stmt =
    CaseJML(set2list(ann_event_set(mp)(ts)(v)))

  % var_names in generated annotation are subset of variable names of 
  % original programs and newly declared ghost variables
  var_names_ann_event_set : LEMMA % :-)
    FORALL (ts : finite_set[Transition], v : ValOrExcpt) :
      subset?(ts, ts(mva(mp))) IMPLIES
        subset?({n : Name | EXISTS (x : [Expr, Stmt]) :
                              ann_event_set(mp)(ts)(v)(x) AND 
                              (var_names(proj_1(x))(n) OR 
                               var_names(proj_2(x))(n))},
                union(var_names(program(mp)), var_names(new_gvds(mp))))

  var_names_ann_event : LEMMA % :-)
    FORALL (ts : finite_set[Transition], v : ValOrExcpt) :
      subset?(ts, ts(mva(mp))) IMPLIES
        subset?(var_names(ann_event(mp)(ts)(v)),
                union(var_names(program(mp)), var_names(new_gvds(mp))))

  ann_event_var_names : LEMMA % :-)
    FORALL (ts : finite_set[Transition], v : Name, ve : ValOrExcpt) :
      subset?(ts, ts(mva(mp))) IMPLIES
      var_names(ann_event(mp)(ts)(ve))(v) IMPLIES
        ext_declared_var_names(program(mp))(v) OR
        var_names(new_gvds(mp))(v)

  % Set annotations that are subterm of newly generated annotations
  % have a target that is a newly declared ghost variable
  ann_event_set_set_ghostvar : LEMMA % :-)
    FORALL (ts : finite_set[Transition], b: Body, x : [Expr, Stmt],
            v : ValOrExcpt):
      subset?(ts, ts(mva(mp))) IMPLIES
      Set?(b) IMPLIES
      ann_event_set(mp)(ts)(v)(x) IMPLIES
      (subterm(b, proj_1(x)) OR subterm(b, proj_2(x))) IMPLIES
        var_names(new_gvds(mp))(target(b))

  ann_event_set_ghostvar : LEMMA % :-)
    FORALL (ts : finite_set[Transition], b: Body, v : ValOrExcpt):
      subset?(ts, ts(mva(mp))) IMPLIES
      Set?(b) IMPLIES
      subterm(b, ann_event(mp)(ts)(v)) IMPLIES
        var_names(new_gvds(mp))(target(b))

END AnnotateEvent


AnnotateMethod[CP, Name : TYPE+] : THEORY
BEGIN

  % Annotate methods
  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) :
        FORALL(mp : (wf_and_complete_MP)) :
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateEvent[CP, Name]

  mp : VAR (wf_and_complete_MP)

  a : VAR (wf_MVA)


  % filter transitions with appropriate event
  filter_event(a)(et : EventType)(m : Name) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  % filter_event returns subset of all transitions
  filter_event_subset : LEMMA % :-)
    FORALL(et : EventType, m : Name) :
      subset?(filter_event(a)(et)(m), ts(a))
  
  % filter_event returns finite set
  filter_event_cp_is_finite : LEMMA % :-)
    FORALL (et : EventType, n : Name, q : CP) :
      is_finite({t: Transition | filter_event(mva(mp))(et)(n)(t) AND scp(t) = q})

  % annotate method m
  % generate pre_set, post_set and exc_set annotations, encoding the monitor
  % use ann_event for this, with argument all transitions for appropriate event
  % for pre_set, add additional Assert annotation, to check that cp has
  % not reached halted
  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType)(v : ValOrExcpt) :
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))(v)
    IN
    m WITH [pre_set  := LAMBDA(v : Expr) :
                        Sequence(pre_set(m)(v),
                        Sequence(ann_event_type(Entry)(val(v)),
                        Assert(Neg(Eq(NumVarEval(cp(mp)),
                                      NumVarEval(halted(mp))))))),
            post_set := LAMBDA(v : Expr) : 
                        Sequence(post_set(m)(v), 
                        ann_event_type(ExitNormal)(val(v))),
            exc_set  := LAMBDA(e : Excpt) :
                        Sequence(exc_set(m)(e), 
                        ann_event_type(ExitExceptional)(excpt(e)))]


  % annotate all methods in ms
  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % Simple rewrite lemmas, appropriate for auto-rewrite

  ann_method_name : LEMMA % :-)
    FORALL (m : Method) :
      name(ann_method(mp)(m)) = name(m)

  ann_method_arg : LEMMA % :-)
    FORALL (m : Method) :
      arg(ann_method(mp)(m)) = arg(m)

  ann_method_pre : LEMMA % :-)
    FORALL (m : Method) :
      pre(ann_method(mp)(m)) = pre(m)

  ann_method_post : LEMMA % :-)
    FORALL (m : Method) :
      post(ann_method(mp)(m)) = post(m)

  ann_method_lvars : LEMMA % :-)
    FORALL (m : Method) :
      lvars(ann_method(mp)(m)) = lvars(m)

  ann_method_body : LEMMA % :-)
    FORALL (m : Method) :
      body(ann_method(mp)(m)) = body(m)

  ann_method_pre_set : LEMMA % :-)
    FORALL (m : Method, v : Expr) :
      Sequence?(pre_set(ann_method(mp)(m))(v)) AND
        s1(pre_set(ann_method(mp)(m))(v)) = pre_set(m)(v)

  ann_method_post_set : LEMMA % :-)
    FORALL (m : Method, v : Expr) :
      Sequence?(post_set(ann_method(mp)(m))(v)) AND
        s1(post_set(ann_method(mp)(m))(v)) = post_set(m)(v)

  ann_method_exc_set : LEMMA % :-)
    FORALL (m : Method, e : Excpt) :
      Sequence?(exc_set(ann_method(mp)(m))(e)) AND
        s1(exc_set(ann_method(mp)(m))(e)) = exc_set(m)(e)

  ann_method_res : LEMMA % :-)
    FORALL (m : Method) :
      res(ann_method(mp)(m)) = res(m)

  ann_method_res_type : LEMMA % :-)
    FORALL (m : Method) :
      res_type(ann_method(mp)(m)) = res_type(m)

  % all components of the annotated method satisfy first conjunct of 
  % wf_Body
  ann_method_wf_Body1 : LEMMA % :-)
    FORALL(m : Method) :
      wf_Method(program(mp))(m) IMPLIES
      LET am = ann_method(mp)(m) IN
      (FORALL(v : Name) : var_names(body(am))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v))
      AND
      (FORALL(v : Name, val : Expr) : 
                          var_names(pre(am)(val))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v))
      AND
      (FORALL(v : Name, val : Expr) : 
                          var_names(post(am)(val))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v))
      AND
      (FORALL(v : Name) : var_names(res(am))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v))
      AND
      (FORALL(v : Name, val : Expr) : 
                          var_names(pre_set(am)(val))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v) OR
                          var_names(new_gvds(mp))(v))
      AND
      (FORALL(v : Name, val : Expr) : 
                          var_names(post_set(am)(val))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v) OR
                          var_names(new_gvds(mp))(v))
      AND
      (FORALL(v : Name, e : Excpt) : 
                          var_names(exc_set(am)(e))(v) IMPLIES
                          ext_declared_var_names(program(mp))(v) OR
                          var_names(new_gvds(mp))(v))

  % all components of annotated method satisfy second conjunct of wf_Body
  ann_method_wf_Body2 : LEMMA % :-)
    FORALL(m : Method, b : Body) :
      wf_Method(program(mp))(m) IMPLIES
      Set?(b) IMPLIES
      LET am = ann_method(mp)(m) IN
      (subterm(b, body(am)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b))) AND
      (FORALL (v : Expr) : 
         subterm(b, pre(am)(v)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b))) AND
      (FORALL(v : Expr) :
         subterm(b, post(am)(v)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b))) AND
      (subterm(b, res(am)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b))) AND
      (FORALL(v : Expr) :
       subterm(b, pre_set(am)(v)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b)) OR
         var_names(new_gvds(mp))(target(b))) AND
      (FORALL(v : Expr) :
         subterm(b, post_set(am)(v)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b)) OR
         var_names(new_gvds(mp))(target(b))) AND
      (FORALL(e : Excpt) :
         subterm(b, exc_set(am)(e)) IMPLIES
         var_names(getGhostDecls(program(mp)))(target(b)) OR
         var_names(new_gvds(mp))(target(b)))


END AnnotateMethod


AnnotateClass[CP, Name : TYPE+] : THEORY
BEGIN

  % Annotate class, if class is monitored (otherwise do nothing)

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) :
        FORALL(mp : (wf_and_complete_MP)) :
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateMethod[CP, Name]

  mp : VAR (wf_and_complete_MP)

  a : VAR (wf_MVA)

  % If class is monitored, then
  % add conjunct: cp != halted to invariant,
  % add new ghost variable declarations
  % annotate methods of class
  ann_class(mp)(c : Class) : Class =
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN c WITH [inv := Conj(Neg(Eq(NumVarEval(cp(mp)),
                                    NumVarEval(halted(mp)))), inv(c)),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF

  % Simple rewrite lemmas, useful for auto-rewrite 

  FieldDecls_ann_class : LEMMA % :-)
    FORALL(c : Class) :
      fields(ann_class(mp)(c)) = fields(c)

  LocalDecls_ann_class : LEMMA % :-)
    FORALL(c : Class) :
      getLocalDecls(ann_class(mp)(c)) = getLocalDecls(c)

  GhostDecls_ann_class_annotated : LEMMA % :-)
    FORALL(c : Class) :
      classes(program(mp))(c) IMPLIES
      name(c) = class_name(mva(mp)) IMPLIES
        ghost_vars(ann_class(mp)(c)) = union(ghost_vars(c), new_gvds(mp))

  GhostDecls_ann_class_not_annotated : LEMMA % :-)
    FORALL(c : Class) :
      classes(program(mp))(c) IMPLIES
      NOT name(c) = class_name(mva(mp)) IMPLIES
        ghost_vars(ann_class(mp)(c)) = ghost_vars(c)

  % ann_class satisfies global part of the wf_Class condition
  ann_class_almost_wf_Class : LEMMA % :-)
    FORALL(c : Class) :
      wf_Class(program(mp))(c) IMPLIES
      LET ac = ann_class(mp)(c) IN
        FORALL (m1, m2 : Method) :
           methods(ac)(m1) IMPLIES
           methods(ac)(m2) IMPLIES
           name(m1) = name(m2) IMPLIES
           m1 = m2

  % var_names in new invariant are declared in original program or new
  % ghost variable names
  ann_class_inv_wf_Body1 : LEMMA % :-)
    FORALL(c : Class) :
      wf_Body(program(mp))(inv(c)) IMPLIES
       (FORALL (v : Name) : var_names(inv(ann_class(mp)(c)))(v) IMPLIES
                            ext_declared_var_names(program(mp))(v) OR
                            var_names(new_gvds(mp))(v))


  % rewrite rule for invariant in annotated class
  ann_class_inv : LEMMA % :-)
    FORALL(c : Class) :
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN Conj?(inv(ann_class(mp)(c))) AND
         b2(inv(ann_class(mp)(c))) = inv(c)
    ELSE inv(ann_class(mp)(c)) = inv(c)
    ENDIF

  % class name unchanged by annotation
  ann_program_preserves_class_name : LEMMA % :-)
    FORALL(c : Class) :
      name(ann_class(mp)(c)) = name(c)


END AnnotateClass


AnnotateProgram[CP, Name : TYPE+] : THEORY
BEGIN

  % Annotate Program

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) :
        FORALL(mp : (wf_and_complete_MP)) :
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateClass[CP, Name]

  mp : VAR (wf_and_complete_MP)

  a : VAR (wf_MVA)

  % Program annotation

  % annotate program by applying class annotation to all classes
  ann_program(mp) : Program =
    (# classes := {c : Class | EXISTS (c1 : Class) :
                                 classes(program(mp))(c1) AND
                                 c = ann_class(mp)(c1)} #)


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  % Properties about translation algorithm

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) :
        FORALL(mp : (wf_and_complete_MP)) :
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateProgram[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name]

  mp : VAR (wf_and_complete_MP)

  % Every class in annotated program corresponds to a class in original program
  ann_program_class_correspondence : LEMMA % :-)
    FORALL(c : Class) : classes(ann_program(mp))(c) IMPLIES
      EXISTS (c1 : Class) : classes(program(mp))(c1) AND c = ann_class(mp)(c1)

  % Every method in annotated program corresponds to method in original program
  ann_program_method_correspondence : LEMMA % :-)
    FORALL(c : Class, m : Method) :
      classes(ann_program(mp))(c) IMPLIES
      methods(c)(m) IMPLIES
        EXISTS (c1 : Class, m1 : Method) :
          classes(program(mp))(c1) AND
          methods(c1)(m1) AND
          (IF name(c1) = class_name(mva(mp))
           THEN m = ann_method(mp)(m1)
           ELSE m = m1
           ENDIF)

  % Fields and Local Variables are unchanged
  % Ghost variables of original program subset of ghost variables in
  % annotated program
  ann_program_preserves_var_decls : LEMMA % :-)
    getFieldDecls(program(mp)) = getFieldDecls(ann_program(mp)) AND
    getLocalDecls(program(mp)) = getLocalDecls(ann_program(mp)) AND
    subset?(getGhostDecls(program(mp)), getGhostDecls(ann_program(mp)))

  ann_program_preserves_var_decl_names : LEMMA % :-)
    FORALL (vn : Name) :
      (var_names(getFieldDecls(program(mp)))(vn) IFF
       var_names(getFieldDecls(ann_program(mp)))(vn))
      AND
      (var_names(getGhostDecls(program(mp)))(vn) IMPLIES
       var_names(getGhostDecls(ann_program(mp)))(vn))
      AND
      (var_names(getLocalDecls(program(mp)))(vn) IFF
       var_names(getLocalDecls(ann_program(mp)))(vn))

  % ghost variables in annotated program: union of original ghost variables
  % and newly declared ghost variables
  ann_program_add_ghost_var_decls : LEMMA % :-)
    getGhostDecls(ann_program(mp)) =
      union(getGhostDecls(program(mp)), new_gvds(mp))

  ann_program_ext_declared_var_names : LEMMA % :-)
     ext_declared_var_names(ann_program(mp)) =
       union(ext_declared_var_names(program(mp)), var_names(new_gvds(mp)))

  % if state s is wellformed wrt original program p, it is also
  % wellformed wrt annotated program
  ann_program_preserves_wf_state : LEMMA % :-)
    FORALL (s : PState) :
      wf_state(program(mp))(s) IMPLIES
        wf_state(ann_program(mp))(s)

  % fields and local variables in state for original program are the
  % same as for annotated program
  ann_program_preserves_pstate_vars : LEMMA % :-)
    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))

  % ghost variable in state for original program is also a ghost 
  % variable in state of annotated program
  ann_program_preserves_ghoststate_vars : LEMMA % :-)
    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_ghost(vn, sMP) IMPLIES is_ghost(vn, sAP))

  var_names_ann_program : LEMMA % :-)
    subset?(var_names(ann_program(mp)),
            union(var_names(program(mp)), var_names(new_gvds(mp))))

  % all automaton variables are declared as ghost variables in 
  % annotated program
  var_names_declared_in_MVA_subset_ghostvars : LEMMA % :-)
    subset?(var_names(vdsA(mva(mp))),
            var_names(getGhostDecls(ann_program(mp))))

  % all variables in new_gvds are declared in the annotated program
  ann_program_defines_MVA_vars : LEMMA % :-)
    FORALL (n : Name) : var_names(new_gvds(mp))(n) IMPLIES
      EXISTS (c : Class, gd : Decl) :
        classes(ann_program(mp))(c) AND
        name(c) = class_name(mva(mp)) AND
        ghost_vars(c)(gd) AND name(gd) = n

  % new variables are all ghost variables in annotated program
  new_vars_ghost_in_ann_program : LEMMA % :-)
    FORALL (n : Name, s : APState) :
      wf_state(ann_program(mp))(s) IMPLIES
      var_names(new_gvds(mp))(n) IMPLIES
        is_ghost(n, s)

  % if expression satisfies wf_Body wrt the mva(mp), then
  % it also satisfies wf_Body wrt the annotated program
  wf_Body_MVA_implies_wf_Body : LEMMA % :-)
    FORALL (e : Expr) :
      wf_Body(mva(mp))(e) IMPLIES
        wf_Body(ann_program(mp))(e)

  % wellformed action in mva, then the source expression is a wf_Body 
  % wrt the annotated program
  one_action_source_wf_Body : LEMMA % :-)
    FORALL (a : Action, oa : OneAction) :
      wf_Action(mva(mp))(a) IMPLIES
      member(oa, a) IMPLIES
        wf_Body(ann_program(mp))(source(oa))

  % and therefore also the generated Set annotated is a wf_Body
  % wrt the annotated program
  one_action_translation_wf_Body : LEMMA % :-)
    FORALL (a : Action, oa : OneAction) :
      wf_Action(mva(mp))(a) IMPLIES
      member(oa, a) IMPLIES
        wf_Body(ann_program(mp))(Set(target(oa), source(oa)))

  % therefore sequence of set annotations encoding action list is a 
  % wf_Body wrt the annotated program
  ann_action_yields_wf_Body : LEMMA % :-)
    FORALL (a : Action) :
      wf_Action(mva(mp))(a) IMPLIES
        wf_Body(ann_program(mp))(ann_action(a))

  % and the annotation generated for transition t is a wf_Body (Stmt)
  % wrt the annotated program
  update_vars_wf_Stmt : LEMMA % :-)
    FORALL (t : Transition) :
      ts(mva(mp))(t) IMPLIES
        wf_Stmt(ann_program(mp))(update_vars(mp)(t))

  % guard_to_expression returns a wf_Body (Expr) wrt the annotated program
  guard_to_expression_wf_Expr : LEMMA % :-)
    FORALL (t : Transition, v : ValOrExcpt) :
      ts(mva(mp))(t) IMPLIES
        wf_Expr(ann_program(mp))(guard_to_expression(mva(mp))(guard(t))(v))
  
  % components of guard_action tuple are wf_Body wrt annotated program
  ann_trans_cp_wf : LEMMA % :-)
   FORALL (q : CP, ts : finite_set[Transition], v : ValOrExcpt) :
     LET p = ann_trans_cp(mp)(q, ts)(v) IN
     cps(mva(mp))(q) IMPLIES
     subset?(ts, ts(mva(mp))) IMPLIES
       (wf_Expr(ann_program(mp))(p`1) AND
        wf_Stmt(ann_program(mp))(p`2))

  % annotations generated for an event are wf_Body wrt annotated program
  ann_event_wf_Body : LEMMA % :-)
    FORALL (ts : finite_set[Transition], v : ValOrExcpt) :
      subset?(ts, ts(mva(mp))) IMPLIES
        wf_Body(ann_program(mp))(ann_event(mp)(ts)(v))

  % every annotated method is wellformed wrt the annotated program
  ann_program_preserves_wf_method : LEMMA % :-)
    FORALL (m : (wf_Method(program(mp)))) :
      wf_Method(ann_program(mp))(ann_method(mp)(m))

  % any body that is wellformed wrt the original program is wellformed
  % wrt the annotated program
  ann_program_preserves_wf_body : LEMMA % :-)
    FORALL (b : (wf_Body(program(mp)))) :
      wf_Body(ann_program(mp))(b)

  % name of classes in annotated program unchanged
  get_class_ann_program : LEMMA % :-)
    FORALL (c1, c2 : Class, tgt : Val) :
      up?(get_class(program(mp))(tgt)) IMPLIES
      up?(get_class(ann_program(mp))(tgt)) IMPLIES
      c1 = down(get_class(program(mp))(tgt)) IMPLIES
      c2 = down(get_class(ann_program(mp))(tgt)) IMPLIES
        name(c1) = name(c2)

  % if c1 is class in original program, and c2 is class in annotated program
  % and names are the same, then
  % if c1 is the monitored class, then c2 = ann_class(c1) 
  % else c2 is equal to c1
  same_class_name_ann_class_implies_same_class : LEMMA % :-)
    FORALL (c1, c2 : Class) :
      classes(program(mp))(c1) IMPLIES
      classes(ann_program(mp))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        IF name(c1) = class_name(mva(mp))
        THEN c2 = ann_class(mp)(c1)
        ELSE c2 = c1
        ENDIF

  % method names not changed by annotations
  same_method_name_ann_class_implies_same_method : LEMMA % :-)
    FORALL (c1, c2 : Class, m1, m2 : Method) :
      classes(program(mp))(c1) IMPLIES
      c2 = ann_class(mp)(c1) IMPLIES
      name(c1) = class_name(mva(mp)) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = ann_method(mp)(m1)

  % lookup method returns annotated method if method originally in 
  % monitored class, otherwise original method returned
  lookup_mthd_ann_program : LEMMA % :-)
    FORALL (m1, m2 : Method, mn : Name, tgt : Val) :
      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
        IF name(down(get_class(program(mp))(tgt))) = class_name(mva(mp))
        THEN m2 = ann_method(mp)(m1)
        ELSE m2 = m1
        ENDIF

  % class names unchanged by program annotations
  ann_program_preserves_class_names : LEMMA % :-)
    class_names(program(mp)) = class_names(ann_program(mp))

  % if a reference to class in original program, then also in annotated program
  up_get_class_equivalence : LEMMA % :-)
    FORALL(a : Val) :
      up?(get_class(program(mp))(a)) IMPLIES
        up?(get_class(ann_program(mp))(a))

  % if reference to annotated class, then annotated class returned,
  % otherwise original class returned by get_class
  get_class_equivalence : LEMMA % :-)
    FORALL(a : Val) :
      up?(get_class(program(mp))(a)) IMPLIES
      IF name(down(get_class(program(mp))(a))) = class_name(mva(mp))
      THEN get_class(ann_program(mp))(a) =
             up(ann_class(mp)(down(get_class(program(mp))(a))))
      ELSE get_class(ann_program(mp))(a) = get_class(program(mp))(a)
      ENDIF


END AnnotateProgramProperties
