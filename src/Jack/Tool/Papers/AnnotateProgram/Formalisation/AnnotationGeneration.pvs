AnnotateProgram[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MonitoredProgramSemantics[CP, string],
            set2list

  mp : VAR {mp : MonitoredProgram | wf_MP(mp) AND well_typed_Program(mp)}
  a : VAR (wf_MVA)

  % TODO: These definitions generates TCCs that can not be proved!
  unique : (injective?[CP, nat])

  name_of : (injective?[CP, string])

  cp : string

  halted : string = name_of(halted)


  % Ghost variable declarations

  new_gvds(mp) : finite_set[GhostVarDecl] =
   {gd : GhostVarDecl | jtype(gd) = IntType AND
     (name(gd) = cp AND init_val(gd) = Int(unique(init_cp(mva(mp))))) OR
     ((EXISTS (q : (cps(mva(mp)))) : name(gd) = name_of(q) AND 
                                     init_val(gd) = Int(unique(q))) OR
      (EXISTS (v : (vdsA(mva(mp)))) : name(gd) = name(v) AND
                                      init_val(gd) = init_val(v)))}


  % Event annotation

  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)

  update_vars(t : Transition) : Stmt =
    Sequence(Set(cp, NExpr(NumVarEval(name_of(tcp(t))))), 
                       ann_action(action(t)))

  ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[Expr, Stmt]] =
    set2list({x : [Expr, Stmt] | EXISTS (t : Transition) :
      ts(t) AND x = (guard_to_expression(mva(mp))(guard(t)), update_vars(t))})

  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) : [Expr, Stmt] =
    (BExpr(Eq(NumVarEval(cp), NumVarEval(name_of(q)))),
     CaseJML(ann_guard_actions(mp)(ts)))

  % Generates annotations to update the control point and the variables when an
  % event occurs
  ann_event(mp)(ts : set[Transition]): Stmt =
    CaseJML(set2list({c : [Expr, Stmt] | EXISTS (q : CP) : 
              cps(mva(mp))(q) AND
              nonempty?({t: Transition | ts(t) AND scp(t) = q}) AND
              c = ann_trans_cp(mp)(q,
                                  {t: Transition | ts(t) AND scp(t) = q})}))


  % Method annotation

  filter_event(a)(et : EventType)(m : string) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType) : 
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))
    IN
    m WITH [pre_set  := Sequence(pre_set(m), ann_event_type(Entry)),
            post_set := Sequence(post_set(m), ann_event_type(ExitNormal)),
            exc_set  := Sequence(exc_set(m), ann_event_type(ExitExceptional))]


  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % Class annotation

  ann_class(mp)(c : Class) : Class =
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN c WITH [inv := BExpr(Conj(b(inv(c)), Neq(NumVarEval(cp), 
                                                  NumVarEval(halted)))),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF


  % Program annotation

  % The generated ghost variables must have differnt names
  disjoint_model_vars(a : MVA) : boolean =
    FORALL (q : CP, vd : MVAVarDecl) :
      cps(a)(q) IMPLIES
      vdsA(a)(vd) IMPLIES
        NOT name_of(q) = cp AND
        NOT name(vd) = cp AND
        NOT name_of(q) = name(vd)

  % The ghost variables we add should not be already defined
  % NOTE: The case where there is no monitored class is trivial, thus to
  % simplify proofs we restrict ourselves to the case where such a class exists.
  not_clashing_model_vars(mp : MonitoredProgram) : boolean =
    LET a = mva(mp), p = program(mp) IN
    EXISTS (c: Class) :
      classes(p)(c) AND name(c) = class_name(a) AND
      (FORALL (gv : GhostVarDecl) :
        ghost_vars(c)(gv) IMPLIES NOT name(gv) = cp) AND
      (FORALL (q : CP, gd : GhostVarDecl) :
        cps(a)(q) IMPLIES ghost_vars(c)(gd) IMPLIES 
          NOT name(gd) = name_of(q)) AND
      (FORALL (vd : MVAVarDecl, gd : GhostVarDecl) :
        vdsA(a)(vd) IMPLIES ghost_vars(c)(gd) IMPLIES
          NOT name(gd) = name(vd))

  ann_program_pre(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND
    complete(mva(mp)) AND
    well_typed_Program(mp) AND
    disjoint_model_vars(mva(mp)) AND
    not_clashing_model_vars(mp)

  ann_program(mp : (ann_program_pre)) : Program = 
    (# classes := {c : Class | EXISTS (c1 : Class) : 
                                 classes(program(mp))(c1) AND 
                                 c = ann_class(mp)(c1)} #)


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotateProgram[CP],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string]

  % TODO: prove!
  ann_program_yields_wf_program : LEMMA
    FORALL (mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
        wf_Program(ann_program(mp))

  ann_program_preserves_var_decls : LEMMA
    FORALL (mp : MonitoredProgram)(vn : string) :
      ann_program_pre(mp) IMPLIES
        (is_declared_as_field(program(mp))(vn) IFF
         is_declared_as_field(ann_program(mp))(vn))
        AND
        (is_declared_as_ghost(program(mp))(vn) IMPLIES
         is_declared_as_ghost(ann_program(mp))(vn))
        AND
        (is_declared_as_arg(program(mp))(vn) IFF
         is_declared_as_arg(ann_program(mp))(vn))
        AND
        (is_declared_as_local(program(mp))(vn) IFF
         is_declared_as_local(ann_program(mp))(vn))

  % TODO: prove!
  ann_program_preserves_state_vars : LEMMA
    FORALL (mp : MonitoredProgram)(vn : string)
           (sMP : MPState, sAP : APState) :
      ann_program_pre(mp) IMPLIES
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP))) AND
        (is_ghost(vn, sMP) IFF is_ghost(vn, sAP))

  % THINK: I won't be able to prove this, maybe taken as axiom of get_class
  get_class_ann_program : LEMMA
    FORALL (mp : MonitoredProgram, c1, c2 : Class, s : PState, tgt : Val) :
      ann_program_pre(mp) IMPLIES
      up?(get_class(program(mp))(tgt, s)) IMPLIES
      up?(get_class(ann_program(mp))(tgt, s)) IMPLIES
      c1 = down(get_class(program(mp))(tgt, s)) IMPLIES
      c2 = down(get_class(ann_program(mp))(tgt, s)) IMPLIES
        name(c1) = name(c2)

  same_class_name_ann_class_implies_same_class : LEMMA % :-)
    FORALL (mp : MonitoredProgram, c1, c2 : Class) :
      ann_program_pre(mp) IMPLIES
      classes(program(mp))(c1) IMPLIES
      classes(ann_program(mp))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        IF name(c1) = class_name(mva(mp))
        THEN c2 = ann_class(mp)(c1)
        ELSE c2 = c1
        ENDIF

  same_method_name_ann_class_implies_same_method : LEMMA % :-)
    FORALL (mp : MonitoredProgram, c1, c2 : Class, m1, m2 : Method) :
      ann_program_pre(mp) IMPLIES
      classes(program(mp))(c1) IMPLIES
      c2 = ann_class(mp)(c1) IMPLIES
      name(c1) = class_name(mva(mp)) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = ann_method(mp)(m1)

  lookup_mthd_ann_program : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : PState, 
            m1, m2 : Method, mn : string, tgt : Val) :
      ann_program_pre(mp) IMPLIES
      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
        IF name(down(get_class(program(mp))(tgt, s))) = class_name(mva(mp))
        THEN m2 = ann_method(mp)(m1)
        ELSE m2 = m1
        ENDIF

  % TODO: prove!
  ann_program_preserves_side_effect_freedom : LEMMA
    FORALL (mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
      assertions_have_no_side_effects(mp) IMPLIES
        assertions_have_no_side_effects(ann_program(mp))

  ann_program_defines_MVA_vars : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, s : APState) :
      ann_program_pre(mp) IMPLIES
      ap = ann_program(mp) IMPLIES
      wf_state(ap)(s) IMPLIES
        is_ghost(cp, s) AND
        (FORALL (q : CP) :
          cps(mva(mp))(q) IMPLIES is_ghost(name_of(q), s)) AND
        (FORALL (v : MVAVarDecl) :
          vdsA(mva(mp))(v) IMPLIES is_ghost(name(v), s))

  ann_program_defines_MVA_vars2 : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program) :
      ann_program_pre(mp) IMPLIES
      ap = ann_program(mp) IMPLIES
        up?(get_GhostVarDecl(cp, ap)) AND
        (FORALL (q : CP) :
          cps(mva(mp))(q) IMPLIES up?(get_GhostVarDecl(name_of(q), ap))) AND
        (FORALL (v : MVAVarDecl) :
          vdsA(mva(mp))(v) IMPLIES up?(get_GhostVarDecl(name(v), ap)))


END AnnotateProgramProperties
