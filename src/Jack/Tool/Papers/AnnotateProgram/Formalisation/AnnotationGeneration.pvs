VariableNames[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  ENDASSUMING

  IMPORTING MonitoredProgram[CP, Name]

  forbidden_names(mp : MonitoredProgram) : set[Name] =
    union(declared_var_names(program(mp)),
    union(var_names(mva(mp)),
          reserved_words))

  cp(mp : MonitoredProgram) : {n : Name | NOT forbidden_names(mp)(n)}

  legal_names(mp : MonitoredProgram) : set[Name] =
    {n : Name | NOT forbidden_names(mp)(n) AND NOT n = cp(mp)}


END VariableNames


NewVariableDeclarations[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MonitoredProgramSemantics[CP, Name],
            set2list

  mp : VAR (wf_MP)

  name_of(mp) : (injective?[CP, (legal_names(mp))])

  unique : (injective?[CP, nat])

  halted(mp) : Name = name_of(mp)(halted)


  % Variables that will be added in the annotation process

  new_cp_gvd(mp) : FieldDecl =
    (# name := cp(mp),
       jtype := IntType,
       init_val := Int(unique(init_cp(mva(mp)))) #)

  new_cps_gvds(mp) : finite_set[FieldDecl] =
    {gd : FieldDecl | EXISTS (q : (cps(mva(mp)))) :
                      name(gd) = name_of(mp)(q) AND
                      jtype(gd) = IntType AND
                      init_val(gd) = Int(unique(q))}

  new_mva_vars_gvds(mp) : finite_set[FieldDecl] =
    {gd : FieldDecl | EXISTS (v : (vdsA(mva(mp)))) :
                      name(gd) = name(v) AND
                      jtype(gd) = jtype(v) AND
                      init_val(gd) = init_val(v)}

  new_gvds(mp) : finite_set[FieldDecl] =
    add(new_cp_gvd(mp), union(new_cps_gvds(mp), new_mva_vars_gvds(mp)))


  new_vars_derived_from_mp : LEMMA % :-)
    var_names(new_gvds(mp))(cp(mp)) AND
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      var_names(new_gvds(mp))(name_of(mp)(q))) AND
    (FORALL (v : MVAVarDecl) : vdsA(mva(mp))(v) IMPLIES
      var_names(new_gvds(mp))(name(v)))


  % The generated ghost variables must have different names
  wf_new_vars : LEMMA % :-)
    (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
        NOT name_of(mp)(q) = cp(mp)) AND
    (FORALL (vd : MVAVarDecl) : vdsA(mva(mp))(vd) IMPLIES
        NOT name(vd) = cp(mp)) AND
    (FORALL (q : CP, vd : MVAVarDecl) :
      cps(mva(mp))(q) IMPLIES
      vdsA(mva(mp))(vd) IMPLIES
        NOT name_of(mp)(q) = name(vd)) AND
    disjoint?(var_names(new_gvds(mp)), reserved_words) AND
    disjoint?(var_names(new_gvds(mp)), declared_var_names(program(mp)))


  cp_new_ghostvar : LEMMA % :-)
    var_names(new_gvds(mp))(cp(mp))

  halted_new_ghostvar : LEMMA % :-)
    var_names(new_gvds(mp))(halted(mp))

  new_halted_gvd(mp) : FieldDecl =
    (# name := halted(mp),
       jtype := IntType,
       init_val := Int(unique(halted)) #)

  halted_gvd_new_ghostvar : LEMMA % :-)
    new_gvds(mp)(new_halted_gvd(mp))

  cp_not_cps_ghostvar : LEMMA % :-)
    NOT new_cps_gvds(mp)(new_cp_gvd(mp))

  cp_not_mva_ghostvar : LEMMA % :-)
    NOT new_mva_vars_gvds(mp)(new_cp_gvd(mp))

  var_names_MVA_subset_var_names_new_gdvs : LEMMA % :-)
    subset?(var_names(mva(mp)), 
            union(var_names(program(mp)), var_names(new_gvds(mp))))



END NewVariableDeclarations


AnnotateEvent[CP, Name : TYPE+] : THEORY
BEGIN


  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING NewVariableDeclarations[CP, Name]

  mp : VAR (wf_MP)

  a : VAR (wf_MVA)


  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)


  var_names_ann_action : LEMMA % :-)
    FORALL(a : Action, n : Name) :
      var_names(ann_action(a))(n) = 
        EXISTS(oa : OneAction) : 
          member(oa, a) AND
          (n = target(oa) OR var_names(source(oa))(n))


  update_vars(mp)(t : Transition) : Stmt =
    Sequence(Set(cp(mp), NExpr(NumVarEval(name_of(mp)(tcp(t))))), 
             ann_action(action(t)))

  ann_guard_actions_set(mp)(ts : finite_set[Transition]) : 
                            finite_set[[BoolExpr, Stmt]] =
     {x : [BoolExpr, Stmt] | EXISTS (t : Transition) :
          ts(t) AND x = (guard_to_expression(mva(mp))(guard(t)), 
          update_vars(mp)(t))}


  ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[BoolExpr, Stmt]] =
    set2list(ann_guard_actions_set(mp)(ts))

  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) : [BoolExpr, Stmt] =
    (Eq(NExpr(NumVarEval(cp(mp))), 
        NExpr(NumVarEval(name_of(mp)(q)))),
     CaseJML(ann_guard_actions(mp)(ts)))


  ann_event_set(mp)(ts : finite_set[Transition]) : 
                         finite_set[[BoolExpr, Stmt]] = 
    {c : [BoolExpr, Stmt] | EXISTS (q : CP) : 
         cps(mva(mp))(q) AND
         nonempty?({t: Transition | ts(t) AND scp(t) = q}) AND
         c = ann_trans_cp(mp)(q, {t: Transition | ts(t) AND scp(t) = q})}

  % Generates annotations to update the control point and the variables when an
  % event occurs
  ann_event(mp)(ts : finite_set[Transition]): Stmt =
    CaseJML(set2list(ann_event_set(mp)(ts)))

  var_names_ann_event : LEMMA % :-)
    FORALL (ts : finite_set[Transition]) :
      subset?(ts, ts(mva(mp))) IMPLIES
        subset?(var_names(ann_event(mp)(ts)), 
                union(var_names(program(mp)), var_names(new_gvds(mp))))

  ann_event_var_names : LEMMA % :-)
    FORALL (ts : finite_set[Transition], v : Name) :
      subset?(ts, ts(mva(mp))) IMPLIES
      var_names(ann_event(mp)(ts))(v) IMPLIES 
        ext_declared_var_names(program(mp))(v) OR
        var_names(new_gvds(mp))(v)


END AnnotateEvent


AnnotateMethod[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateEvent[CP, Name]

  mp : VAR (wf_MP)

  a : VAR (wf_MVA)


  filter_event(a)(et : EventType)(m : Name) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  filter_event_subset : LEMMA % :-)
    FORALL(et : EventType, m : Name) :
      subset?(filter_event(a)(et)(m), ts(a))

  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType) : 
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))
    IN
    m WITH [pre_set  := Sequence(pre_set(m), 
                        Sequence(ann_event_type(Entry),
                        Assert(Neg(Eq(NExpr(NumVarEval(cp(mp))),
                                      NExpr(NumVarEval(halted(mp)))))))),
            post_set := Sequence(post_set(m), ann_event_type(ExitNormal)),
            exc_set  := Sequence(exc_set(m), ann_event_type(ExitExceptional))]


  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % NOTE: The following lemmas are simple but are useful as autorewrite rules
  
  ann_method_body : LEMMA % :-)
    FORALL(m : Method) :
      body(ann_method(mp)(m)) = body(m)

  ann_method_pre : LEMMA % :-)
    FORALL(m : Method) :
      pre(ann_method(mp)(m)) = pre(m)

  ann_method_post : LEMMA % :-)
    FORALL(m : Method) :
      post(ann_method(mp)(m)) = post(m)

  ann_method_arg : LEMMA % :-)
    FORALL(m : Method) :
      arg(ann_method(mp)(m)) = arg(m)

  ann_method_res : LEMMA % :-)
    FORALL(m : Method) :
      res(ann_method(mp)(m)) = res(m)

  ann_method_res_type : LEMMA % :-)
    FORALL(m : Method) :
      res_type(ann_method(mp)(m)) = res_type(m)

  ann_method_lvars : LEMMA % :-)
    FORALL(m : Method) :
      lvars(ann_method(mp)(m)) = lvars(m)

  ann_method_pre_set : LEMMA % :-)
    FORALL(m : Method) :
      Sequence?(pre_set(ann_method(mp)(m))) AND
        s1(pre_set(ann_method(mp)(m))) = pre_set(m)

  ann_method_post_set : LEMMA % :-)
    FORALL(m : Method) :
      Sequence?(post_set(ann_method(mp)(m))) AND
        s1(post_set(ann_method(mp)(m))) = post_set(m)

  ann_method_exc_set : LEMMA % :-)
    FORALL(m : Method) :
      Sequence?(exc_set(ann_method(mp)(m))) AND
        s1(exc_set(ann_method(mp)(m))) = exc_set(m)


  ann_method_wf_Body : LEMMA % :-)
    FORALL(m : Method) :
      wf_Method(program(mp))(m) IMPLIES
      LET am = ann_method(mp)(m) IN
      (FORALL(v : Name) : var_names(body(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v)) 
      AND
      (FORALL(v : Name) : var_names(pre(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v)) 
      AND 
      (FORALL(v : Name) : var_names(post(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v)) 
      AND 
      (FORALL(v : Name) : var_names(res(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v)) 
      AND 
      (FORALL(v : Name) : var_names(pre_set(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v) OR
                          var_names(new_gvds(mp))(v))
      AND 
      (FORALL(v : Name) : var_names(post_set(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v) OR
                          var_names(new_gvds(mp))(v))
      AND 
      (FORALL(v : Name) : var_names(exc_set(am))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v) OR
                          var_names(new_gvds(mp))(v))


END AnnotateMethod


AnnotateClass[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateMethod[CP, Name]

  mp : VAR (wf_MP)

  a : VAR (wf_MVA)



  ann_class(mp)(c : Class) : Class =
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN c WITH [inv := Conj(Neg(Eq(NExpr(NumVarEval(cp(mp))), 
                                    NExpr(NumVarEval(halted(mp))))), inv(c)),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF

  FieldDecls_ann_class : LEMMA % :-)
    FORALL(c : Class) :
      fields(ann_class(mp)(c)) = fields(c)

  LocalDecls_ann_class : LEMMA % :-)
    FORALL(c : Class) :
      getLocalDecls(ann_class(mp)(c)) = getLocalDecls(c)

  GhostDecls_ann_class_annotated : LEMMA % :-)
    FORALL(c : Class) :
      classes(program(mp))(c) IMPLIES 
      name(c) = class_name(mva(mp)) IMPLIES
        ghost_vars(ann_class(mp)(c)) = union(ghost_vars(c), new_gvds(mp))

  GhostDecls_ann_class_not_annotated : LEMMA % :-)
    FORALL(c : Class) :
      classes(program(mp))(c) IMPLIES
      NOT name(c) = class_name(mva(mp)) IMPLIES
        ghost_vars(ann_class(mp)(c)) = ghost_vars(c)


  ann_class_almost_wf_Class : LEMMA % :-)
    FORALL(c : Class) :
      wf_Class(program(mp))(c) IMPLIES
      LET ac = ann_class(mp)(c) IN
        (FORALL (m1, m2 : Method) :
           methods(ac)(m1) IMPLIES
           methods(ac)(m2) IMPLIES
           name(m1) = name(m2) IMPLIES
           m1 = m2) 
     AND
     (FORALL (v : Name) : var_names(inv(ann_class(mp)(c)))(v) IMPLIES 
                          ext_declared_var_names(program(mp))(v) OR 
                          var_names(new_gvds(mp))(v))

  ann_class_inv : LEMMA % :-)
    FORALL(c : Class) :
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN Conj?(inv(ann_class(mp)(c))) AND 
         b2(inv(ann_class(mp)(c))) = inv(c)
    ELSE inv(ann_class(mp)(c)) = inv(c)
    ENDIF

  ann_program_preserves_class_name : LEMMA % :-)
    FORALL(c : Class) :
      name(ann_class(mp)(c)) = name(c)
        
END AnnotateClass


AnnotateProgram[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateClass[CP, Name]

  mp : VAR (wf_MP)

  a : VAR (wf_MVA)



  % Program annotation

  ann_program(mp) : Program = 
    (# classes := {c : Class | EXISTS (c1 : Class) : 
                                 classes(program(mp))(c1) AND 
                                 c = ann_class(mp)(c1)} #)


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING AnnotateProgram[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name]

  mp : VAR (wf_MP)

  ann_program_class_correspondence : LEMMA % :-)
    FORALL(c : Class) : classes(ann_program(mp))(c) IMPLIES
      EXISTS (c1 : Class) : classes(program(mp))(c1) AND c = ann_class(mp)(c1)

  ann_program_method_correspondence : LEMMA % :-)
    FORALL(c : Class, m : Method) :
      classes(ann_program(mp))(c) IMPLIES
      methods(c)(m) IMPLIES
        EXISTS (c1 : Class, m1 : Method) :
          classes(program(mp))(c1) AND 
          methods(c1)(m1) AND 
          (IF name(c1) = class_name(mva(mp))
           THEN m = ann_method(mp)(m1)
           ELSE m = m1
           ENDIF)

  ann_program_preserves_var_decls : LEMMA % :-)
    getFieldDecls(program(mp)) = getFieldDecls(ann_program(mp)) AND
    getLocalDecls(program(mp)) = getLocalDecls(ann_program(mp)) AND
    subset?(getGhostDecls(program(mp)), getGhostDecls(ann_program(mp)))

  ann_program_preserves_var_decl_names : LEMMA % :-)
    FORALL (vn : Name) :
      (var_names(getFieldDecls(program(mp)))(vn) IFF
       var_names(getFieldDecls(ann_program(mp)))(vn))
      AND
      (var_names(getGhostDecls(program(mp)))(vn) IMPLIES
       var_names(getGhostDecls(ann_program(mp)))(vn))
      AND
      (var_names(getLocalDecls(program(mp)))(vn) IFF
       var_names(getLocalDecls(ann_program(mp)))(vn))

  ann_program_add_ghost_var_decls : LEMMA % :-)
    getGhostDecls(ann_program(mp)) =
      union(getGhostDecls(program(mp)), new_gvds(mp))

  ann_program_ext_declared_var_names : LEMMA % :-)
     ext_declared_var_names(ann_program(mp)) = 
       union(ext_declared_var_names(program(mp)), var_names(new_gvds(mp)))

  ann_program_preserves_wf_state : LEMMA % :-)
    FORALL (s : PState) :
      wf_state(program(mp))(s) IMPLIES
        wf_state(ann_program(mp))(s)


  ann_program_preserves_pstate_vars : LEMMA % :-)
    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))

  ann_program_preserves_ghoststate_vars : LEMMA % :-)
    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_ghost(vn, sMP) IMPLIES is_ghost(vn, sAP))

  var_names_ann_program : LEMMA % :-)
    subset?(var_names(ann_program(mp)), 
            union(var_names(program(mp)), var_names(new_gvds(mp))))

  ann_program_preserves_wf_body : LEMMA % :-)
    FORALL(b : (wf_Body(program(mp)))) :
      wf_Body(ann_program(mp))(b)

  ann_program_preserves_wf_method : LEMMA  % :-)
    FORALL(m : (wf_Method(program(mp)))) :
      wf_Method(ann_program(mp))(ann_method(mp)(m))

  % PROVE
  ann_event_wf_Body : LEMMA
    FORALL (m : Method, ts : finite_set[Transition]) :
      methods(get_monitored_class(mp))(m) IMPLIES
      subset?(ts, ts(mva(mp))) IMPLIES
        wf_Body(ann_program(mp))(ann_event(mp)(ts))

  get_class_ann_program : LEMMA % :-)
    FORALL (c1, c2 : Class, tgt : Val) :
      up?(get_class(program(mp))(tgt)) IMPLIES
      up?(get_class(ann_program(mp))(tgt)) IMPLIES
      c1 = down(get_class(program(mp))(tgt)) IMPLIES
      c2 = down(get_class(ann_program(mp))(tgt)) IMPLIES
        name(c1) = name(c2)

  same_class_name_ann_class_implies_same_class : LEMMA % :-)
    FORALL (c1, c2 : Class) :
      classes(program(mp))(c1) IMPLIES
      classes(ann_program(mp))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        IF name(c1) = class_name(mva(mp))
        THEN c2 = ann_class(mp)(c1)
        ELSE c2 = c1
        ENDIF

  same_method_name_ann_class_implies_same_method : LEMMA % :-)
    FORALL (c1, c2 : Class, m1, m2 : Method) :
      classes(program(mp))(c1) IMPLIES
      c2 = ann_class(mp)(c1) IMPLIES
      name(c1) = class_name(mva(mp)) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = ann_method(mp)(m1)


  lookup_mthd_ann_program : LEMMA % :-)
    FORALL (m1, m2 : Method, mn : Name, tgt : Val) :
      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
        IF name(down(get_class(program(mp))(tgt))) = class_name(mva(mp))
        THEN m2 = ann_method(mp)(m1)
        ELSE m2 = m1
        ENDIF

  ann_program_defines_MVA_vars : LEMMA % :-)
    FORALL (n : Name) : var_names(new_gvds(mp))(n) IMPLIES
      EXISTS (c : Class, gd : FieldDecl) :
        classes(ann_program(mp))(c) AND 
        name(c) = class_name(mva(mp)) AND
        ghost_vars(c)(gd) AND name(gd) = n

  new_vars_ghost_in_ann_program : LEMMA % :-)
    FORALL (n : Name, s : APState) :
      wf_state(ann_program(mp))(s) IMPLIES
      var_names(new_gvds(mp))(n) IMPLIES
        is_ghost(n, s)



  ann_program_preserves_class_names : LEMMA % :-)
    class_names(program(mp)) = class_names(ann_program(mp))

  up_get_class_equivalence : LEMMA % :-)
    FORALL(a : Val) : 
      up?(get_class(program(mp))(a)) IMPLIES
        up?(get_class(ann_program(mp))(a))

  get_class_equivalence : LEMMA % :-)
    FORALL(a : Val) :
      up?(get_class(program(mp))(a)) IMPLIES
      IF name(down(get_class(program(mp))(a))) = class_name(mva(mp)) 
      THEN get_class(ann_program(mp))(a) = 
             up(ann_class(mp)(down(get_class(program(mp))(a))))
      ELSE get_class(ann_program(mp))(a) = get_class(program(mp))(a)
      ENDIF


END AnnotateProgramProperties
