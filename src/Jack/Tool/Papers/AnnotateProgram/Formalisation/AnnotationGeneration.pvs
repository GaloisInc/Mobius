AnnotateProgram[CP : TYPE+] : THEORY
BEGIN

  ASSUMING
    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)
  ENDASSUMING

  IMPORTING MonitoredProgramSemantics[CP, string],
            set2list,
            FunProp

  mp : VAR {mp : MonitoredProgram | wf_MP(mp) AND 
                                    well_typed_Program(program(mp))}
  a : VAR (wf_MVA)

  unique : (injective?[CP, nat])

  name_of : (injective?[CP, string])

  cp : string

  halted : string = name_of(halted)


  % Ghost variable declarations

  new_gvds(mp : MonitoredProgram) : finite_set[FieldDecl] =
   {gd : FieldDecl | jtype(gd) = IntType AND
     (name(gd) = cp AND init_val(gd) = Int(unique(init_cp(mva(mp))))) OR
     ((EXISTS (q : (cps(mva(mp)))) : name(gd) = name_of(q) AND 
                                     jtype(gd) = IntType AND
                                     init_val(gd) = Int(unique(q))) OR
      (EXISTS (v : (vdsA(mva(mp)))) : name(gd) = name(v) AND
                                      jtype(gd) = jtype(v) AND
                                      init_val(gd) = init_val(v)))}


  % Event annotation

  ann_action(l : Action) : RECURSIVE Stmt =
    CASES l OF
      null : Skip,
      cons(x, xs) : Sequence(Set(target(x), source(x)), ann_action(xs))
    ENDCASES
  MEASURE length(l)

  update_vars(t : Transition) : Stmt =
    Sequence(Set(cp, NExpr(NumVarEval(name_of(tcp(t))))), 
             ann_action(action(t)))

  ann_guard_actions(mp)(ts : finite_set[Transition]) : list[[Expr, Stmt]] =
    set2list({x : [Expr, Stmt] | EXISTS (t : Transition) :
      ts(t) AND x = (guard_to_expression(mva(mp))(guard(t)), update_vars(t))})

  ann_trans_cp(mp)(q : CP, ts : finite_set[Transition]) : [Expr, Stmt] =
    (BExpr(Eq(NumVarEval(cp), NumVarEval(name_of(q)))),
     CaseJML(ann_guard_actions(mp)(ts)))


  % Generates annotations to update the control point and the variables when an
  % event occurs
  ann_event(mp)(ts : finite_set[Transition]): Stmt =
    CaseJML(set2list({c : [Expr, Stmt] | EXISTS (q : CP) : 
              cps(mva(mp))(q) AND
              nonempty?({t: Transition | ts(t) AND scp(t) = q}) AND
              c = ann_trans_cp(mp)(q,
                                  {t: Transition | ts(t) AND scp(t) = q})}))


  % Method annotation

  filter_event(a)(et : EventType)(m : string) : finite_set[Transition] =
    {t : Transition | ts(a)(t) AND etype(event(t)) = et AND mname(event(t)) = m}

  ann_method(mp)(m : Method) : Method =
    LET ann_event_type = LAMBDA (et : EventType) : 
                           ann_event(mp)(filter_event(mva(mp))(et)(name(m)))
    IN
    m WITH [pre_set  := Sequence(pre_set(m), ann_event_type(Entry)),
            post_set := Sequence(post_set(m), ann_event_type(ExitNormal)),
            exc_set  := Sequence(exc_set(m), ann_event_type(ExitExceptional))]


  ann_methods(mp)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = ann_method(mp)(n)}


  % Class annotation

  ann_class(mp)(c : Class) : Class =
    IF classes(program(mp))(c) AND name(c) = class_name(mva(mp))
    THEN c WITH [inv := BExpr(Conj(b(inv(c)), Neq(NumVarEval(cp), 
                                                  NumVarEval(halted)))),
                 ghost_vars := union(ghost_vars(c),
                                     new_gvds(mp)),
                 methods := ann_methods(mp)(methods(c))]
    ELSE c
    ENDIF


  % Program annotation

  % The generated ghost variables must have differnt names
  disjoint_model_vars(a : MVA) : boolean =
    (FORALL (vd : MVAVarDecl) :
      vdsA(a)(vd) IMPLIES
        NOT name(vd) = cp) AND
    (FORALL (q : CP) :
      cps(a)(q) IMPLIES
        NOT name_of(q) = cp) AND
    (FORALL (q : CP, vd : MVAVarDecl) :
      cps(a)(q) IMPLIES
      vdsA(a)(vd) IMPLIES
        NOT name_of(q) = name(vd))

  % Java reserved words. We only need to mention This, the other are given as
  % examples. 
  reserved_words : finite_set[string] = 
    {n : string | n = This OR n = "super" OR n = "if" OR n = "then" OR n = "else"}

  wf_new_vars(mp : MonitoredProgram) : boolean =
    disjoint_model_vars(mva(mp)) AND
    FORALL (n : string) : 
      var_names(new_gvds(mp))(n) IMPLIES
        NOT reserved_words(n) AND
        NOT var_names(getGhostDecls(program(mp)))(n) AND
        NOT var_names(getFieldDecls(program(mp)))(n) AND
        NOT var_names(getLocalDecls(program(mp)))(n)

  ann_program_pre(mp : MonitoredProgram) : boolean =
    wf_MP(mp) AND
    complete(mva(mp)) AND % REMOVE
    well_typed_Program(program(mp)) AND % REMOVE
    wf_new_vars(mp)

  ann_program(mp : (ann_program_pre)) : Program = 
    (# classes := {c : Class | EXISTS (c1 : Class) : 
                                 classes(program(mp))(c1) AND 
                                 c = ann_class(mp)(c1)} #)


END AnnotateProgram


% Properties relating MPs and APs through ann_program
AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING
    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)
  ENDASSUMING

  IMPORTING AnnotateProgram[CP],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string]

  ann_program_preserves_fields : LEMMA % :-)
    FORALL (mp : MonitoredProgram, fv : FieldDecl) :
      ann_program_pre(mp) IMPLIES
      getFieldDecls(ann_program(mp))(fv) IMPLIES
        getFieldDecls(program(mp))(fv)

  ann_program_preserves_locals : LEMMA % :-)
    FORALL (mp : MonitoredProgram, lv : LocalVarDecl) :
      ann_program_pre(mp) IMPLIES
      getLocalDecls(ann_program(mp))(lv) IMPLIES
        getLocalDecls(program(mp))(lv)

  ann_program_yields_wf_program : LEMMA % :-)
    FORALL (mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
        wf_Program(ann_program(mp))

  ann_program_class_correspondence : LEMMA % :-)
    FORALL(mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
        FORALL(c : Class) :
          classes(ann_program(mp))(c) IMPLIES
            EXISTS (c1 : Class) :
              classes(program(mp))(c1) AND c = ann_class(mp)(c1)
 
  ann_program_method_correspondence : LEMMA % :-)
    FORALL(mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
        FORALL(c : Class, m : Method) :
          classes(ann_program(mp))(c) IMPLIES
          methods(c)(m) IMPLIES
            EXISTS (c1 : Class, m1 : Method) :
              classes(program(mp))(c1) AND 
              methods(c1)(m1) AND 
              (IF name(c1) = class_name(mva(mp))
               THEN m = ann_method(mp)(m1)
               ELSE m = m1
               ENDIF)

  ann_program_preserves_var_decls : LEMMA % :-)
    FORALL (mp : MonitoredProgram):
      ann_program_pre(mp) IMPLIES
        getFieldDecls(program(mp)) = getFieldDecls(ann_program(mp))
        AND
        getLocalDecls(program(mp)) = getLocalDecls(ann_program(mp))
        AND
        subset?(getGhostDecls(program(mp)), getGhostDecls(ann_program(mp)))


  ann_program_preserves_var_decl_names : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(vn : string) :
      ann_program_pre(mp) IMPLIES
        (var_names(getFieldDecls(program(mp)))(vn) IFF
         var_names(getFieldDecls(ann_program(mp)))(vn))
        AND
        (var_names(getGhostDecls(program(mp)))(vn) IMPLIES
         var_names(getGhostDecls(ann_program(mp)))(vn))
        AND
        (var_names(getLocalDecls(program(mp)))(vn) IFF
         var_names(getLocalDecls(ann_program(mp)))(vn))

  ann_program_preserves_wf_state : LEMMA % :-)
    FORALL (mp : MonitoredProgram, s : PState) :
      ann_program_pre(mp) IMPLIES
      wf_state(program(mp))(s) IMPLIES
        wf_state(ann_program(mp))(s)


  ann_program_preserves_pstate_vars : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(vn : string)
           (sMP : MPState, sAP : APState) :
      ann_program_pre(mp) IMPLIES
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))


  ann_program_preserves_ghoststate_vars : LEMMA % :-)
    FORALL (mp : MonitoredProgram)(vn : string)
           (sMP : MPState, sAP : APState) :
      ann_program_pre(mp) IMPLIES
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_ghost(vn, sMP) IMPLIES is_ghost(vn, sAP))

  % not provable this way
  ann_program_preserves_state_vars : LEMMA
    FORALL (mp : MonitoredProgram)(vn : string)
           (sMP : MPState, sAP : APState) :
      ann_program_pre(mp) IMPLIES
      wf_state(mp)(sMP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP))) AND
        (is_ghost(vn, sMP) IFF is_ghost(vn, sAP))

  get_class_ann_program : LEMMA % :-)
    FORALL (mp : MonitoredProgram, c1, c2 : Class, s : PState, tgt : Val) :
      ann_program_pre(mp) IMPLIES
      up?(get_class(program(mp))(tgt)) IMPLIES
      up?(get_class(ann_program(mp))(tgt)) IMPLIES
      c1 = down(get_class(program(mp))(tgt)) IMPLIES
      c2 = down(get_class(ann_program(mp))(tgt)) IMPLIES
        name(c1) = name(c2)

  same_class_name_ann_class_implies_same_class : LEMMA % :-)
    FORALL (mp : MonitoredProgram, c1, c2 : Class) :
      ann_program_pre(mp) IMPLIES
      classes(program(mp))(c1) IMPLIES
      classes(ann_program(mp))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        IF name(c1) = class_name(mva(mp))
        THEN c2 = ann_class(mp)(c1)
        ELSE c2 = c1
        ENDIF

  same_method_name_ann_class_implies_same_method : LEMMA % :-)
    FORALL (mp : MonitoredProgram, c1, c2 : Class, m1, m2 : Method) :
      ann_program_pre(mp) IMPLIES
      classes(program(mp))(c1) IMPLIES
      c2 = ann_class(mp)(c1) IMPLIES
      name(c1) = class_name(mva(mp)) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = ann_method(mp)(m1)

  % FIX PROOF
  % if possible?? (MH)
  lookup_mthd_ann_program : LEMMA % 
    FORALL (mp : MonitoredProgram, m1, m2 : Method, mn : string, tgt : Val) :
      ann_program_pre(mp) IMPLIES
      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
        IF up?(get_class(program(mp))(tgt)) AND
           name(down(get_class(program(mp))(tgt))) = class_name(mva(mp))
        THEN m2 = ann_method(mp)(m1)
        ELSE m2 = m1
        ENDIF

  % PROVE
  % unprovable for the moment
  % one problem: derive(mp)(inv) = derive(ann_program(mp))(inv)
  % should not depend on astate
  ann_program_preserves_well_behaved_Program : LEMMA
    FORALL (mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
      well_behaved_Program(mp) IMPLIES
        well_behaved_Program(ann_program(mp))

  ann_program_defines_MVA_vars2 : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program) :
      ann_program_pre(mp) IMPLIES
      ap = ann_program(mp) IMPLIES
        EXISTS (c : Class) :
          classes(ap)(c) AND 
          name(c) = class_name(mva(mp)) AND
          (EXISTS (gd : FieldDecl) :  
            ghost_vars(c)(gd) AND name(gd) = cp) AND
          (FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
            EXISTS (gd : FieldDecl) :
              ghost_vars(c)(gd) AND name(gd) = name_of(q)) AND
          (FORALL (v : MVAVarDecl) : vdsA(mva(mp))(v) IMPLIES
            EXISTS (gd : FieldDecl) :
              ghost_vars(c)(gd) AND name(gd) = name(v))

  ann_program_defines_MVA_vars : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program, s : APState) :
      ann_program_pre(mp) IMPLIES
      ap = ann_program(mp) IMPLIES
      wf_state(ap)(s) IMPLIES
        is_ghost(cp, s) AND
        (FORALL (q : CP) :
          cps(mva(mp))(q) IMPLIES is_ghost(name_of(q), s)) AND
        (FORALL (v : MVAVarDecl) :
          vdsA(mva(mp))(v) IMPLIES is_ghost(name(v), s))


END AnnotateProgramProperties
