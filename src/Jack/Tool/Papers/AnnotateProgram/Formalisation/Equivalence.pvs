Equivalence[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, string],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string],
            AnnotateProgram[CP]

  cp2val(q : CP) : Val = Int(unique(q))

  % Says if an MVA state is modeled by a state of an annotated program
  MVA_modeled?(sA : AState, sAP : APState) : boolean =
    (cp2val(cp(sA)) = gvs(sAP)("cp")) AND
    (FORALL (n : string) : NOT Bottom?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)) AND
    (cp(sA) = halted IMPLIES
      down(ex(pstate(sAP))) = JMLExc)

  % Says if sAP2 is a "super state" of sAP1
  Program_modeled?(sAP1, sAP2 : APState) : boolean =
    LET s1 = pstate(sAP1), s2 = pstate(sAP2) IN
    ex(s1) = ex(s2) AND
    fvs(st(s1)) = fvs(st(s2)) AND
    lvs(st(s1)) = lvs(st(s2)) AND
    FORALL (n : string) : NOT Bottom?(gvs(sAP1)(n)) IMPLIES
      gvs(sAP1)(n) = gvs(sAP2)(n)

  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    Program_modeled?((# pstate := pstate(sMP), gvs := gvs(sMP) #), sAP)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(astate(sMP), sAP) AND 
    Program_modeled?(sMP, sAP)


  % Properties about MP_modeled?

  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(sMP, sAP) IMPLIES ex(pstate(sMP)) = ex(pstate(sAP))

  MP_modeled_preserved_by_update : LEMMA
    FORALL (sMP : MPState, sAP : APState)(vn : string, v : Val) :
      MP_modeled?(sMP, sAP) IMPLIES 
        MP_modeled?(update_state_MP(update(vn, v), sMP),
                    update_state_AP(update(vn, v), sAP))

%   MP_modeled_preserved_by_update2 : LEMMA
%     FORALL (mp : MonitoredProgram, ap : Program)
%            (sMP : MPState, sAP : APState)(vn : string, v : Val) :
%       ann_program_pre(mp) IMPLIES
%       ap = ann_program(mp) IMPLIES
%       wf_state(mp, sMP) IMPLIES 
%       wf_state(ap, sAP) IMPLIES
%       MP_modeled?(sMP, sAP) IMPLIES 
%         MP_modeled?(update_state_MP(update(vn, v), sMP),
%                     update_state_AP(update(vn, v), sAP))


%   % TODO: Define
%   assertion_breached?(p : Program)(s1, s2 : APState, n : nat) : boolean

%   % JML Exceptions are only generated by annotations
%   JMLExc_iff_assertion_breached : LEMMA
%     FORALL (p : (wf_Program))(main : Method, arg : int)(s2P : PState, n : nat) :
%       run_Program(p)(main, arg)(s2P)(n) IMPLIES
%       up?(ex(s2P)) IMPLIES
%       down(ex(s2P)) = JMLExc IMPLIES
%         assertion_breached?(p)(initial_Program_state(p), s2P, n)


  IMPORTING EpsilonProps  % imports choose_singleton?

  initial_states_are_equivalent : LEMMA
    FORALL (mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
        MP_modeled?(initial_MP_state(mp), 
                    initial_AP_state(ann_program(mp)))


  execute_set_equivalence : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program, vn : string, e : Expr,
            n1, n2 : nat, sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      ap = ann_program(mp) IMPLIES
      Program_modeled?(sMP1, sAP1) IMPLIES
      (FORALL (n1, n2 : nat)(e : Expr, v1, v2 : Val)
              (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
        deriv_expr(mp)(e, sMP1, v1, sMP2)(n1) IMPLIES
        deriv_expr(ap)(e, sAP1, v2, sAP2)(n2) IMPLIES
          v1 = v2 AND
          MP_modeled?(sMP2, sAP2)) IMPLIES
      execute_set_MP(mp, vn, e, sMP1, sMP2, n1, deriv_stmt, deriv_expr) IMPLIES
      execute_set_AP(ap, vn, e, sAP1, sAP2, n1, deriv_stmt, deriv_expr) IMPLIES
      Program_modeled?(sMP2, sAP2)


  deriv_expr_equivalence : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program)
           (e : Expr, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      ap = ann_program(mp) IMPLIES
      MP_modeled?(sMP1, sAP1) IMPLIES
      deriv_expr(mp)(e, sMP1, v1, sMP2)(n1) IMPLIES
      deriv_expr(ap)(e, sAP1, v2, sAP2)(n2) IMPLIES
        v1 = v2 AND
        MP_modeled?(sMP2, sAP2)

  deriv_stmt_equivalence : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program)(n1, n2 : nat)(c : Stmt)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      ap = ann_program(mp) IMPLIES
      MP_modeled?(sMP1, sAP1) IMPLIES
      deriv_stmt(mp)(c, sMP1, sMP2)(n1) IMPLIES
      deriv_stmt(ap)(c, sAP1, sAP2)(n2) IMPLIES
        MP_modeled?(sMP2, sAP2)


  % The main result
  correcteness_of_ann_program : THEOREM
    FORALL (mp : MonitoredProgram)(main : Method, arg : int)
           (n : nat, sMP : MPState, sAP : APState) :
      ann_program_pre(mp) IMPLIES
      run_monitored_program(mp)(main, arg)(sMP)(n) IMPLIES
        EXISTS (m : nat) :
          run_annotated_program(ann_program(mp))(main, arg)(sAP)(m) AND
          MP_modeled?(sMP, sAP)


END Equivalence
