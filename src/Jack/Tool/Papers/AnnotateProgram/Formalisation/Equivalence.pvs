Equivalence[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, string],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string],
            AnnotateProgram[CP],
            AnnotateProgramProperties[CP, string]

  cp2val(q : CP) : Val = Int(unique(q))

  % Says if an MVA state is modeled by a state of an annotated program
  MVA_modeled?(sA : AState, sAP : APState) : boolean =
    (cp2val(cp(sA)) = gvs(sAP)("cp")) AND
    (FORALL (n : string) : NOT Bottom?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)) AND
    (cp(sA) = halted IMPLIES
      up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc)

  % Says if sAP is a "super state" of sMP
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND
    FORALL (n : string) : NOT Bottom?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(astate(sMP), sAP) AND 
    Program_modeled?(sMP, sAP)

  related_states(mp : MonitoredProgram, ap : Program)
                (sMP : MPState, sAP : APState) : boolean =
    ann_program_pre(mp) AND
    ap = ann_program(mp) AND
    wf_state(mp)(sMP) AND
    wf_state(ap)(sAP) AND
    MP_modeled?(sMP, sAP)

  related_states_implies_wf_mp_and_ap : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        wf_MP(mp) AND wf_Program(ap)


  % Properties about MP_modeled?

  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(sMP, sAP) IMPLIES ex(pstate(sMP)) = ex(pstate(sAP))

  MP_modeled_preserved_by_update : LEMMA  % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(vn : string, v : Val) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        MP_modeled?(update_state_MP(update(vn, v), sMP),
                    update_state_AP(update(vn, v), sAP))

  MP_modeled_implies_cp_not_halted : LEMMA % :-)
    FORALL (mp : MonitoredProgram, sMP : MPState, sAP : APState) :
      MP_modeled?(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        NOT cp(astate(sMP)) = halted

  % NOTE: If cp(astate(sMP)) = halted, upd must leave the JML exception in sAP
  MP_modeled_preserved_by_update2 : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        MP_modeled?(update_state_MP(upd, sMP),
                    update_state_AP(upd, sAP))

  MP_modeled_implies_same_num_eval : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(n : NumExpr) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        eval(n)(pstate(sMP)) = eval(n)(pstate(sAP))

  MP_modeled_implies_same_bool_eval : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(b : BoolExpr) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        eval(b)(pstate(sMP)) = eval(b)(pstate(sAP))


  % Main lemmas used in the proof of the correcteness_of_ann_program

  initial_states_are_equivalent : LEMMA
    FORALL (mp : MonitoredProgram) :
      MP_modeled?(initial_MP_state(mp),
                  initial_AP_state(ann_program(mp)))

  deriv_expr_maintains_equivalence : THEOREM
    FORALL (mp : MonitoredProgram, ap : Program)
           (e : Expr, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      deriv_expr(mp)(e, sMP1, v1, sMP2)(n1) IMPLIES
      deriv_expr(ap)(e, sAP1, v2, sAP2)(n2) IMPLIES
        v1 = v2 AND
        MP_modeled?(sMP2, sAP2)

  deriv_stmt_maintains_equivalence : THEOREM
    FORALL (mp : MonitoredProgram, ap : Program)(n1, n2 : nat)(c : Stmt)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      deriv_stmt(mp)(c, sMP1, sMP2)(n1) IMPLIES
      deriv_stmt(ap)(c, sAP1, sAP2)(n2) IMPLIES
        MP_modeled?(sMP2, sAP2)


  % The main result
  correcteness_of_ann_program : THEOREM % :-)
    FORALL (mp : MonitoredProgram)(main : Method, arg : int)
           (sMP : MPState, sAP : APState)(n, m : nat) :
      ann_program_pre(mp) IMPLIES
      run_monitored_program(mp)(main, arg)(sMP)(n) IMPLIES
      run_annotated_program(ann_program(mp))(main, arg)(sAP)(m) IMPLIES
        MP_modeled?(sMP, sAP)


END Equivalence
