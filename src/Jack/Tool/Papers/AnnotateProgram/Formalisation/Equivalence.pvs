Equivalence[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MVASemantics[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name],
            AnnotateProgram[CP, Name],
            AnnotateProgramProperties[CP, Name]


  mp : VAR (wf_MP)

  MVA_cp_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    Int(unique(cp(sA))) = gvs(sAP)(cp(mp))

  MVA_cps_modeled?(mp)(sAP : APState) : boolean =
    FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      Int(unique(q)) = gvs(sAP)(name_of(mp)(q))

  MVA_vars_modeled?(sA : AState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)

  % A state of a MVA, sA, is modeled by a state of an AP, sAP, if:
  % .The value of cp in sAP is equal to the mapping from cp to integers
  % .Variables that model the control points are unchnaged
  % .Variables in MVA have the same value as the respective ghost vars in the AP
  MVA_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    MVA_cp_modeled?(mp)(sA, sAP) AND
    MVA_cps_modeled?(mp)(sAP) AND
    MVA_vars_modeled?(sA, sAP)

  Program_gvs_modeled?(sMP : MPState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Says if sAP is a "super state" of sMP
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    % any exception in the monitored prog also happens in the annotated prog
    (up?(ex(pstate(sMP))) IMPLIES
       up?(ex(pstate(sAP))) AND ex(pstate(sMP)) = ex(pstate(sAP))) AND
    % the only new exceptions are JMLExc
    (up?(ex(pstate(sAP))) AND NOT up?(ex(pstate(sMP))) IMPLIES
       down(ex(pstate(sAP))) = JMLExc) AND
    st(pstate(sMP)) = st(pstate(sAP)) AND
    Program_gvs_modeled?(sMP, sAP)

  Program_modeled2?(sMP : MPState, sAP : APState) : boolean =
    IF up?(ex(pstate(sMP)))
    % any exception in the monitored prog also happens in the annotated prog
    THEN up?(ex(pstate(sAP))) AND ex(pstate(sMP)) = ex(pstate(sAP))
    % the only new exceptions are JMLExc
    ELSE up?(ex(pstate(sAP))) IMPLIES down(ex(pstate(sAP))) = JMLExc
    ENDIF AND
    st(pstate(sMP)) = st(pstate(sAP)) AND
    Program_gvs_modeled?(sMP, sAP)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(mp)(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(mp)(astate(sMP), sAP) AND
    Program_modeled?(sMP, sAP)


  % It is possible to translate every guard of the MVA into an expression that
  % evaluates to the same result. Note that if the guard holds then evaluation
  % of the expression can not result in an exception (v would be Bottom).
  % Furthermore, the evaluation must have no side-effects.
  guard_to_expression_behavior(mp) : boolean =
    FORALL (t : Transition, sAP : APState, sMVA : AState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      wf_AState(mva(mp))(sMVA) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_modeled?(mp)(sMVA, sAP) IMPLIES
      ts(mva(mp))(t) IMPLIES scp(t) = cp(sMVA) IMPLIES
        EXISTS (e : BoolExpr, v : Val, n : nat) : 
          guard_to_expression(mva(mp))(guard(t)) = e AND
          wf_BoolExpr(ann_program(mp))(e) AND
          derive(ann_program(mp))(e, sAP, v, sAP)(n) AND
          (guard(t)(stA(sMVA), st(pstate(sAP))) = (v = Bool(TRUE)))

  % It is possible to evaluate expressions appearing in actions (they 
  % terminate) and they are side-effect-free. Note that the evaluation 
  % of the expresion can not throw an exception (provided it starts in 
  % a non-exceptional state).
  eval_action_behavior(mp) : boolean =
    FORALL (e : Expr, v : Val, sAP : APState, sMVA : AState) :
      wf_Expr(mva(mp))(e) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
      wf_AState(mva(mp))(sMVA) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_modeled?(mp)(sMVA, sAP) IMPLIES
        (eval(e)(stA(sMVA), st(pstate(sAP))) = v) =
        EXISTS (n : nat) : derive(ann_program(mp))(e, sAP, v, sAP)(n)

  actions_have_no_side_effects(mp) : boolean =
    FORALL (t : Transition, oa : OneAction) :
      ts(mva(mp))(t) IMPLIES
      member(oa, action(t)) IMPLIES
        FORALL (s1, s2 : APState, v : Val, n : nat) :
          wf_state(ann_program(mp))(s1) IMPLIES
          derive(ann_program(mp))(source(oa), s1, v, s2)(n) IMPLIES
            s1 = s2

  well_behaved_MVA(mp) : boolean =
    guard_to_expression_behavior(mp) AND
    eval_action_behavior(mp) AND
    actions_have_no_side_effects(mp)

%  well_behaved_MP(mp) : boolean =
%    well_behaved_Program(mp) AND
%    well_behaved_MVA(mp)

  halted_implies_JMLExc(mp)(sMP : MPState, sAP : APState) : boolean =
    cp(astate(sMP)) = halted IMPLIES
      (up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc)

  related_states(mp)(sMP : MPState, sAP : APState) : boolean = 
    wf_state(mp)(sMP) AND
    wf_state(ann_program(mp))(sAP) AND
    MP_modeled?(mp)(sMP, sAP) AND
    halted_implies_JMLExc(mp)(sMP, sAP)
    

END Equivalence
