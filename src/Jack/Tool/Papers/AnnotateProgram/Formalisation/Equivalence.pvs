Equivalence[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, string],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string],
            AnnotateProgram[CP],
            AnnotateProgramProperties[CP, string]

  cp2val(q : CP) : Val = Int(unique(q))

  % Says if an MVA state is modeled by a state of an annotated program
  MVA_modeled?(sA : AState, sAP : APState) : boolean =
    (cp2val(cp(sA)) = gvs(sAP)("cp")) AND
    (FORALL (n : string) : NOT Bottom?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)) AND
    (cp(sA) = halted IMPLIES
      up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc)

  % Says if sAP is a "super state" of sMP
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND
    FORALL (n : string) : NOT Bottom?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(astate(sMP), sAP) AND 
    Program_modeled?(sMP, sAP)

  related_states(mp : MonitoredProgram, ap : Program)
                (sMP : MPState, sAP : APState) : boolean =
    ann_program_pre(mp) AND
    ap = ann_program(mp) AND
    wf_state(mp)(sMP) AND
    wf_state(ap)(sAP) AND
    MP_modeled?(sMP, sAP)

  related_states_implies_wf_mp_and_ap : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        wf_MP(mp) AND wf_Program(ap)


  % Properties about MP_modeled?

  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(sMP, sAP) IMPLIES ex(pstate(sMP)) = ex(pstate(sAP))

  MP_modeled_preserved_by_update : LEMMA  % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(vn : string, v : Val) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        MP_modeled?(update_state_MP(update(vn, v), sMP),
                    update_state_AP(update(vn, v), sAP))

  MP_modeled_implies_cp_not_halted : LEMMA % :-)
    FORALL (mp : MonitoredProgram, sMP : MPState, sAP : APState) :
      MP_modeled?(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        NOT cp(astate(sMP)) = halted

  % NOTE: If cp(astate(sMP)) = halted, upd must leave the JML exception in sAP
  MP_modeled_preserved_by_update2 : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        MP_modeled?(update_state_MP(upd, sMP),
                    update_state_AP(upd, sAP))

  MP_modeled_implies_same_num_eval : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(n : NumExpr) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        eval(n)(pstate(sMP)) = eval(n)(pstate(sAP))

  MP_modeled_implies_same_bool_eval : LEMMA % :-)
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP : MPState, sAP : APState)(b : BoolExpr) :
      related_states(mp, ap)(sMP, sAP) IMPLIES
        eval(b)(pstate(sMP)) = eval(b)(pstate(sAP))

  % THINK: I must say that the two v's are the same, but how do I get that?
  MP_modeled_preverved_by_assertion_checking : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState, 
            assertion : Expr, n1, n2 : nat,
            deriv_expr_MP : [MonitoredProgram -> [Expr, MPState, Val, MPState ->
                                                 [below(n1 + 1) -> bool]]],
            deriv_expr_AP : [Program -> [Expr, APState, Val, APState ->
                                        [below(n2 + 1) -> bool]]]) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      (FORALL (v : Val, tau : MPState) :
        deriv_expr_MP(mp)(assertion, sMP1, v, tau)(n1)
          IMPLIES sMP1 = tau) IMPLIES
      (FORALL (v : Val, tau : APState) :
        deriv_expr_AP(ap)(assertion, sAP1, v, tau)(n2) 
          IMPLIES sAP1 = tau) IMPLIES
      check_assertion(mp)(assertion, sMP1, sMP2)(n1)(deriv_expr_MP) IMPLIES
      check_assertion(ap)(assertion, sAP1, sAP2)(n2)(deriv_expr_AP) IMPLIES
        MP_modeled?(sMP2, sAP2)

  % THINK: The invariant (retrieved by lookup_inv) in the annotated class should
  % include the added check cp != halted
  on_method_entry_for_ann_method_equivalence  : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState, c : Class, 
            m1, m2 : Method, a : Val, n1, n2 : nat,
            deriv_stmt_MP : [MonitoredProgram -> [Stmt, MPState, MPState ->
                                                 [below(n1 + 1) -> bool]]],
            deriv_expr_MP : [MonitoredProgram -> [Expr, MPState, Val, MPState ->
                                                 [below(n1 + 1) -> bool]]],
            deriv_stmt_AP : [Program -> [Stmt, APState, APState ->
                                        [below(n2 + 1) -> bool]]],
            deriv_expr_AP : [Program -> [Expr, APState, Val, APState ->
                                        [below(n2 + 1) -> bool]]]) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      assertions_have_no_side_effect(mp) IMPLIES
      classes(program(mp))(c) IMPLIES
      methods(c)(m1) IMPLIES
      m2 = ann_method(mp)(m1) IMPLIES
      on_method_entry_MP(mp, m1, a, sMP1, sMP2, n1, deriv_stmt_MP, 
                         deriv_expr_MP) IMPLIES
      on_method_entry_AP(ap, m2, a, sAP1, sAP2, n2, deriv_stmt_AP, 
                         deriv_expr_AP) IMPLIES
        MP_modeled?(sMP2, sAP2)

  on_method_entry_for_same_method_equivalence  : LEMMA
    FORALL (mp : MonitoredProgram, ap : Program)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState, m : Method,
            a : Val, n1, n2 : nat,
            deriv_stmt_MP : [MonitoredProgram -> [Stmt, MPState, MPState ->
                                                 [below(n1 + 1) -> bool]]],
            deriv_expr_MP : [MonitoredProgram -> [Expr, MPState, Val, MPState ->
                                                 [below(n1 + 1) -> bool]]],
            deriv_stmt_AP : [Program -> [Stmt, APState, APState ->
                                        [below(n2 + 1) -> bool]]],
            deriv_expr_AP : [Program -> [Expr, APState, Val, APState ->
                                        [below(n2 + 1) -> bool]]]) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      on_method_entry_MP(mp, m, a, sMP1, sMP2, n1, deriv_stmt_MP, 
                         deriv_expr_MP) IMPLIES
      on_method_entry_AP(ap, m, a, sAP1, sAP2, n2, deriv_stmt_AP, 
                         deriv_expr_AP) IMPLIES
      MP_modeled?(sMP2, sAP2)


  % Main lemmas used in the proof of the correcteness_of_ann_program

  initial_states_are_equivalent : LEMMA
    FORALL (mp : MonitoredProgram) :
      MP_modeled?(initial_MP_state(mp),
                  initial_AP_state(ann_program(mp)))

  deriv_expr_maintains_equivalence : THEOREM
    FORALL (mp : MonitoredProgram, ap : Program)
           (e : Expr, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      deriv_expr(mp)(e, sMP1, v1, sMP2)(n1) IMPLIES
      deriv_expr(ap)(e, sAP1, v2, sAP2)(n2) IMPLIES
        v1 = v2 AND
        MP_modeled?(sMP2, sAP2)

  deriv_stmt_maintains_equivalence : THEOREM
    FORALL (mp : MonitoredProgram, ap : Program)(n1, n2 : nat)(c : Stmt)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      related_states(mp, ap)(sMP1, sAP1) IMPLIES
      deriv_stmt(mp)(c, sMP1, sMP2)(n1) IMPLIES
      deriv_stmt(ap)(c, sAP1, sAP2)(n2) IMPLIES
        MP_modeled?(sMP2, sAP2)


  % The main result
  correcteness_of_ann_program : THEOREM % :-)
    FORALL (mp : MonitoredProgram)(main : Method, arg : int)
           (sMP : MPState, sAP : APState)(n, m : nat) :
      ann_program_pre(mp) IMPLIES
      run_monitored_program(mp)(main, arg)(sMP)(n) IMPLIES
      run_annotated_program(ann_program(mp))(main, arg)(sAP)(m) IMPLIES
        MP_modeled?(sMP, sAP)


END Equivalence
