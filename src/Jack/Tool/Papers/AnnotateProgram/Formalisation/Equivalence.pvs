Equivalence[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MVASemantics[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name],
            AnnotateProgram[CP, Name],
            AnnotateProgramProperties[CP, Name]


  mp : VAR (wf_MP)

  MVA_cp_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    Int(unique(cp(sA))) = gvs(sAP)(cp(mp))

  MVA_cps_modeled?(mp)(sAP : APState) : boolean =
    FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      Int(unique(q)) = gvs(sAP)(name_of(mp)(q))

  MVA_vars_modeled?(sA : AState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)

  % A state of a MVA, sA, is modeled by a state of an AP, sAP, if:
  % .The value of cp in sAP is equal to the mapping from cp to integers
  % .Variables that model the control points are unchnaged
  % .Variables in MVA have the same value as the respective ghost vars in the AP
  MVA_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    MVA_cp_modeled?(mp)(sA, sAP) AND
    MVA_cps_modeled?(mp)(sAP) AND
    MVA_vars_modeled?(sA, sAP)

  Program_gvs_modeled?(sMP : MPState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  % Says if sAP is a super state of sMP
  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND
    Program_gvs_modeled?(sMP, sAP)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(mp)(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(mp)(astate(sMP), sAP) AND
    Program_modeled?(sMP, sAP)

  % NOTE: It looks natural to include this requirement in MVA_modeled?. The
  % problem is that it does not hold in the intermediate state of the method
  % call case (before the invariant is checked), in particular for some
  % lemmas in LemmasAnnGeneration.
  halted_implies_JMLExc(sMP : MPState, sAP : APState) : boolean =
    cp(astate(sMP)) = halted IMPLIES
      up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc


  % It is possible to translate every guard of the MVA into an expression that
  % evaluates to the same result. Note that if the guard holds then evaluation
  % of the expression can not result in an exception (v would be Bottom).
  % Furthermore, the evaluation must have no side-effects.
  guard_to_expression_behavior(mp) : boolean =
    FORALL (g : Guard, sAP : APState, sMVA : AState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_vars_modeled?(sMVA, sAP) IMPLIES
      (EXISTS (t : Transition) :
        ts(mva(mp))(t) AND guard(t) = g) IMPLIES
        EXISTS (e : Expr, v : Val, n : nat) : 
          guard_to_expression(mva(mp))(g) = e AND
          derive(ann_program(mp))(e, sAP, v, sAP)(n) AND
          (g(stA(sMVA), st(pstate(sAP))) IFF v = Bool(TRUE))

  % It is possible to evaluate expressions appearing in actions (they 
  % terminate) and they are side-effect-free. Note that the evaluation 
  % of the expresion can not throw an exception (provided it starts in 
  % a non-exceptional state).
  eval_action_behavior(mp) : boolean =
    FORALL (e : Expr, v : Val, sAP : APState, sMVA : AState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_vars_modeled?(sMVA, sAP) IMPLIES
        (eval(e)(stA(sMVA), st(pstate(sAP))) = v IFF
         EXISTS (n : nat) : derive(ann_program(mp))(e, sAP, v, sAP)(n))

  well_behaved_MVA(mp) : boolean =
    guard_to_expression_behavior(mp) AND
    eval_action_behavior(mp)

  well_behaved_MP(mp) : boolean =
    well_behaved_Program(mp) AND
    well_behaved_MVA(mp)

  related_states(mp)(sMP : (wf_state(mp)), 
                     sAP : (AnnotatedProgramSemantics.wf_state(ann_program(mp)))) : boolean =
    MP_modeled?(mp)(sMP, sAP) AND
    halted_implies_JMLExc(sMP, sAP)
    


END Equivalence
