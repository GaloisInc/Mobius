Equivalence[CP : TYPE+] : THEORY
BEGIN

  IMPORTING MVASemantics[CP, string],
            AnnotatedProgramSemantics[string],
            MonitoredProgramSemantics[CP, string],
            AnnotateProgram[CP]

  cp2val(q : CP) : Val =
    Int(unique(q))

  % Says if an MVA state is modeled by a state of an annotated program
  MVA_modeled?(sA : AState, sAP : APState) : boolean =
    (cp2val(cp(sA)) = gvs(sAP)("cp")) AND
    (FORALL (n : string) : NOT Bottom?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)) AND
    (cp(sA) = halted IMPLIES 
      up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc)

  % Says if s2AP is a "super state" of s1AP
  Program_modeled?(s1AP, s2AP : APState) : boolean =
    LET s1 = pstate(s1AP), s2 = pstate(s2AP) IN
    ex(s1) = ex(s2) AND
    fvs(st(s1)) = fvs(st(s2)) AND
    lvs(st(s1)) = lvs(st(s2)) AND
    FORALL (n : string) : NOT Bottom?(gvs(s1AP)(n)) IMPLIES
      gvs(s1AP)(n) = gvs(s2AP)(n)

  MP_modeled?(sMP : MState, sAP : APState) : boolean =
    MVA_modeled?(astate(sMP), sAP) AND 
    Program_modeled?((# pstate := pstate(sMP), gvs := gvs(sMP) #), sAP)


%   % TODO: Define
%   assertion_breached?(p : Program)(s1, s2 : APState, n : nat) : boolean

%   % JML Exceptions are only generated by annotations
%   JMLExc_iff_assertion_breached : LEMMA
%     FORALL (p : (wf_Program))(main : Method, arg : int)(s2P : PState, n : nat) :
%       run_Program(p)(main, arg)(s2P)(n) IMPLIES
%       up?(ex(s2P)) IMPLIES
%       down(ex(s2P)) = JMLExc IMPLIES
%         assertion_breached?(p)(initial_Program_state(p), s2P, n)


  IMPORTING EpsilonProps  % imports choose_singleton?

  initial_states_are_equivalent : LEMMA
    FORALL (mp : MonitoredProgram) :
      ann_program_pre(mp) IMPLIES
        MP_modeled?(initial_MP_state(mp), 
                    initial_AP_state(ann_program(mp)))

  % The main result
  % NOTE: Because of the way the semantics are defined, we can use the seme n
  % for both derivations
  correcteness_of_ann_program : THEOREM
    FORALL (mp : MonitoredProgram)(main : Method, arg : int)
           (n : nat, s2MP : MState, s2AP : APState) :
      ann_program_pre(mp) IMPLIES
      run_annotated_program(ann_program(mp))(main, arg)(s2AP)(n) IMPLIES
      run_monitored_program(mp)(main, arg)(s2MP)(n) IMPLIES
        MP_modeled?(s2MP, s2AP)


END Equivalence
