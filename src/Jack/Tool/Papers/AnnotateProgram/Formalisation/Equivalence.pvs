Equivalence[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MVATotalSemantics[CP, Name],
            AnnotatedProgramSemantics[Name],
            MonitoredProgramSemantics[CP, Name],
            AnnotateProgram[CP, Name],
            AnnotateProgramProperties[CP, Name]

  mp : VAR (wf_and_complete_MP)


  MVA_cp_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    Int(unique(cp(sA))) = gvs(sAP)(cp(mp))

  MVA_cps_modeled?(mp)(sAP : APState) : boolean =
    FORALL (q : CP) : cps(mva(mp))(q) IMPLIES
      Int(unique(q)) = gvs(sAP)(name_of(mp)(q))

  MVA_vars_modeled?(sA : AState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(stA(sA)(n)) IMPLIES
      stA(sA)(n) = gvs(sAP)(n)

  % A state of a MVA, sA, is modeled by a state of an AP, sAP, if:
  % .The value of cp in sAP is equal to the mapping from cp to integers
  % .Variables that model the control points are unchnaged
  % .Variables in MVA have the same value as the respective ghost vars in the AP
  MVA_modeled?(mp)(sA : AState, sAP : APState) : boolean =
    MVA_cp_modeled?(mp)(sA, sAP) AND
    MVA_cps_modeled?(mp)(sAP) AND
    MVA_vars_modeled?(sA, sAP)

  Program_gvs_modeled?(sMP : MPState, sAP : APState) : boolean =
    FORALL (n : Name) : defined?(gvs(sMP)(n)) IMPLIES
      gvs(sMP)(n) = gvs(sAP)(n)

  Program_modeled?(sMP : MPState, sAP : APState) : boolean =
    pstate(sMP) = pstate(sAP) AND 
    Program_gvs_modeled?(sMP, sAP)

  % Says if an state of a MP is correctly modeled by a state of an AP
  MP_modeled?(mp)(sMP : MPState, sAP : APState) : boolean =
    MVA_modeled?(mp)(astate(sMP), sAP) AND
    Program_modeled?(sMP, sAP)


  % It is possible to translate every guard of the MVA into an expression that
  % evaluates to the same result. Note that if the guard holds then evaluation
  % of the expression can not result in an exception (v would be Bottom).
  % Furthermore, the evaluation must have no side-effects.
  guard_to_expression_behavior(mp) : boolean =
    FORALL (t : Transition, sAP : APState, sMVA : AState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      wf_AState(mva(mp))(sMVA) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_modeled?(mp)(sMVA, sAP) IMPLIES
      ts(mva(mp))(t) IMPLIES scp(t) = cp(sMVA) IMPLIES
        EXISTS (e : [ValOrExcpt -> Expr], v : Val, n : nat) : 
          guard_to_expression(mva(mp))(guard(t)) = e AND
          FORALL(arg : ValOrExcpt) :
          wf_Expr(ann_program(mp))(e(arg)) AND
          derive(ann_program(mp))(e(arg), sAP, v, sAP)(n) AND
          (guard(t)(stA(sMVA), st(pstate(sAP)), arg) = (v = Bool(TRUE)))

  % It is possible to evaluate expressions appearing in actions (they 
  % terminate) and they are side-effect-free. Note that the evaluation 
  % of the expresion can not throw an exception (provided it starts in 
  % a non-exceptional state).
  eval_action_behavior(mp) : boolean =
    FORALL (e : Expr, v : Val, sAP : APState, sMVA : AState) :
      wf_Expr(mva(mp))(e) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
      wf_AState(mva(mp))(sMVA) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      MVA_modeled?(mp)(sMVA, sAP) IMPLIES
        (eval(e)(stA(sMVA), st(pstate(sAP))) = v) =
        EXISTS (n : nat) : derive(ann_program(mp))(e, sAP, v, sAP)(n)

  actions_have_no_side_effects(mp) : boolean =
    FORALL (t : Transition, oa : OneAction) :
      ts(mva(mp))(t) IMPLIES
      member(oa, action(t)) IMPLIES
        FORALL (s1, s2 : APState, v : Val, n : nat) :
          wf_state(ann_program(mp))(s1) IMPLIES
          derive(ann_program(mp))(source(oa), s1, v, s2)(n) IMPLIES
            s1 = s2

  well_behaved_MVA(mp) : boolean =
    guard_to_expression_behavior(mp) AND
    eval_action_behavior(mp) AND
    actions_have_no_side_effects(mp)

  related_states(mp)(sMP : MPState, sAP : APState) : boolean = 
    wf_state(mp)(sMP) AND
    wf_state(ann_program(mp))(sAP) AND
    IF cp(astate(sMP)) = halted
    THEN up?(ex(pstate(sAP))) AND down(ex(pstate(sAP))) = JMLExc
    ELSE MP_modeled?(mp)(sMP, sAP)
    ENDIF


END Equivalence



RelatedStatesProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING Equivalence[CP, Name]

  mp : VAR (wf_and_complete_MP)


  get_address_same_in_related_states : LEMMA % :-)
    FORALL(vn : Name, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        get_address(vn, sMP) = get_address(vn, sAP)

  get_dynamic_type_name_same_in_related_states : LEMMA % :-)
    FORALL(vn : Name, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        get_dynamic_type_name(vn, sMP) = get_dynamic_type_name(vn, sAP)

  halted_implies_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES 
      cp(astate(sMP)) = halted IMPLIES
        up?(ex(pstate(sAP)))
  
  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(mp)(sMP, sAP) IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  related_states_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES 
      NOT cp(astate(sMP)) = halted IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  related_states_implies_same_lookup : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, n : Name) :
      related_states(mp)(sMP, sAP) IMPLIES 
      NOT cp(astate(sMP)) = halted IMPLIES
      ext_declared_var_names(program(mp))(n) IMPLIES
        lookup(n, sMP) = lookup(n, sAP)

  MP_modeled_preserved_by_update : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp)(sMP, sAP) IMPLIES
      (FORALL (pstate1, pstate2 : PState) : 
        (st(pstate1) = st(pstate2) IMPLIES st(upd(pstate1)) = st(upd(pstate2))))
      IMPLIES
      (FORALL (pstate : PState) : (ex(upd(pstate)) = ex(pstate))) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        MP_modeled?(mp)(update_PState(sMP, upd), update_PState(sAP, upd))

  related_states_preserved_by_update_local : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(vn : Name, v : (defined?)) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      is_local(vn, pstate(sMP)) IMPLIES
      is_local(vn, pstate(sAP)) IMPLIES
        related_states(mp)(update_PState(sMP, update_local(vn, v)), 
                           update_PState(sAP, update_local(vn, v)))

  related_states_preserved_by_catch : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        related_states(mp)(update_PState(sMP, catch), 
                           update_PState(sAP, catch))

  related_states_preserved_by_raise : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
      (cp(astate(sMP)) = halted IMPLIES JMLExc?(e)) IMPLIES
        related_states(mp)(update_PState(sMP, raise(e)), 
                           update_PState(sAP, raise(e)))

  related_states_preserved_by_update_stack : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState,
            this_val : Val, arg :  (getLocalDecls(program(mp))), 
            param_val : Val, lvds : finite_set[LocalVarDecl]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      (FORALL (l : LocalVarDecl) : lvds(l) IMPLIES 
                                   getLocalDecls(program(mp))(l)) IMPLIES
        related_states(mp)(update_stack(this_val, arg, param_val,
                                        lvds, sMP),
                           update_stack(this_val, arg, param_val,
                                        lvds, sAP))


  % NOTE: The use of equalities[Val] is needed for disambiaguation of =
  MP_modeled_lookup_correspondence : LEMMA % :-)
    FORALL (q1, q2 : CP, sMP : MPState, sAP : APState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      MP_modeled?(mp)(sMP, sAP) IMPLIES
      cps(mva(mp))(q1) IMPLIES
      cps(mva(mp))(q2) IMPLIES
      cp(astate(sMP)) = q1 IMPLIES
        (q1 = q2) =
        equalities[Val].=((Int(val2int(lookup(cp(mp), sAP))),
                           Int(val2int(lookup(name_of(mp)(q2), sAP)))))

  related_states_lookup_correspondence : LEMMA % :-)
    FORALL (q1, q2 : CP, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      cps(mva(mp))(q1) IMPLIES
      cps(mva(mp))(q2) IMPLIES
      cp(astate(sMP)) = q1 IMPLIES
        (q1 = q2) =
        equalities[Val].=((Int(val2int(lookup(cp(mp), sAP))),
                           Int(val2int(lookup(name_of(mp)(q2), sAP)))))


END RelatedStatesProperties
