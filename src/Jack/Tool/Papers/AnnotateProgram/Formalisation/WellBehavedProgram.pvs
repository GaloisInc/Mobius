WellBehavedProgram[Name : TYPE+,
          FullProgram : TYPE,
          FullState : TYPE,
          (IMPORTING WellFormedProgram[Name]) program : [FullProgram -> Program],
          (IMPORTING State[Name]) pstate : [FullState -> PState],
          lookup : [Name, FullState -> Val],
          (IMPORTING SemanticsTypes[Name, FullProgram, FullState, 
                                    program, pstate])
          update_PState : (update_PState_type),
          execute_set : (execute_set_type),
          execute_assert : (execute_assert_type),
          execute_CaseJML : (execute_CaseJML_type),
          on_method_entry : (on_method_event_type),
          on_method_exit_normal : (on_method_event_type),
          on_method_exit_exceptional : (on_method_event_type)] : THEORY
BEGIN

  IMPORTING Semantics[Name, FullProgram, FullState, program, pstate,
                      lookup, update_PState, execute_set, execute_assert,
                      execute_CaseJML, on_method_entry, 
                      on_method_exit_normal, on_method_exit_exceptional]

  % The following expression (that appear only in annotations) should have no
  % side-effects: invariants, preconditions, postconditions, source expression
  % of a set statement.
  well_behaved_Program(p : FullProgram) : boolean =
    FORALL (c : Class) : classes(program(p))(c) IMPLIES
      spec_expr_has_no_side_effects(p)(inv(c)) AND
      FORALL (m : Method) : methods(c)(m) IMPLIES
        spec_expr_has_no_side_effects(p)(pre(m)) AND
        spec_expr_has_no_side_effects(p)(post(m)) AND
        (FORALL (s : Stmt) : proper_subterm_set_clause(s, m) IMPLIES
          Set?(s) IMPLIES spec_expr_has_no_side_effects(p)(source(s)))

END WellBehavedProgram


WellBehavedProgramProperty[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

  IMPORTING MonitoredProgramSemantics[CP, Name]
  IMPORTING AnnotatedProgramSemantics[Name]

  % method call case not finished
  derive_MP_from_derive_AP : LEMMA
    FORALL(mp : MonitoredProgram, b : (wf_Body(program(mp))), v : Val)
          (sMP1 : MPState)(sAP1, sAP2 : APState)(n : nat) :
      pstate(sMP1) = pstate(sAP1) IMPLIES
      gvs(sMP1) = gvs(sAP1) IMPLIES
      derive(program(mp))(b, sAP1, v, sAP2)(n) IMPLIES
      EXISTS (sMP2 : MPState) :
        pstate(sMP2) = pstate(sAP2) AND
        gvs(sMP2) = gvs(sAP2) AND
        derive(mp)(b, sMP1, v, sMP2)(n)

  IMPORTING WellBehavedProgram[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  IMPORTING WellBehavedProgram[Name, MonitoredProgram, MPState, 
                      LAMBDA (mp : MonitoredProgram) : program(mp),
                      LAMBDA (s : MPState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry_MP,
                      on_method_exit_normal_MP,
                      on_method_exit_exceptional_MP]

  IMPORTING AnnotateProgramProperties[CP, Name]

  mp : VAR (wf_MP)

  % PROVE
  % unprovable for the moment
  % one problem: derive(mp)(inv) = derive(ann_program(mp))(inv)
  % should not depend on astate
  % TODO: See the proofs in AnnGenerationLemmas where it is used and try to do
  % without it (we need another lemma saying that the annotations we add have
  % no side-effect.
  ann_program_preserves_well_behaved_Program : LEMMA
    well_behaved_Program(mp) IMPLIES
      well_behaved_Program(ann_program(mp))


END WellBehavedProgramProperty
