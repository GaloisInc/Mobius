RelatedStateProperties[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING


  IMPORTING Equivalence[CP, Name]

  mp : VAR (wf_MP)

  get_address_same_in_related_states : LEMMA  % :-)
    FORALL(vn : Name, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
        get_address(vn, sMP) = get_address(vn, sAP)

  get_dynamic_type_name_same_in_related_states : LEMMA % :-)
    FORALL(vn : Name, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
        get_dynamic_type_name(vn, sMP) = get_dynamic_type_name(vn, sAP)
  
  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(mp)(sMP, sAP) IMPLIES
      up?(ex(pstate(sMP))) IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  related_states_implies_same_exception : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES 
      up?(ex(pstate(sMP))) IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  % TESTING
  MP_modeled_implies_same_exception2 : LEMMA
    FORALL (sMP : MPState, sAP : APState) :
      Program_modeled2?(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        ex(pstate(sMP)) = ex(pstate(sAP))

  related_states_implies_same_lookup : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, n : Name) :
      related_states(mp)(sMP, sAP) IMPLIES 
      ext_declared_var_names(program(mp))(n) IMPLIES
        lookup(n, sMP) = lookup(n, sAP)
       
  % If cp(astate(sMP)) = halted, upd must leave the JML exception in sAP
  MP_modeled_preserved_by_update : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        MP_modeled?(mp)(update_PState(sMP, upd), update_PState(sAP, upd))

  % If cp(astate(sMP)) = halted, upd must leave the JML exception in sAP
  halted_implies_JMLExc_preserved_by_update : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      NOT up?(ex(upd(pstate(sAP)))) IMPLIES
        halted_implies_JMLExc(mp)(update_PState(sMP, upd), 
                                  update_PState(sAP, upd))

  related_states_preserved_by_update_local : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState)(vn : Name, v : (defined?)) :
      related_states(mp)(sMP, sAP) IMPLIES
      is_local(vn, pstate(sMP)) IMPLIES
      is_local(vn, pstate(sAP)) IMPLIES
        related_states(mp)(update_PState(sMP, update_local(vn, v)), 
                           update_PState(sAP, update_local(vn, v)))

  MP_modeled_preserved_by_catch : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
        MP_modeled?(mp)(update_PState(sMP, catch), update_PState(sAP, catch))

  MP_modeled_preserved_by_raise : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
        MP_modeled?(mp)(update_PState(sMP, raise(e)), 
                        update_PState(sAP, raise(e)))

  halted_implies_JMLExc_preserved_by_catch : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      (up?(ex(pstate(sAP))) IMPLIES NOT down(ex(pstate(sAP))) = JMLExc) IMPLIES
        halted_implies_JMLExc(mp)(update_PState(sMP, catch), 
                                  update_PState(sAP, catch))

  halted_implies_JMLExc_preserved_by_catch2 : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        halted_implies_JMLExc(mp)(update_PState(sMP, catch), 
                                  update_PState(sAP, catch))

  halted_implies_JMLExc_preserved_by_raise : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        halted_implies_JMLExc(mp)(update_PState(sMP, raise(e)), 
                                  update_PState(sAP, raise(e)))

  halted_implies_JMLExc_preserved_by_raise2 : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      NOT e = JMLExc IMPLIES
        halted_implies_JMLExc(mp)(update_PState(sMP, raise(e)), 
                                  update_PState(sAP, raise(e)))

  related_states_preserved_by_catch : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      (up?(ex(pstate(sAP))) IMPLIES NOT down(ex(pstate(sAP))) = JMLExc) IMPLIES
        related_states(mp)(update_PState(sMP, catch), 
                           update_PState(sAP, catch))

  related_states_preserved_by_catch2 : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
        related_states(mp)(update_PState(sMP, catch), 
                           update_PState(sAP, catch))

  related_states_preserved_by_raise : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        related_states(mp)(update_PState(sMP, raise(e)), 
                           update_PState(sAP, raise(e)))

  related_states_preserved_by_raise2 : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState, e : Excpt) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT cp(astate(sMP)) = halted IMPLIES
      NOT e = JMLExc IMPLIES
        related_states(mp)(update_PState(sMP, raise(e)), 
                           update_PState(sAP, raise(e)))

  MP_modeled_lookup_correspondence : LEMMA % :-)
    FORALL (q1, q2 : CP, sMP : MPState, sAP : APState) :
      wf_state(ann_program(mp))(sAP) IMPLIES
      MP_modeled?(mp)(sMP, sAP) IMPLIES
      cps(mva(mp))(q1) IMPLIES
      cps(mva(mp))(q2) IMPLIES
      cp(astate(sMP)) = q1 IMPLIES
        (q1 = q2) =
        (val2int(lookup(cp(mp), sAP)) = val2int(lookup(name_of(mp)(q2), sAP)))

  related_states_lookup_correspondence : LEMMA % :-)
    FORALL (q1, q2 : CP, sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      cps(mva(mp))(q1) IMPLIES
      cps(mva(mp))(q2) IMPLIES
      cp(astate(sMP)) = q1 IMPLIES
        (q1 = q2) =
        (val2int(lookup(cp(mp), sAP)) = val2int(lookup(name_of(mp)(q2), sAP)))

  % TODO: use MP_modeled_lookup_correspondence instead of these lemmas
%   MP_modeled_implies_cp_halted_correspondence : LEMMA % :-)
%     FORALL (sMP : MPState, sAP : APState) :
%       wf_state(ann_program(mp))(sAP) IMPLIES
%       MP_modeled?(mp)(sMP, sAP) IMPLIES
%       (cp(astate(sMP)) = halted) = 
%       (lookup(cp(mp), sAP) = lookup(halted(mp), sAP))

%   related_states_implies_cp_halted_correspondence : LEMMA % :-)
%     FORALL (sMP : MPState, sAP : APState) :
%       related_states(mp)(sMP, sAP) IMPLIES
%       (cp(astate(sMP)) = halted) =
%       (lookup(cp(mp), sAP) = lookup(halted(mp), sAP))

  MP_modeled_implies_cp_Int : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(mp)(sMP, sAP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
      Int?(lookup(cp(mp), sAP))

  MP_modeled_implies_halted_Int : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      MP_modeled?(mp)(sMP, sAP) IMPLIES
      wf_state(ann_program(mp))(sAP) IMPLIES
      Int?(lookup(halted(mp), sAP))

  related_states_implies_cp_Int : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      Int?(lookup(cp(mp), sAP))

  related_states_implies_halted_Int : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES
      Int?(lookup(halted(mp), sAP))

  related_states_preserved_by_update_stack : LEMMA % :-)
    FORALL (sMP : MPState, sAP : APState,
            this_val : Val, arg :  (getLocalDecls(program(mp))), 
            param_val : Val, lvds : finite_set[LocalVarDecl]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
      (FORALL (l : LocalVarDecl) : lvds(l) IMPLIES 
                                   getLocalDecls(program(mp))(l)) IMPLIES
        related_states(mp)(update_stack(this_val, arg, param_val,
                                        lvds, sMP),
                           update_stack(this_val, arg, param_val,
                                        lvds, sAP))


END RelatedStateProperties


AnnEventPreservesMPModeled[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING


  IMPORTING RelatedStateProperties[CP, Name],
            APSemanticsProperties,
            listfuncs

  mp : VAR (wf_MP)

  % Eexecuting an action on a MVA modifies its variables in the same way that
  % the execution of the annotations representing that action modifies the 
  % corresponding ghost variables in the annotated program.
  % NOTE: We need a quantification over a to be able to apply induction.
  ann_action_preserves_MP_modeled : LEMMA % :-)
    FORALL (t : Transition, a : Action, n : nat)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA(mp) IMPLIES
      wf_state(mp)(sMP1) IMPLIES
      wf_state(ann_program(mp))(sAP1) IMPLIES
      MP_modeled?(mp)(sMP1, sAP1) IMPLIES
      a = action(t) IMPLIES
      wf_Action(mva(mp))(a) IMPLIES
      (EXISTS (t1 : Transition) : 
         ts(mva(mp))(t1) AND suffix(action(t), action(t1))) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))(ann_action(a), sAP1, Unit, sAP2)(n) IMPLIES
      sMP2 = (# astate := (# cp := cp(astate(sMP1)),
                             stA := execute_action(a)(stA(astate(sMP1)),
                                                          st(pstate(sMP1)))
                           #),
                pstate := pstate(sMP1),
                gvs := gvs(sMP1) #) IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

 % If sMP1 and sAP1 are related states and for a given transition t, sMVA is the
 % state of the automaton after performing t and sAP2 is the state of the 
 % annotated program after executing the annotations that model the effect of t, 
 % then sMVA is still well modeled by sAP2.
  update_vars_preserves_MP_modeled : LEMMA
    FORALL (t : Transition, n : nat)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      ts(mva(mp))(t) IMPLIES
      sMP2 = (# astate := (# cp := tcp(t),
                             stA := execute_action(action(t))(stA(astate(sMP1)),
                                                              st(pstate(sMP1)))
                           #),
                pstate := pstate(sMP1),
                gvs := gvs(sMP1) #) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))(update_vars(mp)(t), sAP1, Unit, sAP2)(n) IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

  % If sMP1 and sAP1 are related stated, sMP2 is the state of the monitored
  % progran after evaluating on_method_MVA with some event type et and some
  % method m, ts is the set of transitions that has (et, name(m)) as event and
  % sAP2 is the state of the annotated program after the execution of ann_event
  % with ts as argument, then sMP2 and sAP2 comply with MP_modeled?.
  ann_event_preserves_MP_modeled : LEMMA % :-)
    FORALL (m : (wf_Method(program(mp))), et : EventType,  n : nat)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      methods(get_monitored_class(mp))(m) IMPLIES
      sMP2 = (# astate := on_method_MVA(et)(mp, m)(sMP1),
                pstate := pstate(sMP1),
                gvs := gvs(sMP1) #) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      derive(ann_program(mp))(ann_event(mp)(filter_event(mva(mp))(et)(name(m))),
                              sAP1, Unit, sAP2)(n) IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)


END AnnEventPreservesMPModeled


MethodCallsPreserveRelatedState[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING


  IMPORTING AnnEventPreservesMPModeled[CP, Name]

  mp : VAR (wf_MP)

  on_method_entry_preserves_related_states_annotated : LEMMA % :-)
    FORALL(mn : Name, md : (wf_Method(program(mp))), a : (defined?), 
           m1, m2 : nat, sMP1, sMP2 : MPState, sAP1, sAP2 : APState) :
      well_behaved_MVA(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      up?(get_class(program(mp))(a)) IMPLIES
      name(down(get_class(program(mp))(a))) = class_name(mva(mp)) IMPLIES
      up?(lookup_mthd(program(mp), a, mn)) IMPLIES
      down(lookup_mthd(program(mp), a, mn)) = md IMPLIES
      (FORALL(b : (wf_Body(program(mp))), v1, v2 : Val)
             (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
             (n1 : below(m1), n2 : below(m2)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
          related_states(mp)(sMP2, sAP2) AND v1 = v2) IMPLIES
      on_method_entry_MP(mp, md, a, sMP1, sMP2, m1,
                         LAMBDA (k: upto(m1))(p: MonitoredProgram)
                                (b: (wf_Body(program(p))), sigma1: MPState,
                                 v: Val, sigma2: MPState)(m: below(k)):
                           derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
      on_method_entry(ann_program(mp), ann_method(mp)(md), a, sAP1, sAP2, m2,
                      LAMBDA (k: upto(m2))(p: Program)
                             (b: (wf_Body(p)), sigma1: APState,
                              v: Val, sigma2: APState)(m: below(k)):
                        derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        related_states(mp)(sMP2, sAP2)

  on_method_entry_preserves_related_states_not_annotated : LEMMA % :-)
    FORALL(mn : Name, md : (wf_Method(program(mp))), a : (defined?), 
           m1, m2 : nat, sMP1, sMP2 : MPState, sAP1, sAP2 : APState) : 
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      up?(get_class[Name](program(mp))(a)) IMPLIES
      NOT name(down(get_class(program(mp))(a))) = class_name(mva(mp)) IMPLIES
      up?(lookup_mthd(program(mp), a, mn)) IMPLIES
      down(lookup_mthd(program(mp), a, mn)) = md IMPLIES
      (FORALL(b : (wf_Body(program(mp))), v1, v2 : Val)
             (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
             (n1 : below(m1), n2 : below(m2)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
          related_states(mp)(sMP2, sAP2) AND v1 = v2) IMPLIES
      on_method_entry_MP(mp, md, a, sMP1, sMP2, m1,
                         LAMBDA (k: upto(m1))(p: MonitoredProgram)
                                (b: (wf_Body(program(p))), sigma1: MPState,
                                 v: Val, sigma2: MPState)(m: below(k)):
                           derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
      on_method_entry(ann_program(mp), md, a, sAP1, sAP2, m2,
                      LAMBDA (k: upto(m2))(p: Program)
                             (b: (wf_Body(p)), sigma1: APState,
                              v: Val, sigma2: APState)(m: below(k)):
                        derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        related_states(mp)(sMP2, sAP2)

  on_method_exit_normal_preserves_related_states_annotated : LEMMA
    FORALL(mn : Name, md : (wf_Method(program(mp))), a : (defined?), m1, m2 : nat,
           sMP1, sMP2 : MPState, sAP1, sAP2 : APState) : 
      well_behaved_MVA(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      up?(get_class[Name](program(mp))(a)) IMPLIES
      name(down(get_class(program(mp))(a))) = class_name(mva(mp)) IMPLIES
      up?(lookup_mthd(program(mp), a, mn)) IMPLIES
      down(lookup_mthd(program(mp), a, mn)) = md IMPLIES
      (FORALL(b : (wf_Body(program(mp))), v1, v2 : Val)
             (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
             (n1 : below(m1), n2 : below(m2)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
          related_states(mp)(sMP2, sAP2) AND v1 = v2) IMPLIES
      on_method_exit_normal_MP(mp, md, a, sMP1, sMP2, m1,
                         LAMBDA (k: upto(m1))(p: MonitoredProgram)
                                (b: (wf_Body(program(p))), sigma1: MPState,
                                 v: Val, sigma2: MPState)(m: below(k)):
                           derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
      on_method_exit_normal(ann_program(mp), ann_method(mp)(md), 
                            a, sAP1, sAP2, m2,
                      LAMBDA (k: upto(m2))(p: Program)
                             (b: (wf_Body(p)), sigma1: APState,
                              v: Val, sigma2: APState)(m: below(k)):
                        derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        related_states(mp)(sMP2, sAP2)

  on_method_exit_normal_preserves_related_states_not_annotated : LEMMA % :-)
    FORALL(mn : Name, md : (wf_Method(program(mp))), a : (defined?), m1, m2 : nat,
           sMP1, sMP2 : MPState, sAP1, sAP2 : APState) : 
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT up?(ex(pstate(sAP1))) IMPLIES
      up?(get_class[Name](program(mp))(a)) IMPLIES
      NOT name(down(get_class(program(mp))(a))) = class_name(mva(mp)) IMPLIES
      up?(lookup_mthd(program(mp), a, mn)) IMPLIES
      down(lookup_mthd(program(mp), a, mn)) = md IMPLIES
      (FORALL(b : (wf_Body(program(mp))), v1, v2 : Val)
             (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
             (n1 : below(m1), n2 : below(m2)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
          related_states(mp)(sMP2, sAP2) AND v1 = v2) IMPLIES
      on_method_exit_normal_MP(mp, md, a, sMP1, sMP2, m1,
                         LAMBDA (k: upto(m1))(p: MonitoredProgram)
                                (b: (wf_Body(program(p))), sigma1: MPState,
                                 v: Val, sigma2: MPState)(m: below(k)):
                           derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
      on_method_exit_normal(ann_program(mp), md, a, sAP1, sAP2, m2,
                      LAMBDA (k: upto(m2))(p: Program)
                             (b: (wf_Body(p)), sigma1: APState,
                              v: Val, sigma2: APState)(m: below(k)):
                        derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        related_states(mp)(sMP2, sAP2)

  on_method_exit_exceptional_preserves_related_states_annotated : LEMMA
    FORALL(mn : Name, md : (wf_Method(program(mp))), a : (defined?), m1, m2 : nat,
           sMP1, sMP2 : MPState, sAP1, sAP2 : APState) : 
      well_behaved_MVA(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      up?(ex(pstate(sAP1))) IMPLIES
      up?(get_class[Name](program(mp))(a)) IMPLIES
      name(down(get_class(program(mp))(a))) = class_name(mva(mp)) IMPLIES
      up?(lookup_mthd(program(mp), a, mn)) IMPLIES
      down(lookup_mthd(program(mp), a, mn)) = md IMPLIES
      (FORALL(b : (wf_Body(program(mp))), v1, v2 : Val)
             (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
             (n1 : below(m1), n2 : below(m2)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
          related_states(mp)(sMP2, sAP2) AND v1 = v2) IMPLIES
      on_method_exit_exceptional_MP(mp, md, a, sMP1, sMP2, m1,
                         LAMBDA (k: upto(m1))(p: MonitoredProgram)
                                (b: (wf_Body(program(p))), sigma1: MPState,
                                 v: Val, sigma2: MPState)(m: below(k)):
                           derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
      on_method_exit_exceptional(ann_program(mp), ann_method(mp)(md), 
                                  a, sAP1, sAP2, m2,
                      LAMBDA (k: upto(m2))(p: Program)
                             (b: (wf_Body(p)), sigma1: APState,
                              v: Val, sigma2: APState)(m: below(k)):
                        derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        related_states(mp)(sMP2, sAP2)

  on_method_exit_exceptional_preserves_related_states_not_annotated : LEMMA % :-)
    FORALL(mn : Name, md : (wf_Method(program(mp))), a : (defined?), m1, m2 : nat,
           sMP1, sMP2 : MPState, sAP1, sAP2 : APState) : 
      related_states(mp)(sMP1, sAP1) IMPLIES
      up?(ex(pstate(sAP1))) IMPLIES
      up?(get_class[Name](program(mp))(a)) IMPLIES
      NOT name(down(get_class(program(mp))(a))) = class_name(mva(mp)) IMPLIES
      up?(lookup_mthd(program(mp), a, mn)) IMPLIES
      down(lookup_mthd(program(mp), a, mn)) = md IMPLIES
      (FORALL(b : (wf_Body(program(mp))), v1, v2 : Val)
             (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
             (n1 : below(m1), n2 : below(m2)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
          related_states(mp)(sMP2, sAP2) AND v1 = v2) IMPLIES
      on_method_exit_exceptional_MP(mp, md, a, sMP1, sMP2, m1,
                         LAMBDA (k: upto(m1))(p: MonitoredProgram)
                                (b: (wf_Body(program(p))), sigma1: MPState,
                                 v: Val, sigma2: MPState)(m: below(k)):
                           derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
      on_method_exit_exceptional(ann_program(mp), md, a, sAP1, sAP2, m2,
                      LAMBDA (k: upto(m2))(p: Program)
                             (b: (wf_Body(p)), sigma1: APState,
                              v: Val, sigma2: APState)(m: below(k)):
                        derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        related_states(mp)(sMP2, sAP2)


END MethodCallsPreserveRelatedState


CorrectnessAnnProgram[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING


  mp : VAR (wf_MP)

  IMPORTING MethodCallsPreserveRelatedState[CP, Name]

  % Base case
  initial_states_are_equivalent : LEMMA % :-)
    FORALL (root_object : (defined?)) :
      related_states(mp)(initial_MP_state(mp)(root_object),
                         initial_AP_state(ann_program(mp))(root_object))

  % Inductive case
  % TODO: all cases proven, except try catch
  derive_maintains_related_states_for_unchanged_program : THEOREM
    FORALL (b : (wf_Body(program(mp))), v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      well_behaved_MVA(mp) IMPLIES
      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
        related_states(mp)(sMP2, sAP2) AND v1 = v2

  % The main result
  correctness_of_ann_program : THEOREM % :-)
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (sMP : MPState, sAP : APState) :
      well_behaved_MVA(mp) IMPLIES
      run_monitored_program(mp)(main, arg)(root_object)(sMP) IMPLIES
      run_annotated_program(ann_program(mp))
                               (main, arg)(root_object)(sAP) IMPLIES
        related_states(mp)(sMP, sAP)


END CorrectnessAnnProgram
