CorrectnessAnnProgram[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_MP)) : 
          injective?(f(mp))

  ENDASSUMING

%  IMPORTING AnnGenerationLemmas[CP, Name]
  IMPORTING Equivalence[CP, Name],
            APSemanticsProperties,
            listfuncs

  mp : VAR (wf_MP)

  % Properties about MP_modeled?

  MP_modeled_implies_same_exception : LEMMA % :-)
    FORALL (mp)(sMP : MPState, sAP : APState) :
      MP_modeled?(mp)(sMP, sAP) IMPLIES ex(pstate(sMP)) = ex(pstate(sAP))

  related_states_implies_same_exception : LEMMA % :-)
    FORALL (mp)(sMP : MPState, sAP : APState) :
      related_states(mp)(sMP, sAP) IMPLIES ex(pstate(sMP)) = ex(pstate(sAP))

  related_states_implies_same_lookup : LEMMA % :-)
    FORALL(mp)(sMP : MPState, sAP : APState, n : Name) :
      related_states(mp)(sMP, sAP) IMPLIES 
      declared_var_names(program(mp))(n) IMPLIES
        lookup(n, sMP) = lookup(n, sAP)
       
  % If cp(astate(sMP)) = halted, upd must leave the JML exception in sAP
  MP_modeled_preserved_by_update : LEMMA % :-)
    FORALL (mp)(sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        MP_modeled?(mp)(update_PState(sMP, upd), update_PState(sAP, upd))

  % If cp(astate(sMP)) = halted, upd must leave the JML exception in sAP
  halted_implies_JMLExc_preserved_by_update : LEMMA % :-)
    FORALL (mp)(sMP : MPState, sAP : APState)(upd : [PState -> PState]) :
      related_states(mp)(sMP, sAP) IMPLIES
      NOT up?(ex(pstate(sAP))) IMPLIES
        halted_implies_JMLExc(update_PState(sMP, upd), update_PState(sAP, upd))


  % PROVE! This can be long. We have to show that the expressions and
  % statements of the mp are not modified, only new exprs and stmts are
  % added and they do not interfere with the others.
%  MP_modeled_implies_same_num_eval : LEMMA % :-)
%    FORALL (mp, ap : Program)
%           (sMP : MPState, sAP : APState)(n : NumExpr) :
%      related_states(mp, ap)(sMP, sAP) IMPLIES
%      (VarEval?(n) IMPLIES declared_var_names(program(mp))(varname(n))) IMPLIES
%          eval(n)(sMP) = eval(n)(sAP)

%  MP_modeled_implies_same_bool_eval : LEMMA % :-)
%    FORALL (mp, ap : Program)
%           (sMP : MPState, sAP : APState)(b : BoolExpr) :
%      related_states(mp, ap)(sMP, sAP) IMPLIES
%        eval(b)(sMP) = eval(b)(sAP)

 
  % TODO: To get that v1 = v2, I need to do an induction over the lenght of the
  % derivation
  MP_modeled_preserved_by_assertion_checking : LEMMA
    FORALL (mp)(sMP1, sMP2 : MPState, sAP1, sAP2 : APState, 
                assertion : Expr, n1, n2 : posnat) :
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT up?(ex(pstate(sMP1))) IMPLIES
%      (FORALL (v1, v2 : Val, tau1 : MPState, tau2 : APState) :
%        (derive_rec(n1)(mp)(assertion, sMP1, v1, tau1)(n1 - 1) 
%          IMPLIES sMP1 = tau1) AND
%        (derive_rec(n2)(ann_program(mp))(assertion, sAP1, v1, tau2)(n2 - 1)
%          IMPLIES sAP1 = tau2) AND
%        v1 = v2) IMPLIES
%      check_assertion(mp)(assertion, sMP1, sMP2)(n1)(derive_rec(n1))
%      IMPLIES
%      check_assertion(ann_program(ap))
%                     (assertion, sAP1, sAP2)(n2)(derive_rec(n2))
%      IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

  % THINK: The invariant (retrieved by lookup_inv) in the annotated class should
  % include the added check cp != halted
  on_method_entry_for_ann_method_equivalence  : LEMMA
    FORALL (mp)(sMP1, sMP2 : MPState, sAP1, sAP2 : APState, c : Class, 
            m1, m2 : Method, a : Val, n1, n2 : posnat) :
      related_states(mp)(sMP1, sAP1) IMPLIES
      classes(program(mp))(c) IMPLIES
      methods(c)(m1) IMPLIES
      m2 = ann_method(mp)(m1) IMPLIES
%      on_method_entry_MP(mp, m1, a, sMP1, sMP2, n1, bounded_derive_rec(n1))
%        IMPLIES
%      on_method_entry_AP(ap, m2, a, sAP1, sAP2, n2, bounded_derive_rec(n2))
%        IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)

  on_method_entry_for_same_method_equivalence  : LEMMA
    FORALL (mp)(sMP1, sMP2 : MPState, sAP1, sAP2 : APState, m : Method,
            a : Val, n1, n2 : nat) :
      related_states(mp)(sMP1, sAP1) IMPLIES
%      on_method_entry_MP(mp, m1, a, sMP1, sMP2, n1, bounded_derive_rec(n1))
%        IMPLIES
%      on_method_entry_AP(ap, m2, a, sAP1, sAP2, n2, bounded_derive_rec(n2))
%        IMPLIES
        MP_modeled?(mp)(sMP2, sAP2)


  % Main lemmas used in the proof of the correcteness_of_ann_program

  initial_states_are_equivalent : LEMMA % :-)
    FORALL (mp)(root_object : (defined?)) :
        related_states(mp)(initial_MP_state(mp)(root_object),
                           initial_AP_state(ann_program(mp))(root_object))


  derive_maintains_MP_modeled? : THEOREM
    FORALL (mp)(b : Body, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      wf_state(mp)(sMP1) IMPLIES
      wf_state(ann_program(mp))(sAP1) IMPLIES
      well_behaved_MP(mp) IMPLIES
      MP_modeled?(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
        wf_state(mp)(sMP2) AND
        wf_state(ann_program(mp))(sAP2) AND
        MP_modeled?(mp)(sMP2, sAP2)


  derive_maintains_related_states_for_unchanged_program : THEOREM
    FORALL (mp)(b : Body, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      well_behaved_MP(mp) IMPLIES
      subset?(var_names(b), declared_var_names(program(mp))) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
        related_states(mp)(sMP2, sAP2) AND v1 = v2

  derive_maintains_related_states : THEOREM
    FORALL (mp)(b : Body, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      well_behaved_MP(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
        related_states(mp)(sMP2, sAP2) AND v1 = v2


  derive_maintains_same_value : THEOREM % not strictly necessary
    FORALL (mp)(b : Body, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      wf_state(mp)(sMP1) IMPLIES
      wf_state(ann_program(mp))(sAP1) IMPLIES
      well_behaved_MP(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
        v1 = v2

  derive_maintains_halted_equivalence : THEOREM
    FORALL (mp)(b : Body, v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      wf_state(mp)(sMP1) IMPLIES
      wf_state(ann_program(mp))(sAP1) IMPLIES
      well_behaved_MP(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
        halted_implies_JMLExc(sMP2, sAP2)

%  deriv_expr_maintains_equivalence : THEOREM
%    FORALL (mp, ap : Program)
%           (e : Expr, v1, v2 : Val)
%           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
%           (n1, n2 : nat) :
%      related_states(mp, ap)(sMP1, sAP1) IMPLIES
%      deriv_expr(mp)(e, sMP1, v1, sMP2)(n1) IMPLIES
%      deriv_expr(ap)(e, sAP1, v2, sAP2)(n2) IMPLIES
%        v1 = v2 AND MP_modeled?(mp)(sMP2, sAP2)

%  deriv_stmt_maintains_equivalence : THEOREM
%    FORALL (mp, ap : Program)(c : Stmt)
%           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)(n1, n2 : nat) :
%      related_states(mp, ap)(sMP1, sAP1) IMPLIES
%      deriv_stmt(mp)(c, sMP1, sMP2)(n1) IMPLIES
%      deriv_stmt(ap)(c, sAP1, sAP2)(n2) IMPLIES
%        MP_modeled?(mp)(sMP2, sAP2)

  % The main result
  correctness_of_ann_program : THEOREM % :-)
    FORALL (mp)(main : Method, arg : int)
           (root_object : (defined?))
           (sMP : MPState, sAP : APState) :
      well_behaved_MP(mp) IMPLIES
      run_monitored_program(mp)(main, arg)(root_object)(sMP) IMPLIES
      run_annotated_program(ann_program(mp))(main, arg)(root_object)(sAP)
      IMPLIES
        related_states(mp)(sMP, sAP)

END CorrectnessAnnProgram
