set2list[T : TYPE] : THEORY
BEGIN

  set2list(s : finite_set[T]) : RECURSIVE list[T] =
    IF empty?(s)
    THEN null
    ELSE LET x = choose(s), xs = remove(x, s) IN
      cons(x, set2list(xs))
    ENDIF
    MEASURE
      Card(s)

  %CONVERSION set2list

  IMPORTING FiniteSetInduction[T]

  set2list_same_elements : LEMMA % :-)
    FORALL (s : finite_set[T], x : T) :
      member(x, s) IFF member(x, set2list(s))

  % NOT USED
  set_list_set: LEMMA % :-)
    FORALL (s : finite_set[T]) : list2set(set2list(s)) = s


END set2list


listfuncs[T : TYPE] : THEORY
BEGIN

  before(a, b : T, l : list[T]) : RECURSIVE boolean =
    CASES l OF
      null : FALSE,
      cons(x, xs) : IF x = b  % NOT before(a, a, xs)
                    THEN FALSE
                    ELSIF x = a
                    THEN TRUE
                    ELSE before(a, b, xs)
                    ENDIF
    ENDCASES
    MEASURE
      length(l)

  every_is_forall : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      every(p)(l) IFF FORALL (x : T) : member(x, l) IMPLIES p(x)

  some_is_exists : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      some(p)(l) IFF EXISTS (x : T) : member(x, l) AND p(x)

  list_is_null_or_cons : LEMMA % :-)
    FORALL (xs : list[T]) :
      xs = null OR EXISTS (y : T, ys : list[T]) : xs = cons(y, ys)


END listfuncs

FunProp : THEORY
BEGIN

  nat2string(n : nat) : RECURSIVE list[char] =
    IF n = 0
    THEN null
    ELSE cons(char(0), nat2string(n - 1))
    ENDIF
  MEASURE n


  nat2string_injective : LEMMA % :-)
    injective?(nat2string)

  list2finseq_injective : LEMMA % :-)
    injective?[list[char], string](list2finseq)

  nat2string_injective_function_exists : LEMMA % :-)
    EXISTS (f : [nat -> string]) : injective?(f)


END FunProp
