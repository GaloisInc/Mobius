set2list[T : TYPE] : THEORY
BEGIN

  set2list(s : finite_set[T]) : RECURSIVE list[T] =
    IF empty?(s)
    THEN null
    ELSE LET x = choose(s), xs = remove(x, s) IN
      cons(x, set2list(xs))
    ENDIF
    MEASURE
      Card(s)

  %CONVERSION set2list

  excluded_middle : LEMMA % :-)
    FORALL (b : boolean) : b OR NOT b

  incredibly_stupid_property : LEMMA % :-)
    FORALL (s : set[T], y : T) :
      {x : T | x = y OR NOT x = y} = {x : T | TRUE}

  % proved using incredibly_stupid_property, NOT USED
  stupid_property_of_choose : LEMMA % :-)
    FORALL (s : (nonempty?[T])) :
      {x : T | x = choose(s) OR NOT x = choose(s)} = {x : T | TRUE}

  epsilon_membership : LEMMA % :-) (USED)
    FORALL (s : (nonempty?[T])) : s(epsilon(s))

  % NOT USED
  add_remove_choose_equivalence : LEMMA % :-)
    FORALL (s : (nonempty?[T])) :
      add(choose(s), remove(choose(s), s)) = s

  % NOT USED
  add_remove_equivalence : LEMMA % :-)
    FORALL (s : set[T], x : T) :
      s(x) IMPLIES add(x, remove(x, s)) = s

  IMPORTING FiniteSetInduction[T]

  set2list_same_elements : LEMMA % :-)
    FORALL (s : finite_set[T], x : T) :
      member(x, s) IFF member(x, set2list(s))

  not_in_s_implies_not_in_set2list : LEMMA % :-)
    FORALL (s : finite_set[T], x : T) :
      NOT s(x) IMPLIES NOT member(x, set2list(s))


  not_removed_set2list : LEMMA % :-)
    FORALL (s : finite_set[T], x, y : T) :
      s(x) IMPLIES
      NOT x = y IMPLIES
        member(x, set2list(remove(y, s)))

  set_list_set: LEMMA % :-)
    FORALL (s : finite_set[T]) : list2set(set2list(s)) = s


  remove_list2set_set2list : LEMMA % :-)
    FORALL (s : finite_set[T], x : T) :
      list2set(set2list(remove(x, s))) = remove(x, list2set(set2list(s)))


END set2list


listfuncs[T : TYPE] : THEORY
BEGIN

  before(a, b : T, l : list[T]) : RECURSIVE boolean =
    CASES l OF
      null : FALSE,
      cons(x, xs) : IF x = b  % NOT before(a, a, xs)
                    THEN FALSE
                    ELSIF x = a
                    THEN TRUE
                    ELSE before(a, b, xs)
                    ENDIF
    ENDCASES
    MEASURE
      length(l)

  every_is_forall : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      every(p)(l) IFF FORALL (x : T) : member(x, l) IMPLIES p(x)

  some_is_exists : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      some(p)(l) IFF EXISTS (x : T) : member(x, l) AND p(x)

  list_is_null_or_cons : LEMMA % :-)
    FORALL (xs : list[T]) :
      xs = null OR EXISTS (y : T, ys : list[T]) : xs = cons(y, ys)

END listfuncs

FunProp : THEORY
BEGIN

  nat2string(n : nat) : RECURSIVE list[char] =
    IF n = 0
    THEN null
    ELSE cons(char(0), nat2string(n - 1))
    ENDIF
  MEASURE n


  nat2string_injective : LEMMA % :-)
    injective?(nat2string)

  list2finseq_injective : LEMMA % :-)
    injective?[list[char], string](list2finseq)


  nat2string_injective_function_exists : LEMMA % :-)
    EXISTS (f : [nat -> string]) : injective?(f)


END FunProp
