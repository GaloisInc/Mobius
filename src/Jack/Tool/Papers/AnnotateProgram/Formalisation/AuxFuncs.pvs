% Some general auxiliary functions on finite sets, lists and sets

% set2list: transform a finite set into a list
set2list[T : TYPE] : THEORY
BEGIN

  set2list(s : finite_set[T]) : RECURSIVE list[T] =
    IF empty?(s)
    THEN null
    ELSE LET x = choose(s), xs = remove(x, s) IN
         cons(x, set2list(xs))
    ENDIF
    MEASURE
      Card(s)

  IMPORTING WF_Card[T]

  % elements preserved by set2list
  set2list_same_elements : LEMMA % :-)
    FORALL (s : finite_set[T], x : T) :
      member(x, s) IFF member(x, set2list(s))

  % list2set is left inverse of set2list
  set_list_set: LEMMA % :-)
    FORALL (s : finite_set[T]) : list2set(set2list(s)) = s

  
END set2list


% some advanced list functions
listfuncs[T : TYPE] : THEORY
BEGIN

  % does a occur strictly before b in list?
  before(a, b : T, l : list[T]) : RECURSIVE boolean =
    CASES l OF
      null : FALSE,
      cons(x, xs) : IF x = b  % NOT before(a, a, xs)
                    THEN FALSE
                    ELSIF x = a
                    THEN TRUE
                    ELSE before(a, b, xs)
                    ENDIF
    ENDCASES
    MEASURE
      length(l)

  % before(a, b, l) can only hold if a is not b
  before_distinct : LEMMA % :-)
    FORALL (a, b : T, l : list[T]) :
      before(a, b, l) IMPLIES NOT a = b

  % before(a, b, l) can only hold if a is a member of l
  before_member : LEMMA % :-)
    FORALL (a, b : T, l : list[T]) :
      before(a, b, l) IMPLIES member(a, l)

  % is l1 a suffix list of l2?
  suffix(l1, l2 : list[T]) : boolean =
    EXISTS (l3 : list[T]) : append(l3, l1) = l2

  % suffix is reflexive
  suffix_reflexive : LEMMA % :-)
    FORALL (l : list[T]) : suffix(l, l)

  % if x is member of l1, it is also a member of append(l2, l1)
  append_member : LEMMA % :-)
    FORALL (x : T, l1, l2 : list[T]) :
      member(x, l1) IMPLIES
        member(x, append(l2, l1))

  % every(p)(l) holds IFF p holds for all members of the list
  every_is_forall : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      every(p)(l) = FORALL (x : T) : member(x, l) IMPLIES p(x)

  % some(p)(l) holds IFF there is a member of the list for which p holds
  some_is_exists : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      some(p)(l) = EXISTS (x : T) : member(x, l) AND p(x)

  % case distinction on lists
  list_is_null_or_cons : LEMMA % :-)
    FORALL (xs : list[T]) :
      xs = null OR EXISTS (y : T, ys : list[T]) : xs = cons(y, ys)

END listfuncs


% sum of elements in list of natural numbers
listsum : THEORY
BEGIN

  sum(l : list[nat]) : RECURSIVE nat =
    IF null?(l)
    THEN 0
    ELSE car(l) + sum(cdr(l))
    ENDIF
  MEASURE length(l)

  % sum is always larger than any of its elements (since all elements
  % are positive)
  sum_geq_than_elements : LEMMA % :-)
    FORALL(l : list[nat], x : nat) :
      member(x, l) IMPLIES
        sum(l) >= x


END listsum


% lemmas about map
list_map_funcs[T1, T2 : TYPE] : THEORY
BEGIN

  % if x member of xs, then f(x) member of map(f)(xs)
  list_map_member : LEMMA % :-)
    FORALL(xs : list[T1], x : T1, f : [T1 -> T2]) :
      member(x, xs) IMPLIES member(f(x), map(f)(xs))


END list_map_funcs


% lemmas about (arbitrary) sets
SetProp [A : TYPE] : THEORY
BEGIN

  % test for disjoint? is commutative
  disjoint?_commutative : LEMMA % :-)
    FORALL(S1, S2 : set[A]) :
      disjoint?(S1, S2) = disjoint?(S2, S1)

  % S1 disjoint from union of S2 and S3, if S1 disjoint from S2 and 
  % disjoint from S3
  disjoint?_union : LEMMA % :-)
    FORALL(S1, S2, S3 : set[A]) :
      disjoint?(S1, union(S2, S3)) =
        (disjoint?(S1, S2) AND disjoint?(S1, S3))

END SetProp
