set2list[T : TYPE] : THEORY
BEGIN

  set2list(s : finite_set[T]) : RECURSIVE list[T] =
    IF empty?(s)
    THEN null
    ELSE LET x = choose(s), xs = remove(x, s) IN
         cons(x, set2list(xs))
    ENDIF
    MEASURE
      Card(s)

  %CONVERSION set2list

  IMPORTING FiniteSetInduction[T]

  set2list_same_elements : LEMMA % :-)
    FORALL (s : finite_set[T], x : T) :
      member(x, s) IFF member(x, set2list(s))

  % NOT USED
  set_list_set: LEMMA % :-)
    FORALL (s : finite_set[T]) : list2set(set2list(s)) = s


END set2list


listfuncs[T : TYPE] : THEORY
BEGIN

  before(a, b : T, l : list[T]) : RECURSIVE boolean =
    CASES l OF
      null : FALSE,
      cons(x, xs) : IF x = b  % NOT before(a, a, xs)
                    THEN FALSE
                    ELSIF x = a
                    THEN TRUE
                    ELSE before(a, b, xs)
                    ENDIF
    ENDCASES
    MEASURE
      length(l)

  before_distinct : LEMMA % :-)
    FORALL (a, b : T, l : list[T]) :
      before(a, b, l) IMPLIES NOT a = b

  every_is_forall : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      every(p)(l) = FORALL (x : T) : member(x, l) IMPLIES p(x)

  some_is_exists : LEMMA % :-)
    FORALL (p : pred[T], l : list[T]) : 
      some(p)(l) = EXISTS (x : T) : member(x, l) AND p(x)

  list_is_null_or_cons : LEMMA % :-)
    FORALL (xs : list[T]) :
      xs = null OR EXISTS (y : T, ys : list[T]) : xs = cons(y, ys)

    
END listfuncs

listsum : THEORY
BEGIN

  sum(l : list[nat]) : RECURSIVE nat =
    IF null?(l)
    THEN 0
    ELSE car(l) + sum(cdr(l))
    ENDIF
  MEASURE length(l)

  sum_geq_than_elements : LEMMA % :-)
    FORALL(l : list[nat], x : nat) :
      member(x, l) IMPLIES
        sum(l) >= x

END listsum


list_map_funcs[T1, T2 : TYPE] : THEORY
BEGIN

  list_map_member : LEMMA % :-)
    FORALL(xs : list[T1], x : T1, f : [T1 -> T2]) :
      member(x, xs) IMPLIES member(f(x), map(f)(xs))

END list_map_funcs


list_of_set_funcs[T : TYPE] : THEORY
BEGIN

  list_to_union(l : list[set[T]]) : RECURSIVE set[T] =
    IF null?(l)
    THEN emptyset[T]
    ELSE union(car(l), list_to_union(cdr(l)))
    ENDIF
  MEASURE length(l)

  list_to_union_subset : LEMMA % :-)
    FORALL(l : list[set[T]], x : set[T]) :
      member(x, l) IMPLIES subset?(x, list_to_union(l))

END list_of_set_funcs

% NOT USED
FunProp : THEORY
BEGIN

  nat2string(n : nat) : RECURSIVE list[char] =
    IF n = 0
    THEN null
    ELSE cons(char(0), nat2string(n - 1))
    ENDIF
  MEASURE n


  nat2string_injective : LEMMA % :-)
    injective?(nat2string)

  list2finseq_injective : LEMMA % :-)
    injective?[list[char], string](list2finseq)

  nat2string_injective_function_exists : LEMMA % :-)
    EXISTS (f : [nat -> string]) : injective?(f)


END FunProp
