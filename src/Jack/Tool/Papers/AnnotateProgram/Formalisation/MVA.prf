(EventType)
(MVA
 (get_MVAVarDecl_TCC1 0
  (get_MVAVarDecl_TCC1-1 nil 3411366436 3430124165 ("" (subtype-tcc) nil nil)
   proved
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   23 20 nil nil)))
(WellFormedMVA)
(MVAProperties)
(MVACommonSemantics
 (execute_action_TCC1 0
  (execute_action_TCC1-1 nil 3411366856 3430124165 ("" (subtype-tcc) nil nil)
   proved nil 55 10 nil nil))
 (execute_action_TCC2 0
  (execute_action_TCC2-1 nil 3411366856 3430124165
   ("" (termination-tcc) nil nil) proved
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   25 20 nil nil))
 (execute_action_yields_wf_state 0
  (execute_action_yields_wf_state-1 nil 3411366948 3430124165
   ("" (induct "l")
    (("1" (skosimp)
      (("1" (expand "execute_action") (("1" (propax) nil nil)) nil)) nil)
     ("2" (skosimp*)
      (("2" (expand "execute_action" 1)
        (("2" (inst?)
          (("2" (assert)
            (("2" (split)
              (("1" (hide -1 -2 2)
                (("1" (expand "wf_Action")
                  (("1" (skosimp)
                    (("1" (inst?)
                      (("1" (expand "member" -2) (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (expand* "wf_store" "wf_Action")
                  (("2" (skosimp)
                    (("2" (inst?)
                      (("2" (inst?)
                        (("2" (expand* "member" "update_store")
                          (("2" (lift-if)
                            (("2" (split 1)
                              (("1" (skosimp*)
                                (("1" (use "eval_yields_not_bottom")
                                  (("1" (assert) nil nil)) nil))
                                nil)
                               ("2" (skosimp*)
                                (("2" (split 2)
                                  (("1" (propax) nil nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((update_store const-decl "Store" State nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (eval const-decl "Val" MVACommonSemantics nil)
    (member def-decl "bool" list_props nil)
    (eval_yields_not_bottom formula-decl nil MVACommonSemantics nil)
    (list_induction formula-decl nil list_adt nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil)
    (CP formal-nonempty-type-decl nil MVACommonSemantics nil)
    (OneAction type-eq-decl nil MVA nil)
    (execute_action def-decl "Store" MVACommonSemantics nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_store const-decl "boolean" State nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (Decl type-eq-decl nil Program nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Action type-eq-decl nil MVA nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   377 340 t nil))
 (initial_MVA_state_TCC1 0
  (initial_MVA_state_TCC1-1 nil 3411367276 3430124165
   ("" (subtype-tcc) nil nil) proved
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil))
   82 80 nil nil))
 (wf_initial_MVA_state 0
  (wf_initial_MVA_state-1 nil 3411367324 3430124166
   ("" (skosimp*)
    (("" (expand* "wf_AState" "initial_MVA_state" "wf_MVA")
      (("" (flatten)
        (("" (assert)
          (("" (expand "wf_store")
            (("" (skosimp*)
              (("" (expand "defined?")
                (("" (lift-if)
                  (("" (assert)
                    (("" (split 2)
                      (("1" (skosimp*) (("1" (grind) nil nil)) nil)
                       ("2" (skosimp*)
                        (("2"
                          (typepred
                           "init_val(down(get_MVAVarDecl(vn!1, a!1)))")
                          (("2" (expand "defined?")
                            (("2" (assert)
                              (("2" (expand "get_MVAVarDecl" 2)
                                (("2" (lift-if)
                                  (("2" (assert)
                                    (("2" (split 2)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (expand "empty?")
                                        (("2"
                                          (expand "member")
                                          (("2"
                                            (skosimp*)
                                            (("2"
                                              (expand "var_names")
                                              (("2"
                                                (inst?)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((initial_MVA_state const-decl "AState" MVACommonSemantics nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (get_MVAVarDecl const-decl "lift[Decl]" MVA nil)
    (CP formal-nonempty-type-decl nil MVACommonSemantics nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (choose const-decl "(p)" sets nil) (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil) (Val type-decl nil Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MVA type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (lift type-decl nil lift_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_store const-decl "boolean" State nil))
   871 760 t nil)))
(MVAPartialSemantics
 (step_TCC1 0
  (step_TCC1-1 nil 3411367277 3430124167 ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil) (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_store const-decl "boolean" State nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   483 440 nil nil))
 (step_yields_wf_state 0
  (step_yields_wf_state-1 nil 3411367568 3430124167
   ("" (skolem-typepred)
    (("" (skosimp*)
      (("" (expand* "wf_AState" "wf_PEvent" "step")
        (("" (lift-if)
          (("" (assert)
            ((""
              (apply (branch (split -4)
                      ((then (flatten) (assert) (flatten) (assert)))))
              ((""
                (apply (branch (split 1)
                        ((then (flatten) (assert) (flatten) (assert)))))
                (("" (hide -2)
                  ((""
                    (name "t1" "choose(LAMBDA (t: Transition):
                                                                  ts(a!1)(t) AND
                                                                  scp(t) = cp(s!1) AND
                                                                  event(t) = event(pe!1) AND
                                                                  guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))")
                    (("1" (replace -1)
                      (("1" (hide -2)
                        (("1" (assert)
                          (("1" (expand "wf_MVA")
                            (("1" (flatten)
                              (("1" (inst -10 "t1")
                                (("1" (assert)
                                  (("1" (expand "wf_Trans")
                                    (("1" (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (use
                                           "execute_action_yields_wf_state")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite "nonempty_exists")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((nonempty_exists formula-decl nil sets_lemmas nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVAPartialSemantics nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVAPartialSemantics nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVAPartialSemantics nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVAPartialSemantics nil)
    (execute_action_yields_wf_state formula-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil) (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (Decl type-eq-decl nil Program nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   315 290 t shostak))
 (complete_definedness 0
  (complete_definedness-1 nil 3411708261 3430124167
   ("" (skosimp*)
    (("" (expand "step")
      (("" (lift-if)
        (("" (assert)
          (("" (split 1)
            (("1" (propax) nil nil)
             ("2" (typepred "a!1")
              (("2" (expand "complete")
                (("2" (flatten)
                  (("2" (expand "total")
                    (("2"
                      (inst -5 "cp(s!1)" "event(pe!1)" "stA(s!1)" "stP(pe!1)"
                       "arg(pe!1)")
                      (("2" (typepred "pe!1" "s!1")
                        (("2" (expand* "wf_PEvent" "wf_AState")
                          (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (total const-decl "boolean" MVAProperties nil))
   92 100 t shostak)))
(MVATotalSemantics
 (step_TCC1 0
  (step_TCC1-2 nil 3411367180 3430124167
   (";;; Proof for formula MVASemantics.step_TCC1" (skosimp*)
    ((";;; Proof for formula MVASemantics.step_TCC1" (typepred "a!1")
      ((";;; Proof for formula MVASemantics.step_TCC1" (expand "total")
        ((";;; Proof for formula MVASemantics.step_TCC1" (typepred "s!1")
          ((";;; Proof for formula MVASemantics.step_TCC1"
            (expand "wf_AState")
            ((";;; Proof for formula MVASemantics.step_TCC1" (flatten)
              ((";;; Proof for formula MVASemantics.step_TCC1"
                (inst -3 "cp(s!1)" "event(pe!1)" "stA(s!1)" "stP(pe!1)"
                 "arg(pe!1)")
                ((";;; Proof for formula MVASemantics.step_TCC1" (assert)
                  ((";;; Proof for formula MVASemantics.step_TCC1"
                    (typepred "pe!1")
                    ((";;; Proof for formula MVASemantics.step_TCC1"
                      (expand "wf_PEvent")
                      ((";;; Proof for formula MVASemantics.step_TCC1"
                        (flatten)
                        ((";;; Proof for formula MVASemantics.step_TCC1"
                          (assert)
                          ((";;; Proof for formula MVASemantics.step_TCC1"
                            (skosimp*)
                            ((";;; Proof for formula MVASemantics.step_TCC1"
                              (rewrite "nonempty_exists")
                              ((";;; Proof for formula MVASemantics.step_TCC1"
                                (inst 1 "t!1")
                                ((";;; Proof for formula MVASemantics.step_TCC1"
                                  (assert) nil))))))))))))))))))))))))))))))
    "")
   proved
   ((total const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVATotalSemantics nil)
    (Name formal-nonempty-type-decl nil MVATotalSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (a!1 skolem-const-decl "(total[CP, Name])" MVATotalSemantics nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVATotalSemantics nil)
    (s!1 skolem-const-decl "(wf_AState[CP, Name](a!1))" MVATotalSemantics nil)
    (pe!1 skolem-const-decl "(wf_PEvent[CP, Name](a!1))" MVATotalSemantics
     nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil))
   125 100 nil nil)
  (step_TCC1-1 nil 3411367080 3411367108 ("" (subtype-tcc) nil nil) unfinished
   nil 1421 1420 nil nil))
 (step_yields_wf_state 0
  (step_yields_wf_state-1 nil 3411367156 3430124168
   (";;; Proof for formula MVASemantics.step_yields_wf_state"
    (skolem-typepred)
    ((";;; Proof for formula MVASemantics.step_yields_wf_state"
      (expand* "wf_AState" "wf_PEvent" "step")
      ((";;; Proof for formula MVASemantics.step_yields_wf_state"
        (name "t1" "choose(LAMBDA (t: Transition):
                                                           ts(a!1)(t) AND
                                                           scp(t) = cp(s!1) AND
                                                           event(t) = event(pe!1) AND
                                                           guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))")
        (("1" (replace -1)
          (("1" (skosimp*)
            (("1" (assert)
              (("1" (expand "wf_MVA")
                (("1" (flatten)
                  (("1" (inst -11 "t1")
                    (("1" (assert)
                      (("1" (expand "wf_Trans")
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (use "execute_action_yields_wf_state")
                              (("1" (assert) nil)))))))))))))))))))))))
         ("2" (use "step_TCC1") nil))))))
    "")
   proved
   ((step const-decl "AState" MVATotalSemantics nil)
    (step_TCC1 subtype-tcc nil MVATotalSemantics nil)
    (execute_action_yields_wf_state formula-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil) (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (total const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVATotalSemantics nil)
    (Name formal-nonempty-type-decl nil MVATotalSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   167 120 nil nil)))
(MVAMonitoring
 (guard_to_expression_TCC1 0
  (guard_to_expression_TCC1-2 nil 3411366716 3430124629
   ("" (inst 1 "LAMBDA(g : Guard)(v : ValOrExcpt) : Const(Unit)")
    (("" (expand "defined?") (("" (propax) nil nil)) nil)) nil)
   proved
   ((Unit adt-constructor-decl "(Unit?)" Val_adt nil)
    (Unit? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (Const adt-constructor-decl "[(defined?) -> (Const?)]" Body_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Expr type-eq-decl nil Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Body type-decl nil Body_adt nil) (Guard type-eq-decl nil MVA nil)
    (CP formal-nonempty-type-decl nil MVAMonitoring nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVAMonitoring nil))
   8313 20 t nil)
  (guard_to_expression_TCC1-1 nil 3411366569 3411366576
   ("" (existence-tcc) nil nil) unfinished nil 142 140 nil nil)))
(MVACompletion
 (all_guards_TCC1 0
  (all_guards_TCC1-1 nil 3382264515 3430128312
   ("" (skosimp*)
    (("" (typepred "ts(a!1)")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1" "LAMBDA(p : ({p: Guard[CP, Name] |
                     EXISTS (t: Transition[CP, Name]):
                       ts(a!1)(t) AND
                        scp(t) = cp!1 AND
                         event(t) = e!1 AND guard(t) = p})) : f!1(choose({t : Transition[CP, Name] | ts(a!1)(t) AND
                        scp(t) = cp!1 AND
                         event(t) = e!1 AND guard(t) = p}))")
            (("1" (expand "injective?")
              (("1" (skosimp*)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skosimp*)
                        (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2" (typepred "p!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skosimp*)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Action type-eq-decl nil MVA nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (p!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (x2!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (Store type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil))
   484 430 t nil))
 (complete_trans_TCC1 0
  (complete_trans_TCC1-4 nil 3428743396 3430128312
   ("" (skosimp*)
    (("" (use "finite_union[Transition[CP, Name]]")
      (("1" (hide 2)
        (("1" (typepred "evs(a!1)")
          (("1" (expand "is_finite")
            (("1" (skosimp*)
              (("1"
                (inst 1 "N!1" "LAMBDA(t1 : ({t: Transition[CP, Name] |
                                   scp(t) = halted[CP, Name] AND evs(a!1)(event(t))
                               AND guard(t) =
                                    (LAMBDA (stA, stP: Store[Name], arg : ValOrExcpt): TRUE)
                               AND action(t) = skip[CP, Name]
                               AND tcp(t) = halted[CP, Name]})) : f!1(event(t1))")
                (("1" (expand "injective?")
                  (("1" (skosimp*)
                    (("1" (apply-extensionality :hide? t)
                      (("1" (inst -1 "event(x1!1)" "event(x2!1)")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (typepred "cps(a!1)")
          (("2" (typepred "evs(a!1)")
            (("2" (expand "is_finite")
              (("2" (skosimp*)
                (("2" (case "N!1 = 0")
                  (("1"
                    (inst 1 "N!2" "LAMBDA(t : ({t: Transition[CP, Name] |
                                            cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                        AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                        AND action(t) = skip[CP, Name]
                                        AND tcp(t) = halted[CP, Name]})) : f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1" (typepred "f!1(x2!1`event)")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst 2 "N!1 + N!1 * N!2"
                     "LAMBDA(t : ({t: Transition[CP, Name] |
                                                cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                            AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                            AND action(t) = skip[CP, Name]
                                            AND tcp(t) = halted[CP, Name]})) : f!1(event(t)) + N!1 * f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1"
                          (use "unique_quotient"
                               ("b" "N!1" "q1" "f!2(scp(x1!1))" "q2"
                                "f!2(scp(x2!1))" "r1" "f!1(event(x1!1))" "r2"
                                "f!1(event(x2!1))"))
                          (("1" (assert)
                            (("1" (inst -2 "event(x1!1)" "event(x2!1)")
                              (("1" (inst -3 "scp(x1!1)" "scp(x2!1)")
                                (("1" (assert)
                                  (("1" (apply-extensionality 2 :hide? t) nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (typepred "f!1(event(t!1))")
                        (("2" (typepred "f!2(scp(t!1))")
                          (("2" (use "lt_plus_lt1")
                            (("2" (split -1)
                              (("1" (propax) nil nil) ("2" (assert) nil nil)
                               ("3" (use "both_sides_times_pos_lt2")
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_union judgement-tcc nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Action type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (TRUE const-decl "bool" booleans nil) (halted const-decl "CP" MVA nil)
    (skip const-decl "Action" MVA nil) (list type-decl nil list_adt nil)
    (OneAction type-eq-decl nil MVA nil) (Expr type-eq-decl nil Body_adt nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (Decl type-eq-decl nil Program nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (unique_quotient formula-decl nil euclidean_division nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N!1 skolem-const-decl "nat" MVACompletion nil)
    (f!1 skolem-const-decl "[(evs(a!1)) -> below[N!1]]" MVACompletion nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N!2 skolem-const-decl "nat" MVACompletion nil)
    (f!2 skolem-const-decl "[(cps(a!1)) -> below[N!2]]" MVACompletion nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   496 380 nil nil)
  (complete_trans_TCC1-3 nil 3382265153 3428742910
   ("" (skosimp*)
    (("" (use "finite_union[Transition[CP, Name]]")
      (("1" (hide 2)
        (("1" (typepred "evs(a!1)")
          (("1" (expand "is_finite")
            (("1" (skosimp*)
              (("1"
                (inst 1 "N!1" "LAMBDA(t1 : ({t: Transition[CP, Name] |
                               scp(t) = halted[CP, Name] AND evs(a!1)(event(t))
                           AND guard(t) =
                                (LAMBDA (stA: Store[Name], stP: PSt[Name], arg : ValOrExcpt): TRUE)
                           AND action(t) = skip[CP, Name]
                           AND tcp(t) = halted[CP, Name]})) : f!1(event(t1))")
                (("1" (expand "injective?")
                  (("1" (skosimp*)
                    (("1" (apply-extensionality :hide? t)
                      (("1" (inst -1 "event(x1!1)" "event(x2!1)")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (typepred "cps(a!1)")
          (("2" (typepred "evs(a!1)")
            (("2" (expand "is_finite")
              (("2" (skosimp*)
                (("2" (case "N!1 = 0")
                  (("1"
                    (inst 1 "N!2" "LAMBDA(t : ({t: Transition[CP, Name] |
                                      cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                  AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                  AND action(t) = skip[CP, Name]
                                  AND tcp(t) = halted[CP, Name]})) : f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1" (typepred "f!1(x2!1`event)")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst 2 "N!1 + N!1 * N!2"
                     "LAMBDA(t : ({t: Transition[CP, Name] |
                                          cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                      AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                      AND action(t) = skip[CP, Name]
                                      AND tcp(t) = halted[CP, Name]})) : f!1(event(t)) + N!1 * f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1"
                          (use "unique_quotient"
                               ("b" "N!1" "q1" "f!2(scp(x1!1))" "q2"
                                "f!2(scp(x2!1))" "r1" "f!1(event(x1!1))" "r2"
                                "f!1(event(x2!1))"))
                          (("1" (assert)
                            (("1" (inst -2 "event(x1!1)" "event(x2!1)")
                              (("1" (inst -3 "scp(x1!1)" "scp(x2!1)")
                                (("1" (assert)
                                  (("1" (apply-extensionality 2 :hide? t) nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (typepred "f!1(event(t!1))")
                        (("2" (typepred "f!2(scp(t!1))")
                          (("2" (use "lt_plus_lt1")
                            (("2" (split -1)
                              (("1" (propax) nil nil) ("2" (assert) nil nil)
                               ("3" (use "both_sides_times_pos_lt2")
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((finite_union judgement-tcc nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Action type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (TRUE const-decl "bool" booleans nil) (halted const-decl "CP" MVA nil)
    (skip const-decl "Action" MVA nil) (list type-decl nil list_adt nil)
    (OneAction type-eq-decl nil MVA nil) (Expr type-eq-decl nil Body_adt nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (unique_quotient formula-decl nil euclidean_division nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   595 490 t nil)
  (complete_trans_TCC1-2 nil 3382265133 nil ("" (skip) nil nil) unchecked nil
   nil nil nil nil)
  (complete_trans_TCC1-1 nil 3382264515 3382264991 ("" (subtype-tcc) nil nil)
   unfinished nil 32426 31994 nil nil))
 (big_conj_TCC1 0
  (big_conj_TCC1-1 nil 3430127082 3430128313 ("" (subtype-tcc) nil nil) proved
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (defined? const-decl "boolean" ValProp nil))
   38 40 nil nil))
 (big_conj_TCC2 0
  (big_conj_TCC2-1 nil 3430127082 3430128313 ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   46 40 nil nil))
 (big_conj_TCC3 0
  (big_conj_TCC3-1 nil 3430127082 3430128888
   ("" (skosimp*) (("" (use "card_rest[Expr]") (("" (assert) nil nil)) nil))
    nil)
   proved
   ((card_rest formula-decl nil finite_sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Body type-decl nil Body_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   62276 210 t nil))
 (guard_to_expression_big_conj 0
  (guard_to_expression_big_conj-1 nil 3430127298 3430128315
   ("" (lemma "finite_set_induction_rest[Expr]")
    ((""
      (inst -1 "LAMBDA(E : finite_set[Expr]) :  FORALL (a: MVA):
        (FORALL (e: Expr): E(e) IMPLIES wf_Expr(a)(e)) IMPLIES
         wf_Expr(a)(big_conj(E))")
      (("" (split -1)
        (("1" (skosimp*) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skosimp*)
            (("3" (expand "big_conj" 1)
              (("3" (inst? -1)
                (("3" (split -1)
                  (("1" (auto-rewrite "subset?" "member" "union" "emptyset")
                    (("1" (expand "wf_Expr")
                      (("1" (expand "wf_Body")
                        (("1" (flatten)
                          (("1" (inst -3 "choose(SS!1)")
                            (("1" (assert)
                              (("1" (flatten)
                                (("1" (split 1)
                                  (("1" (skosimp*)
                                    (("1" (expand "var_names" -1)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (inst? -4)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (inst? -2)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (skosimp*)
                                    (("2" (expand "subterm" -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split -1)
                                          (("1"
                                            (inst? -6)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (inst? -4)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (inst?) (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (big_conj def-decl "Expr" MVACompletion nil)
    (finite_rest application-judgement "finite_set[Expr]" MVACompletion nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[Expr]" MVACompletion nil)
    (var_names def-decl "[Name -> boolean]" ProgramFunctions nil)
    (empty? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[Expr]" MVACompletion nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     "finite_sets/")
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Body type-decl nil Body_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil))
   523 490 t shostak))
 (guard_to_expression_build_guard_TCC1 0
  (guard_to_expression_build_guard_TCC1-1 nil 3430127082 3430128951
   ("" (skosimp*)
    (("" (typepred "all_guards(a!1)(cp!1, e!1)")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1" "LAMBDA(expr : ({expr: Expr[Name] |
                     EXISTS (g: Guard[CP, Name]):
                       all_guards(a!1)(cp!1, e!1)(g) AND
                        expr = guard_to_expression[CP, Name](g)(v!1)})) : f!1(choose({g : Guard[CP, Name] |  all_guards(a!1)(cp!1, e!1)(g) AND
                        expr = guard_to_expression[CP, Name](g)(v!1)}))")
            (("1" (expand "injective?")
              (("1" (skosimp*)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2"
                    (apply (then (rewrite "nonempty_exists") (typepred "x2!1")
                            (skosimp*) (inst?) (assert)))
                    nil nil)
                   ("3"
                    (apply (then (rewrite "nonempty_exists") (typepred "x1!1")
                            (skosimp*) (inst?) (assert)))
                    nil nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2"
                (apply (then (rewrite "nonempty_exists") (typepred "expr!1")
                        (skosimp*) (inst?) (assert)))
                nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Transition type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (Guard type-eq-decl nil MVA nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (expr!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = guard_to_expression[CP, Name](g)(v!1)})" MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = guard_to_expression[CP, Name](g)(v!1)})" MVACompletion nil)
    (x2!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = guard_to_expression[CP, Name](g)(v!1)})" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (guard_to_expression const-decl "[ValOrExcpt -> Expr]" MVAMonitoring nil)
    (v!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil))
   54387 540 t nil))
 (guard_to_expression_build_guard_wf_Expr 0
  (guard_to_expression_build_guard_wf_Expr-1 nil 3430127622 3430128307
   ("" (skosimp*)
    (("" (lemma "guard_to_expression_big_conj")
      (("" (inst -1 "a!1" _)
        (("" (expand "wf_Expr")
          (("" (expand "wf_Body")
            (("" (use "guard_to_expression_build_guard")
              (("" (replace -1 :hide? t)
                (("" (inst?)
                  (("1" (assert)
                    (("1" (split -1)
                      (("1" (propax) nil nil)
                       ("2" (hide 2)
                        (("2" (skosimp*)
                          (("2" (expand "all_guards")
                            (("2" (skosimp*)
                              (("2" (inst?)
                                (("2" (assert)
                                  (("2" (replace -5)
                                    (("2" (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (typepred "all_guards(a!1)(cp!1, e!1)")
                      (("2" (expand "is_finite")
                        (("2" (skosimp*)
                          (("2"
                            (inst 1 "N!1" "LAMBDA(expr : ({expr: Expr[Name] |
                     EXISTS (g: Guard[CP, Name]):
                       all_guards(a!1)(cp!1, e!1)(g) AND
                        expr = guard_to_expression[CP, Name](g)(v!1)})) : f!1(choose({g : Guard[CP, Name] |  all_guards(a!1)(cp!1, e!1)(g) AND
                        expr = guard_to_expression[CP, Name](g)(v!1)}))")
                            (("1" (expand "injective?")
                              (("1" (skosimp*)
                                (("1" (inst?)
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (apply (then
                                            (rewrite "nonempty_exists")
                                            (typepred "x2!1")
                                            (skosimp*)
                                            (inst?)
                                            (assert)))
                                    nil nil)
                                   ("3"
                                    (apply (then
                                            (rewrite "nonempty_exists")
                                            (typepred "x1!1")
                                            (skosimp*)
                                            (inst?)
                                            (assert)))
                                    nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skosimp*)
                              (("2"
                                (apply (then
                                        (rewrite "nonempty_exists")
                                        (typepred "expr!1")
                                        (skosimp*)
                                        (inst?)
                                        (assert)))
                                nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (nonempty? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (choose const-decl "(p)" sets nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (x2!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = guard_to_expression[CP, Name](g)(v!1)})" MVACompletion nil)
    (x1!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = guard_to_expression[CP, Name](g)(v!1)})" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (expr!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = guard_to_expression[CP, Name](g)(v!1)})" MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (Body type-decl nil Body_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Store type-eq-decl nil State nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (guard_to_expression const-decl "[ValOrExcpt -> Expr]" MVAMonitoring nil)
    (v!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (guard_to_expression_build_guard formula-decl nil MVACompletion nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (guard_to_expression_big_conj formula-decl nil MVACompletion nil))
   331144 870 t shostak))
 (guard_to_expression_LAMBDA_true_TCC1 0
  (guard_to_expression_LAMBDA_true_TCC1-1 nil 3430127082 3430128315
   ("" (subtype-tcc) nil nil) proved
   ((Name formal-nonempty-type-decl nil MVACompletion nil)
    (defined? const-decl "boolean" ValProp nil))
   8 10 nil nil))
 (guard_to_expression_LAMBDA_true_wf_Expr 0
  (guard_to_expression_LAMBDA_true_wf_Expr-1 nil 3430127090 3430128315
   ("" (auto-rewrite "emptyset" "union" "member")
    (("" (skosimp*)
      (("" (rewrite "guard_to_expression_LAMBDA_true")
        (("" (expand "wf_Expr")
          (("" (expand "wf_Body")
            (("" (split 1)
              (("1" (expand "subset?")
                (("1" (assert)
                  (("1" (expand "var_names") (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (expand "subterm") (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_Expr const-decl "boolean" WellFormedMVA nil)
    (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (var_names def-decl "[Name -> boolean]" ProgramFunctions nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (guard_to_expression_LAMBDA_true formula-decl nil MVACompletion nil))
   138 140 t shostak))
 (build_guard_yields_wf_guard 0
  (build_guard_yields_wf_guard-1 nil 3387785549 3430128327
   ("" (skosimp)
    (("" (expand* "wf_Guard" "wf_MVA" "build_guard" "all_guards")
      (("" (flatten)
        (("" (skosimp)
          (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_MVA const-decl "boolean" WellFormedMVA nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (Val type-decl nil Val_adt nil) (Store type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil))
   11123 10840 t shostak))
 (complete_MVA_yields_wf_MVA 0
  (complete_MVA_yields_wf_MVA-1 nil 3387108138 3430128328
   ("" (skolem-typepred)
    (("" (expand "wf_MVA")
      (("" (prop)
        (("1"
          (expand* "complete_MVA" "init_cp" "add" "member" "complete_MVA_pre")
          (("1" (prop) nil nil)) nil)
         ("2" (expand* "wf_vdsA" "complete_MVA") nil nil)
         ("3" (expand* "wf_vdsP" "complete_MVA") nil nil)
         ("4" (expand "complete_MVA") (("4" (propax) nil nil)) nil)
         ("5" (expand "complete_MVA") (("5" (propax) nil nil)) nil)
         ("6" (expand "wf_Trans")
          (("6" (skosimp)
            (("6" (inst? -6)
              (("6" (expand "complete_MVA" -1)
                (("6" (expand* "union" "member")
                  (("6" (split -1)
                    (("1" (assert)
                      (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)
                     ("2" (expand* "complete_trans" "union" "member")
                      (("2" (split -1)
                        (("1" (flatten)
                          (("1" (hide -7 -8 -9 -10)
                            (("1" (use "build_guard_yields_wf_guard")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (hide -3 -4 -5 -6) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_Trans const-decl "boolean" WellFormedMVA nil)
    (union const-decl "set" sets nil)
    (build_guard_yields_wf_guard formula-decl nil MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (member def-decl "bool" list_props nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1112 1030 t shostak))
 (complete_MVA_has_trap_state_TCC1 0
  (complete_MVA_has_trap_state_TCC1-1 nil 3382264515 3430128328
   ("" (use "complete_MVA_yields_wf_MVA") nil nil) proved
   ((complete_MVA_yields_wf_MVA formula-decl nil MVACompletion nil)) 6 0 t
   nil))
 (complete_MVA_has_trap_state 0
  (complete_MVA_has_trap_state-3 nil 3411368153 3430128328
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        (("" (expand* "complete_trans" "union" "member" "partial" "wf_MVA")
          (("" (prop)
            (("" (inst?)
              (("" (expand "wf_Trans")
                (("" (prop) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (trap_state const-decl "boolean" MVAProperties nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   187 180 t nil)
  (complete_MVA_has_trap_state-2 nil 3383048645 3411368119
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        ((""
          (expand* "complete_trans" "union" "member" "complete_MVA_pre"
           "wf_MVA")
          (("" (prop)
            (("" (inst?)
              (("" (expand "wf_Trans")
                (("" (prop) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (trap_state const-decl "boolean" MVAProperties nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   284 250 t nil)
  (complete_MVA_has_trap_state-1 nil 3382270875 3382270880
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        ((""
          (expand* "complete_trans" "union" "member" "complete_MVA_pre"
           "valid_MVA")
          (("" (prop)
            (("" (inst?) (("" (prop) (("" (assert) nil nil)) nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   untried
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil))
   295 42 t nil))
 (complete_MVA_is_deterministic 0
  (complete_MVA_is_deterministic-3 nil 3411368112 3430128340
   ("" (expand "deterministic")
    (("" (skolem-typepred)
      (("" (skosimp)
        (("" (expand "partial")
          (("" (flatten)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1" "arg!1")
                  (("1"
                    (expand* "wf_Store" "wf_PSt" "complete_MVA"
                     "complete_trans" "union" "member")
                    (("1" (prop) nil nil)) nil))
                  nil))
                nil)
               ("2" (expand "complete_MVA" -5)
                (("2" (expand "complete_trans")
                  (("2" (expand "union")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (prop)
                          (("1" (assert)
                            (("1" (replace -3)
                              (("1" (expand "build_guard")
                                (("1" (expand "all_guards")
                                  (("1" (inst? -13)
                                    (("1" (assert)
                                      (("1"
                                        (inst 3 "t1!1")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "complete_MVA" -4)
                (("3" (expand "complete_trans")
                  (("3" (expand "union")
                    (("3" (expand "member")
                      (("3" (assert)
                        (("3" (prop)
                          (("1" (replace -3)
                            (("1" (expand "build_guard")
                              (("1" (inst? -12)
                                (("1" (expand "all_guards")
                                  (("1" (inst 3 "t2!1")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "wf_MVA")
                            (("2" (flatten)
                              (("2" (inst -11 "t2!1")
                                (("2" (expand "wf_Trans")
                                  (("2" (flatten) (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (apply-extensionality 4 :hide? t)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (skip const-decl "Action" MVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (deterministic const-decl "boolean" MVAProperties nil))
   12469 10300 t nil)
  (complete_MVA_is_deterministic-2 nil 3383048795 3411368092
   ("" (expand "deterministic")
    (("" (skolem-typepred)
      (("" (skosimp)
        (("" (expand "complete_MVA_pre")
          (("" (flatten)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1" "arg!1")
                  (("1"
                    (expand* "wf_Store" "wf_PSt" "complete_MVA"
                     "complete_trans" "union" "member")
                    (("1" (prop) nil nil)) nil))
                  nil))
                nil)
               ("2" (expand "complete_MVA" -5)
                (("2" (expand "complete_trans")
                  (("2" (expand "union")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (prop)
                          (("1" (assert)
                            (("1" (replace -3)
                              (("1" (expand "build_guard")
                                (("1" (expand "all_guards")
                                  (("1" (inst? -13)
                                    (("1" (assert)
                                      (("1"
                                        (inst 3 "t1!1")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "complete_MVA" -4)
                (("3" (expand "complete_trans")
                  (("3" (expand "union")
                    (("3" (expand "member")
                      (("3" (assert)
                        (("3" (prop)
                          (("1" (replace -3)
                            (("1" (expand "build_guard")
                              (("1" (inst? -12)
                                (("1" (expand "all_guards")
                                  (("1" (inst 3 "t2!1")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "wf_MVA")
                            (("2" (flatten)
                              (("2" (inst -11 "t2!1")
                                (("2" (expand "wf_Trans")
                                  (("2" (flatten) (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (apply-extensionality 4 :hide? t)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (skip const-decl "Action" MVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (deterministic const-decl "boolean" MVAProperties nil))
   12635 5840 t nil)
  (complete_MVA_is_deterministic-1 nil 3382270657 3382270846
   ("" (skolem-typepred)
    (("" (expand* "deterministic" "complete_MVA")
      (("" (skosimp)
        (("" (expand "complete_MVA_pre")
          (("" (flatten -2)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1")
                  (("1" (prop)
                    (("1" (expand "valid_PSt") (("1" (propax) nil nil)) nil)
                     ("2" (expand "valid_Store") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -3 -6 -7)
                (("2" (expand "complete_trans" -4)
                  (("2" (expand "union" -4)
                    (("2" (expand "member" -4)
                      (("2" (prop)
                        (("1" (delete -8 1)
                          (("1" (expand "valid_MVA")
                            (("1" (prop)
                              (("1" (inst -9 "t1!1")
                                (("1" (prop)
                                  (("1" (delete -4 -5)
                                    (("1" (grind)
                                      (("1" (postpone) nil nil)
                                       ("2" (postpone) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (delete -3 -5 -6 -7)
                (("3" (expand* "complete_trans" "union" "member")
                  (("3" (prop)
                    (("1" (grind)
                      (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)
                     ("2" (expand "valid_MVA")
                      (("2" (prop)
                        (("2" (inst -9 "t2!1")
                          (("2" (prop)
                            (("2" (delete -4 -5) (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (delete -1 -2 -5 -6)
                (("4" (grind)
                  (("1" (decompose-equality 4) nil nil)
                   ("2" (decompose-equality 4) nil nil)
                   ("3" (postpone) nil nil) ("4" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried nil 18669 3635 t nil))
 (complete_MVA_is_total 0
  (complete_MVA_is_total-3 nil 3410259686 3430128342
   ("" (skolem-typepred)
    (("" (expand* "total" "complete_MVA")
      (("" (skosimp)
        ((""
          (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
          (("1" (skolem!)
            (("1" (inst 1 "t!1")
              (("1" (expand* "union" "member") (("1" (prop) nil nil)) nil))
              nil))
            nil)
           ("2" (case "q!1 = halted")
            (("1" (hide 1)
              (("1"
                (inst +
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA, stP: Store , arg : ValOrExcpt): TRUE), action := skip, tcp := halted #)")
                (("1" (expand* "wf_MVA" "complete_MVA_pre")
                  (("1" (flatten)
                    (("1" (replace -1) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2"
                (case "EXISTS (t: Transition): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
                (("1" (skolem!)
                  (("1" (inst + "t!1") (("1" (grind) nil nil)) nil)) nil)
                 ("2"
                  (inst 3
                   "(# scp := q!1, event := e!1, guard := build_guard(a!1)(q!1, e!1), action := skip, tcp := halted #)")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (TRUE const-decl "bool" booleans nil) (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil) (list type-decl nil list_adt nil)
    (skip const-decl "Action" MVA nil) (halted const-decl "CP" MVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1865 1780 t nil)
  (complete_MVA_is_total-2 nil 3383048587 3410259477
   ("" (skolem-typepred)
    (("" (expand* "total" "complete_MVA")
      (("" (skosimp)
        ((""
          (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
          (("1" (skolem!)
            (("1" (inst 1 "t!1")
              (("1" (expand* "union" "member") (("1" (prop) nil nil)) nil))
              nil))
            nil)
           ("2" (case "q!1 = halted")
            (("1" (hide 1)
              (("1"
                (inst +
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: Store , stP: PSt, arg : (defined?)): TRUE), action := skip, tcp := halted #)")
                (("1" (expand* "wf_MVA" "complete_MVA_pre")
                  (("1" (flatten)
                    (("1" (replace -1) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2"
                (case "EXISTS (t: Transition): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
                (("1" (skolem!)
                  (("1" (inst + "t!1") (("1" (grind) nil nil)) nil)) nil)
                 ("2"
                  (inst 3
                   "(# scp := q!1, event := e!1, guard := build_guard(a!1)(q!1, e!1), action := skip, tcp := halted #)")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (TRUE const-decl "bool" booleans nil) (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil) (list type-decl nil list_adt nil)
    (skip const-decl "Action" MVA nil) (halted const-decl "CP" MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   3936 3870 t nil)
  (complete_MVA_is_total-1 nil 3382265612 3382270601
   ("" (skolem-typepred)
    (("" (expand "total")
      (("" (skosimp)
        (("" (expand "complete_MVA" 1)
          ((""
            (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1)")
            (("1" (skolem!)
              (("1" (inst 1 "t!1")
                (("1" (expand "union" 1)
                  (("1" (expand "member" 1) (("1" (prop) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (case "q!1 = halted")
              (("1"
                (inst 2
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: (valid_Store(vdsA(a!1))) , stP: (valid_PSt(vdsP(a!1)))): TRUE), action := skip, tcp := halted #)")
                (("1" (hide -6 -7 1) (("1" (postpone) nil nil)) nil)) nil)
               ("2"
                (inst 3
                 "(# scp := q!1, event := e!1, guard := build_guard(q!1, e!1, ts(a!1), vdsA(a!1), vdsP(a!1)), action := skip, tcp := halted #)")
                (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried nil 46487 3476 t nil))
 (complete_MVA_is_complete 0
  (complete_MVA_is_complete-1 nil 3382265489 3430128343
   ("" (skolem-typepred)
    (("" (expand "complete")
      (("" (split)
        (("1" (use "complete_MVA_yields_wf_MVA") nil nil)
         ("2" (expand "complete_MVA")
          (("2" (expand "add") (("2" (propax) nil nil)) nil)) nil)
         ("3" (use "complete_MVA_has_trap_state") nil nil)
         ("4" (use "complete_MVA_is_deterministic") nil nil)
         ("5" (use "complete_MVA_is_total") nil nil))
        nil))
      nil))
    nil)
   proved
   ((complete const-decl "boolean" MVAProperties nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (complete_MVA_is_deterministic formula-decl nil MVACompletion nil)
    (complete_MVA_has_trap_state formula-decl nil MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_MVA_yields_wf_MVA formula-decl nil MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   723 690 t nil))
 (evs_complete_MVA 0
  (evs_complete_MVA-1 nil 3412338923 3430128343
   ("" (skosimp*) (("" (expand "complete_MVA") (("" (propax) nil nil)) nil))
    nil)
   proved ((complete_MVA const-decl "MVA" MVACompletion nil)) 10 0 t shostak))
 (completion_equivalence_TCC1 0
  (completion_equivalence_TCC1-1 nil 3411913637 3430128343
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil) (JType type-decl nil JType_adt nil)
    (Decl type-eq-decl nil Program nil) (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (defined? const-decl "boolean" ValProp nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_store const-decl "boolean" State nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil))
   451 450 nil nil))
 (completion_equivalence_TCC2 0
  (completion_equivalence_TCC2-1 nil 3411913637 3430128344
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil) (JType type-decl nil JType_adt nil)
    (Decl type-eq-decl nil Program nil) (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_store const-decl "boolean" State nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil))
   490 450 nil nil))
 (completion_equivalence_TCC3 0
  (completion_equivalence_TCC3-1 nil 3411913637 3430128344
   ("" (skosimp*) (("" (use "complete_MVA_is_total") nil nil)) nil) proved
   ((partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil))
   176 180 t nil))
 (completion_equivalence 0
  (completion_equivalence-2 nil 3412328847 3430128345
   (";;; Proof completion_equivalence-1 for formula MVACompletion.completion_equivalence"
    (skosimp*)
    ((";;; Proof completion_equivalence-1 for formula MVACompletion.completion_equivalence"
      (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                            (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                             scp(t) = cp(s!1) AND
                              event(t) = event(pe!1) AND
                               guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                             :hide? t)
                            (("1" (typepred "t")
                              (("1" (split -1)
                                (("1" (inst?) (("1" (assert) nil)))
                                 ("2" (expand "complete_trans")
                                  (("2" (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      nil)))))))))
                             ("2" (hide 2 3)
                              (("2" (rewrite "nonempty_exists")
                                (("2" (expand "total")
                                  (("2"
                                    (inst -1 "cp(s!1)" "event(pe!1)"
                                     "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                                    (("2" (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil)))))))))))))))))))))))))))))))))))))))))))))))))))
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                          (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                           scp(t) = cp(s!1) AND
                            event(t) = event(pe!1) AND
                             guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                       :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "partial")
                              (("1" (flatten)
                                (("1" (split -7)
                                  (("1" (inst?)
                                    (("1" (expand "wf_Trans")
                                      (("1" (assert) nil)))))
                                   ("2" (split 3)
                                    (("1" (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand "build_guard")
                                                  (("1"
                                                    (inst? -18)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand "all_guards")
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (assert)
                                                            nil)))))))))))))))
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2"
                                                    (assert)
                                                    nil)))))))))))))))
                                     ("2" (propax) nil)))))))))))))))
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                               "stP(pe!1)" "arg(pe!1)")
                              (("2" (assert)
                                (("2" (typepred "s!1")
                                  (("2" (typepred "pe!1")
                                    (("2" (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (assert)
                                                      nil))))))))))))))))))))))))))))))))))))))))))))))))))
    ";;; developed with shostak decision procedures")
   proved
   ((step const-decl "AState" MVATotalSemantics nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVACompletion nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (a!1 skolem-const-decl "(partial)" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil))
   985 900 nil nil)
  (completion_equivalence-1 nil 3411913637 3412328771
   ("" (skosimp*)
    (("" (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                      (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                       scp(t) = cp(s!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) " :hide? t)
                            (("1" (typepred "t")
                              (("1" (split -1)
                                (("1" (inst?) (("1" (assert) nil nil)) nil)
                                 ("2" (expand "complete_trans")
                                  (("2" (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2 3)
                              (("2" (rewrite "nonempty_exists")
                                (("2" (expand "total")
                                  (("2"
                                    (inst -1 "cp(s!1)" "event(pe!1)"
                                     "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                                    (("2" (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                      (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                       scp(t) = cp(s!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) " :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "good_for_monitoring")
                              (("1" (flatten)
                                (("1" (split -7)
                                  (("1" (inst?)
                                    (("1" (expand "wf_Trans")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (split 3)
                                    (("1" (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand "build_guard")
                                                  (("1"
                                                    (inst? -18)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand "all_guards")
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                               "stP(pe!1)" "arg(pe!1)")
                              (("2" (assert)
                                (("2" (typepred "s!1")
                                  (("2" (typepred "pe!1")
                                    (("2" (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((step const-decl "AState" MVATotalSemantics nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil))
   1098 990 t shostak))
 (completion_equivalence2_TCC1 0
  (completion_equivalence2_TCC1-1 nil 3412337967 3430128345
   ("" (skosimp*)
    (("" (use "complete_definedness")
      (("" (use "complete_MVA_is_complete") nil nil)) nil))
    nil)
   proved
   ((complete_definedness formula-decl nil MVAPartialSemantics nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (a!1 skolem-const-decl "(partial[CP, Name])" MVACompletion nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (complete const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (complete_MVA_is_complete formula-decl nil MVACompletion nil))
   132 130 t nil))
 (completion_equivalence2 0
  (completion_equivalence2-1 nil 3412338025 3430128346
   ("" (skosimp*)
    (("" (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                                  (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                                   scp(t) = cp(s!1) AND
                                    event(t) = event(pe!1) AND
                                     guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                             :hide? t)
                            (("1" (typepred "t")
                              (("1" (split -1)
                                (("1" (inst?) (("1" (assert) nil nil)) nil)
                                 ("2" (expand "complete_trans")
                                  (("2" (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      (("1"
                                        (split 2)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (split 2)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2 3)
                              (("2" (rewrite "nonempty_exists")
                                (("2" (expand "total")
                                  (("2"
                                    (inst -1 "cp(s!1)" "event(pe!1)"
                                     "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                                    (("2" (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                              (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                               scp(t) = cp(s!1) AND
                                event(t) = event(pe!1) AND
                                 guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                       :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "partial")
                              (("1" (flatten)
                                (("1" (split -7)
                                  (("1" (inst?)
                                    (("1" (expand "wf_Trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split -11)
                                          (("1"
                                            (skosimp*)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (skosimp*)
                                            (("2"
                                              (inst?)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (split 3)
                                    (("1" (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand "build_guard")
                                                  (("1"
                                                    (inst? -18)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand "all_guards")
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                               "stP(pe!1)" "arg(pe!1)")
                              (("2" (assert)
                                (("2" (typepred "s!1")
                                  (("2" (typepred "pe!1")
                                    (("2" (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVACompletion nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (a!1 skolem-const-decl "(partial)" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil))
   962 900 t shostak)))
(EmptyMVA
 (unit_TCC1 0
  (unit_TCC1-1 nil 3413191968 3430124198
   ("" (use "CP_not_only_halted") (("" (skosimp*) (("" (inst?) nil nil)) nil))
    nil)
   proved
   ((CP formal-nonempty-type-decl nil EmptyMVA nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Name formal-nonempty-type-decl nil EmptyMVA nil)
    (halted const-decl "CP" MVA nil)
    (cp!1 skolem-const-decl "CP" EmptyMVA nil)
    (CP_not_only_halted formula-decl nil EmptyMVA nil))
   124 120 t nil))
 (empty_TCC1 0
  (empty_TCC1-1 nil 3413191968 3430124198 ("" (subtype-tcc) nil nil) proved
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   8 10 nil nil))
 (empty_TCC2 0
  (empty_TCC2-1 nil 3413191968 3430124198 ("" (subtype-tcc) nil nil) proved
   ((extend const-decl "R" extend nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props
     nil)
    (finite_extend application-judgement "finite_set[T]" extend_set_props nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (choose const-decl "(p)" sets nil) (emptyset const-decl "set" sets nil)
    (Name formal-nonempty-type-decl nil EmptyMVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (CP formal-nonempty-type-decl nil EmptyMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil))
   388 340 nil nil)))

