(EventType)
(MVA
 (get_MVAVarDecl_TCC1 0
  (get_MVAVarDecl_TCC1-1 nil 3411366436 3412072564
   ("" (subtype-tcc) nil nil) proved
   ((member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   22 20 nil nil)))
(WellFormedMVA)
(MVAProperties)
(MVACommonSemantics
 (update_yields_wf_Store 0
  (update_yields_wf_Store-1 nil 3411366922 3412072564
   (";;; Proof for formula MVASemantics.update_yields_wf_Store"
    (skosimp*)
    ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
      (expand* "wf_Store" "update")
      ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
        (skolem!)
        ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
          (lift-if)
          ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
            (assert)
            ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
              (expand "defined?")
              ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
                (assert)
                ((";;; Proof for formula MVASemantics.update_yields_wf_Store"
                  (split 1)
                  (("1" (skosimp*)
                    (("1" (assert) (("1" (grind) nil)))))
                   ("2" (skosimp*)
                    (("2" (inst -1 "n!2") nil))))))))))))))))))
    "")
   proved
   ((update const-decl "Store" MVACommonSemantics nil)
    (wf_Store const-decl "boolean" MVACommonSemantics nil)
    (defined? const-decl "boolean" ValProp nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil))
   391 360 nil nil))
 (execute_action_TCC1 0
  (execute_action_TCC1-1 nil 3411366856 3412072564
   ("" (subtype-tcc) nil nil) proved nil 12 10 nil nil))
 (execute_action_TCC2 0
  (execute_action_TCC2-1 nil 3411366856 3412072564
   ("" (termination-tcc) nil nil) proved
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   29 30 nil nil))
 (execute_action_yields_wf_state 0
  (execute_action_yields_wf_state-1 nil 3411366948 3412072565
   (";;; Proof for formula MVASemantics.execute_action_yields_wf_state"
    (induct "l")
    (("1" (skosimp)
      (("1" (expand "execute_action") (("1" (propax) nil)))))
     ("2" (skosimp*)
      (("2" (expand "execute_action" 1)
        (("2" (inst?)
          (("2" (assert)
            (("2" (split)
              (("1" (hide -1 -2 2)
                (("1" (expand "wf_Action")
                  (("1" (skosimp)
                    (("1" (inst?)
                      (("1" (expand "member" -2)
                        (("1" (assert) nil)))))))))))
               ("2" (hide 2)
                (("2" (expand* "wf_Store" "wf_Action")
                  (("2" (expand "wf_Store")
                    (("2" (skosimp)
                      (("2" (inst?)
                        (("2" (inst?)
                          (("2" (expand* "member" "update")
                            (("2" (lift-if)
                              (("2"
                                (prop)
                                (("1"
                                  (use "eval_yields_not_bottom")
                                  (("1" (assert) nil)))
                                 ("2"
                                  (assert)
                                  nil))))))))))))))))))))))))))))))
    "")
   proved
   ((update const-decl "Store" MVACommonSemantics nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (eval const-decl "Val" MVACommonSemantics nil)
    (member def-decl "bool" list_props nil)
    (eval_yields_not_bottom formula-decl nil MVACommonSemantics nil)
    (list_induction formula-decl nil list_adt nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil)
    (CP formal-nonempty-type-decl nil MVACommonSemantics nil)
    (OneAction type-eq-decl nil MVA nil)
    (execute_action def-decl "Store" MVACommonSemantics nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_Store const-decl "boolean" MVACommonSemantics nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Action type-eq-decl nil MVA nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   439 370 nil nil))
 (initial_MVA_state_TCC1 0
  (initial_MVA_state_TCC1-1 nil 3411367276 3412072565
   ("" (subtype-tcc) nil nil) proved
   ((member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   96 90 nil nil))
 (wf_initial_MVA_state 0
  (wf_initial_MVA_state-1 nil 3411367324 3412072566
   (";;; Proof for formula MVASemantics.wf_initial_MVA_state"
    (skosimp*)
    ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
      (expand* "wf_AState" "initial_MVA_state" "wf_MVA")
      ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
        (flatten)
        ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
          (assert)
          ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
            (expand "wf_Store")
            ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
              (skosimp*)
              ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
                (expand "defined?")
                ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
                  (lift-if)
                  ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
                    (assert)
                    ((";;; Proof for formula MVASemantics.wf_initial_MVA_state"
                      (split 2)
                      (("1" (skosimp*) (("1" (grind) nil)))
                       ("2" (skosimp*)
                        (("2"
                          (typepred
                           "init_val(down(get_MVAVarDecl(n!1, a!1)))")
                          (("2" (expand "defined?")
                            (("2" (assert)
                              (("2"
                                (expand "get_MVAVarDecl" 2)
                                (("2"
                                  (lift-if)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (split 2)
                                      (("1" (propax) nil)
                                       ("2"
                                        (expand "empty?")
                                        (("2"
                                          (expand "member")
                                          (("2"
                                            (skosimp*)
                                            (("2"
                                              (expand "var_names")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (assert)
                                                  nil))))))))))))))))))))))))))))))))))))))))))))))
    "")
   proved
   ((initial_MVA_state const-decl "AState" MVACommonSemantics nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (get_MVAVarDecl const-decl "lift[MVAVarDecl]" MVA nil)
    (CP formal-nonempty-type-decl nil MVACommonSemantics nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (choose const-decl "(p)" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (FieldDecl type-eq-decl nil Program nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon const-decl "T" epsilons nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVA type-eq-decl nil MVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (lift type-decl nil lift_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_Store const-decl "boolean" MVACommonSemantics nil))
   1073 990 nil nil)))
(MVAPartialSemantics
 (step_TCC1 0
  (step_TCC1-1 nil 3411367277 3412072566 ("" (subtype-tcc) nil nil)
   proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVA type-eq-decl nil MVA nil) (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_Store const-decl "boolean" MVACommonSemantics nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   500 460 nil nil))
 (step_yields_wf_state 0
  (step_yields_wf_state-1 nil 3411367568 3412072567
   ("" (skolem-typepred)
    (("" (skosimp*)
      (("" (expand* "wf_AState" "wf_PEvent" "step")
        (("" (lift-if)
          (("" (assert)
            ((""
              (apply (branch (split -4)
                      ((then (flatten) (assert) (flatten) (assert)))))
              ((""
                (apply (branch (split 1)
                        ((then (flatten) (assert) (flatten)
                          (assert)))))
                (("" (hide -2)
                  ((""
                    (name "t1" "choose(LAMBDA (t: Transition):
                                                                  ts(a!1)(t) AND
                                                                  scp(t) = cp(s!1) AND
                                                                  event(t) = event(pe!1) AND
                                                                  guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))")
                    (("1" (replace -1)
                      (("1" (hide -2)
                        (("1" (assert)
                          (("1" (expand "wf_MVA")
                            (("1" (flatten)
                              (("1"
                                (inst -10 "t1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "wf_Trans")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (use
                                           "execute_action_yields_wf_state")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite "nonempty_exists")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((nonempty_exists formula-decl nil sets_lemmas nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVAPartialSemantics nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVAPartialSemantics
     nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVAPartialSemantics nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVAPartialSemantics nil)
    (execute_action_yields_wf_state formula-decl nil MVACommonSemantics
     nil)
    (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   350 320 t shostak))
 (complete_definedness 0
  (complete_definedness-1 nil 3411708261 3412072567
   ("" (skosimp*)
    (("" (expand "step")
      (("" (lift-if)
        (("" (assert)
          (("" (split 1)
            (("1" (propax) nil nil)
             ("2" (typepred "a!1")
              (("2" (expand "complete")
                (("2" (flatten)
                  (("2" (expand "total")
                    (("2"
                      (inst -5 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                       "stP(pe!1)" "arg(pe!1)")
                      (("2" (typepred "pe!1" "s!1")
                        (("2" (expand* "wf_PEvent" "wf_AState")
                          (("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (total const-decl "boolean" MVAProperties nil))
   133 100 t shostak)))
(MVATotalSemantics
 (step_TCC1 0
  (step_TCC1-2 nil 3411367180 3412072567
   (";;; Proof for formula MVASemantics.step_TCC1" (skosimp*)
    ((";;; Proof for formula MVASemantics.step_TCC1" (typepred "a!1")
      ((";;; Proof for formula MVASemantics.step_TCC1" (expand "total")
        ((";;; Proof for formula MVASemantics.step_TCC1"
          (typepred "s!1")
          ((";;; Proof for formula MVASemantics.step_TCC1"
            (expand "wf_AState")
            ((";;; Proof for formula MVASemantics.step_TCC1" (flatten)
              ((";;; Proof for formula MVASemantics.step_TCC1"
                (inst -3 "cp(s!1)" "event(pe!1)" "stA(s!1)" "stP(pe!1)"
                 "arg(pe!1)")
                ((";;; Proof for formula MVASemantics.step_TCC1"
                  (assert)
                  ((";;; Proof for formula MVASemantics.step_TCC1"
                    (typepred "pe!1")
                    ((";;; Proof for formula MVASemantics.step_TCC1"
                      (expand "wf_PEvent")
                      ((";;; Proof for formula MVASemantics.step_TCC1"
                        (flatten)
                        ((";;; Proof for formula MVASemantics.step_TCC1"
                          (assert)
                          ((";;; Proof for formula MVASemantics.step_TCC1"
                            (skosimp*)
                            ((";;; Proof for formula MVASemantics.step_TCC1"
                              (rewrite "nonempty_exists")
                              ((";;; Proof for formula MVASemantics.step_TCC1"
                                (inst 1 "t!1")
                                ((";;; Proof for formula MVASemantics.step_TCC1"
                                  (assert)
                                  nil))))))))))))))))))))))))))))))
    "")
   proved
   ((total const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVATotalSemantics nil)
    (Name formal-nonempty-type-decl nil MVATotalSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (a!1 skolem-const-decl "(total[CP, Name])" MVATotalSemantics nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVATotalSemantics
     nil)
    (s!1 skolem-const-decl "(wf_AState[CP, Name](a!1))"
     MVATotalSemantics nil)
    (pe!1 skolem-const-decl "(wf_PEvent[CP, Name](a!1))"
     MVATotalSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil))
   102 100 nil nil)
  (step_TCC1-1 nil 3411367080 3411367108 ("" (subtype-tcc) nil nil)
   unfinished nil 1421 1420 nil nil))
 (step_yields_wf_state 0
  (step_yields_wf_state-1 nil 3411367156 3412072567
   (";;; Proof for formula MVASemantics.step_yields_wf_state"
    (skolem-typepred)
    ((";;; Proof for formula MVASemantics.step_yields_wf_state"
      (expand* "wf_AState" "wf_PEvent" "step")
      ((";;; Proof for formula MVASemantics.step_yields_wf_state"
        (name "t1" "choose(LAMBDA (t: Transition):
                                                           ts(a!1)(t) AND
                                                           scp(t) = cp(s!1) AND
                                                           event(t) = event(pe!1) AND
                                                           guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))")
        (("1" (replace -1)
          (("1" (skosimp*)
            (("1" (assert)
              (("1" (expand "wf_MVA")
                (("1" (flatten)
                  (("1" (inst -11 "t1")
                    (("1" (assert)
                      (("1" (expand "wf_Trans")
                        (("1" (flatten)
                          (("1" (assert)
                            (("1"
                              (use "execute_action_yields_wf_state")
                              (("1" (assert) nil)))))))))))))))))))))))
         ("2" (use "step_TCC1") nil))))))
    "")
   proved
   ((step const-decl "AState" MVATotalSemantics nil)
    (step_TCC1 subtype-tcc nil MVATotalSemantics nil)
    (execute_action_yields_wf_state formula-decl nil MVACommonSemantics
     nil)
    (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (total const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVATotalSemantics nil)
    (Name formal-nonempty-type-decl nil MVATotalSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   176 150 nil nil)))
(MVAMonitoring
 (guard_to_expression_TCC1 0
  (guard_to_expression_TCC1-2 nil 3411366716 3412074297
   (""
    (inst 1 "LAMBDA(m : MVA)(g : Guard)(v : ValOrExcpt) : Const(Unit)")
    (("" (expand "defined?") (("" (propax) nil nil)) nil)) nil)
   proved
   ((Unit adt-constructor-decl "(Unit?)" Val_adt nil)
    (Unit? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (Const adt-constructor-decl "[(defined?) -> (Const?)]" Body_adt
     nil)
    (Expr type-eq-decl nil Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Body type-decl nil Body_adt nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAMonitoring nil)
    (Name formal-nonempty-type-decl nil MVAMonitoring nil))
   14980 60 t nil)
  (guard_to_expression_TCC1-1 nil 3411366569 3411366576
   ("" (existence-tcc) nil nil) unfinished nil 142 140 nil nil)))
(MVACompletion
 (all_guards_TCC1 0
  (all_guards_TCC1-1 nil 3382264515 3412072568
   ("" (skosimp*)
    (("" (typepred "ts(a!1)")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1" "LAMBDA(p : ({p: Guard[CP, Name] |
                     EXISTS (t: Transition[CP, Name]):
                       ts(a!1)(t) AND
                        scp(t) = cp!1 AND
                         event(t) = e!1 AND guard(t) = p})) : f!1(choose({t : Transition[CP, Name] | ts(a!1)(t) AND
                        scp(t) = cp!1 AND
                         event(t) = e!1 AND guard(t) = p}))")
            (("1" (expand "injective?")
              (("1" (skosimp*)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skosimp*)
                        (("3" (inst?) (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2" (typepred "p!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skosimp*)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Action type-eq-decl nil MVA nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (p!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (x2!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Store type-eq-decl nil State nil) (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil))
   578 520 t nil))
 (complete_trans_TCC1 0
  (complete_trans_TCC1-3 nil 3382265153 3412072568
   ("" (skosimp*)
    (("" (use "finite_union[Transition[CP, Name]]")
      (("1" (hide 2)
        (("1" (typepred "evs(a!1)")
          (("1" (expand "is_finite")
            (("1" (skosimp*)
              (("1"
                (inst 1 "N!1" "LAMBDA(t1 : ({t: Transition[CP, Name] |
                               scp(t) = halted[CP, Name] AND evs(a!1)(event(t))
                           AND guard(t) =
                                (LAMBDA (stA: Store[Name], stP: PSt[Name], arg : ValOrExcpt): TRUE)
                           AND action(t) = skip[CP, Name]
                           AND tcp(t) = halted[CP, Name]})) : f!1(event(t1))")
                (("1" (expand "injective?")
                  (("1" (skosimp*)
                    (("1" (apply-extensionality :hide? t)
                      (("1" (inst -1 "event(x1!1)" "event(x2!1)")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (typepred "cps(a!1)")
          (("2" (typepred "evs(a!1)")
            (("2" (expand "is_finite")
              (("2" (skosimp*)
                (("2" (case "N!1 = 0")
                  (("1"
                    (inst 1 "N!2"
                     "LAMBDA(t : ({t: Transition[CP, Name] |
                                      cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                  AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                  AND action(t) = skip[CP, Name]
                                  AND tcp(t) = halted[CP, Name]})) : f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1" (typepred "f!1(x2!1`event)")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst 2 "N!1 + N!1 * N!2"
                     "LAMBDA(t : ({t: Transition[CP, Name] |
                                          cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                      AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                      AND action(t) = skip[CP, Name]
                                      AND tcp(t) = halted[CP, Name]})) : f!1(event(t)) + N!1 * f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1"
                          (use "unique_quotient"
                               ("b"
                                "N!1"
                                "q1"
                                "f!2(scp(x1!1))"
                                "q2"
                                "f!2(scp(x2!1))"
                                "r1"
                                "f!1(event(x1!1))"
                                "r2"
                                "f!1(event(x2!1))"))
                          (("1" (assert)
                            (("1" (inst -2 "event(x1!1)" "event(x2!1)")
                              (("1"
                                (inst -3 "scp(x1!1)" "scp(x2!1)")
                                (("1"
                                  (assert)
                                  (("1"
                                    (apply-extensionality 2 :hide? t)
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (typepred "f!1(event(t!1))")
                        (("2" (typepred "f!2(scp(t!1))")
                          (("2" (use "lt_plus_lt1")
                            (("2" (split -1)
                              (("1" (propax) nil nil)
                               ("2" (assert) nil nil)
                               ("3"
                                (use "both_sides_times_pos_lt2")
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_union judgement-tcc nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Action type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (TRUE const-decl "bool" booleans nil)
    (halted const-decl "CP" MVA nil) (skip const-decl "Action" MVA nil)
    (list type-decl nil list_adt nil)
    (OneAction type-eq-decl nil MVA nil)
    (Expr type-eq-decl nil Body_adt nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (unique_quotient formula-decl nil euclidean_division nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N!1 skolem-const-decl "nat" MVACompletion nil)
    (f!1 skolem-const-decl "[(evs(a!1)) -> below[N!1]]" MVACompletion
     nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N!2 skolem-const-decl "nat" MVACompletion nil)
    (f!2 skolem-const-decl "[(cps(a!1)) -> below[N!2]]" MVACompletion
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   597 490 t nil)
  (complete_trans_TCC1-2 nil 3382265133 nil ("" (skip) nil nil)
   unchecked nil nil nil nil nil)
  (complete_trans_TCC1-1 nil 3382264515 3382264991
   ("" (subtype-tcc) nil nil) unfinished nil 32426 31994 nil nil))
 (build_guard_yields_wf_guard 0
  (build_guard_yields_wf_guard-1 nil 3387785549 3412072580
   ("" (skosimp)
    (("" (expand* "wf_Guard" "wf_MVA" "build_guard" "all_guards")
      (("" (flatten)
        (("" (skosimp)
          (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_MVA const-decl "boolean" WellFormedMVA nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (Transition type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil))
   11360 10940 t shostak))
 (complete_MVA_yields_wf_MVA 0
  (complete_MVA_yields_wf_MVA-1 nil 3387108138 3412072581
   ("" (skolem-typepred)
    (("" (expand "wf_MVA")
      (("" (prop)
        (("1"
          (expand* "complete_MVA" "init_cp" "add" "member"
           "complete_MVA_pre")
          (("1" (prop) nil nil)) nil)
         ("2" (expand* "wf_vdsA" "complete_MVA") nil nil)
         ("3" (expand* "wf_vdsP" "complete_MVA") nil nil)
         ("4" (expand "complete_MVA") (("4" (propax) nil nil)) nil)
         ("5" (expand "complete_MVA") (("5" (propax) nil nil)) nil)
         ("6" (expand "wf_Trans")
          (("6" (skosimp)
            (("6" (inst? -6)
              (("6" (expand "complete_MVA" -1)
                (("6" (expand* "union" "member")
                  (("6" (split -1)
                    (("1" (assert)
                      (("1" (flatten) (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (expand* "complete_trans" "union" "member")
                      (("2" (split -1)
                        (("1" (flatten)
                          (("1" (hide -7 -8 -9 -10)
                            (("1" (use "build_guard_yields_wf_guard")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (hide -3 -4 -5 -6)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_Trans const-decl "boolean" WellFormedMVA nil)
    (union const-decl "set" sets nil)
    (build_guard_yields_wf_guard formula-decl nil MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (member def-decl "bool" list_props nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (skip const-decl "Action" MVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1234 1130 t shostak))
 (complete_MVA_has_trap_state_TCC1 0
  (complete_MVA_has_trap_state_TCC1-1 nil 3382264515 3412072581
   ("" (use "complete_MVA_yields_wf_MVA") nil nil) proved
   ((complete_MVA_yields_wf_MVA formula-decl nil MVACompletion nil)) 3
   0 t nil))
 (complete_MVA_has_trap_state 0
  (complete_MVA_has_trap_state-3 nil 3411368153 3412072581
   (";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
    (skolem-typepred)
    ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
      (expand* "trap_state" "complete_MVA")
      ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
        (skosimp)
        ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
          (expand* "complete_trans" "union" "member"
           "good_for_monitoring" "wf_MVA")
          ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
            (prop)
            ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
              (inst?)
              ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
                (expand "wf_Trans")
                ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
                  (prop)
                  ((";;; Proof complete_MVA_has_trap_state-2 for formula MVACompletion.complete_MVA_has_trap_state"
                    (assert) nil))))))))))))))))
    ";;; developed with shostak decision procedures")
   proved
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (trap_state const-decl "boolean" MVAProperties nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   270 220 nil nil)
  (complete_MVA_has_trap_state-2 nil 3383048645 3411368119
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        ((""
          (expand* "complete_trans" "union" "member" "complete_MVA_pre"
           "wf_MVA")
          (("" (prop)
            (("" (inst?)
              (("" (expand "wf_Trans")
                (("" (prop) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (trap_state const-decl "boolean" MVAProperties nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   284 250 t nil)
  (complete_MVA_has_trap_state-1 nil 3382270875 3382270880
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        ((""
          (expand* "complete_trans" "union" "member" "complete_MVA_pre"
           "valid_MVA")
          (("" (prop)
            (("" (inst?) (("" (prop) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   295 42 t nil))
 (complete_MVA_is_deterministic 0
  (complete_MVA_is_deterministic-3 nil 3411368112 3412072591
   (";;; Proof complete_MVA_is_deterministic-2 for formula MVACompletion.complete_MVA_is_deterministic"
    (expand "deterministic")
    ((";;; Proof complete_MVA_is_deterministic-2 for formula MVACompletion.complete_MVA_is_deterministic"
      (skolem-typepred)
      ((";;; Proof complete_MVA_is_deterministic-2 for formula MVACompletion.complete_MVA_is_deterministic"
        (skosimp)
        ((";;; Proof complete_MVA_is_deterministic-2 for formula MVACompletion.complete_MVA_is_deterministic"
          (expand "good_for_monitoring")
          ((";;; Proof complete_MVA_is_deterministic-2 for formula MVACompletion.complete_MVA_is_deterministic"
            (flatten)
            ((";;; Proof complete_MVA_is_deterministic-2 for formula MVACompletion.complete_MVA_is_deterministic"
              (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1" "arg!1")
                  (("1"
                    (expand* "wf_Store" "wf_PSt" "complete_MVA"
                     "complete_trans" "union" "member")
                    (("1" (prop) nil)))))))
               ("2" (expand "complete_MVA" -5)
                (("2" (expand "complete_trans")
                  (("2" (expand "union")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (prop)
                          (("1" (assert)
                            (("1" (replace -3)
                              (("1"
                                (expand "build_guard")
                                (("1"
                                  (expand "all_guards")
                                  (("1"
                                    (inst? -13)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst 3 "t1!1")
                                        (("1"
                                          (assert)
                                          nil)))))))))))))))
                           ("2" (grind) nil)))))))))))))
               ("3" (expand "complete_MVA" -4)
                (("3" (expand "complete_trans")
                  (("3" (expand "union")
                    (("3" (expand "member")
                      (("3" (assert)
                        (("3" (prop)
                          (("1" (replace -3)
                            (("1" (expand "build_guard")
                              (("1"
                                (inst? -12)
                                (("1"
                                  (expand "all_guards")
                                  (("1"
                                    (inst 3 "t2!1")
                                    (("1" (assert) nil)))))))))))
                           ("2" (expand "wf_MVA")
                            (("2" (flatten)
                              (("2"
                                (inst -11 "t2!1")
                                (("2"
                                  (expand "wf_Trans")
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (grind)
                                      nil)))))))))))))))))))))))
               ("4" (apply-extensionality 4 :hide? t)
                (("1" (grind) nil) ("2" (grind) nil)
                 ("3" (grind) nil))))))))))))))
    ";;; developed with shostak decision procedures")
   proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (skip const-decl "Action" MVA nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (deterministic const-decl "boolean" MVAProperties nil))
   9750 9330 nil nil)
  (complete_MVA_is_deterministic-2 nil 3383048795 3411368092
   ("" (expand "deterministic")
    (("" (skolem-typepred)
      (("" (skosimp)
        (("" (expand "complete_MVA_pre")
          (("" (flatten)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1" "arg!1")
                  (("1"
                    (expand* "wf_Store" "wf_PSt" "complete_MVA"
                     "complete_trans" "union" "member")
                    (("1" (prop) nil nil)) nil))
                  nil))
                nil)
               ("2" (expand "complete_MVA" -5)
                (("2" (expand "complete_trans")
                  (("2" (expand "union")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (prop)
                          (("1" (assert)
                            (("1" (replace -3)
                              (("1"
                                (expand "build_guard")
                                (("1"
                                  (expand "all_guards")
                                  (("1"
                                    (inst? -13)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst 3 "t1!1")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "complete_MVA" -4)
                (("3" (expand "complete_trans")
                  (("3" (expand "union")
                    (("3" (expand "member")
                      (("3" (assert)
                        (("3" (prop)
                          (("1" (replace -3)
                            (("1" (expand "build_guard")
                              (("1"
                                (inst? -12)
                                (("1"
                                  (expand "all_guards")
                                  (("1"
                                    (inst 3 "t2!1")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "wf_MVA")
                            (("2" (flatten)
                              (("2"
                                (inst -11 "t2!1")
                                (("2"
                                  (expand "wf_Trans")
                                  (("2"
                                    (flatten)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (apply-extensionality 4 :hide? t)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (skip const-decl "Action" MVA nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (deterministic const-decl "boolean" MVAProperties nil))
   12635 5840 t nil)
  (complete_MVA_is_deterministic-1 nil 3382270657 3382270846
   ("" (skolem-typepred)
    (("" (expand* "deterministic" "complete_MVA")
      (("" (skosimp)
        (("" (expand "complete_MVA_pre")
          (("" (flatten -2)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1")
                  (("1" (prop)
                    (("1" (expand "valid_PSt") (("1" (propax) nil nil))
                      nil)
                     ("2" (expand "valid_Store")
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -3 -6 -7)
                (("2" (expand "complete_trans" -4)
                  (("2" (expand "union" -4)
                    (("2" (expand "member" -4)
                      (("2" (prop)
                        (("1" (delete -8 1)
                          (("1" (expand "valid_MVA")
                            (("1" (prop)
                              (("1"
                                (inst -9 "t1!1")
                                (("1"
                                  (prop)
                                  (("1"
                                    (delete -4 -5)
                                    (("1"
                                      (grind)
                                      (("1" (postpone) nil nil)
                                       ("2" (postpone) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (delete -3 -5 -6 -7)
                (("3" (expand* "complete_trans" "union" "member")
                  (("3" (prop)
                    (("1" (grind)
                      (("1" (postpone) nil nil)
                       ("2" (postpone) nil nil))
                      nil)
                     ("2" (expand "valid_MVA")
                      (("2" (prop)
                        (("2" (inst -9 "t2!1")
                          (("2" (prop)
                            (("2" (delete -4 -5)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (delete -1 -2 -5 -6)
                (("4" (grind)
                  (("1" (decompose-equality 4) nil nil)
                   ("2" (decompose-equality 4) nil nil)
                   ("3" (postpone) nil nil) ("4" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried nil 18669 3635 t nil))
 (complete_MVA_is_total 0
  (complete_MVA_is_total-3 nil 3410259686 3412072592
   (";;; Proof complete_MVA_is_total-2 for formula MVACompletion.complete_MVA_is_total"
    (skolem-typepred)
    ((";;; Proof complete_MVA_is_total-2 for formula MVACompletion.complete_MVA_is_total"
      (expand* "total" "complete_MVA")
      ((";;; Proof complete_MVA_is_total-2 for formula MVACompletion.complete_MVA_is_total"
        (skosimp)
        ((";;; Proof complete_MVA_is_total-2 for formula MVACompletion.complete_MVA_is_total"
          (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
          (("1" (skolem!)
            (("1" (inst 1 "t!1")
              (("1" (expand* "union" "member") (("1" (prop) nil)))))))
           ("2" (case "q!1 = halted")
            (("1" (hide 1)
              (("1"
                (inst +
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: Store , stP: PSt, arg : ValOrExcpt): TRUE), action := skip, tcp := halted #)")
                (("1" (expand* "wf_MVA" "complete_MVA_pre")
                  (("1" (flatten)
                    (("1" (replace -1) (("1" (grind) nil)))))))))))
             ("2" (delete 2)
              (("2"
                (case "EXISTS (t: Transition): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
                (("1" (skolem!)
                  (("1" (inst + "t!1") (("1" (grind) nil)))))
                 ("2"
                  (inst 3
                   "(# scp := q!1, event := e!1, guard := build_guard(a!1)(q!1, e!1), action := skip, tcp := halted #)")
                  (("2" (grind) nil))))))))))))))))
    ";;; developed with shostak decision procedures")
   proved
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (add const-decl "(nonempty?)" sets nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (TRUE const-decl "bool" booleans nil)
    (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (skip const-decl "Action" MVA nil) (halted const-decl "CP" MVA nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1511 1410 nil nil)
  (complete_MVA_is_total-2 nil 3383048587 3410259477
   ("" (skolem-typepred)
    (("" (expand* "total" "complete_MVA")
      (("" (skosimp)
        ((""
          (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
          (("1" (skolem!)
            (("1" (inst 1 "t!1")
              (("1" (expand* "union" "member") (("1" (prop) nil nil))
                nil))
              nil))
            nil)
           ("2" (case "q!1 = halted")
            (("1" (hide 1)
              (("1"
                (inst +
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: Store , stP: PSt, arg : (defined?)): TRUE), action := skip, tcp := halted #)")
                (("1" (expand* "wf_MVA" "complete_MVA_pre")
                  (("1" (flatten)
                    (("1" (replace -1) (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2"
                (case "EXISTS (t: Transition): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
                (("1" (skolem!)
                  (("1" (inst + "t!1") (("1" (grind) nil nil)) nil))
                  nil)
                 ("2"
                  (inst 3
                   "(# scp := q!1, event := e!1, guard := build_guard(a!1)(q!1, e!1), action := skip, tcp := halted #)")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (add const-decl "(nonempty?)" sets nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (TRUE const-decl "bool" booleans nil)
    (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (skip const-decl "Action" MVA nil) (halted const-decl "CP" MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   3936 3870 t nil)
  (complete_MVA_is_total-1 nil 3382265612 3382270601
   ("" (skolem-typepred)
    (("" (expand "total")
      (("" (skosimp)
        (("" (expand "complete_MVA" 1)
          ((""
            (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1)")
            (("1" (skolem!)
              (("1" (inst 1 "t!1")
                (("1" (expand "union" 1)
                  (("1" (expand "member" 1) (("1" (prop) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "q!1 = halted")
              (("1"
                (inst 2
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: (valid_Store(vdsA(a!1))) , stP: (valid_PSt(vdsP(a!1)))): TRUE), action := skip, tcp := halted #)")
                (("1" (hide -6 -7 1) (("1" (postpone) nil nil)) nil))
                nil)
               ("2"
                (inst 3
                 "(# scp := q!1, event := e!1, guard := build_guard(q!1, e!1, ts(a!1), vdsA(a!1), vdsP(a!1)), action := skip, tcp := halted #)")
                (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried nil 46487 3476 t nil))
 (complete_MVA_is_complete 0
  (complete_MVA_is_complete-1 nil 3382265489 3412072593
   ("" (skolem-typepred)
    (("" (expand "complete")
      (("" (split)
        (("1" (use "complete_MVA_yields_wf_MVA") nil nil)
         ("2" (expand "complete_MVA")
          (("2" (expand "add") (("2" (propax) nil nil)) nil)) nil)
         ("3" (use "complete_MVA_has_trap_state") nil nil)
         ("4" (use "complete_MVA_is_deterministic") nil nil)
         ("5" (use "complete_MVA_is_total") nil nil))
        nil))
      nil))
    nil)
   proved
   ((complete const-decl "boolean" MVAProperties nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (complete_MVA_is_deterministic formula-decl nil MVACompletion nil)
    (complete_MVA_has_trap_state formula-decl nil MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_MVA_yields_wf_MVA formula-decl nil MVACompletion nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   568 500 t nil))
 (completion_equivalence_TCC1 0
  (completion_equivalence_TCC1-1 nil 3411913637 3412072593
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil) (JType type-decl nil JType_adt nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subset? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_Store const-decl "boolean" MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil))
   388 350 nil nil))
 (completion_equivalence_TCC2 0
  (completion_equivalence_TCC2-1 nil 3411913637 3412072594
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil) (JType type-decl nil JType_adt nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Store const-decl "boolean" MVACommonSemantics nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil))
   426 350 nil nil))
 (completion_equivalence_TCC3 0
  (completion_equivalence_TCC3-1 nil 3411913637 3412072594
   ("" (skosimp*) (("" (use "complete_MVA_is_total") nil nil)) nil)
   proved
   ((good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil))
   126 120 t nil))
 (completion_equivalence 0
  (completion_equivalence-1 nil 3411913637 3412072595
   ("" (skosimp*)
    (("" (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                      (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                       scp(t) = cp(s!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                             :hide? t)
                            (("1" (typepred "t")
                              (("1"
                                (split -1)
                                (("1"
                                  (inst?)
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (expand "complete_trans")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2 3)
                              (("2"
                                (rewrite "nonempty_exists")
                                (("2"
                                  (expand "total")
                                  (("2"
                                    (inst
                                     -1
                                     "cp(s!1)"
                                     "event(pe!1)"
                                     "stA(s!1)"
                                     "stP(pe!1)"
                                     "arg(pe!1)")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                      (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                       scp(t) = cp(s!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                       :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "good_for_monitoring")
                              (("1"
                                (flatten)
                                (("1"
                                  (split -7)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (expand "wf_Trans")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (split 3)
                                    (("1"
                                      (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand
                                                   "build_guard")
                                                  (("1"
                                                    (inst? -18)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "all_guards")
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)"
                               "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                              (("2"
                                (assert)
                                (("2"
                                  (typepred "s!1")
                                  (("2"
                                    (typepred "pe!1")
                                    (("2"
                                      (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((step const-decl "AState" MVATotalSemantics nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVACompletion nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (a!1 skolem-const-decl "(good_for_monitoring)" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil))
   1153 1040 t shostak))
 (complete_MVA_correctness 0
  (complete_MVA_correctness-1 nil 3411733716 3412072595
   ("" (expand "correct_completion_function")
    (("" (skosimp)
      (("" (split)
        (("1" (skosimp)
          (("1" (expand "complete_MVA") (("1" (assert) nil nil)) nil))
          nil)
         ("2" (expand* "subset?" "complete_MVA" "union" "member")
          (("2" (skosimp) nil nil)) nil)
         ("3" (skosimp)
          (("3" (expand* "difference" "complete_MVA" "union" "member")
            (("3" (prop)
              (("3" (expand* "complete_trans" "union" "member")
                (("3" (prop) nil nil)) nil))
              nil))
            nil))
          nil)
         ("4" (use "complete_MVA_is_complete") nil nil))
        nil))
      nil))
    nil)
   proved
   ((good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (complete_MVA_is_complete formula-decl nil MVACompletion nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion
     nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (correct_completion_function const-decl "boolean" MVACompletion
     nil))
   184 170 t shostak))
 (complete_function_correctness_implication_TCC1 0
  (complete_function_correctness_implication_TCC1-1 nil 3411802660
   3412072596
   ("" (skosimp*)
    (("" (expand* "correct_completion_function" "restrict")
      (("" (inst?)
        (("" (flatten)
          (("" (expand "wf_AState")
            (("" (inst -2 "emptyset")
              (("" (split)
                (("1"
                  (case-replace
                   "cps(complete_fun!1(a!1))(cp(sa!1)) = cps(complete_fun!1(a!1) WITH [ts := emptyset])(cp(sa!1))"
                   :hide? t)
                  (("1" (replace -2 1 :dir rl)
                    (("1" (assert)
                      (("1" (expand* "add" "member")
                        (("1" (typepred "sa!1")
                          (("1" (expand "wf_AState")
                            (("1" (prop) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil)
                 ("2"
                  (case-replace
                   "vdsA(complete_fun!1(a!1)) = vdsA(complete_fun!1(a!1) WITH [ts := emptyset])"
                   :hide? t)
                  (("1" (replace -2 1 :dir rl :hide? t)
                    (("1" (assert)
                      (("1" (typepred "sa!1")
                        (("1" (expand "wf_AState")
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((restrict const-decl "R" restrict nil)
    (correct_completion_function const-decl "boolean" MVACompletion
     nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil))
   118 120 t nil))
 (complete_function_correctness_implication_TCC2 0
  (complete_function_correctness_implication_TCC2-1 nil 3411802660
   3412072596
   ("" (skosimp*)
    (("" (expand* "correct_completion_function" "restrict")
      (("" (inst?)
        (("" (flatten)
          (("" (expand "wf_PEvent")
            (("" (inst -2 "emptyset")
              (("" (split)
                (("1"
                  (case-replace
                   "evs(complete_fun!1(a!1))(event(pe!1)) = evs(complete_fun!1(a!1) WITH [ts := emptyset])(event(pe!1))"
                   :hide? t)
                  (("1" (replace -2 1 :dir rl :hide? t)
                    (("1" (assert)
                      (("1" (typepred "pe!1")
                        (("1" (expand "wf_PEvent")
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil)
                 ("2"
                  (case-replace
                   "vdsP(complete_fun!1(a!1)) = vdsP(complete_fun!1(a!1) WITH [ts := emptyset])"
                   :hide? t)
                  (("1" (replace -2 1 :dir rl :hide? t)
                    (("1" (assert)
                      (("1" (typepred "pe!1")
                        (("1" (expand "wf_PEvent")
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((restrict const-decl "R" restrict nil)
    (correct_completion_function const-decl "boolean" MVACompletion
     nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil))
   135 110 t nil))
 (complete_function_correctness_implication_TCC3 0
  (complete_function_correctness_implication_TCC3-1 nil 3411802660
   3412072596
   ("" (skosimp*)
    (("" (expand* "correct_completion_function" "restrict")
      (("" (inst?)
        (("" (flatten)
          (("" (expand "complete") (("" (flatten) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((restrict const-decl "R" restrict nil)
    (correct_completion_function const-decl "boolean" MVACompletion
     nil)
    (complete const-decl "boolean" MVAProperties nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil))
   77 70 t nil))
 (complete_function_correctness_implication 0
  (complete_function_correctness_implication-1 nil 3411802682
   3412072596
   ("" (skosimp*)
    (("" (expand* "correct_completion_function" "restrict")
      (("" (inst?)
        (("" (flatten)
          (("" (expand "step")
            (("" (lift-if)
              (("" (ground)
                ((""
                  (name-replace "t"
                   "choose(LAMBDA (t: Transition[CP, Name]):
                      ts(complete_fun!1(a!1))(t) AND
                       scp(t) = cp(sa!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(sa!1), stP(pe!1), arg(pe!1)))")
                  (("1" (typepred "t")
                    (("1" (inst -7 "t")
                      (("1" (expand* "difference" "member")
                        (("1" (assert)
                          (("1" (inst?) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (expand* "nonempty?" "empty?" "member" "complete"
                     "total")
                    (("2" (flatten)
                      (("2"
                        (inst -9 "cp(sa!1)" "event(pe!1)" "stA(sa!1)"
                         "stP(pe!1)" "arg(pe!1)")
                        (("2" (assert)
                          (("2" (split -)
                            (("1" (skosimp)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (inst -2 "emptyset")
                              (("2"
                                (hide-all-but (-2 1))
                                (("2"
                                  (case
                                   "evs(complete_fun!1(a!1))(event(pe!1)) = evs(complete_fun!1(a!1) WITH [ts := emptyset])(event(pe!1))")
                                  (("1"
                                    (replace -1 1)
                                    (("1"
                                      (replace -2 1 :dir rl)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (typepred "pe!1")
                                          (("1"
                                            (expand "wf_PEvent")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (hide-all-but (-2 1))
                              (("3"
                                (inst -1 "emptyset")
                                (("3"
                                  (case-replace
                                   "cps(complete_fun!1(a!1))(cp(sa!1)) = cps(complete_fun!1(a!1) WITH [ts := emptyset])(cp(sa!1))"
                                   :hide?
                                   t)
                                  (("1"
                                    (replace -1 1 :dir rl :hide? t)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (typepred "sa!1")
                                        (("1"
                                          (expand*
                                           "wf_AState"
                                           "add"
                                           "member")
                                          (("1" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((restrict const-decl "R" restrict nil)
    (correct_completion_function const-decl "boolean" MVACompletion
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (difference const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (total const-decl "boolean" MVAProperties nil)
    (complete const-decl "boolean" MVAProperties nil)
    (empty? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (step const-decl "AState" MVATotalSemantics nil)
    (good_for_monitoring const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil)
    (ProgVarDecl type-eq-decl nil MVA nil)
    (MVAVarDecl type-eq-decl nil MVA nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil))
   360 310 t shostak)))

