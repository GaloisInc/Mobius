WellBehavedMVA [CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            MVAMonitoring[CP, Name],
            MVACommonSemantics[CP, Name]

  mva : VAR (wf_MVA)

  % Every guard of the MVA is translated into an expression that
  % evaluates to the same result. Evaluation of the expression can not
  % result in an exception (v would be Bottom).
  % Furthermore, the evaluation must have no side-effects.
  guard_to_expression_behavior(mva)(stA : [APState -> Store]) : boolean =
    FORALL (t : Transition, p : Program, s : APState, arg : ValOrExcpt) : 
      LET e = guard_to_expression(guard(t)) IN
        ts(mva)(t) IMPLIES % t transition in MVA
        wf_Expr(p)(e(arg)) IMPLIES % e wellformed wrt p
        wf_state(p)(s) IMPLIES % s good
        NOT up?(ex(pstate(s))) IMPLIES % and non-exceptional state
          EXISTS(v : Val, n : nat) : 
          derive(p)(e(arg), s, v, s)(n) AND % evaluation of e does not 
                                            % have side effects
          v = Bool(guard(t)(stA(s), fvs(st(pstate(s))), arg))
              % evaluation of expression returns value of guard


  % Evaluation of expressions appearing in actions terminate
  % and is side-effect-free (and thus does not throw an exception)
  eval_action_behavior(mva) (stA : [APState -> Store]) : boolean =
    FORALL(t : Transition, oa : OneAction, p : Program, 
           s : APState) :
      ts(mva)(t) IMPLIES % t transition in MVA
      member(oa, action(t)) IMPLIES % oa single action in t        
      wf_state(p)(s) IMPLIES % s good and
      NOT up?(ex(pstate(s))) IMPLIES % non-exceptional state
      wf_Expr(p)(source(oa)) IMPLIES % all variables used in source(oa) 
                                     % declared in p
        EXISTS (n : nat) : 
          derive(p)(source(oa), s, 
                    eval(source(oa))(stA(s), fvs(st(pstate(s)))), s)(n)
          % derivation without side effect
          % returns value that is the same as evaluation of source(oa) in 
          % the automaton

  well_behaved_MVA(mva)(stA : [APState -> Store]) : boolean =
    guard_to_expression_behavior(mva)(stA) AND
    eval_action_behavior(mva)(stA) 

  IMPORTING MVACompletion[CP, Name]

  % some auxiliary lemmas and definitions, 
  % to prove well_behaved_MVA_preserved_by_complete
  collect_set : LEMMA % :-)
    FORALL(E : finite_set[Expr], p : Program, s : APState) :
      (FORALL(e : Expr) :
         wf_Expr(p)(e) IMPLIES
         E(e) IMPLIES 
           EXISTS(v : Val, n : nat) : derive(p)(e, s, v, s)(n) AND Bool?(v))
      IMPLIES
      EXISTS (C : finite_set[[Expr, (Bool?), nat]]) :
        FORALL(e : Expr) :
          wf_Expr(p)(e) IMPLIES
          E(e) IMPLIES
          EXISTS(c : [Expr, Val, nat]) :
            C(c) AND
            proj_1(c) = e AND
            derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))

  collect_set_equivalence : LEMMA % 
    FORALL(E : finite_set[Expr], p : Program, s : APState) :
      (EXISTS (C : finite_set[[Expr, (Bool?), nat]]) :
        FORALL(e : Expr) :
          wf_Expr(p)(e) IMPLIES
          E(e) IMPLIES
          EXISTS(c : [Expr, Val, nat]) :
            C(c) AND
            proj_1(c) = e AND
            derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))) IMPLIES
      (FORALL(e : Expr) :
         wf_Expr(p)(e) IMPLIES
         E(e) IMPLIES 
           EXISTS(v : Val, n : nat) : derive(p)(e, s, v, s)(n) AND Bool?(v))

  big_and(V : finite_set[(Bool?)]) : RECURSIVE (Bool?) =
    IF empty?(V)
    THEN Bool(TRUE)
    ELSE Bool(b(choose(V)) AND b(big_and(rest(V))))
    ENDIF
  MEASURE card(V)

  sum(N : finite_set[nat]) : RECURSIVE nat = 
    IF (empty?(N)) 
    THEN 0
    ELSE choose(N) + sum(sets[nat].rest(N))
    ENDIF 
  MEASURE card(N)


  collect_combine : LEMMA
    FORALL(C : finite_set[[Expr, (Bool?), nat]], p : Program, s : APState) :
      (FORALL (c : [Expr, (Bool?), nat]) :
         wf_Expr(p)(proj_1(c)) IMPLIES
         C(c) IMPLIES 
         derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))) IMPLIES
      LET E = {e : Expr | EXISTS(c : [Expr, (Bool?), nat]) :
                            C(c) AND proj_1(c) = e} IN
      LET V = {v : Val | EXISTS(c : [Expr, (Bool?), nat]) :
                           C(c) AND proj_2(c) = v} IN
      LET N = {n : nat | EXISTS(c : [Expr, (Bool?), nat]) :
                           C(c) AND proj_3(c) = n} IN
      derive(p)(big_conj(E), s, big_and(V), s)(sum(N))


  % remaining case: build_guard for transition from existing state to halted
  well_behaved_MVA_preserved_by_complete : LEMMA
    FORALL(mva : (partial), stA : [APState -> Store]) :
    well_behaved_MVA(mva)(stA) IMPLIES
        well_behaved_MVA(complete_MVA(mva))(stA)

END WellBehavedMVA

