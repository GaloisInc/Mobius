WellBehavedMVA [CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            MVAMonitoring[CP, Name],
            MVACommonSemantics[CP, Name]

  mva : VAR (wf_MVA)

  % Every guard of the MVA is translated into an expression that
  % evaluates to the same result. Evaluation of the expression can not
  % result in an exception (v would be Bottom).
  % Furthermore, the evaluation must have no side-effects.
  guard_to_expression_behavior(mva)(stA : [APState -> Store]) : boolean =
    FORALL (t : Transition, p : Program, s : APState, arg : ValOrExcpt) : 
      LET e = guard_to_expression(guard(t)) IN
        ts(mva)(t) IMPLIES % t transition in MVA
        wf_Expr(p)(e(arg)) IMPLIES % e wellformed wrt p
        wf_state(p)(s) IMPLIES % s good
        NOT up?(ex(pstate(s))) IMPLIES % and non-exceptional state
          EXISTS(v : Val, n : nat) : 
          derive(p)(e(arg), s, v, s)(n) AND % evaluation of e does not 
                                            % have side effects
          v = Bool(guard(t)(stA(s), fvs(st(pstate(s))), arg))
              % evaluation of expression returns value of guard


  % Evaluation of expressions appearing in actions terminate
  % and is side-effect-free (and thus does not throw an exception)
  eval_action_behavior(mva) (stA : [APState -> Store]) : boolean =
    FORALL(t : Transition, oa : OneAction, p : Program, 
           s : APState) :
      ts(mva)(t) IMPLIES % t transition in MVA
      member(oa, action(t)) IMPLIES % oa single action in t        
      wf_state(p)(s) IMPLIES % s good and
      NOT up?(ex(pstate(s))) IMPLIES % non-exceptional state
      wf_Expr(p)(source(oa)) IMPLIES % all variables used in source(oa) 
                                     % declared in p
        EXISTS (n : nat) : 
          derive(p)(source(oa), s, 
                    eval(source(oa))(stA(s), fvs(st(pstate(s)))), s)(n)
          % derivation without side effect
          % returns value that is the same as evaluation of source(oa) in 
          % the automaton

  well_behaved_MVA(mva)(stA : [APState -> Store]) : boolean =
    guard_to_expression_behavior(mva)(stA) AND
    eval_action_behavior(mva)(stA) 

  IMPORTING MVACompletion[CP, Name]

  % some auxiliary lemmas and definitions, 
  % to prove well_behaved_MVA_preserved_by_complete


  % if all components are wellformed expressions, so is the big conjunction
  big_conj_wf_Expr : LEMMA % :-)
    FORALL(p : Program)(E : finite_set[Expr]) :
      (FORALL (e : Expr) : E(e) IMPLIES wf_Expr(p)(e)) IMPLIES
      wf_Expr(p)(big_conj(E))

  % if the big conjunction is wellformed, so are all components
  big_conj_wf_Expr_components : LEMMA % :-)
    FORALL(p : Program)(E : finite_set[Expr]) :
      wf_Expr(p)(big_conj(E)) IMPLIES
        FORALL (e : Expr) : E(e) IMPLIES wf_Expr(p)(e)

  % if for every element in E a derivation exists, returning a boolean
  % value, then the derivation of big_conj(E) exists, and its value is
  % a universal quantification over all boolean values returned by the 
  % individual expressions
  big_conj_cases : LEMMA % :-)
    FORALL(E : finite_set[Expr], p : Program, s : APState) :
      (FORALL (e : Expr) :
         wf_Expr(p)(e) IMPLIES
         E(e) IMPLIES 
         EXISTS (v1 : (Bool?), n1 : nat) :
           derive(p)(e, s, v1, s)(n1)) IMPLIES    
      NOT up?(ex(pstate(s))) IMPLIES
        wf_Expr(p)(big_conj(E)) IMPLIES
      LET v = (FORALL (e : Expr) :
                 E(e) IMPLIES (EXISTS (n1 : nat) : 
                                 derive(p)(e, s, Bool(TRUE), s)(n1))) IN
          EXISTS (n : nat) : derive(p)(big_conj(E), s, Bool(v), s)(n) 

  % well_behaved_MVA is preserved by complete
  well_behaved_MVA_preserved_by_complete : LEMMA % :-)
    FORALL(mva : (partial), stA : [APState -> Store]) :
    well_behaved_MVA(mva)(stA) IMPLIES
        well_behaved_MVA(complete_MVA(mva))(stA)

END WellBehavedMVA

 
	
