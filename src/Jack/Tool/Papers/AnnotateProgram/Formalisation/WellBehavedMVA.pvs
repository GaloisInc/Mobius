WellBehavedMVA [CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            MVAMonitoring[CP, Name],
            MVACommonSemantics[CP, Name]

  mva : VAR (wf_MVA)

  % Every guard of the MVA is translated into an expression that
  % evaluates to the same result. Evaluation of the expression can not
  % result in an exception (v would be Bottom).
  % Furthermore, the evaluation must have no side-effects.
  guard_to_expression_behavior(mva)(stA : [APState -> Store]) : boolean =
    FORALL (t : Transition, p : Program, s : APState, arg : ValOrExcpt) : 
      LET e = guard_to_expression(guard(t)) IN
        ts(mva)(t) IMPLIES % t transition in MVA
        wf_Expr(p)(e(arg)) IMPLIES % e wellformed wrt p
        wf_state(p)(s) IMPLIES % s good
        NOT up?(ex(pstate(s))) IMPLIES % and non-exceptional state
          EXISTS(v : Val, n : nat) : 
          derive(p)(e(arg), s, v, s)(n) AND % evaluation of e does not 
                                            % have side effects
          v = Bool(guard(t)(stA(s), fvs(st(pstate(s))), arg))
              % evaluation of expression returns value of guard


  % Evaluation of expressions appearing in actions terminate
  % and is side-effect-free (and thus does not throw an exception)
  eval_action_behavior(mva) (stA : [APState -> Store]) : boolean =
    FORALL(t : Transition, oa : OneAction, p : Program, 
           s : APState) :
      ts(mva)(t) IMPLIES % t transition in MVA
      member(oa, action(t)) IMPLIES % oa single action in t        
      wf_state(p)(s) IMPLIES % s good and
      NOT up?(ex(pstate(s))) IMPLIES % non-exceptional state
      wf_Expr(p)(source(oa)) IMPLIES % all variables used in source(oa) 
                                     % declared in p
        EXISTS (n : nat) : 
          derive(p)(source(oa), s, 
                    eval(source(oa))(stA(s), fvs(st(pstate(s)))), s)(n)
          % derivation without side effect
          % returns value that is the same as evaluation of source(oa) in 
          % the automaton

  well_behaved_MVA(mva)(stA : [APState -> Store]) : boolean =
    guard_to_expression_behavior(mva)(stA) AND
    eval_action_behavior(mva)(stA) 

  IMPORTING MVACompletion[CP, Name]

  % some auxiliary lemmas and definitions, 
  % to prove well_behaved_MVA_preserved_by_complete
  collect_set : LEMMA % :-)
    FORALL(E : finite_set[Expr], p : Program, s : APState) :
      (FORALL(e : Expr) :
         wf_Expr(p)(e) IMPLIES
         E(e) IMPLIES 
           EXISTS(v : Val, n : nat) : derive(p)(e, s, v, s)(n) AND Bool?(v))
      IMPLIES
      EXISTS (C : finite_set[[Expr, (Bool?), nat]]) :
        FORALL(e : Expr) :
          wf_Expr(p)(e) IMPLIES
          E(e) IMPLIES
          EXISTS(c : [Expr, (Bool?), nat]) :
            C(c) AND
            proj_1(c) = e AND
            derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))

%   collect_set_equivalence : LEMMA % 
%     FORALL(E : finite_set[Expr], p : Program, s : APState) :
%       (EXISTS (C : finite_set[[Expr, (Bool?), nat]]) :
%         FORALL(e : Expr) :
%           wf_Expr(p)(e) IMPLIES
%           E(e) IMPLIES
%           EXISTS(c : [Expr, Val, nat]) :
%             C(c) AND
%             proj_1(c) = e AND
%             derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))) IMPLIES
%       (FORALL(e : Expr) :
%          wf_Expr(p)(e) IMPLIES
%          E(e) IMPLIES 
%            EXISTS(v : Val, n : nat) : derive(p)(e, s, v, s)(n) AND Bool?(v))

%   collect_set_existence : LEMMA % 
%     FORALL(E : finite_set[Expr], p : Program, s : APState) :
%       (EXISTS (C : finite_set[[Expr, (Bool?), nat]]) :
%         FORALL(e : Expr) :
%           wf_Expr(p)(e) IMPLIES
%           EXISTS(c : [Expr, Val, nat]) :
%             C(c) AND
%             proj_1(c) = e AND
%             derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))) IMPLIES
%       (FORALL(e : Expr) :
%          wf_Expr(p)(e) IMPLIES
%            EXISTS(v : Val, n : nat) : derive(p)(e, s, v, s)(n) AND Bool?(v))


  count_sum(C : finite_set[[Expr, (Bool?), nat]]) : RECURSIVE nat = 
    IF (empty?(C)) 
    THEN 0
    ELSE proj_3(choose(C)) + count_sum(rest(C)) + 1
    ENDIF 
  MEASURE card(C)

  big_conj(C : finite_set[[Expr, (Bool?), nat]]) : RECURSIVE Expr =
    IF empty?(C)
    THEN Const(Bool(TRUE))
    ELSE Conj(proj_1(choose(C)), big_conj(rest(C)))
    ENDIF
  MEASURE card(C)

%   derive_big_conj : LEMMA
%     FORALL(E : finite_set[Expr]) :
      
%       EXISTS(v : Val, n : nat) : derive(p)(big_conj(E), 
  
  IMPORTING finite_sets@finite_sets_inductions[[Expr, (Bool?), nat]]

  big_conj_wf_Expr : LEMMA % :-)
    FORALL(p : Program)(E : finite_set[Expr]) :
      (FORALL (e : Expr) : E(e) IMPLIES wf_Expr(p)(e)) IMPLIES
      wf_Expr(p)(big_conj(E))


  big_conj_wf_Expr_components : LEMMA % :-)
    FORALL(p : Program)(E : finite_set[Expr]) :
      wf_Expr(p)(big_conj(E)) IMPLIES
        FORALL (e : Expr) : E(e) IMPLIES wf_Expr(p)(e)

  big_conj_wf_Expr_collected : LEMMA % :-)
    FORALL(p : Program)(C : finite_set[[Expr, (Bool?), nat]]) :
      (FORALL (e : Expr) : 
         (EXISTS (c : [Expr, (Bool?), nat]) : C(c) AND proj_1(c) = e)
          IMPLIES wf_Expr(p)(e)) IMPLIES
      wf_Expr(p)(big_conj(C))


  big_conj_wf_Expr_components_collected : LEMMA % :-)
    FORALL(p : Program)(C : finite_set[[Expr, (Bool?), nat]]) :
      wf_Expr(p)(big_conj(C)) IMPLIES
        FORALL (e : Expr) : 
          (EXISTS (c : [Expr, (Bool?), nat]) : C(c) AND proj_1(c) = e)
          IMPLIES wf_Expr(p)(e)


  derivation_steps_unique : LEMMA % :-)
    FORALL(p : Program)(b : Body, s1, s2 : APState, v : Val) :
      wf_Body(p)(b) IMPLIES
      (EXISTS(n : nat) : derive(p)(b, s1, v, s2)(n)) IMPLIES
      exists1(LAMBDA(n : nat) : derive(p)(b, s1, v, s2)(n))


  collect_combine : LEMMA
    FORALL(C : finite_set[[Expr, (Bool?), nat]], p : Program, s : APState) :
      (FORALL (c : [Expr, (Bool?), nat]) :
         wf_Expr(p)(proj_1(c)) IMPLIES
         C(c) IMPLIES 
         derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))) IMPLIES
      NOT up?(ex(pstate(s))) IMPLIES
      LET v = (FORALL (c : [Expr, (Bool?), nat]) :
                 C(c) IMPLIES b(proj_2(c))) IN
      wf_Expr(p)(big_conj(C)) IMPLIES
      derive(p)(big_conj(C), s, Bool(v), s)(count_sum(C))

  big_conj_unfold : LEMMA
    FORALL(E : finite_set[Expr], p : Program, s : APState,
           v : (Bool?), n : nat) :
      (FORALL (e : Expr) :
         wf_Expr(p)(e) IMPLIES
         E(e) IMPLIES 
         EXISTS (v1 : (Bool?), n1 : nat) :
           derive(p)(e, s, v1, s)(n1)) IMPLIES    
      NOT up?(ex(pstate(s))) IMPLIES
        wf_Expr(p)(big_conj(E)) IMPLIES
        FORALL(e : Expr) : 
          E(e) IMPLIES
          derive(p)(big_conj(E), s, v, s)(n) =
            derive(p)(Conj(e, big_conj(remove(e, E))), s, v, s)(n)

  big_conj_equivalence : LEMMA
    FORALL(C : finite_set[[Expr, (Bool?), nat]], p : Program, s : APState,
           v : (Bool?), n : nat) :
      (FORALL (c : [Expr, (Bool?), nat]) :
         wf_Expr(p)(proj_1(c)) IMPLIES
         C(c) IMPLIES 
         derive(p)(proj_1(c), s, proj_2(c), s)(proj_3(c))) IMPLIES    
      LET E = {e : Expr | EXISTS(c : [Expr, (Bool?), nat]) :
                            C(c) AND proj_1(c) = e} IN
      wf_Expr(p)(big_conj(C)) IMPLIES
	derive(p)(big_conj(C), s, v, s)(n) =
          derive(p)(big_conj(E), s, v, s)(n)

  % remaining case: finiteness of collected set C
  well_behaved_MVA_preserved_by_complete : LEMMA
    FORALL(mva : (partial), stA : [APState -> Store]) :
    well_behaved_MVA(mva)(stA) IMPLIES
        well_behaved_MVA(complete_MVA(mva))(stA)

END WellBehavedMVA

 
