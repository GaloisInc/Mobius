EventType : DATATYPE
BEGIN

  Entry : Entry?
  ExitNormal : ExitNormal?
  ExitExceptional : ExitExceptional?

END EventType


% Multi-Variable Automata
MVA[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING JType, 
            Expr[Name], 
            Val
  
  MVAVarDecl : TYPE =
    [# name : Name,
       jtype : JType,
       init_val : Val
    #]

  ProgVarDecl : TYPE =
    [# name : Name,
       jtype : JType
    #]

  Store : TYPE = [Name -> Val]

  IMPORTING State[Name]

  Guard : TYPE = [Store, PSt -> boolean]

  OneAction : TYPE =
    [# target : Name,
       source : Expr[Name]
    #]

  Action : TYPE = list[OneAction]

  skip : Action = null[OneAction]

  IMPORTING EventType

  Event : TYPE =
    [# etype : EventType,
       mname : Name
    #]

  Transition : TYPE =
    [# scp : CP,         % source control point
       event : Event,
       guard : Guard,
       action : Action,
       tcp : CP          % target control point
    #]
   
  % halted is our characterization of a state where the automaton is blocked
  halted : CP

  % An NVA consists of:
  % a name of the class that the automaton monitors,
  % a finite set of control points other than halted,
  % an initial control point,
  % a finite set of events,
  % a finite set of variable declarations used by the automaton,
  % a finite set of vars decls from the program that may be used in guards,
  % a finite transition relation
  MVA : TYPE =
    [# name : Name,
       class_name : Name,
       cps : finite_set[CP],
       init_cp : CP,
       evs : finite_set[Event],
       vdsA : finite_set[MVAVarDecl],
       vdsP : finite_set[ProgVarDecl],
       ts : finite_set[Transition]
    #]

  % NOTE: vdsA and vdsP are just the signatures of the variables, they do not
  %       contain their values. Only states have values for variables.


END MVA


WellFormedMVA[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVA[CP, Name]

  % Functions to get a set of names from a set of variable declarations
  var_names(V : set[MVAVarDecl]) : set[Name] =
    {n : Name | EXISTS (va : MVAVarDecl) : V(va) AND name(va) = n}

  var_names(V : set[ProgVarDecl]) : set[Name] =
    {n : Name | EXISTS (vp : ProgVarDecl) : V(vp) AND name(vp) = n}

  % Gets the variable's names involved in an expression
  % TODO: define and move to another file
  var_names(e : Expr[Name]) : set[Name]

  wf_Store(vdsA : set[MVAVarDecl])(f : Store) : boolean =
    FORALL (n : Name) :
      var_names(vdsA)(n) IFF NOT Bottom?(f(n))

  wf_Store(f : Store, a : MVA) : boolean =
    wf_Store(vdsA(a))(f)

  wf_PSt(vdsP : set[ProgVarDecl])(f : PSt) : boolean =
    FORALL (n : Name) :
      var_names(vdsP)(n) IFF NOT Bottom?(lookup(n, f))

  wf_PSt(f : PSt, a : MVA) : boolean =
    wf_PSt(vdsP(a))(f)

  % TODO: It may be necessary (maybe not) to ensure that the initial value 
  % conforms to the declared type (we need to define conform).
  wf_vdsA(vds : set[MVAVarDecl]) : boolean =
    FORALL (vd : MVAVarDecl) : vds(vd) IMPLIES
      NOT EXISTS (vd1 : MVAVarDecl) : vds(vd1) AND name(vd) = name(vd1)

  % TODO: Same as above
  wf_vdsP(vds : set[ProgVarDecl]) : boolean =
    FORALL (vd : ProgVarDecl) : vds(vd) IMPLIES
      NOT EXISTS (vd1 : ProgVarDecl) : vds(vd1) AND name(vd) = name(vd1)

  IMPORTING func_props   % imports domain_set

  wf_Guard(p : Guard, a : MVA) : boolean =
    wf_Store(proj_1(domain_set(p)), a) AND
    wf_PSt(proj_2(domain_set(p)), a)

  wf_Action(l : Action, a : MVA) : boolean =
    FORALL (c : OneAction) :
      member(c, l) IMPLIES
        var_names(vdsA(a))(target(c)) AND
        subset?(var_names(source(c)), 
                union(var_names(vdsA(a)), var_names(vdsP(a))))

  % Rules that every MVA must follow:
  % The initial control point is in the set of control points of the automaton
  % The set vdsA and vdsP are "well formed"
  % The name of the variables in vdsA and vdsP are distinct
  % The source and target of every transition is in the set of control points
  % The event of every transition is in the set of events
  % The target of every OneAction in every transition is in vdsA and variables
  % appearing in the source expression are either in vdsA or in vdsP
  % Variables appearing in guards are in in vdsA or in vdsP. In our formalization
  % this means that the Store is defined for each var in vdsA and the PSt is
  % defined for each var in vdsP (they also may be defined elsewhere)
  wf_MVA(a : MVA) : boolean =
    cps(a)(init_cp(a)) AND
    wf_vdsA(vdsA(a)) AND
    wf_vdsP(vdsP(a)) AND
    disjoint?(var_names(vdsA(a)), var_names(vdsP(a))) AND
    FORALL (t : Transition) :
      ts(a)(t) IMPLIES
        cps(a)(scp(t)) AND
        cps(a)(tcp(t)) AND
        evs(a)(event(t)) AND
        wf_Guard(guard(t), a) AND
        wf_Action(action(t), a)


END WellFormedMVA


MVAProperties[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name]

  deterministic(a : (wf_MVA)) : boolean =
    FORALL (t1, t2 : Transition, stA : Store, stP : PSt) :
      ts(a)(t1) IMPLIES
      ts(a)(t2) IMPLIES
      wf_Store(stA, a) IMPLIES
      wf_PSt(stP, a) IMPLIES
      scp(t2) = scp(t1) IMPLIES
      event(t2) = event(t1) IMPLIES
      guard(t1)(stA, stP) IMPLIES
      guard(t2)(stA, stP) IMPLIES
        t1 = t2

  total(a : (wf_MVA)) : boolean =
    FORALL (q : CP, e : Event, stA : Store, stP : PSt) :
      cps(a)(q) IMPLIES
      evs(a)(e) IMPLIES
      wf_Store(stA, a) IMPLIES
      wf_PSt(stP, a) IMPLIES
        EXISTS (t : Transition) : ts(a)(t) AND
                                  scp(t) = q AND
                                  event(t) = e AND
                                  guard(t)(stA, stP)

  trap_state(q : CP, a : (wf_MVA)) : boolean =
    FORALL (t : Transition) :
      ts(a)(t) AND scp(t) = q IMPLIES
        tcp(t) = halted

  complete(a : MVA) : boolean =
    wf_MVA(a) AND
    cps(a)(halted) AND
    trap_state(halted, a) AND
    deterministic(a) AND
    total(a)


END MVAProperties


% RENAME TO MVASemantics
MVASemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVAProperties[CP, Name]

  % The state of a MVA is composed by its currrent control point and values for
  % its variables
  AState : TYPE =
    [# cp : CP,
       stA : Store 
    #]

  get_MVAVarDecl(n : Name, a : (wf_MVA)) : lift[MVAVarDecl] =
    LET vds = {vd : MVAVarDecl | vdsA(a)(vd) AND name(vd) = n}  IN
      IF empty?(vds) 
      THEN bottom 
      ELSE up(choose(vds))
      ENDIF

  % Initial state of a MVA
  initial_MVA_state(a : (wf_MVA)) : AState =
    (# cp := init_cp(a),
       stA := LAMBDA (n: Name) :
         LET vd = get_MVAVarDecl(n, a) IN
         IF bottom?(vd)
         THEN Bottom
         ELSE init_val(down(vd))
         ENDIF
    #)


  % A program event is an event that occurred in the program together with the 
  % value of its variables at that point
  PEvent : TYPE =
    [# stP : PSt,
       event : Event
    #]

  % Updates a store
  update(st : Store)(n : Name)(v : Val) : Store =
    LAMBDA(m : Name) :
      IF m = n
      THEN v
      ELSE st(m)
      ENDIF

  % TODO: define!
  eval(e : Expr)(st : Store) : Val

  % type checking problem, because program expressions cannot be evaluated
  execute_actions(stA : Store, l : Action) : RECURSIVE Store =
    IF null?(l)
    THEN stA
    ELSE execute_actions(update(stA)(target(car(l)))
                                    (eval(source(car(l)))(stA)), cdr(l))
    ENDIF
  MEASURE length(l)


  %%%  Well formed states
  wf_AState(s : AState, a : MVA) : boolean =
    cps(a)(cp(s)) AND
    wf_Store(stA(s), a)

  wf_AState(a : MVA)(s : AState) : boolean =
    wf_AState(s, a)

  wf_PEvent(pe : PEvent, a : MVA) : boolean =
    evs(a)(event(pe)) AND wf_PSt(stP(pe), a)

  wf_PEvent(a : MVA)(pe : PEvent) : boolean =
    wf_PEvent(pe, a)


  % Single judgement for a MVA
  step(a : (total))(x : (wf_AState(a)), p : (wf_PEvent(a))) : AState =
      LET t = choose(LAMBDA (t : Transition) : 
                       ts(a)(t) AND 
                       scp(t) = cp(x) AND 
                       event(t) = event(p) AND
                       guard(t)(stA(x), stP(p))) IN
      (# cp := tcp(t),
         stA := execute_actions(stA(x), action(t))
      #)

  %%%  Well formed lemmas
  wf_initial_MVA_state: LEMMA
    FORALL (a: MVA) :
      wf_MVA(a) IMPLIES wf_AState(initial_MVA_state(a), a)

  % TODO: prove (needs the definition of eval for Expressions)
  execute_action_yields_wf_state: LEMMA
    FORALL (a : MVA, stA : Store, l : Action) :
      wf_Store(stA, a) IMPLIES
        wf_Store(execute_actions(stA, l), a)

  step_yields_wf_state : THEOREM % :-)
    FORALL (a : (total), x : (wf_AState(a)), p : (wf_PEvent(a))) :
      wf_AState(step(a)(x, p), a) 


END MVASemantics


MVACompletion[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVAProperties[CP, Name],
            EpsilonProps, 
            MVAFiniteProps

  % Returns the set of guards from transitions in ts with cp as source control
  % point and e as event
  all_guards(cp : CP, e : Event,
             ts : finite_set[Transition]) : finite_set[Guard] =
    {p : Guard | EXISTS (t : Transition) : ts(t) AND scp(t) = cp AND
                                           event(t) = e AND guard(t) = p}
 
  % Returns a guard that is the conjuction of the negation of the guards in ts
  % with source control point cp and event e. The sets of variable declarations
  % are needed to make sure that the guard is defined in for those variables.
  build_guard(cp : CP, e : Event, ts : finite_set[Transition], 
              vdsA : finite_set[MVAVarDecl], 
              vdsP : finite_set[ProgVarDecl]) : Guard = 
   LAMBDA (stA : (wf_Store(vdsA)), stP : (wf_PSt(vdsP))) :
     FORALL (p : Guard) : all_guards(cp, e, ts)(p) IMPLIES NOT p(stA, stP)

  % Makes ts complete with respect cps and es
  complete_trans(cps : finite_set[CP], es : finite_set[Event], 
                 ts : finite_set[Transition], vdsA : finite_set[MVAVarDecl],
                 vdsP : finite_set[ProgVarDecl]) : finite_set[Transition] =
    union({t : Transition | cps(scp(t)) AND es(event(t)) AND
                            action(t) = skip AND tcp(t) = halted AND
                            guard(t) = build_guard(scp(t), event(t), ts, vdsA, 
                                                     vdsP)},
          {t : Transition | scp(t) = halted AND es(event(t)) AND
                            guard(t) = (LAMBDA (stA : (wf_Store(vdsA)) , 
                                                stP : (wf_PSt(vdsP))): TRUE)
                            AND action(t) = skip AND tcp(t) = halted})


  % Preconditions for completeMVA
  complete_MVA_pre(a : (wf_MVA)) : boolean =
    deterministic(a) AND NOT cps(a)(halted)

  % Makes a deterministic MVA total
  complete_MVA(a : (complete_MVA_pre)) : MVA =
    a WITH [cps := add(halted, cps(a)),
            ts := union(ts(a), complete_trans(cps(a), evs(a), ts(a), vdsA(a), 
                                             vdsP(a)))]


  % TODO: prove the remaining cases (Fix the proof)
  complete_MVA_is_valid: LEMMA
    FORALL (a: (complete_MVA_pre)) :
      wf_MVA(complete_MVA(a))

  complete_MVA_has_trap_state: LEMMA % :-)
    FORALL (a: (complete_MVA_pre)) :
      trap_state(halted, complete_MVA(a))

  % TODO: Fix the proof
  complete_MVA_is_deterministic: LEMMA
    FORALL (a: (complete_MVA_pre)) :
      deterministic(complete_MVA(a))

  % TODO: Fix the proof
  complete_MVA_is_total: LEMMA
    FORALL (a: (complete_MVA_pre)) :
      total(complete_MVA(a))

  complete_MVA_is_complete: THEOREM % :-)
    FORALL (a: (complete_MVA_pre)) :
      complete(complete_MVA(a))

END MVACompletion
