EventType : DATATYPE
BEGIN

  Entry : Entry?
  ExitNormal : ExitNormal?
  ExitExceptional : ExitExceptional?


END EventType


% Multi-Variable Automata
MVA[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name]

  MVAVarDecl : TYPE = FieldDecl

  ProgVarDecl : TYPE = LocalVarDecl

  IMPORTING State[Name], ValOrExcpt[Name]

  Guard : TYPE = [Store, PSt, ValOrExcpt -> boolean]

  OneAction : TYPE =
    [# target : Name,
       source : Expr[Name]
    #]

  Action : TYPE = list[OneAction]

  skip : Action = null[OneAction]

  IMPORTING EventType

  Event : TYPE =
    [# etype : EventType,
       mname : Name
    #]

  Transition : TYPE =
    [# scp : CP,         % source control point
       event : Event,
       guard : Guard,
       action : Action,
       tcp : CP          % target control point
    #]

  % halted represents an error state
  halted : CP

  % An MVA consists of:
  % the name of the class that the automaton monitors,
  % a finite set of control points other than halted,
  % an initial control point,
  % a finite set of events,
  % a finite set of variable declarations used by the automaton,
  % a finite set of var decls from the program used in guards and actions,
  % a finite transition relation
  MVA : TYPE =
    [# name : Name,
       class_name : Name,
       cps : finite_set[CP],
       init_cp : CP,
       evs : finite_set[Event],
       vdsA : finite_set[MVAVarDecl],
       vdsP : finite_set[ProgVarDecl],
       ts : finite_set[Transition]
    #]

  % NOTE: vdsA and vdsP are just the signatures of the variables, they do not
  %       contain their values. Only states have values for variables.

  IMPORTING ProgramFunctions[Name] % imports var_names

  % TODO: rename to declared_var_names
  var_names(a : MVA) : finite_set[Name] =
    union(var_names(vdsA(a)), var_names(vdsP(a)))

  get_MVAVarDecl(n : Name, a : MVA) : lift[MVAVarDecl] =
    LET vds = {vd : MVAVarDecl | vdsA(a)(vd) AND name(vd) = n}  IN
      IF empty?(vds) 
      THEN bottom 
      ELSE up(choose(vds))
      ENDIF


END MVA


% Constraints for well-formed MVAs
WellFormedMVA[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVA[CP, Name]

  wf_Body(a : MVA)(b : Body) : boolean =
    subset?(var_names(b), var_names(a)) AND
    (FORALL (b1 : Body) : subterm(b1, b) IMPLIES NOT Set?(b1))

  wf_BoolExpr(a : MVA)(b : BoolExpr) : boolean =
    wf_Body(a)(b)

  wf_Expr(a : MVA)(e : Expr) : boolean =
    wf_Body(a)(e)

  wf_vdsA(vds : finite_set[MVAVarDecl]) : boolean =
    (FORALL (vd1, vd2 : MVAVarDecl) : vds(vd1) IMPLIES vds(vd2) IMPLIES
       name(vd1) = name(vd2) IMPLIES vd1 = vd2) AND
    disjoint?(var_names(vds), reserved_words)

  wf_vdsP(vds : finite_set[ProgVarDecl]) : boolean =
    FORALL (vd1, vd2 : ProgVarDecl) : vds(vd1) IMPLIES vds(vd2) IMPLIES
      name(vd1) = name(vd2) IMPLIES vd1 = vd2

  wf_Guard(a : MVA)(g : Guard) : boolean =
    FORALL (sA : Store, sP : PSt, arg : ValOrExcpt, n : Name, v : Val) :
      (NOT var_names(vdsA(a))(n) AND NOT var_names(vdsP(a))(n)) IMPLIES
        g(sA, sP, arg) = g(sA WITH [n |-> v], sP, arg) AND
        g(sA, sP, arg) = g(sA, sP WITH [fvs := fvs(sP) WITH [n |-> v]], arg)

  wf_Action(a : MVA)(l : Action) : boolean =
    FORALL (c : OneAction) :
      member(c, l) IMPLIES 
        (var_names(vdsA(a))(target(c)) AND
         wf_Expr(a)(source(c)))

  wf_Trans(a : MVA)(t : Transition) : boolean = 
    ts(a)(t) IMPLIES
      cps(a)(scp(t)) AND
      cps(a)(tcp(t)) AND
      evs(a)(event(t)) AND
      wf_Guard(a)(guard(t)) AND
      wf_Action(a)(action(t))

  % Rules that every MVA must follow:
  % The initial control point is in the set of control points of the automaton
  % The initial control point is not halted
  % The sets vdsA and vdsP are "well formed"
  % The name of the variables in vdsA and vdsP are distinct
  % The source and target of every transition is in the set of control points
  % The event of every transition is in the set of events
  % The target of every OneAction in every transition is in vdsA and variables
  % appearing in the source expression are either in vdsA or in vdsP
  % Guards and actions are well formed
  wf_MVA(a : MVA) : boolean =
    cps(a)(init_cp(a)) AND
    NOT init_cp(a) = halted AND  % needed to prove initial_states_are_equivalent
    wf_vdsA(vdsA(a)) AND
    wf_vdsP(vdsP(a)) AND
    disjoint?(var_names(vdsA(a)), var_names(vdsP(a))) AND
    FORALL (t : Transition) : wf_Trans(a)(t)


END WellFormedMVA


MVAProperties[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name]

  deterministic(a : MVA) : boolean =
    FORALL (t1, t2 : Transition, stA : Store, stP : PSt, arg : ValOrExcpt) :
      ts(a)(t1) IMPLIES
      ts(a)(t2) IMPLIES
      scp(t2) = scp(t1) IMPLIES
      event(t2) = event(t1) IMPLIES
      guard(t1)(stA, stP, arg) IMPLIES
      guard(t2)(stA, stP, arg) IMPLIES
        t1 = t2

  total(a : MVA) : boolean =
    FORALL (q : CP, e : Event, stA : Store, stP : PSt, arg : ValOrExcpt) :
      cps(a)(q) IMPLIES
      evs(a)(e) IMPLIES
        EXISTS (t : Transition) : ts(a)(t) AND
                                  scp(t) = q AND
                                  event(t) = e AND
                                  guard(t)(stA, stP, arg)

  trap_state(q : CP, a : (wf_MVA)) : boolean =
    FORALL (t : Transition) :
      ts(a)(t) AND scp(t) = q IMPLIES
        tcp(t) = halted

  % A MVA does not necessarily have to pass through our completion function to
  % be usable. These are the conditions we require to work with a MVA
  complete(a : MVA) : boolean =
    wf_MVA(a) AND
    cps(a)(halted) AND
    trap_state(halted, a) AND
    deterministic(a) AND
    total(a)

  AUTO_REWRITE- complete, total, deterministic

  % Preconditions for completeMVA
  good_for_monitoring(a : (wf_MVA)) : boolean =
    deterministic(a) AND NOT cps(a)(halted)


END MVAProperties


MVACommonSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name]

  % Updates a store
  update(st : Store)(n : Name)(v : Val) : Store =
    LAMBDA(m : Name) :
      IF m = n
      THEN v
      ELSE st(m)
      ENDIF


  %  Well formed states

  wf_Store(vds : finite_set[MVAVarDecl])(st : Store) : boolean =
    FORALL (n : Name) :
      var_names(vds)(n) IFF defined?(st(n))


  % NOTE: Recall that we assume that variables in PSt are fields.
  % Variables in PSt are a subset of the program variables, if we require them
  % to be equal then we can use an IFF
  wf_PSt(vds : finite_set[ProgVarDecl])(st : PSt) : boolean =
    FORALL (n : Name) :
      var_names(vds)(n) IMPLIES defined?(fvs(st)(n))


  update_yields_wf_Store : LEMMA % :-)
    FORALL (a : MVA, st : Store, n : Name, v : Val) :
      wf_Store(vdsA(a))(st) IMPLIES
      (Bottom?(st(n)) IFF Bottom?(v)) IMPLIES
        wf_Store(vdsA(a))(update(st)(n)(v))

  % A program event is an event that occurred in the program together with the 
  % value of its variables at that point
  PEvent : TYPE =
    [# stP : PSt,
       event : Event,
       arg : ValOrExcpt
    #]

  wf_PEvent(a : MVA)(pe : PEvent) : boolean =
    evs(a)(event(pe)) AND wf_PSt(vdsP(a))(stP(pe))

  % NOTE: eval is implicitly defined by eval_action_behavior in Equivalence.
  % Since we only consider the PSt of the state of the program, actions can not
  % talk about existing ghost variables in the monitored program, but that is 
  % fine since we assumed that they are fields (although it could be extended to
  % handle ghosts as well).
  eval(e : Expr)(stA : Store, stP : PSt) : Val

  % The evaluation of actions must return a defined value (thus it can not
  % return a state with an exception). 
  % Note that this is required by well_behaved_MVA, but for simplicity we
  % ask it here (otherwise we have to move execute_action_yields_wf_state
  % to MonitoredProgramSemantics).
  eval_yields_not_bottom : AXIOM
    FORALL (a : MVA, e : Expr, stA : Store, stP : PSt) :
      wf_Store(vdsA(a))(stA) IMPLIES
      wf_PSt(vdsP(a))(stP) IMPLIES
        defined?(eval(e)(stA, stP))


  execute_action(l : Action)(stA : Store, stP : PSt) : RECURSIVE Store =
    IF null?(l)
    THEN stA
    ELSE execute_action(cdr(l))(update(stA)(target(car(l)))
                                            (eval(source(car(l)))(stA, stP)),
                                 stP)
    ENDIF
  MEASURE length(l)

  execute_action_yields_wf_state : LEMMA % :-)
    FORALL (a : MVA, l : Action, stA : Store, stP : PSt) :
      wf_Store(vdsA(a))(stA) IMPLIES
      wf_PSt(vdsP(a))(stP) IMPLIES
      wf_Action(a)(l) IMPLIES
        wf_Store(vdsA(a))(execute_action(l)(stA, stP))

  % The state of a MVA is composed by its currrent control point and values for
  % its variables
  AState : TYPE =
    [# cp : CP,
       stA : Store
    #]

  % Initial state of a MVA
  initial_MVA_state(a : MVA) : AState =
    (# cp := init_cp(a),
       stA := LAMBDA (n: Name) :
         LET vd = get_MVAVarDecl(n, a) IN
         IF bottom?(vd)
         THEN Bottom
         ELSE init_val(down(vd))
         ENDIF
    #)

  wf_AState(a : MVA)(s : AState) : boolean =
    cps(a)(cp(s)) AND
    wf_Store(vdsA(a))(stA(s))


  %  Well-formed lemmas

  wf_initial_MVA_state: LEMMA % :-)
    FORALL (a: MVA) :
      wf_MVA(a) IMPLIES wf_AState(a)(initial_MVA_state(a))



END MVACommonSemantics


% Operational semantics for MVAs
MVAPartialSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVACommonSemantics[CP, Name], 
            MVAProperties[CP, Name]

  % Single judgement for a MVA
  step(a : MVA)(s : (wf_AState(a)), pe : (wf_PEvent(a))) : lift[AState] =
      IF EXISTS (t : Transition) :
                       ts(a)(t) AND 
                       scp(t) = cp(s) AND 
                       event(t) = event(pe) AND
                       guard(t)(stA(s), stP(pe), arg(pe))
      THEN LET t = choose(LAMBDA (t : Transition) : 
                       ts(a)(t) AND 
                       scp(t) = cp(s) AND 
                       event(t) = event(pe) AND
                       guard(t)(stA(s), stP(pe), arg(pe))) IN
      up((# cp := tcp(t),
         stA := execute_action(action(t))(stA(s), stP(pe))
         #))
      ELSE bottom
      ENDIF


  %  Well-formed lemmas


  step_yields_wf_state : THEOREM % :-)
    FORALL (a : MVA, s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      wf_MVA(a) IMPLIES
      up?(step(a)(s, pe)) IMPLIES
      wf_AState(a)(down(step(a)(s, pe)))


END MVAPartialSemantics


% Operational semantics for MVAs
MVATotalSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVACommonSemantics[CP, Name],
            MVAProperties[CP, Name]

  % Single judgement for a MVA
  step(a : (total))(s : (wf_AState(a)), pe : (wf_PEvent(a))) : AState =
      LET t = choose(LAMBDA (t : Transition) : 
                       ts(a)(t) AND 
                       scp(t) = cp(s) AND 
                       event(t) = event(pe) AND
                       guard(t)(stA(s), stP(pe), arg(pe))) IN
      (# cp := tcp(t),
         stA := execute_action(action(t))(stA(s), stP(pe))
      #)



  %  Well-formed lemmas

  step_yields_wf_state : THEOREM % :-)
    FORALL (a : (total), s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      wf_MVA(a) IMPLIES
      wf_AState(a)(step(a)(s, pe))


END MVATotalSemantics



MVAMonitoring[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name]


  % guard_to_expression is implicitly defined by guard_to_expression_behavior
  % in Equivalence.
  % TODO: To be more precise we should ask g to be well formed wrt a
%  guard_to_expression(a : MVA)(g : (wf_Guard(a))) : BoolExpr
  guard_to_expression(a : MVA)(g : Guard) : [ValOrExcpt -> BoolExpr]

  guard_to_expression_yields_wf_BoolExpr : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(v : ValOrExcpt) :
          wf_BoolExpr(a)(guard_to_expression(a)(guard(t))(v))

  IMPORTING ContainsNoMethodCall[Name]

  guard_to_expression_contains_no_method_calls : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(v : ValOrExcpt) :
        contains_no_method_call(guard_to_expression(a)(guard(t))(v))


  action_sources_contains_no_method_calls : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(l : OneAction) :
          member(l, action(t)) IMPLIES
            contains_no_method_call(source(l))

END MVAMonitoring


MVACompletion[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVAProperties[CP, Name]

  % Returns the set of guards from transitions with cp as source control
  % point and e as event
  all_guards(a : MVA)(cp : CP, e : Event) : finite_set[Guard] =
    {p : Guard | EXISTS (t : Transition) : ts(a)(t) AND scp(t) = cp AND
                                           event(t) = e AND guard(t) = p}
 
  % Returns a guard that is the conjuction of the negation of the guards in ts
  % with source control point cp and event e. The sets of variable declarations
  % are needed to make sure that the guard is defined in for those variables.
  build_guard(a : MVA)(cp : CP, e : Event) : Guard =
   LAMBDA (stA : Store, stP : PSt, arg : ValOrExcpt) :
     FORALL (p : Guard) : all_guards(a)(cp, e)(p) IMPLIES NOT p(stA, stP, arg)

  % Makes ts(a) complete with respect cps and evs(a)
  complete_trans(a : MVA) : finite_set[Transition] =
    union({t : Transition | cps(a)(scp(t)) AND evs(a)(event(t)) AND
                            guard(t) = build_guard(a)(scp(t), event(t)) AND
                            action(t) = skip AND tcp(t) = halted},
          {t : Transition | scp(t) = halted AND evs(a)(event(t)) AND
                            guard(t) = (LAMBDA (stA : Store, 
                                                stP : PSt, 
                                                arg : ValOrExcpt) : TRUE)
                            AND action(t) = skip AND tcp(t) = halted})



  % Makes a deterministic MVA total
  complete_MVA(a : (good_for_monitoring)) : MVA =
    a WITH [cps := add(halted, cps(a)),
            ts := union(ts(a), complete_trans(a))]


  build_guard_yields_wf_guard : LEMMA % :-)
    FORALL (a : MVA, cp : CP, e : Event ) :
      wf_MVA(a) IMPLIES wf_Guard(a)(build_guard(a)(cp, e))

  complete_MVA_yields_wf_MVA : LEMMA % :-)
    FORALL (a : (good_for_monitoring)) :
      wf_MVA(complete_MVA(a))

  complete_MVA_has_trap_state: LEMMA % :-)
    FORALL (a : (good_for_monitoring)) :
      trap_state(halted, complete_MVA(a))

  complete_MVA_is_deterministic : LEMMA % :-)
    FORALL (a : (good_for_monitoring)) :
      deterministic(complete_MVA(a))

  complete_MVA_is_total : LEMMA % :-)

    FORALL (a : (good_for_monitoring)) :
      total(complete_MVA(a))

  complete_MVA_is_complete : THEOREM % :-)
    FORALL (a : (good_for_monitoring)) :
      complete(complete_MVA(a))


END MVACompletion
