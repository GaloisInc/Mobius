NewVar[Name : TYPE] : DATATYPE
BEGIN

  IMPORTING Program[Name]

  res(m : Method) : res?
  ex(m : Method) : ex?

END NewVar

InlineVariableNames[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  ENDASSUMING

  IMPORTING WellFormedProgram[Name]

  legal_names(p : Program)(n : Name) : bool =
    NOT union(declared_var_names(p), reserved_words)(n)


END InlineVariableNames


InlineNewVariableDeclarations[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

  ENDASSUMING

  res_ex(p : Program): (injective?[NewVar[Name], (legal_names(p))])

  res(p : Program)(m : Method) : Name = res_ex(p)(res(m))

  ex(p : Program)(m : Method) : Name = res_ex(p)(ex(m))

  p : VAR Program
  m : VAR Method

  res_ex_disjoint : LEMMA % :-)
    FORALL(m1, m2 : Method) :
     (NOT res(p)(m1) = ex(p)(m2)) AND
     (NOT m1 = m2 IMPLIES
         (NOT res(p)(m1) = res(p)(m2)) AND
         (NOT ex(p)(m1) = ex(p)(m2)))


  % Variables that will be added for the inline process

  new_res_lvar(p, m) : LocalVarDecl =
    (# name := res(p)(m),
       jtype := res_type(m) #)

  new_ex_lvar(p, m) : LocalVarDecl =
    (# name := ex(p)(m),
       jtype := BoolType #)

  new_res_lvars(p) : finite_set[LocalVarDecl] =
    {lv : LocalVarDecl | EXISTS (m : Method) : 
                        methods(p)(m) AND lv = new_res_lvar(p, m) }


  new_ex_lvars(p) : finite_set[LocalVarDecl] =
    {lv : LocalVarDecl | EXISTS (m : Method) : 
                        methods(p)(m) AND lv = new_ex_lvar(p, m) }

  new_lvars(p) : finite_set[LocalVarDecl] =
    union(new_res_lvars(p), new_ex_lvars(p))

  new_res_lvar_new_lvar : LEMMA % :-)
     methods(p)(m) IMPLIES
     new_lvars(p)(new_res_lvar(p, m))

  new_ex_lvar_new_lvar : LEMMA % :-)
     methods(p)(m) IMPLIES
     new_lvars(p)(new_ex_lvar(p, m))

  IMPORTING ProgramFunctions[Name], SetProp[Name]

  new_lvars_not_field_decls : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), var_names(getFieldDecls(p)))
 
  new_lvars_not_ghost_decls : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), var_names(getGhostDecls(p)))

  new_lvars_not_old_local_decls : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), var_names(getLocalDecls(p)))

  new_lvars_not_reserved_words : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), reserved_words)

  new_vars_not_ext_declared_var_names : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), ext_declared_var_names(p))

  new_lvars_not_ext_declared_var_names : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), ext_declared_var_names(p))


END InlineNewVariableDeclarations


InlineMethodAnnotation[Name : TYPE+] : THEORY
BEGIN

  ASSUMING


    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})


  IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING


  IMPORTING InlineNewVariableDeclarations[Name]

  p : VAR Program
  m : VAR Method

  % with every method call, ex initialised to false

  % several try-catches needed, because we do not model subclass hierarchy
  % of exceptions

  % inline_method_body(p)(m) gives in Java-like syntax:
  % pre_set(m);
  % try{
  %   try{
  %     try{
  %       body(m);
  %       ex := true;
  %     }
  %     catch(Throwable){
  %       exc_set(m);
  %     }
  %   catch(NullPointerExc){
  %       exc_set(m);
  %   }
  % catch(JMLExc){
  %   exc_set(m);
  % }
  % finally{
  %   if (ex){
  %    res := res(m);
  %    post_set(m);
  % }
  inline_method_body(p)(m) : Body = 
    Sequence(
      pre_set(m),
      TryCatch(
       TryCatch(
        TryCatch(
          Sequence(
             body(m),
             StmtExpr(Assign(ex(p)(m), BExpr(TT)))),
                              % this is only executed if body terminates
                              % normally
          Throwable,
          exc_set(m),
          Skip),
        NullPointer,
        exc_set(m),
        Skip),
       JMLExc,
       exc_set(m),
       IfThenElse(
         BoolVarEval(ex(p)(m)),
         Sequence(StmtExpr(Assign(res(p)(m), res(m))),
                  post_set(m)),
         Skip)))
         

  inline_method(p)(m : Method) : Method =
    m WITH [pre_set  := Skip,
            post_set := Skip,
            exc_set := Skip,
            lvars := add(new_res_lvar(p, m),
                     add(new_ex_lvar(p, m), lvars(m))),
            body := inline_method_body(p)(m),
            res := CASES res_type(m) OF
                     IntType : NExpr(NumVarEval(res(p)(m))),
                     BoolType : BExpr(BoolVarEval(res(p)(m))),
                     RefType : RExpr(RefVarEval(res(p)(m))),
                     Void : BExpr(TT)
                   ENDCASES]


  inline_methods(p)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = inline_method(p)(n)}

  inline_method_name : LEMMA % :-)
    FORALL (m : Method) :
      name(inline_method(p)(m)) = name(m)

  inline_method_arg : LEMMA % :-)
    FORALL (m : Method) :
      arg(inline_method(p)(m)) = arg(m)

  inline_method_pre : LEMMA % :-)
    FORALL (m : Method) :
      pre(inline_method(p)(m)) = pre(m)

  inline_method_post : LEMMA % :-)
    FORALL (m : Method) :
      post(inline_method(p)(m)) = post(m)

  inline_method_lvars : LEMMA % :-)
    FORALL (m : Method) :
      lvars(inline_method(p)(m)) = 
        add(new_res_lvar(p, m),
        add(new_ex_lvar(p, m), lvars(m)))

  inline_method_body : LEMMA % :-)
    FORALL (m : Method) :
      body(inline_method(p)(m)) = inline_method_body(p)(m)

  inline_method_pre_set : LEMMA % :-)
    FORALL (m : Method) :
      pre_set(inline_method(p)(m)) = Skip

  inline_method_post_set : LEMMA % :-)
    FORALL (m : Method) :
      post_set(inline_method(p)(m)) = Skip

  inline_method_exc_set : LEMMA % :-)
    FORALL (m : Method) :
      exc_set(inline_method(p)(m)) = Skip

  inline_method_res : LEMMA % TO DO
    FORALL (m : Method) :
      res(inline_method(p)(m)) = 
        CASES res_type(m) OF
          IntType : NExpr(NumVarEval(res(p)(m))),
          BoolType : BExpr(BoolVarEval(res(p)(m))),
          RefType : RExpr(RefVarEval(res(p)(m))),
          Void : BExpr(TT)
        ENDCASES

  inline_method_res_type : LEMMA % :-)
    FORALL (m : Method) :
      res_type(inline_method(p)(m)) = res_type(m)

  inline_method_wf_Body1 : LEMMA % :-)
    FORALL(m : Method) :
      methods(p)(m) IMPLIES
      wf_Method(p)(m) IMPLIES
      LET im = inline_method(p)(m) IN
      (FORALL(v : Name) : var_names(body(im))(v) IMPLIES
                          ext_declared_var_names(p)(v) OR
                          var_names(new_lvars(p))(v))
      AND
      (FORALL(v : Name) : var_names(pre(im))(v) IMPLIES
                          ext_declared_var_names(p)(v))
      AND
      (FORALL(v : Name) : var_names(post(im))(v) IMPLIES
                          ext_declared_var_names(p)(v))
      AND
      (FORALL(v : Name) : var_names(res(im))(v) IMPLIES
                          var_names(new_lvars(p))(v))
      AND
      (FORALL(v : Name) : NOT var_names(pre_set(im))(v))
      AND
      (FORALL(v : Name) : NOT var_names(post_set(im))(v))
      AND
      (FORALL(v : Name) : NOT var_names(exc_set(im))(v))

  inline_method_wf_Body2 : LEMMA % :-)
    FORALL(m : Method, b : Body) :
      wf_Method(p)(m) IMPLIES
      Set?(b) IMPLIES
      LET im = inline_method(p)(m) IN
      (subterm(b, body(im)) IMPLIES
         var_names(getGhostDecls(p))(target(b))) AND
      (subterm(b, pre(im)) IMPLIES
         var_names(getGhostDecls(p))(target(b))) AND
      (subterm(b, post(im)) IMPLIES
         var_names(getGhostDecls(p))(target(b))) AND
      (NOT subterm(b, res(im))) AND
      (NOT subterm(b, pre_set(im))) AND
      (NOT subterm(b, post_set(im))) AND
      (NOT subterm(b, exc_set(im)))


END InlineMethodAnnotation


InlineClassAnnotation[Name : TYPE+] : THEORY
BEGIN

  ASSUMING


    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING

  IMPORTING InlineMethodAnnotation[Name]

  p : VAR Program


  inline_class(p)(c : Class) : Class =
    c WITH [methods := inline_methods(p)(methods(c))]

  inv_inline_class : LEMMA
    FORALL(c : Class) :
      inv(inline_class(p)(c)) = inv(c)

  FieldDecls_inline_class : LEMMA % :-)
    FORALL(c : Class) :
      fields(inline_class(p)(c)) = fields(c)

  GhostDecls_inline_class : LEMMA % :-)
    FORALL(c : Class) :
      ghost_vars(inline_class(p)(c)) = ghost_vars(c)

  name_inline_class : LEMMA
    FORALL(c : Class) :
      name(inline_class(p)(c)) = name(c)

  inline_class_almost_wf_Class : LEMMA % :-)
    FORALL(c : Class) :
      wf_Class(p)(c) IMPLIES
      LET ic = inline_class(p)(c) IN
        FORALL (m1, m2 : Method) :
           methods(ic)(m1) IMPLIES
           methods(ic)(m2) IMPLIES
           name(m1) = name(m2) IMPLIES
           m1 = m2

  inline_class_inv_wf_Body1 : LEMMA % :-)
    FORALL(c : Class) :
      wf_Body(p)(inv(c)) IMPLIES
       (FORALL (v : Name) : var_names(inv(inline_class(p)(c)))(v) IMPLIES
                            ext_declared_var_names(p)(v))

  inline_class_inv_wf_Body2 : LEMMA % :-)
    FORALL(c : Class) :
      wf_Body(p)(inv(c)) IMPLIES
         FORALL(b : Body) : 
           Set?(b) IMPLIES 
           subterm(b, inv(inline_class(p)(c))) IMPLIES 
            var_names(getGhostDecls(p))(target(b))



END InlineClassAnnotation


InlineProgramAnnotation[Name : TYPE+] : THEORY
BEGIN

  ASSUMING


    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING

  IMPORTING InlineClassAnnotation[Name]

  p : VAR Program

  % Inline set-annotations into method bodies

  IMPORTING SetProp[Name] % to prove TCC

  inline_program(p) : Program =
    (# classes := {c : Class | EXISTS (c1 : Class) :
                                 classes(p)(c1) AND
                                 c = inline_class(p)(c1)} #)


  LocalDecls_inline_program : LEMMA % :-)
    getLocalDecls(inline_program(p)) = 
      union(getLocalDecls(p), new_lvars(p))


END InlineProgramAnnotation


%% Properties relating MPs and APs through ann_program
%AnnotateProgramProperties[CP, Name : TYPE+] : THEORY
%BEGIN

%  ASSUMING

%    CP_is_enumerable : ASSUMPTION
%      EXISTS (f : [CP -> nat]) : injective?(f)

%    infinite_namespace : ASSUMPTION
%      is_infinite({n : Name | TRUE})

%    IMPORTING VariableNames[CP, Name]


%    name_of_exists : ASSUMPTION
%      EXISTS (f : [mp : (wf_MP) -> [CP -> (legal_names(mp))]]) :
%        FORALL(mp : (wf_MP)) :
%          injective?(f(mp))

%  ENDASSUMING

%  IMPORTING AnnotateProgram[CP, Name],
%            AnnotatedProgramSemantics[Name],
%            MonitoredProgramSemantics[CP, Name]

%  mp : VAR (wf_MP)

%  ann_program_class_correspondence : LEMMA % :-)
%    FORALL(c : Class) : classes(ann_program(mp))(c) IMPLIES
%      EXISTS (c1 : Class) : classes(program(mp))(c1) AND c = inline_class(mp)(c1)

%  ann_program_method_correspondence : LEMMA % :-)
%    FORALL(c : Class, m : Method) :
%      classes(ann_program(mp))(c) IMPLIES
%      methods(c)(m) IMPLIES
%        EXISTS (c1 : Class, m1 : Method) :
%          classes(program(mp))(c1) AND
%          methods(c1)(m1) AND
%          (IF name(c1) = class_name(mva(mp))
%           THEN m = ann_method(mp)(m1)
%           ELSE m = m1
%           ENDIF)

%  ann_program_preserves_var_decls : LEMMA % :-)
%    getFieldDecls(program(mp)) = getFieldDecls(ann_program(mp)) AND
%    getLocalDecls(program(mp)) = getLocalDecls(ann_program(mp)) AND
%    subset?(getGhostDecls(program(mp)), getGhostDecls(ann_program(mp)))

%  ann_program_preserves_var_decl_names : LEMMA % :-)
%    FORALL (vn : Name) :
%      (var_names(getFieldDecls(program(mp)))(vn) IFF
%       var_names(getFieldDecls(ann_program(mp)))(vn))
%      AND
%      (var_names(getGhostDecls(program(mp)))(vn) IMPLIES
%       var_names(getGhostDecls(ann_program(mp)))(vn))
%      AND
%      (var_names(getLocalDecls(program(mp)))(vn) IFF
%       var_names(getLocalDecls(ann_program(mp)))(vn))

%  ann_program_add_ghost_var_decls : LEMMA % :-)
%    getGhostDecls(ann_program(mp)) =
%      union(getGhostDecls(program(mp)), new_lvars(mp))

%  ann_program_ext_declared_var_names : LEMMA % :-)
%     ext_declared_var_names(ann_program(mp)) =
%       union(ext_declared_var_names(program(mp)), var_names(new_lvars(mp)))

%  ann_program_preserves_wf_state : LEMMA % :-)
%    FORALL (s : PState) :
%      wf_state(program(mp))(s) IMPLIES
%        wf_state(ann_program(mp))(s)


%  ann_program_preserves_pstate_vars : LEMMA % :-)
%    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
%      wf_state(mp)(sMP) IMPLIES
%      wf_state(ann_program(mp))(sAP) IMPLIES
%        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP))) AND
%        (is_local(vn, pstate(sMP)) IFF is_local(vn, pstate(sAP)))

%  ann_program_preserves_ghoststate_vars : LEMMA % :-)
%    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
%      wf_state(mp)(sMP) IMPLIES
%      wf_state(ann_program(mp))(sAP) IMPLIES
%        (is_ghost(vn, sMP) IMPLIES is_ghost(vn, sAP))

%  var_names_ann_program : LEMMA % :-)
%    subset?(var_names(ann_program(mp)),
%            union(var_names(program(mp)), var_names(new_lvars(mp))))

%  var_names_declared_in_MVA_subset_ghostvars : LEMMA % :-)
%    subset?(var_names(vdsA(mva(mp))),
%            var_names(getGhostDecls(ann_program(mp))))

%  ann_program_defines_MVA_vars : LEMMA % :-)
%    FORALL (n : Name) : var_names(new_lvars(mp))(n) IMPLIES
%      EXISTS (c : Class, gd : FieldDecl) :
%        classes(ann_program(mp))(c) AND
%        name(c) = class_name(mva(mp)) AND
%        ghost_vars(c)(gd) AND name(gd) = n

%  new_vars_ghost_in_ann_program : LEMMA % :-)
%    FORALL (n : Name, s : APState) :
%      wf_state(ann_program(mp))(s) IMPLIES
%      var_names(new_lvars(mp))(n) IMPLIES
%        is_ghost(n, s)


%  wf_Body_MVA_implies_wf_Body : LEMMA % :-)
%    FORALL (e : Expr) :
%      wf_Body(mva(mp))(e) IMPLIES
%        wf_Body(ann_program(mp))(e)

%  one_action_source_wf_Body : LEMMA % :-)
%    FORALL (a : Action, oa : OneAction) :
%      wf_Action(mva(mp))(a) IMPLIES
%      member(oa, a) IMPLIES
%        wf_Body(ann_program(mp))(source(oa))

%  one_action_translation_wf_Body : LEMMA % :-)
%    FORALL (a : Action, oa : OneAction) :
%      wf_Action(mva(mp))(a) IMPLIES
%      member(oa, a) IMPLIES
%        wf_Body(ann_program(mp))(Set(target(oa), source(oa)))

%  ann_action_yields_wf_Body : LEMMA % :-)
%    FORALL (a : Action) :
%      wf_Action(mva(mp))(a) IMPLIES
%        wf_Body(ann_program(mp))(ann_action(a))

%  update_vars_wf_Stmt : LEMMA % :-)
%    FORALL (t : Transition) :
%      ts(mva(mp))(t) IMPLIES
%        wf_Stmt(ann_program(mp))(update_vars(mp)(t))

%  guard_to_expression_wf_BoolExpr : LEMMA % :-)
%    FORALL (t : Transition) :
%      ts(mva(mp))(t) IMPLIES
%        wf_BoolExpr(ann_program(mp))(guard_to_expression(mva(mp))(guard(t)))

% ann_trans_cp_wf : LEMMA % :-)
%   FORALL (q : CP, ts : finite_set[Transition]) :
%     LET p = ann_trans_cp(mp)(q, ts) IN
%     cps(mva(mp))(q) IMPLIES
%     subset?(ts, ts(mva(mp))) IMPLIES
%       (wf_BoolExpr(ann_program(mp))(p`1) AND
%        wf_Stmt(ann_program(mp))(p`2))

%  ann_event_wf_Body : LEMMA % :-)
%    FORALL (ts : finite_set[Transition]) :
%      subset?(ts, ts(mva(mp))) IMPLIES
%        wf_Body(ann_program(mp))(ann_event(mp)(ts))

%  ann_program_preserves_wf_method : LEMMA % :-)
%    FORALL (m : (wf_Method(program(mp)))) :
%      wf_Method(ann_program(mp))(ann_method(mp)(m))


%  ann_program_preserves_wf_body : LEMMA % :-)
%    FORALL (b : (wf_Body(program(mp)))) :
%      wf_Body(ann_program(mp))(b)


%  get_class_ann_program : LEMMA % :-)
%    FORALL (c1, c2 : Class, tgt : Val) :
%      up?(get_class(program(mp))(tgt)) IMPLIES
%      up?(get_class(ann_program(mp))(tgt)) IMPLIES
%      c1 = down(get_class(program(mp))(tgt)) IMPLIES
%      c2 = down(get_class(ann_program(mp))(tgt)) IMPLIES
%        name(c1) = name(c2)

%  same_class_name_ann_class_implies_same_class : LEMMA % :-)
%    FORALL (c1, c2 : Class) :
%      classes(program(mp))(c1) IMPLIES
%      classes(ann_program(mp))(c2) IMPLIES
%      name(c1) = name(c2) IMPLIES
%        IF name(c1) = class_name(mva(mp))
%        THEN c2 = ann_class(mp)(c1)
%        ELSE c2 = c1
%        ENDIF

%  same_method_name_ann_class_implies_same_method : LEMMA % :-)
%    FORALL (c1, c2 : Class, m1, m2 : Method) :
%      classes(program(mp))(c1) IMPLIES
%      c2 = ann_class(mp)(c1) IMPLIES
%      name(c1) = class_name(mva(mp)) IMPLIES
%      methods(c1)(m1) IMPLIES
%      methods(c2)(m2) IMPLIES
%      name(m1) = name(m2) IMPLIES
%        m2 = ann_method(mp)(m1)


%  lookup_mthd_ann_program : LEMMA % :-)
%    FORALL (m1, m2 : Method, mn : Name, tgt : Val) :
%      up?(lookup_mthd(program(mp), tgt, mn)) IMPLIES
%      up?(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
%      m1 = down(lookup_mthd(program(mp), tgt, mn)) IMPLIES
%      m2 = down(lookup_mthd(ann_program(mp), tgt, mn)) IMPLIES
%        IF name(down(get_class(program(mp))(tgt))) = class_name(mva(mp))
%        THEN m2 = ann_method(mp)(m1)
%        ELSE m2 = m1
%        ENDIF


%  ann_program_preserves_class_names : LEMMA % :-)
%    class_names(program(mp)) = class_names(ann_program(mp))

%  up_get_class_equivalence : LEMMA % :-)
%    FORALL(a : Val) :
%      up?(get_class(program(mp))(a)) IMPLIES
%        up?(get_class(ann_program(mp))(a))

%  get_class_equivalence : LEMMA % :-)
%    FORALL(a : Val) :
%      up?(get_class(program(mp))(a)) IMPLIES
%      IF name(down(get_class(program(mp))(a))) = class_name(mva(mp))
%      THEN get_class(ann_program(mp))(a) =
%             up(ann_class(mp)(down(get_class(program(mp))(a))))
%      ELSE get_class(ann_program(mp))(a) = get_class(program(mp))(a)
%      ENDIF


%END AnnotateProgramProperties
