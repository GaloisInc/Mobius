NewVar[Name : TYPE] : DATATYPE
BEGIN

  IMPORTING Program[Name]

  res(m : Method) : res?
  ex(m : Method) : ex?

END NewVar

InlineVariableNames[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  ENDASSUMING

  IMPORTING WellFormedProgram[Name]

  legal_names(p : Program)(n : Name) : bool =
    NOT union(declared_var_names(p), reserved_words)(n)


END InlineVariableNames


InlineNewVariableDeclarations[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

  ENDASSUMING

  res_ex(p : Program): (injective?[NewVar[Name], (legal_names(p))])

  res(p : Program)(m : Method) : Name = res_ex(p)(res(m))

  ex(p : Program)(m : Method) : Name = res_ex(p)(ex(m))

  p : VAR Program
  m : VAR Method

  res_ex_disjoint : LEMMA % :-)
    FORALL(m1, m2 : Method) :
     (NOT res(p)(m1) = ex(p)(m2)) AND
     (NOT m1 = m2 IMPLIES
         (NOT res(p)(m1) = res(p)(m2)) AND
         (NOT ex(p)(m1) = ex(p)(m2)))


  % Variables that will be added for the inline process

  new_res_lvar(p, m) : LocalVarDecl =
    (# name := res(p)(m),
       jtype := res_type(m) #)

  new_ex_lvar(p, m) : LocalVarDecl =
    (# name := ex(p)(m),
       jtype := BoolType #)

  new_res_lvars(p) : finite_set[LocalVarDecl] =
    {lv : LocalVarDecl | EXISTS (m : Method) : 
                        methods(p)(m) AND lv = new_res_lvar(p, m) }


  new_ex_lvars(p) : finite_set[LocalVarDecl] =
    {lv : LocalVarDecl | EXISTS (m : Method) : 
                        methods(p)(m) AND lv = new_ex_lvar(p, m) }

  new_lvars(p) : finite_set[LocalVarDecl] =
    union(new_res_lvars(p), new_ex_lvars(p))

  new_res_lvar_new_lvar : LEMMA % :-)
     methods(p)(m) IMPLIES
     new_lvars(p)(new_res_lvar(p, m))

  new_ex_lvar_new_lvar : LEMMA % :-)
     methods(p)(m) IMPLIES
     new_lvars(p)(new_ex_lvar(p, m))

  IMPORTING ProgramFunctions[Name], SetProp[Name]

  new_lvars_not_field_decls : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), var_names(getFieldDecls(p)))
 
  new_lvars_not_ghost_decls : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), var_names(getGhostDecls(p)))

  new_lvars_not_old_local_decls : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), var_names(getLocalDecls(p)))

  new_lvars_not_reserved_words : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), reserved_words)

  new_vars_not_ext_declared_var_names : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), ext_declared_var_names(p))

  new_lvars_not_ext_declared_var_names : LEMMA % :-)
     disjoint?(var_names(new_lvars(p)), ext_declared_var_names(p))


END InlineNewVariableDeclarations


InlineMethodAnnotation[Name : TYPE+] : THEORY
BEGIN

  ASSUMING


    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})


  IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING


  IMPORTING InlineNewVariableDeclarations[Name]

  p : VAR Program
  m : VAR Method

  % with every method call, ex initialised to false

  % several try-catches needed, because we do not model subclass hierarchy
  % of exceptions

  % MH: name ex a bit unfortunate, should rather be no_ex
  % AT: Right, but if you don't want to change the name we could assing it
  %     false after body and then test !ex in the finally clause

  % inline_method_body(p)(m) gives in Java-like syntax:
  % try{
  %   try{
  %     pre_set(m);
  %     body(m);
  %     ex := true;
  %   }
  %   catch(Throwable){
  %     exc_set(m);
  %   }
  % catch(NullPointerExc){
  %   exc_set(m);
  % }
  % finally{
  %   if (ex){
  %     res := res(m);
  %     post_set(m);
  %   }
  % }
  inline_method_body(p)(m) : Body = 
    TryCatch(
       TryCatch(
        Sequence(
          pre_set(m)(var_lookup(name(arg(m)))(jtype(arg(m)))),
          Sequence(
            body(m),
            Sequence(StmtExpr(Assign(res(p)(m), res(m))),
                     StmtExpr(Assign(ex(p)(m), BExpr(TT)))))),
                             % this is only executed if body terminates
                             % normally
         Throwable,
         exc_set(m)(Throwable),
         Skip),
       NullPointer,
       exc_set(m)(NullPointer),
       IfThenElse(
         BoolVarEval(ex(p)(m)),
         post_set(m)(var_lookup(res(p)(m))(res_type(m))),
         Skip))
         

  inline_method(p)(m : Method) : Method =
    m WITH [pre_set  := LAMBDA(v : Expr) : Skip,
            post_set := LAMBDA(v : Expr) : Skip,
            exc_set := LAMBDA (e : Excpt) : Skip,
            lvars := add(new_res_lvar(p, m),
                     add(new_ex_lvar(p, m), lvars(m))),
            body := inline_method_body(p)(m),
            res := var_lookup(res(p)(m))(res_type(m))]


  inline_methods(p)(ms : finite_set[Method]) : finite_set[Method] =
    {m : Method | EXISTS (n : Method) : ms(n) AND m = inline_method(p)(n)}

  inline_method_name : LEMMA % :-)
    FORALL (m : Method) :
      name(inline_method(p)(m)) = name(m)

  inline_method_arg : LEMMA % :-)
    FORALL (m : Method) :
      arg(inline_method(p)(m)) = arg(m)

  inline_method_pre : LEMMA % :-)
    FORALL (m : Method) :
      pre(inline_method(p)(m)) = pre(m)

  inline_method_post : LEMMA % :-)
    FORALL (m : Method) :
      post(inline_method(p)(m)) = post(m)

  inline_method_lvars : LEMMA % :-)
    FORALL (m : Method) :
      lvars(inline_method(p)(m)) = 
        add(new_res_lvar(p, m),
        add(new_ex_lvar(p, m), lvars(m)))

  inline_method_body : LEMMA % :-)
    FORALL (m : Method) :
      body(inline_method(p)(m)) = inline_method_body(p)(m)

  inline_method_pre_set : LEMMA % :-)
    FORALL (m : Method) :
      pre_set(inline_method(p)(m)) = LAMBDA(v : Expr) : Skip

  inline_method_post_set : LEMMA % :-)
    FORALL (m : Method) :
      post_set(inline_method(p)(m)) = LAMBDA(v : Expr) : Skip

  inline_method_exc_set : LEMMA % :-)
    FORALL (m : Method) :
      exc_set(inline_method(p)(m)) = LAMBDA(e : Excpt) : Skip

  inline_method_res : LEMMA % TO DO
    FORALL (m : Method) :
      res(inline_method(p)(m)) = var_lookup(res(p)(m))(res_type(m))

  inline_method_res_type : LEMMA % :-)
    FORALL (m : Method) :
      res_type(inline_method(p)(m)) = res_type(m)

  inline_method_wf_Body1 : LEMMA % :-)
    FORALL(m : Method) :
      methods(p)(m) IMPLIES
      wf_Method(p)(m) IMPLIES
      LET im = inline_method(p)(m) IN
      (FORALL(v : Name) : var_names(body(im))(v) IMPLIES
                          ext_declared_var_names(p)(v) OR
                          var_names(new_lvars(p))(v))
      AND
      (FORALL(v : Name, e : Expr) : var_names(pre(im)(e))(v) IMPLIES
                          ext_declared_var_names(p)(v))
      AND
      (FORALL(v : Name, e : Expr) : var_names(post(im)(e))(v) IMPLIES
                          ext_declared_var_names(p)(v))
      AND
      (FORALL(v : Name) : var_names(res(im))(v) IMPLIES
                          var_names(new_lvars(p))(v))
      AND
      (FORALL(v : Name, e : Expr) : NOT var_names(pre_set(im)(e))(v))
      AND
      (FORALL(v : Name, e : Expr) : NOT var_names(post_set(im)(e))(v))
      AND
      (FORALL(v : Name, e : Excpt) : NOT var_names(exc_set(im)(e))(v))

  inline_method_wf_Body2 : LEMMA % :-)
    FORALL(m : Method, b : Body) :
      wf_Method(p)(m) IMPLIES
      Set?(b) IMPLIES
      LET im = inline_method(p)(m) IN
      (subterm(b, body(im)) IMPLIES
         var_names(getGhostDecls(p))(target(b))) AND
      (FORALL(e : Expr) : 
       subterm(b, pre(im)(e)) IMPLIES
         var_names(getGhostDecls(p))(target(b))) AND
      (FORALL(e : Expr) :
       subterm(b, post(im)(e)) IMPLIES
         var_names(getGhostDecls(p))(target(b))) AND
      (NOT subterm(b, res(im))) AND
      (FORALL(e : Expr) : NOT subterm(b, pre_set(im)(e))) AND
      (FORALL(e : Expr) : NOT subterm(b, post_set(im)(e))) AND
      (FORALL(e : Excpt) : NOT subterm(b, exc_set(im)(e)))


END InlineMethodAnnotation


InlineClassAnnotation[Name : TYPE+] : THEORY
BEGIN

  ASSUMING


    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING

  IMPORTING InlineMethodAnnotation[Name]

  p : VAR Program


  inline_class(p)(c : Class) : Class =
    c WITH [methods := inline_methods(p)(methods(c))]

  inv_inline_class : LEMMA
    FORALL(c : Class) :
      inv(inline_class(p)(c)) = inv(c)

  FieldDecls_inline_class : LEMMA % :-)
    FORALL(c : Class) :
      fields(inline_class(p)(c)) = fields(c)

  GhostDecls_inline_class : LEMMA % :-)
    FORALL(c : Class) :
      ghost_vars(inline_class(p)(c)) = ghost_vars(c)

  name_inline_class : LEMMA
    FORALL(c : Class) :
      name(inline_class(p)(c)) = name(c)

  inline_class_almost_wf_Class : LEMMA % :-)
    FORALL(c : Class) :
      wf_Class(p)(c) IMPLIES
      LET ic = inline_class(p)(c) IN
        FORALL (m1, m2 : Method) :
           methods(ic)(m1) IMPLIES
           methods(ic)(m2) IMPLIES
           name(m1) = name(m2) IMPLIES
           m1 = m2

  inline_class_inv_wf_Body1 : LEMMA % :-)
    FORALL(c : Class) :
      wf_Body(p)(inv(c)) IMPLIES
       (FORALL (v : Name) : var_names(inv(inline_class(p)(c)))(v) IMPLIES
                            ext_declared_var_names(p)(v))

  inline_class_inv_wf_Body2 : LEMMA % :-)
    FORALL(c : Class) :
      wf_Body(p)(inv(c)) IMPLIES
         FORALL(b : Body) : 
           Set?(b) IMPLIES 
           subterm(b, inv(inline_class(p)(c))) IMPLIES 
            var_names(getGhostDecls(p))(target(b))



END InlineClassAnnotation


InlineProgramAnnotation[Name : TYPE+] : THEORY
BEGIN

  ASSUMING


    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]


    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING

  IMPORTING InlineClassAnnotation[Name]

  p : VAR Program

  % Inline set-annotations into method bodies

  IMPORTING SetProp[Name] % to prove TCC

  inline_program(p) : Program =
    (# classes := {c : Class | EXISTS (c1 : Class) :
                                 classes(p)(c1) AND
                                 c = inline_class(p)(c1)} #)


  LocalDecls_inline_program : LEMMA % :-)
    getLocalDecls(inline_program(p)) = 
      union(getLocalDecls(p), new_lvars(p))


END InlineProgramAnnotation



InlineProgramAnnotationProperties[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

  IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))


  ENDASSUMING


  IMPORTING InlineProgramAnnotation[Name],
            AnnotatedProgramSemantics[Name]

  p : VAR Program

  inline_program_class_correspondence : LEMMA % :-)
    FORALL(c : Class) : classes(inline_program(p))(c) IMPLIES
      EXISTS (c1 : Class) : classes(p)(c1) AND c = inline_class(p)(c1)

  inline_program_method_correspondence : LEMMA % :-)
    FORALL(c : Class, m : Method) :
      classes(inline_program(p))(c) IMPLIES
      methods(c)(m) IMPLIES
        EXISTS (c1 : Class, m1 : Method) :
          classes(p)(c1) AND methods(c1)(m1) AND m = inline_method(p)(m1)

  inline_program_preserves_Field_decls : LEMMA % :-)
    getFieldDecls(inline_program(p)) = getFieldDecls(p) 


  inline_program_preserves_Ghost_decls : LEMMA % :-)
    getGhostDecls(inline_program(p)) = getGhostDecls(p)


  inline_program_add_LocalVar_decls : LEMMA % :-)
    getLocalDecls(inline_program(p)) = union(getLocalDecls(p), new_lvars(p))

  inline_program_ext_declared_var_names : LEMMA % :-)
     ext_declared_var_names(inline_program(p)) =
       union(ext_declared_var_names(p), var_names(new_lvars(p)))


% NOT PROVABLE AS IS NOW: SEE IF USED
%  inline_program_preserves_wf_state : LEMMA % :-)
%    FORALL (s : PState) :
%      wf_state(p)(s) IMPLIES
%        wf_state(inline_program(p))(s)

%  new_vars_local_in_inline_program : LEMMA % :-)
%    FORALL (n : Name, s : APState) :
%      wf_state(inline_program(p))(s) IMPLIES
%      var_names(new_lvars(p))(n) IMPLIES
%        is_local(n, pstate(s))


% NOT SURE THAT THESE WILL BE USED
%  inline_program_preserves_fields : LEMMA % :-)
%    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
%      wf_state(p)(sMP) IMPLIES
%      wf_state(inline_program(p))(sAP) IMPLIES
%        (is_field(vn, pstate(sMP)) IFF is_field(vn, pstate(sAP)))

%  inline_program_preserves_ghoststate_vars : LEMMA % :-)
%    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
%      wf_state(p)(sMP) IMPLIES
%      wf_state(inline_program(p))(sAP) IMPLIES
%        (is_ghost(vn, sMP) IFF is_ghost(vn, sAP))

%  inline_program_preserves_local_vars : LEMMA % :-)
%    FORALL (vn : Name)(sMP : MPState, sAP : APState) :
%      wf_state(p)(sMP) IMPLIES
%      wf_state(inline_program(p))(sAP) IMPLIES
%        (is_local(vn, sMP) IMPLIES is_local(vn, sAP))

  var_names_inline_program : LEMMA % :-)
    subset?(var_names(inline_program(p)),
            union(var_names(p), var_names(new_lvars(p))))


  % not directly: needs methods(p)(m)
  inline_program_preserves_wf_method : LEMMA % :-)
    FORALL (m : Method) :
      methods(p)(m) IMPLIES
      wf_Method(inline_program(p))(inline_method(p)(m))


  inline_program_preserves_wf_body : LEMMA % :-)
    FORALL (b : (wf_Body(p))) :
      wf_Body(inline_program(p))(b)


  get_class_inline_program : LEMMA % :-)
    FORALL (c1, c2 : Class, tgt : Val) :
      up?(get_class(p)(tgt)) IMPLIES
      up?(get_class(inline_program(p))(tgt)) IMPLIES
      c1 = down(get_class(p)(tgt)) IMPLIES
      c2 = down(get_class(inline_program(p))(tgt)) IMPLIES
        name(c1) = name(c2)

  same_class_name_inline_class_implies_same_class : LEMMA % :-)
    FORALL (c1, c2 : Class) :
      classes(p)(c1) IMPLIES
      classes(inline_program(p))(c2) IMPLIES
      name(c1) = name(c2) IMPLIES
        c2 = inline_class(p)(c1)

  same_method_name_inline_class_implies_same_method : LEMMA % :-)
    FORALL (c1, c2 : Class, m1, m2 : Method) :
      classes(p)(c1) IMPLIES
      c2 = inline_class(p)(c1) IMPLIES
      methods(c1)(m1) IMPLIES
      methods(c2)(m2) IMPLIES
      name(m1) = name(m2) IMPLIES
        m2 = inline_method(p)(m1)


  lookup_mthd_inline_program : LEMMA % :-)
    FORALL (m1, m2 : Method, mn : Name, tgt : Val) :
      up?(lookup_mthd(p, tgt, mn)) IMPLIES
      up?(lookup_mthd(inline_program(p), tgt, mn)) IMPLIES
      m1 = down(lookup_mthd(p, tgt, mn)) IMPLIES
      m2 = down(lookup_mthd(inline_program(p), tgt, mn)) IMPLIES
        m2 = inline_method(p)(m1)


  inline_program_preserves_class_names : LEMMA % :-)
    class_names(p) = class_names(inline_program(p))

  up_get_class_equivalence : LEMMA % :-)
    FORALL(a : Val) :
      up?(get_class(p)(a)) IMPLIES
        up?(get_class(inline_program(p))(a))

  get_class_equivalence : LEMMA % :-)
    FORALL(a : Val) :
      up?(get_class(p)(a)) IMPLIES
      get_class(inline_program(p))(a) =
        up(inline_class(p)(down(get_class(p)(a))))


END InlineProgramAnnotationProperties
