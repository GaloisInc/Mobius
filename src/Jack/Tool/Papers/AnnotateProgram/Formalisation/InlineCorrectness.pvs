CorrectnessInlineProgram[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [Method -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

  ENDASSUMING


  IMPORTING InlineRelatedStatesProperties[Name]
  IMPORTING WfSetStmts[Name, Program, APState, id,
                       LAMBDA (s : APState) : pstate(s),
                       lookup,
                       update_PState,
                       execute_set,
                       execute_assert,
                       execute_CaseJML,
                       on_method_entry,
                       on_method_exit_normal,
                       on_method_exit_exceptional]

  p : VAR ({p : Program | wf_set_stmts(p) AND 
                          contains_no_method_call_in_sets_in_program(p)})


  derive_maintains_inline_related_states_for_method_call : LEMMA
    FORALL (b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      MethodCall?(b) IMPLIES
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      (FORALL(b : (wf_Body(p)), v1, v2 : Val)
             (sAP1a, sAP1b, sAP2a, sAP2b : APState)
             (m1 : below(n1), m2 : below(n2)) :
        subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
        inline_related_states(p)(sAP1a, sAP2a) IMPLIES
        derive(p)(b, sAP1a, v1, sAP1b)(m1) IMPLIES
        derive(inline_program(p))(b, sAP2a, v2, sAP2b)(m2) IMPLIES
          inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
        inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2

  % Base case
  initial_states_are_equivalent : LEMMA % :-)
    FORALL (root_object : (defined?)) :
      inline_related_states(p)
        (initial_AP_state(p)(root_object),
         initial_AP_state(inline_program(p))(root_object))

  % Inductive case
  derive_maintains_inline_related_states_for_unchanged_program : THEOREM
    FORALL (p : (wf_set_stmts), b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
        inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2

  % The main result
  correctness_of_inline_program : THEOREM % :-)
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (sAP1, sAP2 : APState) :
      run_annotated_program(p)(main, arg)(root_object)(sAP1) IMPLIES
      run_annotated_program(inline_program(p))
                               (main, arg)(root_object)(sAP2) IMPLIES
        inline_related_states(p)(sAP1, sAP2)


END CorrectnessInlineProgram
