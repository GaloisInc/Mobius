MethodCallsPreserveInlineRelatedState[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

  ENDASSUMING



%  method_call_lemma : LEMMA % :-)
%    FORALL(b : (wf_Body(program(mp))), x : [nat, nat],
%           m11, m21, m31, m41, m51, m61, m12, m22, m32, m42, m52, m62 : nat,
%           sMP1, sMP2, tauMP1, tauMP2, tauMP3, tauMP4, tauMP5, tauMP6, 
%           tauMP7 : MPState,
%           sAP1, sAP2, tauAP1, tauAP2, tauAP3, tauAP4, tauAP5, tauAP6,
%           tauAP7 : APState,
%           a1, a2, pv1, pv2, v1, v2, w1, w2, x1, x2 : Val, 
%           old_lvs1, old_lvs2 : Store,
%           md1 : (wf_Method(program(mp))), md2 : (wf_Method(ann_program(mp)))):
%      MethodCall?(b) IMPLIES
%      x`1 = 1 + m11 + m21 + m31 + m41 + m51 + m61 IMPLIES
%      derive(mp)(tgt(b), sMP1, a1, tauMP1)(m11) IMPLIES
%      derive(mp)(arg(b), tauMP1, pv1, tauMP2)(m21) IMPLIES
%      IF bottom?(ex(pstate(tauMP2))) AND Null?(a1)
%      THEN sMP2 = update_PState(tauMP2, raise(NullPointer)) AND
%           v1 = Bottom AND m31 = 0 AND m41 = 0 AND m51 = 0 AND m61 = 0
%      ELSE IF up?(ex(pstate(tauMP2))) 
%      THEN sMP2 = tauMP2 AND 
%            v1 = Bottom AND 
%            m31 = 0 AND m41 = 0 AND m51 = 0 AND m61 = 0
%      ELSE IF up?(lookup_mthd(program(mp), a1, name(b)))
%           THEN md1 = down(lookup_mthd(program(mp), a1, name(b)))
%           ELSE FALSE
%           ENDIF AND
%           old_lvs1 = lvs(st(pstate(tauMP2))) AND
%           tauMP3 = update_stack(a1, arg(md1), pv1, lvars(md1), tauMP2) AND
%           on_method_entry_MP(mp, md1, a1, tauMP3, tauMP4, m31, 
%                              LAMBDA (k: upto(m31))
%                                          (p: MonitoredProgram[CP, Name])
%                                          (b: (wf_Body(program(p))),
%                                           sigma1: MPState[CP, Name],
%                                           v: Val[Name],
%                                           sigma2: MPState[CP, Name])
%                                          (m: below(k)):
%                                     derive(p)(b, sigma1, v, sigma2)(m))
%            AND derive(mp)(body(md1), tauMP4, x1, tauMP5)(m41)
%            AND x1 = Semantics.return_of_stmt(tauMP5)
%            AND IF Void?(res_type(md1))
%                THEN tauMP6 = tauMP5 AND w1 = Unit AND m51 = 0
%                ELSE derive(mp)(res(md1), tauMP5, w1, tauMP6)(m51)
%                ENDIF
%            AND IF bottom?(ex(pstate(tauMP6)))
%                  THEN on_method_exit_normal_MP(mp, md1, a1, tauMP6, tauMP7, m61,
%                                                LAMBDA
%                                                (k: upto(m61))
%                                                (p:
%                                                 MonitoredProgram[CP, Name])
%                                                (b: (wf_Body(program(p))),
%                                                 sigma1: MPState[CP, Name],
%                                                 v: Val[Name],
%                                                 sigma2: MPState[CP, Name])
%                                                (m: below(k)):
%                                                derive(p)(b, sigma1, v, sigma2)(m))
%                ELSE on_method_exit_exceptional_MP(mp, md1,a1, tauMP6, tauMP7, m61,
%                                                   LAMBDA
%                                                   (k: upto(m61))
%                                                   (p:
%                                                    MonitoredProgram
%                                                    [CP, Name])
%                                                   (b:
%                                                    (wf_Body(program(p))),
%                                                    sigma1:
%                                                    MPState[CP, Name],
%                                                    v: Val[Name],
%                                                    sigma2:
%                                                    MPState[CP, Name])
%                                                   (m: below(k)): 
%                                                   derive(p)(b, sigma1, v, sigma2)(m))
%                ENDIF
%            AND IF up?(ex(pstate(tauMP7))) THEN v1 = Bottom
%                ELSE v1 = w1
%                ENDIF
%            AND sMP2 =
%                 update_PState(tauMP7,
%                               LAMBDA(pstate : PState) : 
%                                 pstate WITH 
%                                 [st := st(pstate) WITH [lvs := old_lvs1]])
%      ENDIF ENDIF IMPLIES
%      ex(pstate(sMP1)) = ex(pstate(sAP1)) IMPLIES
%      (FORALL (y: [nat, nat]):
%        PROJ_1(y) < PROJ_1(x) AND PROJ_2(y) < PROJ_2(x) IMPLIES
%         (FORALL (b: (wf_Body(program(mp))), v1, v2: Val)
%                 (sMP1, sMP2: MPState, sAP1, sAP2: APState):
%            subset?(var_names(b), ext_declared_var_names(program(mp)))
%             IMPLIES
%             related_states(mp)(sMP1, sAP1) IMPLIES
%              derive(mp)(b, sMP1, v1, sMP2)(y`1) IMPLIES
%               derive(ann_program(mp))(b, sAP1, v2, sAP2)(y`2) IMPLIES
%                legal_Body(ann_program(mp))(b) IMPLIES
%                 related_states(mp)(sMP2, sAP2) AND
%                  (NOT cp(astate(sMP2)) = halted IMPLIES v1 = v2))) IMPLIES
%      well_behaved_MVA(mp) IMPLIES
%      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
%      related_states(mp)(sMP1, sAP1) IMPLIES
%      x`2 = 1 + m12 + m22 + m32 + m42 + m52 + m62 IMPLIES
%      derive(ann_program(mp))(tgt(b), sAP1, a2, tauAP1)(m12) IMPLIES
%      derive(ann_program(mp))(arg(b), tauAP1, pv2, tauAP2)(m22) IMPLIES
%      IF bottom?(ex(pstate(tauAP2))) AND Null?(a2)
%      THEN sAP2 = update_PState(tauAP2, raise(NullPointer))
%           AND v2 = Bottom AND m32 = 0 AND m42 = 0 AND m52 = 0
%           AND m62 = 0
%      ELSIF up?(ex(pstate(tauAP2))) 
%      THEN sAP2 = tauAP2 AND 
%           v2 = Bottom AND 
%           m32 = 0 AND m42 = 0 AND m52 = 0 AND m62 = 0
%      ELSE IF up?(lookup_mthd(ann_program(mp), a2, name(b)))
%           THEN md2 = down(lookup_mthd(ann_program(mp), a2, name(b)))
%           ELSE FALSE
%           ENDIF AND
%           old_lvs2 = lvs(st(pstate(tauAP2))) AND
%           tauAP3 = update_stack(a2, arg(md2), pv2, lvars(md2), tauAP2) AND
%           on_method_entry(ann_program(mp), md2, a2, tauAP3, tauAP4, m32, 
%                                LAMBDA (k: upto(m32))
%                                       (p: Program[Name])
%                                       (b: (wf_Body(id(p))),
%                                        sigma1: APState[Name],
%                                        v: Val[Name],
%                                        sigma2: APState[Name])
%                                       (m: below(k)):
%                                  derive(p)(b, sigma1, v, sigma2)(m))
%            AND derive(ann_program(mp))(body(md2), tauAP4, x2, tauAP5)(m42)
%            AND x2 = Semantics.return_of_stmt(tauAP5)
%            AND IF Void?(res_type(md2))
%                THEN tauAP6 = tauAP5 AND w2 = Unit AND m52 = 0
%                ELSE derive(ann_program(mp))(res(md2), tauAP5, w2, tauAP6)(m52)
%                ENDIF
%            AND IF bottom?(ex(pstate(tauAP6)))
%                  THEN on_method_exit_normal(ann_program(mp), md2, a2, tauAP6, tauAP7, m62,
%                                             LAMBDA
%                                             (k: upto(m62))
%                                             (p: Program[Name])
%                                             (b: (wf_Body(id(p))),
%                                              sigma1: APState[Name],
%                                              v: Val[Name],
%                                              sigma2: APState[Name])
%                                             (m: below(k)):
%                                             derive(p)(b, sigma1, v, sigma2)(m))
%                ELSE on_method_exit_exceptional(ann_program(mp), md2, a2, tauAP6, tauAP7, m62,
%                                                LAMBDA
%                                                (k: upto(m62))
%                                                (p: Program[Name])
%                                                (b: (wf_Body(id(p))),
%                                                 sigma1: APState[Name],
%                                                 v: Val[Name],
%                                                 sigma2: APState[Name])
%                                                (m: below(k)):
%                                                derive(p)(b, sigma1, v, sigma2)(m))
%                ENDIF
%            AND IF up?(ex(pstate(tauAP7))) THEN v2 = Bottom
%                ELSE v2 = w2
%                ENDIF
%            AND sAP2 = update_PState(tauAP7,
%                               LAMBDA(pstate : PState) : 
%                                 pstate WITH 
%                                 [st := st(pstate) WITH [lvs := old_lvs2]])
%      ENDIF IMPLIES
%      legal_Program(ann_program(mp)) IMPLIES
%      legal_Body(ann_program(mp))(b) IMPLIES
%      NOT up?(ex(pstate(sAP1))) IMPLIES
%      related_states(mp)(sMP2, sAP2) AND
%       (NOT cp(astate(sMP2)) = halted IMPLIES v1 = v2)


END MethodCallsPreserveInlineRelatedState


CorrectnessInlineProgram[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING NewVar[Name], InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [NewVar[Name] -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

  ENDASSUMING


  IMPORTING InlineRelatedStatesProperties[Name]
  IMPORTING WfSetStmts[Name, Program, APState, id,
                       LAMBDA (s : APState) : pstate(s),
                       lookup,
                       update_PState,
                       execute_set,
                       execute_assert,
                       execute_CaseJML,
                       on_method_entry,
                       on_method_exit_normal,
                       on_method_exit_exceptional]

  p : VAR ({p : Program | wf_set_stmts(p) AND 
                          contains_no_method_call_in_sets_in_program(p)})


  derive_maintains_inline_related_states_for_method_call : LEMMA
    FORALL (b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      MethodCall?(b) IMPLIES
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      (FORALL(b : (wf_Body(p)), v1, v2 : Val)
             (sAP1a, sAP1b, sAP2a, sAP2b : APState)
             (m1 : below(n1), m2 : below(n2)) :
        subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
        inline_related_states(p)(sAP1a, sAP2a) IMPLIES
        derive(p)(b, sAP1a, v1, sAP1b)(m1) IMPLIES
        derive(inline_program(p))(b, sAP2a, v2, sAP2b)(m2) IMPLIES
          inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
        inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2

  % Base case
  initial_states_are_equivalent : LEMMA % :-)
    FORALL (root_object : (defined?)) :
      inline_related_states(p)
        (initial_AP_state(p)(root_object),
         initial_AP_state(inline_program(p))(root_object))

  % Inductive case
  derive_maintains_inline_related_states_for_unchanged_program : THEOREM
    FORALL (p : (wf_set_stmts), b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
        inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2

  % The main result
  correctness_of_inline_program : THEOREM % :-)
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (sAP1, sAP2 : APState) :
      run_annotated_program(p)(main, arg)(root_object)(sAP1) IMPLIES
      run_annotated_program(inline_program(p))
                               (main, arg)(root_object)(sAP2) IMPLIES
        inline_related_states(p)(sAP1, sAP2)


END CorrectnessInlineProgram
