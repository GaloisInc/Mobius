(WF
 (well_founded?_product 0
  (well_founded?_product-1 nil 3372766387 3372767677
   ("" (skosimp*)
    (("" (expand "well_founded?")
      (("" (skosimp*)
        (("" (inst -1 "LAMBDA(x : A) : EXISTS(y : B) : p!1(x, y)")
          (("" (split -1)
            (("1" (skosimp*)
              (("1" (inst -2 "LAMBDA(y : B) : p!1(y!2, y)")
                (("1" (split -2)
                  (("1" (skosimp*)
                    (("1" (inst 1 "(y!2, y!3)")
                      (("1" (skosimp*)
                        (("1" (inst -2 "PROJ_1(x!1)")
                          (("1" (typepred "x!1")
                            (("1" (inst 1 "PROJ_2(x!1)")
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace
                                   "x!1 = (PROJ_1(x!1), PROJ_2(x!1))")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "y!2") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (inst 1 "PROJ_1(y!1)" "PROJ_2(y!1)")
              (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((well_founded? const-decl "bool" orders nil)
    (A formal-type-decl nil WF nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (B formal-type-decl nil WF nil) nil nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   714379 6890 t shostak)))
(WFProperties
 (wf_founded_is_not_reflexive 0
  (wf_founded_is_not_reflexive-1 nil 3389439536 3389441483
   ("" (skosimp)
    (("" (expand* "well_founded?" "reflexive?")
      (("" (name "p" "choose({x:T|TRUE})")
        (("1" (inst - "LAMBDA (x : T) : TRUE")
          (("1" (split -)
            (("1" (skosimp*)
              (("1" (inst - "y!1") (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (expand "nonempty?")
          (("2" (expand "empty?")
            (("2" (expand "member") (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil WFProperties nil)
    (pred type-eq-decl nil defined_types nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (well_founded? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil))
   1362337 510 t shostak)))
(WF_Card
 (wf_card 0
  (wf_card-1 nil 3378631808 3383472927
   ("" (expand "well_founded?")
    (("" (skosimp*)
      ((""
        (case "EXISTS (z : finite_set[T]) : p!1(z) AND card[T](z) < card[T](y!1)")
        (("1" (skosimp*)
          (("1"
            (name "S"
                  "{n : nat | EXISTS (z : finite_set[T]) : card[T](z) = n AND p!1(z) AND n < card[T](y!1)}")
            (("1"
              (case "EXISTS (z : finite_set[T]) : p!1(z) AND card[T](z) = min(S)")
              (("1" (skosimp*)
                (("1" (inst 1 "z!2")
                  (("1" (skosimp*)
                    (("1" (replace -3 :dir rl)
                      (("1" (assert)
                        (("1" (replace -2)
                          (("1"
                            (typepred "min({n: nat |
              EXISTS (z: finite_set[T]):
                card[T](z) = n AND p!1(z) AND n < card[T](y!1)})")
                            (("1" (skosimp*)
                              (("1"
                                (inst -4 "card[T](x!1)")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst 1 "x!1")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "nonempty_exists")
                              (("2"
                                (inst 1 "card[T](z!1)")
                                (("2" (inst 1 "z!1") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "min(S)")
                (("1" (replace -3 :dir rl)
                  (("1" (assert)
                    (("1" (skosimp*)
                      (("1" (inst 1 "z!2") (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replace -1 :dir rl)
                  (("2" (rewrite "nonempty_exists")
                    (("2" (inst 1 "card[T](z!1)")
                      (("2" (inst 1 "z!1") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (skosimp*)
                (("3" (replace -2 :dir rl)
                  (("3" (rewrite "nonempty_exists")
                    (("3" (inst 1 "card[T](z!1)")
                      (("3" (inst 1 "z!1") (("3" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (inst 2 "y!1")
          (("2" (skosimp*)
            (("2" (inst 1 "x!1") (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" sets nil) nil nil
    (nonempty_exists formula-decl nil sets_lemmas nil) nil
    (NOT const-decl "[bool -> bool]" booleans nil) nil
    (T formal-type-decl nil WF_Card nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (well_founded? const-decl "bool" orders nil))
   827 630 t shostak)))

