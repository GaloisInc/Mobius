CompleteMonitorProgramPropertiesPreservation[CP, Name : TYPE+] : THEORY
BEGIN

ASSUMING 

    IMPORTING MVA[CP, Name]

    CP_not_only_halted : ASSUMPTION
      EXISTS(cp : CP) : NOT cp = halted

ENDASSUMING

  IMPORTING MonitoredProgramCompletessRelation[CP, Name],
            ContainsNoMethodCall[Name],
            WfSetStmts[Name, MonitoredProgram, MPState,
                             LAMBDA(mp : MonitoredProgram) : program(mp),
                             LAMBDA(s : MPState) : pstate(s),
                             lookup, update_PState, execute_set,
                             execute_assert, execute_CaseJML, 
                             on_method_entry_MP, on_method_exit_normal_MP,
                             on_method_exit_exceptional_MP]

  derive_equivalence : LEMMA % :-)
    FORALL(mp : (wf_and_partial_MP), b : (wf_Body(program(mp))),
           sMP1, sMP2 : MPState, v : Val, n : nat) :
      contains_no_method_call(b) IMPLIES
      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
      derive(complete_MP(mp))(b, sMP1, v, sMP2)(n) IMPLIES
        derive(mp)(b, sMP1, v, sMP2)(n)

  contains_no_method_call_preserved_by_complete_MP : LEMMA % :-)
     FORALL(mp : (wf_and_partial_MP)) :
      contains_no_method_call_in_sets_in_program(program(mp)) IMPLIES
      contains_no_method_call_in_sets_in_program(program(complete_MP(mp)))

  wf_set_stmts_preserved_by_complete_MP : LEMMA
    FORALL(mp : (wf_and_partial_MP)) :
      wf_set_stmts(mp) IMPLIES
      contains_no_method_call_in_sets_in_program(program(mp)) IMPLIES
        wf_set_stmts(complete_MP(mp))

  unit : (LAMBDA(cp : CP) : NOT cp = halted)

  full_partial_MP(p : Program) : (wf_and_partial_MP) =
    (# mva := empty(unit),
       program := p #)

  full_total_MP(p : Program) : (wf_and_complete_MP) =
    complete_MP(full_partial_MP(p))

%  IMPORTING LegalProgramRestriction[Name, MonitoredProgram, MPState,
%                             LAMBDA(mp : MonitoredProgram) : program(mp),
%                             LAMBDA(s : MPState) : pstate(s),
%                             lookup, update_PState, execute_set,
%                             execute_assert, execute_CaseJML, 
%                             on_method_entry_MP, on_method_exit_normal_MP,
%                             on_method_exit_exceptional_MP, full_partial_MP]

%  IMPORTING LegalProgramRestriction[Name, MonitoredProgram, MPState,
%                             LAMBDA(mp : MonitoredProgram) : program(mp),
%                             LAMBDA(s : MPState) : pstate(s),
%                             lookup, update_PState, execute_set,
%                             execute_assert, execute_CaseJML, 
%                             on_method_entry_MP, on_method_exit_normal_MP,
%                             on_method_exit_exceptional_MP, full_total_MP]

%  legal_Program_preserved_by_complete_MP : LEMMA
%    FORALL(mp : (wf_and_partial_MP)) :
%      legal_Program(program(mp)) IMPLIES
%        legal_Program(program(complete_MP(mp)))

END CompleteMonitorProgramPropertiesPreservation



AnnotateProgramPropertiesPreservation[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))
    IMPORTING MVA[CP, Name]

    CP_not_only_halted : ASSUMPTION
      EXISTS(cp : CP) : NOT cp = halted


  ENDASSUMING

  IMPORTING Equivalence[CP, Name]

  make_MPState(mp : (wf_and_complete_MP))(s : APState) : MPState =
    (# astate := initial_MVA_state(mva(mp)),
       stuck := FALSE,
       pstate := pstate(s),
       gvs := gvs(s) #)


  IMPORTING ContainsNoMethodCall[Name]

  derive_equivalence : LEMMA % :-)
    FORALL(mp : (wf_and_complete_MP), b : (wf_Body(program(mp))),
           sAP1, sAP2 : APState, v : Val, n : nat) :
      contains_no_method_call(b) IMPLIES
      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
      derive(ann_program(mp))(b, sAP1, v, sAP2)(n) IMPLIES
        derive(mp)(b, make_MPState(mp)(sAP1), v, make_MPState(mp)(sAP2))(n)

  ann_actions_contains_no_method_calls : LEMMA % :-)
    FORALL(l : Action) :
      (FORALL (oa : OneAction) : 
         member(oa, l) IMPLIES contains_no_method_call(source(oa))) IMPLIES
      contains_no_method_call(ann_action(l))


  contains_no_method_call_preserved_by_ann_program : LEMMA % :-)
    FORALL(mp : (wf_and_complete_MP)) :
      contains_no_method_call_in_sets_in_program(program(mp)) IMPLIES
      contains_no_method_call_in_sets_in_program(ann_program(mp))


  IMPORTING WfSetStmts[Name, Program, APState, id, 
                             LAMBDA(s : APState) : pstate(s), lookup,
                             update_PState, execute_set, execute_assert,
                             execute_CaseJML, on_method_entry,
                             on_method_exit_normal, 
                             on_method_exit_exceptional],
            WfSetStmts[Name, MonitoredProgram, MPState,
                             LAMBDA(mp : MonitoredProgram) : program(mp),
                             LAMBDA(s : MPState) : pstate(s),
                             lookup, update_PState, execute_set,
                             execute_assert, execute_CaseJML, 
                             on_method_entry_MP, on_method_exit_normal_MP,
                             on_method_exit_exceptional_MP]

  IMPORTING AnnEventPreservesMPModeled[CP, Name]

  wf_set_stmts_preserved_by_ann_program : LEMMA % :-)
    FORALL(mp : (wf_and_complete_MP)) :
      wf_set_stmts(mp) IMPLIES
      well_behaved_MVA(mp) IMPLIES
      contains_no_method_call_in_sets_in_program(program(mp)) IMPLIES
      wf_set_stmts(ann_program(mp))

  IMPORTING CompleteMonitorProgramPropertiesPreservation[CP, Name]

  IMPORTING LegalProgramRestriction[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional, id],
            LegalProgramRestriction[Name, MonitoredProgram, MPState,
                             LAMBDA(mp : MonitoredProgram) : program(mp),
                             LAMBDA(s : MPState) : pstate(s),
                             lookup, update_PState, execute_set,
                             execute_assert, execute_CaseJML, 
                             on_method_entry_MP, on_method_exit_normal_MP,
                             on_method_exit_exceptional_MP, full_total_MP]



  legal_Program_preserved_by_ann_program : LEMMA
    FORALL(mp : (wf_and_complete_MP)) :
      legal_Program(mp) IMPLIES
        legal_Program(ann_program(mp))

END AnnotateProgramPropertiesPreservation



InlineAnnotationsPropertiesPreservation[Name : TYPE+] : THEORY
BEGIN

  IMPORTING InlineProgramAnnotation[Name],
            AnnotatedProgramSemantics[Name],
            ContainsNoMethodCall[Name],
            WfSetStmts[Name, Program, APState, id, 
                             LAMBDA(s : APState) : pstate(s), lookup,
                             update_PState, execute_set, execute_assert,
                             execute_CaseJML, on_method_entry,
                             on_method_exit_normal, 
                             on_method_exit_exceptional]


  contains_no_method_call_preserved_by_inline_program : LEMMA % :-)
    FORALL(p : Program) : 
      contains_no_method_call_in_sets_in_program(inline_program(p))

  wf_set_stmts_preserved_by_inline_program : LEMMA % :-)
    FORALL(p : Program) : 
      wf_set_stmts(inline_program(p))

  IMPORTING LegalProgramRestriction[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional, id]

  legal_Program_preserved_by_inline_program : LEMMA
    FORALL(p : Program) :
      legal_Program(p) IMPLIES
        legal_Program(inline_program(p))

END InlineAnnotationsPropertiesPreservation
