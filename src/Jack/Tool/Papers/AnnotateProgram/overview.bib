@TechReport{CheonPeru05,
  author =       "Yoonsik Cheon and Ashaveena Perumendla",
  title =        "{Specifying and Checking Method Call Sequences of Java Programs}",
  type =         "Technical Report",
  number =       "nr. TR 05-32",
  institution =  "Department of Computer Science, University of Texas at El Paso, El Paso, TX",
  year =         "November 2005",
}

@TechReport{PaBaBu03,
  author =       "M. Pavlova and G. Barthe and L. Burdy and M. Huisman and
J.-L. Janet",
  title =        "{Enforcing High-Level Security Properties For Applets}",
  type =         "Technical Report",
  number =       "nr. {RR}-5061",
  institution =  "INRIA",
  year =         "2003",
}

@article{StolzBodden06,
  author =        "Volker Stolz and Eric Bodden",
  title =         "{Temporal Assertions using AspectJ}",
  institution =   "Aachen University",
  year =          "2006",
}

@inproceedings{Schneider89,
  author =       "Fred B. Schneider and Bowen Alpern",
  title =        "{Verifying Temporal Properties without Temporal Logic}",
  journal =      "TOPLAS 11",
  pages =        "147--167",
  number =       "TR 87-848",
  month =        Jan,
  year =         "1989",
}

@article{RosuHavelund,
  author =       "Grigore Ro\c{s}u and Klaus Havelund",
  title =        "{Synthesizing Dynamic Programming Algorithms from Linear
Temporal Logic Formulae}",
  institution =  "NASA Ames Research Center"
}

@inproceedings{Schneider00,
  author =       "Fred B. Schneider",
  title =        "{Enforceable Security Policies}",
  journal =      "ACM Transactions on Information and System Security",
  pages =        "30--50",
  number =         "TR 99-1759",
  month =        Feb,
  year =         "2000",
}

@incollection{Oheimb-Nipkow-Java-LNCS,
  author = {Oheimb, David von and Nipkow, Tobias},
  title = {Machine-checking the {J}ava Specification: Proving Type-Safety},
  booktitle = {Formal Syntax and Semantics of {J}ava},
  editor = {Jim Alves-Foss}, 
  note = {\url{http://isabelle.in.tum.de/Bali/papers/Springer98.html}},
  publisher = {Springer},
  series = {LNCS},
  volume = {1523},
  pages = {119--156},
  year = {1999},
  abstract = {In this article we present Bali, the formalization of a large (hitherto sequential) sublanguage
of Java. We give its abstract syntax, type system, well-formedness conditions, and an operational evaluation
semantics. Based on these definitions, we can express soundness of the type system, an important design goal
claimed to be reached by the designers of Java, and prove that Bali is indeed type-safe. All definitions and
proofs have been done formally in the theorem prover Isabelle/HOL. Thus this article demonstrates that
machine-checking the design of non-trivial programming languages has become a reality.}, 
  CRClassification = {D.3.1, F.3.2},
  CRGenTerms = {Languages, Security, Verification}
}

@book{Winskel,
  author = {Winskel, Glynn},
  howpublished = {Paperback},
  isbn = {0262731037},
  keywords = {denotational_semantics lazy operational_semantics strict types},
  month = {February},
  priority = {0},
  publisher = {{The MIT Press}},
  title = {The Formal Semantics of Programming Languages},
  year = {1993},
  abstract = {{<I>The Formal Semantics of Programming Languages</i> provides the basic mathematical techniques
necessary for those who are beginning a study of the semantics and logics of programming languages. These
techniques will allow students to invent, formalize, and justify rules with which to reason about a variety of
programming languages. Although the treatment is elementary, several of the topics covered are drawn from
recent research, including the vital area of concurency. The book contains many exercises ranging from simple
to miniprojects. <br /> <br /> Starting with basic set theory, structural operational semantics is introduced
as a way to define the meaning of programming languages along with associated proof techniques. Denotational
and axiomatic semantics are illustrated on a simple language of while-programs, and fall proofs are given of
the equivalence of the operational and denotational semantics and soundness and relative completeness of the
axiomatic semantics. A proof of Godel's incompleteness theorem, which emphasizes the impossibility of
achieving a fully complete axiomatic semantics, is included. It is supported by an appendix providing an
introduction to the theory of computability based on while-programs. <br /> <br /> Following a presentation of
domain theory, the semantics and methods of proof for several functional languages are treated. The simplest
language is that of recursion equations with both call-by-value and call-by-name evaluation. This work is
extended to languages with higher and recursive types, including a treatment of the eager and lazy
lambda-calculi. Throughout, the relationship between denotational and operational semantics is stressed, and
the proofs of the correspondence between the operation and denotational semantics are provided. The treatment
of recursive types - one of the more advanced parts of the book - relies on the use of information systems to
represent domains. The book concludes with a chapter on parallel programming languages, accompanied by a
discussion of methods for specifying and verifying nondeterministic and parallel programs.}}
}