\section{Modelling Security Properties with Automata}\label{SecMVA}

This section formally defines the format of security automata that we
use. These are particularly suited for monitoring, because transitions
can depend on the state of the monitored program. We call them
Property Automata (PA).
Transitions between states are labelled with guards, events and a list
of actions. The event specifies the method whose entry and/or exit is
being monitored, with a distinction between normal and exceptional
exits.  The guard describes the conditions under which the transition
can be applied. It depends on
\begin{inparaenum}[(\itshape i\upshape)]
\item the automaton state,
\item the state of the program that is being monitored, and
\item the argument of the method, in case the event is method entry;
the result of the method, in case the event is normal method exit; or
the exception with which the method returns, in case the event is
exceptional method exit.
\end{inparaenum}
Each action describes how the automaton state is updated by the transition.

Throughout, we assume that \(\CP\) and \(\Name\) are infinite, but
enumerable non-empty sets of control points and names, respectively.
PA and programs share the definitions of values, types and exceptions,
denoted \Val, \Type and \Excpt, respectively. They are defined by the
following grammar, where \(\mathbb{B}\) and \(\mathbb{Z}\) denote the
standard sets of booleans and integers, respectively\footnote{We will
use a PVS-like notation to declare abstract data types and records
(enclosed by \(\opr\) and \(\clr\)). Further, if \(x\) is a record
with field \textsf{y}, we use \(x.\mathsf{y}\) to access field
\textsf{y}, and \(x \opri\mathsf{y} := z\clri\) to denote the record
\(x\) with the field \textsf{y} updated to \(z\).}.
\[{\small
\begin{array}{rcl}
\Val & = & \B(b : \mathbb{B}) \mid \I(i : \mathbb{Z}) \mid \Null \mid
\R(i : \mathbb{Z}) \mid \One \mid \bot\\
\Type & = & \Bool \mid \Int \mid \Ref \mid \Void\\
\Excpt & = & \Throwable \mid \NullPointer \mid \JMLExc
\end{array}}
\]
The special type \(\Void\), inhabited by \(\One\), models methods
without results. Reference values contain a number, which can be
considered as the location where the object is stored;
\(\bot\) is used to denote the outcome of an undefined expression.

A PA consists of
\begin{inparaenum}[(\itshape i\upshape)]
\item a name,
\item a class name, to specify which class is being monitored,
\item a finite set of control points,
\item an initial control point,
\item a set of events, to specify which methods are being monitored,
\item a set of PA variable declarations, to describe
the internal state of the automaton
\item a set of program variable declarations, to specify which
program variables will be inspected by the monitor, and
\item a set of transitions.
\end{inparaenum}
Transitions go from source to target control points. They are labelled
with events, where an event is a tuple of an event type (entry, exit
or exceptional exit) and a method name, a guard and a list of
actions. Each action assigns the result of an expression (containing
both program and PA variables) to a PA
variable. Figure~\ref{FigPAForm} shows the main components of the
formal PA definition.

\begin{figure}[t]
\[{\small
\begin{array}{rcl}
\Decl & = \opr & \type : \Type, \name : \Name, \init : \Val
\clr \\
\EVENT & = \opr & \etype : (\entry \mid \exit \mid \excexit),
                 \mname : \Name \clr\\
\TRANS & = \opr & \scp, \tcp : \CP, \event : \EVENT, \action : (\opr \target : \Name, \expr : \Expr \clr)^*, \\
& &
\guard : \PAstate \times \Pstate \times (\Val \mid \Excpt) \rightarrow \mathbb{B}\clr\\
\PA & = \opr & \name, \clname : \Name, \cps : \setof{\CP},
            \init : \CP, \evs : \setof{\EVENT},\\
     &   &  \vdsA : \setof{\Decl}, \vdsP : \setof{\Decl},
            \trans : \setof{\TRANS} \clr
\end{array}}
\]
\caption{Formal Definition of PA}\label{FigPAForm}
\end{figure}

We require a PA to be \emph{deterministic}, \emph{i.e.}, for every
source control point and event there is always at most one guard that
holds. Notice that it is not obvious how to transform a
non-deterministic PA into a deterministic one, because the actions
made by the overlapping transitions might differ.

A PA is \emph{total} if there is always a guard that holds
for a given source control point and event, otherwise it is
\emph{partial}. Every deterministic PA can be completed into a total
one (by function \complete): add a special control point
\halted, together with transitions for every control point and every event
to \halted, where the guard is the negation of the
disjunction of all other guards for this control point and event, and
in addition, add unconditional transitions from \halted to \halted
for every possible event.

% NOTE: these are not all the condition (for instance we are not saying that
% the expressions should not include Set statements or that the initial control
% point is in the set of control points and must not be halted.
A PA is \emph{wellformed} if\footnote{We only formalise constraints that are
necessary for our formalisation.}:
\begin{inparaenum}[(\itshape i\upshape)]
\item variable names are unique and are not reserved words,
\item guards do not have side-effects,
\item guards and actions only use declared variables, and
\item control points and events in transitions are declared.
\end{inparaenum}

The state of a PA consists of a current control point, and the store of
automaton variables (the program store is not part of the automaton state).
\[{\small
\PAstate = \opr \cp : \CP, \stA : \Store \clr}
\]
For a PA \(a\), the transition function \(\Delta_a\) specifies how an automaton
state \(\sigma_A\) is updated for a given program store \(\sigma_P\) an
event \(e\) and a value or exception \(v\)
(where \(\chooseop\) is the arbitrary
choice operator, and \textsf{apply} is a function that updates the
automaton store according to a list of actions in the obvious way).
\[{\small
\begin{array}{l}
\Delta_a  :  \PAstate \times \Pstate \times \EVENT \times (\Val \mid
\Excpt) \hookrightarrow
\PAstate\\
\Delta_a(\sigma_A, \sigma_P, e, v) = \\
\quad
\begin{array}[t]{l}
\mathsf{let\ }t = \chooseop(\{t\in \trans(a)\mid
  \begin{array}[t]{l}
     t.\scp = \sigma_A.\cp \wedge t.\event = e \wedge \\
     t.\guard(\sigma_A.\stA, \sigma_P.\fvs.\st, v)\}) \mathsf{\ in}
  \end{array}\\
\quad \opri \cp := t.\tcp, \stA := \mathsf{apply}(t.\action,
\sigma_A.\stA) \clri
\end{array}

\end{array}}
\]
In a total PA $a$, the transition function \(\Delta_a\) is total.
A partial automaton gets stuck on a certain input if and only if the
completed PA reaches the state \halted.

\begin{equation}\label{PAcompletionProp}
\Delta_a(\sigma_A, \sigma_P, e, v) = \perp \Leftrightarrow
\cp (\Delta_{\complete(a)}(\sigma_A, \sigma_P, e, v)) = \halted
\end{equation}


\paragraph{Example}

The following PA\footnote{Where we assume that the default guard is
\(\lambda(\sigma_A, \sigma_P, v). \ttt\) and the default action is
\(\actskip\), an empty sequence.} encodes the property described in
Figure~\ref{FigExample}, while Figure~\ref{FigCompletePA} shows the completed PA.

\[
\small{
\hspace{-0.3em}
\begin{array}[t]{l}
\opri
\begin{array}[t]{l}
\name := \textrm{LimitSMS}, \clname := \texttt{Messaging},
\cps := \{s_1, s_2\},
\init := s_1,\\
\evs :=
\begin{array}[t]{l}
\{ \opri \etype := e, \mname := \texttt{sendSMS} \clri \mid e \in \{ \entry,
\exit, \excexit \} \} \:\cup \\
\{ \opri \etype := \exit, \mname := \texttt{reset} \clri\},
\end{array}
\\
\vdsA := \{\opri \name := n, \type := \Int, \init := 0 \clri\},
\vdsP := \emptyset,\\
\trans := \{
\begin{array}[t]{l}
\opri
 \begin{array}[t]{l}
\scp := s_1, \tcp := s_2, \guard := \lambda(\sigma_A, \sigma_P, v). n(\sigma_A) < N,\\
             \event := \opri \etype := \entry,
                             \mname := \texttt{sendSMS} \clri \clri,
\end{array}\\
\opri
 \begin{array}[t]{l}
\scp := s_2, \tcp := s_1, \action := [\opri \target := n, \expr := n + 1 \clri]\\
             \event := \opri \etype := \exit,
                             \mname := \texttt{sendSMS} \clri \clri,
\end{array}\\
\opri
 \begin{array}[t]{l}
\scp := s_2, \tcp := s_1, \\
             \event := \opri \etype := \excexit,
                             \mname := \texttt{sendSMS} \clri, \clri,
\end{array}\\
\opri
\begin{array}[t]{l}
\scp := s_1, \tcp := s_1, \action := [\opri \target := n, \expr := 0 \clri] \\
             \event := \opri \etype := \exit, \mname := \texttt{reset} \clri \clri
\} \clri
\end{array}
\end{array}
\end{array}\\
\end{array}
}\]

\begin{figure}[t]

\psfrag{s1}{\tiny{\(s_1\)}}
\psfrag{s2}{\tiny{\(s_2\)}}
\psfrag{exit(sendSMS)?true -> n := n + 1;}
{\begin{tabular}{l}
\tiny{\exit(\texttt{SendSMS})?\ttt}\vspace*{-.8em}\\
\tiny{\(\rightarrow\)\texttt{n := n + 1};}
\end{tabular}}
\psfrag{exitE(sendSMS)?true -> ;}
{\begin{tabular}{l}
\tiny{\excexit(\texttt{sendSMS})?\ttt \(\rightarrow\)}%\vspace*{-.8em}\\
\tiny{\actskip;}
\end{tabular}}
\psfrag{exit(reset)?true -> n := 0;}
{\begin{tabular}{l}
\tiny{\exit(\texttt{reset})?\ttt \(\rightarrow\)}\vspace*{-.8em} \\
\tiny{\texttt{n :=} 0;}
\end{tabular}}
\psfrag{entry(sendSMS)? n<N -> ;}
{\begin{tabular}{l}
\tiny{\entry(\texttt{sendSMS})? \texttt{n} \(<\) \texttt{N} \(\rightarrow\)} %\vspace*{-.8em} \\
\tiny{\actskip;}
\end{tabular}}
\psfrag{entry(sendSMS)?true -> ;}
{\tiny{\entry(\texttt{sendSMS})?\ttt \(\rightarrow\)\actskip}}
\psfrag{exit(reset)?true -> ;}
{\tiny{\exit(\texttt{reset})?\ttt \(\rightarrow\)\actskip}}
\psfrag{exit(sendSMS)?true -> ;}
{\tiny{\exit(\texttt{sendSMS})?\ttt \(\rightarrow\)\actskip}}
\psfrag{exitE(sendSMS)?true -> ;}
{\tiny{\excexit(\texttt{sendSMS})?\ttt \(\rightarrow\)\actskip}}
\psfrag{entry(sendSMS)?n >= N -> ;}
{\tiny{\entry(\texttt{sendSMS})?\texttt{n} \(\geq\) \texttt{N}
\(\rightarrow\)\actskip}}
\psfrag{halted}{\tiny{\halted}}

\begin{center}
\epsfig{file=completed.eps, width=7cm}
\end{center}
\caption{Automaton of Figure~\ref{FigExample}, after completion}\label{FigCompletePA}

\end{figure}
