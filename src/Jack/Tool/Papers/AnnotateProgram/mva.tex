\section{Modeling Security Properties with Automata}\label{SecMVA}

This section formally defines the format of the automata that we use
to encode security properties. Our automata are particularly suited to
describe the monitoring of an application, because transitions can
depend on the state of the program being monitored. We call these
automata \emph{Multi-Variable Automata} (MVA), because the internal
state of the automata is defined by a set of variables. Transitions
between states are labelled with guards, events and actions. The event
describes the method that is being called or exited in the monitored
program. Distinction is made between normal and exceptional
terminiation of methods. The guard describes the conditions under
which the transition can be applied. It depends on
\begin{inparaenum}[(\itshape i\upshape)]
\item the automaton state,
\item the program state of the program that is being monitored, and
\item in case the event is method entry, the argument of the method;
in case the event is normal method exit, the result of the method; and
in case the event is exceptional method exit, the exception with which
the method returns.
\end{inparaenum}
The action updates the automaton variables.


MVA and programs share the definitions of values, types and exceptions, denoted
\Val, \Type and \Excpt, 
respectively, defined by the following grammar (where \(\mathbb{B}\) and
\(\mathbb{Z}\) denote the standard sets of booleans and integers,
respectively)\footnote{We will
use a PVS-like notation to declare abstract data types and records
(enclosed by brackets \(\opr\) and \(\clr\)). Further, if \(x\) is a
record with field \textsf{y}, we use \(x.\mathsf{y}\) to access field
\textsf{y}, and \(x \opri\mathsf{y} := z\clri\) to denote the record
\(x\) with the field \textsf{y} updated to \(z\).}.
\[
\begin{array}{rcl}
\Val & = & \B(b : \mathbb{B}) \mid \I(i : \mathbb{Z}) \mid \Null \mid
\R(i : \mathbb{Z}) \mid \One \mid \bot\\
\Type & = & \Bool \mid \Int \mid \Ref \mid \Void\\
\Excpt & = & \Throwable \mid \NullPointer \mid \JMLExc
\end{array}
\]

Notice that there is a special type \(\Void\), inhabited by \(\One\)
to model methods without results. Reference values contain a number,
which can be considered as the location where the object is stored;
\(\bot\) is used to denote the outcome of an undefined expression.

Throughout, we assume that \(\CP\) and \(\Name\) are infinite, but
enumerable nonempty sets of control points and names, respectively. We
assume that \(\Name\) contains the special names \textsf{this} and
\textsf{super}.


An MVA consists of
\begin{inparaenum}[(\itshape i\upshape)]
\item a name,
\item a class name, to specify which class is being monitored,
\item a finite set of control points,
\item an initial control point,
\item a set of events, to specify which events are being monitored,
\item a set of special MVA variable declarations, to describe
the internal state of the automaton
\item a set of program variable declarations, to specify which
program variables will be inspected by the monitor, and
\item a set of transitions.
\end{inparaenum}
Transitions go from source to target control points. They are labelled
with events, where an event is a tuple of an event type (entry, exit
or exceptional exit) and a method name, and with guards. Each
transition can update the MVA variables by executing a list of
actions, where each action assigns the result of an expression
(containing both program and MVA variables) to a MVA variable. MVA
variables declarations are the same as program field declarations
(defined below), while program variable declarations in the MVA have
the same format as local variable declarations in a program
(\emph{i.e.}, they are not initialised in the
monitor). Figure~\ref{FigMVAForm} shows the main types of the MVA
definition (the types of \FieldDecl and \LocalVarDecl will also be
used in the abstract syntax of programs).  Notice that the monitor
variables are explicitly initialised, in contrast to the MVA's program
variables: their value is retrieved from the program state.  

\begin{figure}[t]
\[
\begin{array}{rcl}
\FieldDecl & = \opr & \type : \Type, \name : \Name, \init : \Val
\clr \\ 
\LocalVarDecl & = \opr & \type : \Type, \name : \Name \clr \\
\EVENT & = \opr & \etype : (\entry \mid \exit \mid \excexit), 
                 \mname : \Name \clr\\
\TRANS & = \opr & \scp, \tcp : \CP, \event : \EVENT, \\
& & 
\guard : \MVAstate \times \Pstate \times (\Val \mid \Excpt) \rightarrow \mathbb{B}, \\
&& \action : (\opr \target : \Name, \expr : \Expr \clr)^* \clr\\
\MVA & = \opr & \name, \clname : \Name, \cps : \setof{\CP},
            \init : \CP, \evs : \setof{\EVENT},\\
     &   &  \vdsA : \setof{\FieldDecl}, \vdsP : \setof{\LocalVarDecl},\\
     &   &  \trans : \setof{\TRANS} \clr
\end{array}
\]
\caption{Formal Definition of MVA}\label{FigMVAForm}
\end{figure}

We require that an MVA is \emph{deterministic}, \emph{i.e.}, for every
source control point and event there is always at most one guard that
holds. Notice that it is not obvious how to transform a
non-deterministic MVA into a deterministic one, because the actions
made by the overlapping transitions might be different. We believe
that this is realistic restriction, and that most important security
properties can be expressed as deterministic MVAs.

An MVA is \emph{total} if there is always exactly one guard that holds
for a given source control point and event, otherwise it is
\emph{partial}. Every deterministic MVA can be completed by function
\complete into a total
MVA. This function adds a special control state
\halted, together with transitions for every control point and every event
to this \halted control point, where the guard is the negation of the
disjunction of all other guards. In addition, one adds unconditional
transitions from \halted to \halted for every possible
event. 

\marginnote{We could give formal definition of completion}

An MVA is \emph{wellformed} if 
\begin{inparaenum}[(\itshape i\upshape)]
\item the monitor variable names do not overlap with the reserved
words, 
\item the program variable names that are used are unique, 
\item the guards do not have a side-effect, 
\item the ransition updates only uses declared variables, and
\item transitions range between declared control points and are
labelled with declared events.
\end{inparaenum}.

%Formally:
%\[
%\begin{array}[t]{l}
%\mathsf{complete}(a) = 
%\begin{array}[t]{l}
%a \mathsf{with} (\# 
%\begin{array}[t]{l}
%\cps := a.\cps \cup {\halted},
%\trans := a.\trans \cup complete(a.\trans) 
%\end{array}
%\#)
%\end{array}
%\mathsf{complete}(T) =
%\{ (\# \scp := q, 
%       \tcp := \halted,
%       \guard := \lambda s_A s_P v. 
%\end{array}
%\]

\paragraph{MVA Transitions} The state of a MVA consists of a current control
point, and the store of automaton variables.
\[
\MVAstate = \opr \cp : \CP, \stA : \Store \clr
\]
Notice that the program store is not part of the automaton
state. Given a MVA \(a\), the transition function \(\Delta_a\)
describes how given a program store and an event, \(a\) changes its
internal state (where \(\epsilon\) is the arbitrary choice operator,
and \textit{apply} is a function that updates the automaton store
according to the list of actions in the obvious way).
\[
\begin{array}{l}
\Delta_a  :  \MVAstate \times \Pstate \times \EVENT \times (\Val \mid
\Excpt) \hookrightarrow
\MVAstate\\
\Delta_a(\sigma_A, \sigma_P, e, v) = \\
\quad
\begin{array}[t]{l}
\mathsf{let\ }t = \epsilon(\{t\in \trans(a)\mid
  \begin{array}[t]{l}
     \scp(t) = \cp(\sigma_A) \wedge \event(t) = e \wedge \\
     \guard(t)(\stA(\sigma_A), \st(\fvs(\sigma_P)), v)\}) \mathsf{\ in}
  \end{array}\\
\quad \opri \cp := \tcp(t), \stA := \mathit{apply}(\action(t),
\stA(\sigma_A)) \clri
\end{array}

\end{array}
\]
In a total MVA, the transition function \(\Delta_a\) is total. Notice
that a partial automaton gets stuck on a certain input if and only if the
complete MVA will reach the state \halted.

\begin{equation}\label{MVAcompletionProp}
\Delta_a(s_A, s_P, e) = \perp \Leftrightarrow
\cp (\Delta_{\complete(a)}(s_A, s_P, e)) = \halted
\end{equation}


\paragraph{Example}
Recall the example security automaton in Figure~\ref{FigExample},
expressing that the method \texttt{sendSMS} can
be called at most \(N\) times in between calls to a \texttt{reset}
method. This automaton is formally described by the following
automaton.

\[
\begin{array}[t]{l}
\opri 
\begin{array}[t]{l}
\name := \textrm{LimitSMS}, \clname := \texttt{Messaging},\\
\cps := \{s\},
\init := s,\\
\evs := \{
\begin{array}[t]{l}
\opri \etype := \entry, \mname := \texttt{sendSMS} \clri,\\
\opri \etype := \exit, \mname := \texttt{reset} \clri\},
\end{array}
\\
\vdsA := \{\opri \name := n, \type := \Int, \init := 0 \clri\},
\vdsP := \emptyset,\\
\trans := \{
\begin{array}[t]{l}
\opri 
 \begin{array}[t]{l}
\scp := s, \tcp := s, 
             \event := \opri \etype := \entry, 
                             \mname := \texttt{sendSMS} \clri, \\
             \guard := \lambda(s_A, s_P, v). n(s_A) < N,
             \action := \opri \target := n, \expr := n + 1 \clri 
            \clri,
\end{array}\\
\opri 
\begin{array}[t]{l}
\scp := s, \tcp := s,
             \event := \opri \etype := \exit, \mname := \texttt{reset}
\clri, \\
             \guard := \ttt, 
             \action := \opri \target := n, \expr := 0 \clri
           \clri \}
\end{array}
\end{array}
\end{array}\\
\clri
\end{array}
\]

Completion would add a transition from \(s\) to the new state \halted
for the event that \texttt{sendSMS} is entered, with a guard \(n \geq
N\). For the exit event of \texttt{reset}, the transition to halted
would have a guard \fff. And of course, there would be an unguarded
transition from \halted to \halted. Figure~\ref{FigCompleteMVA} shows
the complete MVA. 
 
\begin{figure}[t]
\begin{center}
\epsfig{file=completed.eps, width=4cm}
\end{center}
\label{FigCompleteMVA}
\caption{Automaton of Figure~\ref{FigExample}, after completion}
\end{figure}
