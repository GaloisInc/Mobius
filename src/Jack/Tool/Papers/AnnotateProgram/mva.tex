\section{Modelling Security Properties with Automata}\label{SecMVA}

This section formally defines the format of security automata.  These
are extended finite state machines particularly suited for monitoring,
since transitions can depend on the state of the monitored program.
We call them Property Automata (PA).  Transitions between states are
labelled with guards, events and a list of actions. The event
specifies the method whose entry and/or exit is being monitored, with
a distinction between normal and exceptional exits.  The guard
describes the conditions under which the transition can be applied. It
depends on
\begin{inparaenum}[(\itshape i\upshape)]
\item the automaton state,
\item the state of the program that is being monitored, and
\item the argument of the method, in case the event is method entry;
the result of the method, in case the event is normal method exit; or
the exception with which the method returns, in case the event is
exceptional method exit.
\end{inparaenum}
Actions describe how the automaton state is updated by the transition.

Throughout, we assume that \(\CP\) and \(\Name\) are possibly infinite, but
countable non-empty sets of control points and names.  PA and
programs share the definitions of values, types and exceptions,
denoted \Val, \Type and \Excpt, respectively. They are defined by the
following grammar, where \(\BoolSet\) and \(\IntSet\) denote the
standard sets of booleans and integers, respectively\footnote{We will
use a PVS-like notation to declare abstract data types and records
(enclosed by \(\opr\) and \(\clr\)). Further, if \(x\) is a record
with field \textsf{y}, we use \(x.\mathsf{y}\) to access field
\textsf{y}, and \(x \opri\mathsf{y} := z\clri\) to denote the record
\(x\) with the field \textsf{y} updated to \(z\).}.
\[{\small
\begin{array}{rcl}
\Val & = & \B(b : \BoolSet) \mid \I(i : \IntSet) \mid \Null \mid
\R(i : \IntSet) \mid \One \mid \bot\\
\Type & = & \Bool \mid \Int \mid \Ref \mid \Void\\
\Excpt & = & \Throwable \mid \NullPointer \mid \JMLExc
\end{array}}
\]
The type \(\Void\), inhabited by \(\One\), models methods
without results; a reference can be \(\Null\) or contain a number
representing the location where the object is stored;
\(\bot\) is used to denote the outcome of an expression whose evaluation
is undefined (in Java this would typically result in an exception).

A PA consists of
\begin{inparaenum}[(\itshape i\upshape)]
\item a name,
\item a class name, to specify which class is being monitored,
\item a finite set of control points,
\item an initial control point,
\item a set of events, to specify which methods are being monitored,
\item a set of PA variable declarations, to describe
the internal state of the automaton
\item a set of program variable declarations, to specify which
program variables will be inspected by the monitor, and
\item a set of transitions.
\end{inparaenum}
Transitions go from source to target control points. They are labelled
with events, where an event is a tuple of an event type (entry, exit
or exceptional exit) and a method name, a guard and a list of
actions. Each action assigns the result of an expression (containing
both program and PA variables) to a PA
variable. Notice that we only monitor classes here. This is often
the case in practice, because security-critical methods are often
static API methods. However, a more precise formalisation of Java's semantics
would allow to monitor objects as well. Formally, a PA is defined as follows.
% Figure~\ref{FigPAForm} shows the main components of the
% formal PA definition.
%\begin{figure}[t]

\vspace*{-1em}
\[{\small
\begin{array}{rcl}
\Decl & = \opr & \type : \Type, \name : \Name, \init : \Val
\clr \\
\EVENT & = \opr & \etype : (\entry \mid \exit \mid \excexit),
                 \mname : \Name \clr\\
\TRANS & = \opr & \scp, \tcp : \CP, \event : \EVENT, \action : (\opr \target : \Name, \expr : \Expr \clr)^*, \\
& &
\guard : \PAstate \times \Pstate \times (\Val \mid \Excpt) \rightarrow \BoolSet\clr\\
\PA & = \opr & \name, \clname : \Name, \cps : \setof{\CP},
            \init : \CP, \evs : \setof{\EVENT},\\
     &   &  \vdsA : \setof{\Decl}, \vdsP : \setof{\Decl},
            \trans : \setof{\TRANS} \clr
\end{array}}
\]
% \caption{Formal Definition of PA}\label{FigPAForm}
% \end{figure}

We require a PA to be \emph{deterministic}, \emph{i.e.}, for every source
control point and event there is always at most one guard that holds.
Notice that it is not obvious how to transform a non-deterministic PA into
a deterministic one, because the actions made by the overlapping transitions
might differ.

A PA is \emph{total} if for any source control point and event,
there is always a guard that holds; otherwise it is
\emph{partial}. Every deterministic PA can be completed into a total
one (by function \complete): add a special control point
\halted, together with transitions for every control point and every event
to \halted, where the guard is the negation of the
disjunction of all other guards for this control point and event, and
in addition, add unconditional transitions from \halted to \halted
for every possible event.

% NOTE: these are not all the condition (for instance we are not saying that
% the expressions should not include Set statements or that the initial control
% point is in the set of control points and must not be halted.
A PA is \emph{wellformed} if:
% \footnote{We only formalise constraints that are necessary for our formalisation.}:
\begin{inparaenum}[(\itshape i\upshape)]
\item variable names are unique and are not reserved words,
\item guards do not have side-effects,
\item guards and actions only use declared variables, and
\item control points and events in transitions are declared.
\end{inparaenum}

The state of a PA consists of a current control point, and the store of
automaton variables (the program store is not part of the automaton state):
\({\small
\PAstate = \opr \cp : \CP, \stA : \Store \clr}
\). Given PA \(a\), the transition function \(\Delta_a\) specifies how
an automaton state \(\sigma_A\) is updated for a given program store
\(\sigma_P\) an event \(e\) and a value or exception \(v\) (where
\(\chooseop\) is the arbitrary choice operator, and \textsf{apply} is
a function that updates the automaton store according to a list of
actions in the obvious way).
\[{\small
\begin{array}{l}
\Delta_a  :  \PAstate \times \Pstate \times \EVENT \times (\Val \mid
\Excpt) \hookrightarrow
\PAstate\\
\Delta_a(\sigma_A, \sigma_P, e, v) = \\
\quad
\begin{array}[t]{l}
\mathsf{let\ }t = \chooseop(\{t\in \trans(a)\mid
  \begin{array}[t]{l}
     t.\scp = \sigma_A.\cp \wedge t.\event = e \wedge \\
     t.\guard(\sigma_A.\stA, \sigma_P.\fvs.\st, v)\}) \mathsf{\ in}
  \end{array}\\
\quad \opri \cp := t.\tcp, \stA := \mathsf{apply}(t.\action,
\sigma_A.\stA) \clri
\end{array}

\end{array}}
\]
In a total PA $a$, the transition function \(\Delta_a\) is total.
A partial automaton gets stuck on a certain input if and only if the
completed PA reaches the state \halted.
\vspace*{-.5em}
\begin{equation}\label{PAcompletionProp}
\Delta_a(\sigma_A, \sigma_P, e, v) = \perp \Leftrightarrow
\cp (\Delta_{\complete(a)}(\sigma_A, \sigma_P, e, v)) = \halted
\end{equation}


\paragraph{Example}
The property specified in Figure~\ref{FigExample} is encoded by the
following PA\footnote{Where we leave the default guard
\(\lambda(\sigma_A, \sigma_P, v). \ttt\) and  empty action
\(\actskip\) implicit.}, while Figure~\ref{FigCompletePA} shows the
completed PA (where new transitions are dashed).

\vspace*{-1em}
{\small{
\hspace{-0.3em}
\begin{longtable}[t]{lll}
\(\opri\) &
\multicolumn{2}{l}
  {\(\name := \textrm{LimitSMS}, \clname := \texttt{Messaging},
  \cps := \{s_1, s_2\},
  \init := s_1,\)}\\
& \multicolumn{2}{l}{
  \(\evs :=
    \begin{array}[t]{l}
     \{ \opri \etype := e,
        \mname := \texttt{sendSMS} \clri
        \mid e \in \{ \entry, \exit, \excexit \} \} \:\cup \\
     \{ \opri \etype := \exit, \mname := \texttt{reset} \clri\},
    \end{array}\)} \\
& \multicolumn{2}{l}{
    \(\vdsA := \{\opri \name := n, \type := \Int, \init := 0 \clri\},
    \vdsP := \emptyset,\)}\\
& \(\trans := \{ \) &
       \(\opri
        \begin{array}[t]{l}
           \scp := s_1, \tcp := s_2,
           \guard := \lambda(\sigma_A, \sigma_P, v). n(\sigma_A) < N,\\
           \event := \opri \etype := \entry,
                     \mname := \texttt{sendSMS} \clri \clri,
        \end{array}\)\\
&&
     \(\opri
        \begin{array}[t]{l}
           \scp := s_2, \tcp := s_1,
           \action := [\opri \target := n, \expr := n + 1 \clri]\\
           \event := \opri \etype := \exit,
                     \mname := \texttt{sendSMS} \clri \clri,
        \end{array}\)\\
&&
     \(\opri
        \begin{array}[t]{l}
           \scp := s_2, \tcp := s_1, \\
           \event := \opri \etype := \excexit,
           \mname := \texttt{sendSMS} \clri, \clri,
        \end{array}\)\\
&&
     \(\opri
        \begin{array}[t]{l}
           \scp := s_1, \tcp := s_1,
           \action := [\opri \target := n, \expr := 0 \clri] \\
           \event := \opri \etype := \exit, \mname := \texttt{reset}
           \clri \clri \} \clri
        \end{array}\)
\end{longtable}
}}

% \small{
% \hspace{-0.3em}
% \begin{longtable}[t]{l}
% \opri
% \begin{longtable}[t]{l}
% \(\name := \textrm{LimitSMS}, \clname := \texttt{Messaging},
% \cps := \{s_1, s_2\},
% \init := s_1,\)\\
% \(\evs :=
% \begin{array}[t]{l}
% \{ \opri \etype := e, \mname := \texttt{sendSMS} \clri \mid e \in \{ \entry,
% \exit, \excexit \} \} \:\cup \\
% \{ \opri \etype := \exit, \mname := \texttt{reset} \clri\},
% \end{array}\)
% \\
% \(\vdsA := \{\opri \name := n, \type := \Int, \init := 0 \clri\},
% \vdsP := \emptyset,\)\\
% \(\trans := \{
% \begin{array}[t]{l}
% \opri
%  \begin{array}[t]{l}
% \scp := s_1, \tcp := s_2, \guard := \lambda(\sigma_A, \sigma_P, v). n(\sigma_A) < N,\\
%              \event := \opri \etype := \entry,
%                              \mname := \texttt{sendSMS} \clri \clri,
% \end{array}\)\\
% \(\opri
%  \begin{array}[t]{l}
% \scp := s_2, \tcp := s_1, \action := [\opri \target := n, \expr := n + 1 \clri]\\
%              \event := \opri \etype := \exit,
%                              \mname := \texttt{sendSMS} \clri \clri,
% \end{array}\\
% \opri
%  \begin{array}[t]{l}
% \scp := s_2, \tcp := s_1, \\
%              \event := \opri \etype := \excexit,
%                              \mname := \texttt{sendSMS} \clri, \clri,
% \end{array}\\
% \opri
% \begin{array}[t]{l}
% \scp := s_1, \tcp := s_1, \action := [\opri \target := n, \expr := 0 \clri] \\
%              \event := \opri \etype := \exit, \mname := \texttt{reset} \clri \clri
% \} \clri
% \end{array}
% \end{array}\)
% \end{longtable}\\
% \end{longtable}
% }

\begin{figure}[t]

\psfrag{s1}{\tiny{\(s_1\)}}
\psfrag{s2}{\tiny{\(s_2\)}}
\psfrag{exit(sendSMS)?true -> n := n + 1;}
{\begin{tabular}{l}
\tiny{\exit(\texttt{SendSMS})?\ttt}\vspace*{-.8em}\\
\tiny{\(\rightarrow\)\texttt{n := n + 1};}
\end{tabular}}
\psfrag{exitE(sendSMS)?true -> ;}
{\begin{tabular}{l}
\tiny{\excexit(\texttt{sendSMS})?\ttt \(\rightarrow\)}%\vspace*{-.8em}\\
\tiny{\actskip;}
\end{tabular}}
\psfrag{exit(reset)?true -> n := 0;}
{\begin{tabular}{l}
\tiny{\exit(\texttt{reset})?\ttt \(\rightarrow\)}\vspace*{-.8em} \\
\tiny{\texttt{n :=} 0;}
\end{tabular}}
\psfrag{entry(sendSMS)? n<N -> ;}
{\begin{tabular}{l}
\tiny{\entry(\texttt{sendSMS})? \texttt{n} \(<\) \texttt{N} \(\rightarrow\)} %\vspace*{-.8em} \\
\tiny{\actskip;}
\end{tabular}}
\psfrag{entry(sendSMS)?true -> ;}
{\tiny{\entry(\texttt{sendSMS})?\ttt \(\rightarrow\)\actskip}}
\psfrag{exit(reset)?true -> ;}
{\tiny{\exit(\texttt{reset})?\ttt \(\rightarrow\)\actskip}}
\psfrag{exit(sendSMS)?true -> ;}
{\tiny{\exit(\texttt{sendSMS})?\ttt \(\rightarrow\)\actskip}}
\psfrag{exitE(sendSMS)?true -> ;}
{\tiny{\excexit(\texttt{sendSMS})?\ttt \(\rightarrow\)\actskip}}
\psfrag{entry(sendSMS)?n >= N -> ;}
{\tiny{\entry(\texttt{sendSMS})?\texttt{n} \(\geq\) \texttt{N}
\(\rightarrow\)\actskip}}
\psfrag{halted}{\tiny{\halted}}

\begin{center}
\epsfig{file=complete.eps, width=7cm}
\end{center}
\caption{Automaton of Figure~\ref{FigExample}, after completion}\label{FigCompletePA}
\end{figure}
