

\section{Programs and Semantics}\label{SecProgram}

This section first defines an abstract syntax of programs, followed by
their semantics. Both are fairly standard, except that the semantics
is parametrised on the treatment of specifications. In particular, we
define a run-time checking and a monitoring semantics, that evaluate
differently upon method call and exit.


\subsection{Program Syntax}\label{SecSyntax}
Our language is a restricted subset of (sequential) Java, abstracting
away from typical object-oriented features. This means in particular
that we abstract away from method resolution; instead we assume that
the annotated class contains method bodies for the relevant methods,
thus method lookup is trivial. Similarly, we assume that lookup of
class invariants returns the complete class invariant, including those
invariants that are inherited from superclasses. We consider
only a few exceptions, and assume that methods have only one
parameter. We believe, however, that our formalisation contains all
constructs that are relevant for proving correctness of our inlining
algorithm for class-based monitoring, and implementing the
algorithm for the full language is mainly an engineering issue.

\begin{figure}[t]
\[{\small
\begin{array}{rcl}
\Expr & = & \Plus(n_1, n_2 : \Expr) \mid
            \EvalN(n : \Name) \mid
            \Not(b : \Expr) \mid
            \Conj(b_1, b_2 : \Expr) \mid \\
      &   & \Eq(e_1, e_2 : \Expr) \mid
            \EvalB(n : \Name) \mid
            \EvalR(n : \Name) \mid
            \CondExpr(c, e_1, e_2 : \Expr) \mid\\
      &   & \Assign(n : \Name, e : \Expr) \mid
            \Call(o : \Expr, mn : \Name, p : \Expr) \mid
            \Const(v : \Val) \\
\Stmt & = & \Skip \mid
            \Sequence(s_1, s_2 : \Stmt) \mid
            \IfThenElse(c : \Expr, s_1, s_2 : \Stmt) \mid\\
      &   & \While(c : \Expr, s : \Stmt) \mid
            \StmtExpr(e : \Expr) \mid
            \Throw(e : \Excpt) \mid\\
      &   & \TryCatch(t: \Stmt, e : \Excpt, c, f : \Stmt) \mid
            \Set(n : \Name, e : \Expr) \mid\\
      &   & \CaseJML(b : \listof{\Expr \times \Stmt}) \mid
            \Assert(e : \Expr)
\end{array}}
\]
\caption{Abstract syntax of expressions and statements}
\label{FigExprStmt}
\end{figure}

\begin{figure}[t]
\[{\small
\begin{array}{rcl}
\Method & = \opr & \name : \Name,
                   \param : \LocalVarDecl,
                   \lvars : \setof{\LocalVarDecl},
                   \body : \Stmt,\\
        &        & \res : \Expr,
                   \restype : \Type,
                   \pre, \post : \Expr \rightarrow \Expr, \\
        &        & \preset, \postset : \Expr \rightarrow \Stmt,
                   \excset : \Excpt \rightarrow \Stmt \clr \\
\Class & = \opr & \name : \Name,
                  \super : \Name_{\bot},
                  \fields : \setof{\FieldDecl},
                  \methods : \setof{\Method},\\
        &       & \inv : \Expr,
                  \ghostvars : \setof{\FieldDecl} \clr\\
\Program & = \opr & \classes : \setof{\Class} \clr
\end{array}}
\]
\caption{Abstract Syntax for Programs}\label{FigProgram}
\end{figure}


Figure~\ref{FigExprStmt} defines expressions and statements as a
mutually recursive data type (we use the term \emph{body} to denote
either an expression or a statement). Notice that we define several special
language constructs to represent JML annotations: \Set,
to update ghost variables (\emph{i.e.}, specification-only variables),
\CaseJML, to abbreviate a list of conditional ghost variable updates,
and \Assert, to evaluate a condition on the program state. A standard
program semantics ignores these statements, but the annotated program
semantics evaluates them.

Figure~\ref{FigProgram} describes the syntax for methods,
classes and programs. To ensure that every method has an appropriate
return expression, it is part of the method signature.
Furthermore, methods can be annotated with pre- and postconditions, and
classes with invariants. To support our annotation generation
algorithm, we define special annotations called
\(\preset\), \(\postset\) and \(\excset\). These annotations describe
the updates to the ghost variables at method entry, exit and
exceptional exit, respectively.
Pre- and postcondition and the different method specification-level set
annotations have a function type, to allow the use of the method parameter,
the method result or the returned exception, respectively.

A program is said to be \emph{wellformed} if
\begin{inparaenum}[(\itshape i\upshape)]
\item names of fields, local variables and ghost variables are
disjoint and are not reserved words;
\item class names are unique;
\item method names are unique;
\item every variable name that is used is declared; and
\item only ghost variables are the target of \Set statements.
\end{inparaenum}
% (We have stated only the wellformedness conditions necessary for our
% correctness proofs.)


\subsection{Natural Semantics}\label{SecSemantics}
The behaviour of a program is described via a big step semantics. We
closely follow Von Oheimb's formalisation of Java~\cite{Oheimb01},
with simplifications wherever possible, due to our simplified
program syntax. A judgement $\etp{P}{e,\sigma}{v,\sigma'}$ means that the body
$e$ evaluates to $v$, while transforming the state $\sigma$ into $\sigma'$, in
the context of the program \(P\). Note that \(v\) is \One\ for
normally terminating \emph{statements}, while \(v\) is \(\bot\) whenever
evaluation finishes in an exceptional state.

A basic program state \(\Pstate\) is composed of an optional exception
and a store.  The store maps every field and local variable to a
value.

\[
{\small
\begin{array}{rcl}
\Pstate & = \opr & \ex : \Excp_{\bot}, \st : \PStore \clr\\
\PStore & = \opr & \fvs : \Name \mapsto \Val, \lvs : \Name \mapsto \Val \clr
\end{array}}
\]

Since annotated or monitored programs
contain more information than unannotated programs, the
evaluation rules are parametrised with types
\(\FullProgram\) and \(\FullState\). For each instantiation we give
mappings \program and \progstate to the basic program type \Program
and the basic program state \Pstate. Further, we add parameters that
specify the actions that are taken upon method entry or (normal or
exceptional) exit (\gammain, \gammanorm, and \gammaexc, respectively),
and the handling of annotations (\deltaset, \deltaassert, and
\deltacase).  In a standard program semantics, where specifications
are ignored, these are all instantiated with the identity relation.

The evaluation rules are fairly standard, and we refer to Von Oheimb
and the PVS formalisation for more details.  Evaluation
of normally terminating method calls is described by the following rule
(where for
clarity of presentation, we left out several checks that intermediate
states are not exceptional).

%\begin{figure}[t]
\vspace*{-1em}
\[{\small
\begin{array}{c}
\sigma_0.\progstate.\ex = \bot \qquad        % no exception in sigma_0
\etp{P}{o, \sigma_0}{r,\sigma_1} \qquad      % evaluate receiver
\etp{P}{p, \sigma1}{\act, \sigma_2}\\        % evaluate argument
%\sigma_2.\progstate.\ex = \bot \qquad        % no exceptions in sigma_2
r \not= \Null \qquad                         % receiver not null
\md = \lookupmthd(P, r, \mn) \\
\oldlvs = \sigma_2.\progstate.\st.\lvs \quad
\sigma_3 = \updatelvs(\sigma_2, r, \md.\lvars, md.\param, \act) \\
\gammain(P, \md, r, \Const(\act), \sigma_3, \sigma_4) \qquad
\etp{P}{\md.body, \sigma_4}{\One,\sigma_5} \\
\etp{P}{\md.\res, \sigma_5}{v,\sigma_6}\qquad
%\ex(\progstate(\sigma_6)) = \bot
\gammanorm(P, \md, r, \Const(v), \sigma_6, \sigma_7)\\
%\ex(\progstate(\sigma_7)) = \bot\\
\hline
\etp{P}{\Call(o,\mn,p), \sigma_0}{v, \sigma_7
(\progstate.\st.\lvs := \oldlvs)}
\end{array}}
\]
% \caption{Evaluation rule for normal termination of method
% calls}\label{FigEvalRules}
% \end{figure}

First the receiver is evaluated, resulting in non-null reference
\(r\).  Next, the parameter is evaluated, resulting in value
\act. Using \(r\), the method definition
\md is looked up.  The local variable store is updated assigning
\(r\) to \texttt{this}, initialising the method's local variables and
assigning the actual parameter to the formal parameter. The old local
variable store is remembered as \oldlvs.  Next, an appropriate action
upon method entry is taken, as specified by the relation
\(\gammain\). Then the method body, and method result expression are
evaluated. Since this rule applies to normal method termination only,
the parameter for normal method termination \(\gammanorm\) is
evaluated.  Last, the local store is set back to \(\oldlvs\). In
addition, rules exist that specify behaviour of a method call when it
is called upon a null reference, the body contains an uncaught
exception \emph{etc.}


\paragraph{Annotated Program Semantics}

The program state of an annotated program is extended with a store for
ghost variables:
\[{\small
\Astate = \opr \pstate : \Pstate, \gvs : \Name \mapsto \Val \clr}
\]
The types \FullProgram and \Program coincide, while \FullState is
instantiated as \Astate, and the mapping \progstate is defined as
\pstate. Figure~\ref{FigAnnotatedSem} shows some of the
instantiations of the semantics parameters; % (presented in rule format);
the other instantiations are similar. The relation \gammain uses
the auxiliary relation \(\beta\) which checks a boolean expression \(e\) and
raises a special \JMLExc if it evaluates to false. Upon method
entry, the class invariant and precondition are evaluated. If they
fail, a \JMLExc is thrown, otherwise the method's \preset statement is
executed. Finally, we ensure that the program store is not changed.
The function \deltaset updates a ghost variable: it first evaluates the
expression and if this did not result in an exceptional state, it updates the
value of the ghost variable\footnote{We use \(\tau(\gvs.n := v)\) to
abbreviate that the value of \(\gvs(n)\) in \(\tau\) is updated to
\(v\).} appropriately.

%% Relation with the code:
%% r = a, act = arg, \sigma_1 = s1, \sigma_2 = s2, \beta = check_assertion
\begin{figure}[t]
\[{\small
\begin{array}[t]{c}
\invar = \lookupinv(P, r) \qquad
\beta(P, \invar, \sigma_1, \tau_1) \qquad
\beta(P, \md.\pre(\act), \tau_1, \tau_2) \\
\etp{P}{md.\preset(\act), \tau_1}{v,\tau_2} \qquad v\in\{\bot,\One\} \qquad
\sigma_1.\pstate.\st = \sigma_2.\pstate.\st\\
\hline
\gammain(P, \md, r, \act, \sigma_1, \sigma_2)
\smallskip\\


\etp{P}{e, \sigma_1}{v, \tau} \qquad
\pif{v = \B(\ttt)}{\sigma_2 = \tau}{\sigma_2 = \tau (\ex := \JMLExc)}\\
\hline
\beta(P, e, \sigma_1, \sigma_2)

\smallskip\\

\etp{P}{e, \sigma_1}{v, \tau} \qquad
\pif{\tau.\pstate.\ex = \bot}{\sigma_2 = \tau (\gvs.n := v)}{\sigma_2 = \tau}\\
\hline
\deltaset(P, \Set(e, n), \sigma_1, \sigma_2)
\end{array}}
\]
\caption{Instantiation of semantics for runtime annotation evaluation}
\label{FigAnnotatedSem}
\end{figure}


\paragraph{Monitored Program Semantics}
The parametrised program semantics is also instantiated for monitored
programs. This semantics is only defined when the PA is compatible
with the program. A PA \(a\) is said to be compatible with a program
\(P\), denoted \(a \sqsubseteq P\), if
\begin{inparaenum}[(\itshape i\upshape)]
\item the program contains the class \(c\) that is being monitored,
\item all variables declared as program variables in
\(a\) are fields of the class \(c\) with the correct type, and
\item every event name corresponds to a method in the class.
\end{inparaenum}
A monitored program is a product of a PA and a program. The state of a
monitored program consists of the states of the PA and the program
(including ghost variables)\footnote{For convenience, we assume that a
monitored program also evaluates annotations, but this instantiation
is in fact orthogonal to the annotated program semantics.}, and a flag
\stuck. If the PA is partial, the flag
\stuck is set when \(\Delta_a\) is not defined for a
certain input. If the flag is set, this means that the security policy
is violated, and the program should be stopped (by some external
observer). If the PA is total, the \stuck flag will never be
set. Instead, violation of the security policy is modelled by the PA
reaching the trap state \halted (in which case the external observer
again is supposed to stop execution).

\vspace*{-1em}
\[
{\small
\begin{array}{rcl}
\Mprogram & =  & \opr \pa : \PA, \program : \Program \clr\\
\Mstate & = & \opr \pastate : \PAstate, \pstate : \Pstate, \gvs :  \Name \mapsto \Val, \stuck
: \BoolSet \clr
\end{array}}
\]
Thus, \FullProgram gets instantiated as \Mprogram and \FullState as
\Mstate, with mappings \program and \pstate. Now we can give
appropriate instantiations for the \(\gamma\)- and
\(\delta\)-relations. The \(\delta\)-relations are the same as
for the annotated program semantics, but the \(\gamma\)-relation also
updates the state of the monitor. For example, \(\gammain\) is defined
in terms of \(\gammain\) for annotated programs, as defined in
Figure~\ref{FigAnnotatedSem}.
\[
{\small
\begin{array}{c}
\gammain^{\mathsf{AP}}(P, \md, r, \act, \sigma_1, \tau) \\
\pif{\tau.\pstate.\ex = \bot}
    {\sigma_2 = \gammapa(\entry)(P, \md, \act, \tau)}
    {\sigma_2 = \tau}\\
\hline
\gammain(P, \md, r, \act, \sigma_1, \sigma_2)
\end{array}}
\]


\noindent where
% NOTE: This is a simplified version of on_method_MVA in MonitoredProgram
\[
{\small
\begin{array}[t]{rcl}
\gammapa(\ev)(P, \md, \act, \sigma) & = &
\begin{array}[t]{l}
\mathsf{let\ }
\begin{array}[t]{rcl}
  e & = & \opri \etype := \ev, \mname := \md.\name \clri\\
 \tau & = & \Delta_{P.\pa}(\sigma.\pastate, \sigma.\progstate, e, \act)
\mathsf{\ in\ }\end{array}
\\
\pif{\sigma.\stuck \vee \tau = \bot}
    {\sigma (\stuck := \ttt)}
    {\sigma (\pastate := \tau)}
\end{array}
\end{array}}
\]
