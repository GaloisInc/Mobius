
\section{Programs and Semantics}\label{SecProgram}


\begin{figure}[t]
\[
\begin{array}{rcl}
\Type & = & \Bool \mid \Int \mid \Ref \mid \Void\\
\NumExpr & = & \I(i : \mathbb{Z}) \mid \Plus(n_1, n_2 : \NumExpr) \mid \ldots \mid 
               \EvalN(n : \Name) \\
\BoolExpr & = & \ttt \mid \fff \mid \Not(b : \BoolExpr) \mid \Conj(b_1,
b_2 : \BoolExpr) \mid \ldots \mid \\
          &   & \GT(n_1, n_2 : \NumExpr) \mid \EvalB(n
: \Name) \\
\RefExpr & = & \Null \mid \EvalR(n : \Name)\\
\Val & = & \B(b : \mathbb{B}) \mid \I(i : \mathbb{Z}) \mid \Null \mid
\R(i : \mathbb{Z}) \mid \One \mid \bot\\
\end{array}
\]
\caption{Variable types, numerical, boolean and reference expressions
and values}
\label{FigProgramBase}
\end{figure}

\begin{figure}[t]
\[
\begin{array}{rcl}
\Expr & = & \BExpr(b : \BoolExpr) \mid
            \NExpr(n : \NumExpr) \mid
            \RExpr(r : \RefExpr) \mid\\
      &   & \CondExpr(c : \BoolExpr, e_1, e_2 : \Expr) \mid
            \Assign(n : \Name, e : \Expr) \mid \\
      &   & \Call(o : \Expr, n : \Name, p : \Expr) \mid
            \EvalG(n : \Name) \smallskip\\
\Stmt & = & \Skip \mid
            \Sequence(s_1, s_2 : \Stmt) \mid
            \IfThenElse(c : \BoolExpr, s_1, s_2 : \Stmt) \mid\\
      &   & \While(c : \BoolExpr, s : \Stmt) \mid
            \StmtExpr(e : \Expr) \mid
            \Throw \mid\\
      &   & \TryCatch(t, c, f : \Stmt) \mid
            \Set(n : \Name, e : \Expr) \mid\\
      &   & \CaseJML(b : \listof{\BoolExpr \times \Stmt})
\end{array}
\]
\caption{Abstract syntax of expressions and
statements}\label{FigExprStmt}
\end{figure}

\begin{figure}[t]
\[
\begin{array}{rcl}
\FieldDecl & = \opr & \type : \Type, \name : \Name, \init : \Val
\clr \\ 
\ArgDecl & = \opr & \type : \Type, \name : \Name \clr \\
\LocalVarDecl & = \opr & \type : \Type, \name : \Name \clr \\
\GhostVarDecl & = \opr & \type : \Type, \name : \Name, \init : \Val
\clr \\
\end{array}
\]
\caption{Different types for variable declarations}\label{FigDeclarations}
\end{figure}

\begin{figure}[t]
\[
\begin{array}{rcl}
\Method & = \opr & \name : \Name, 
                   \param : \ArgDecl, 
                   \lvars : \setof{\LocalVarDecl},
                   \body : \Stmt,\\
        &        & \res : \Expr,
                   \restype : \Type,
                   \pre : \Expr,
                   \post : \Expr, \\
        &        & \preset : \Stmt,
                   \postset : \Stmt,
                   \excset : \Stmt \clr \\
\Class & = \opr & \name : \Name,
                  \super : \Name_{\bot},
                  \fields : \setof{\FieldDecl},
                  \methods : \setof{\Method},\\
        &       & \inv : \Expr,
                  \ghostvars : \setof{\GhostVarDecl} \clr\\
\Program & = \opr & \classes : \setof{\Class} \clr
\end{array}
\]
\caption{Abstract Syntax for Programs}\label{FigProgram}
\end{figure}

\subsection{Program Syntax}\label{SecSyntax}

We first formally define the abstract syntax of programs. We will use
a PVS-like notation to declare abstract data types and records
(enclosed by brackets \(\opr\) and \(\clr\)). Let
\(\Name\) be an infinite set of names, containing the special names
\textsf{this} and \textsf{super}. Figure~\ref{FigProgramBase} defines
the abstract syntax of types, numerical, boolean and reference
expressions and values (where \(\mathbb{B}\) and \(\mathbb{Z}\) denote
the standard sets of booleans and integers, respectively). Notice that
there is a special type \(\Void\), inhabited by \(\One\) to model
methods without results. Reference values contain a number,
which can be considered as the location where the object is stored;
\(\bot\) is used to denote the outcome of an undefined expression.

Next, Figure~\ref{FigExprStmt} defines the abstract data types for
program expressions and statements.  The language that we consider is
a restricted subset of (sequential) Java. In particular, we consider
that there are only a few exceptions, and that methods have only one
parameter. However, we believe that it contains all constructs that
are relevant for proving correctness of our approach. Implementing the
technique for the full language is only an engineering issue (see
Section~\ref{SecImplem}).  Figure~\ref{FigDeclarations} defines the
different kinds of variable declarations that can occur in a
program. Notice that field and ghost variable declarations are
explicitly initialised, while parameters and local variables are
not. Finally, Figure~\ref{FigProgram} describes the syntax for
methods, classes and programs. To ensure every method has an
appropriate return expression, this expression is part of the method
signature.

Notice that we have a few language constructs that are used to
represent JML annotations: \EvalG, \(\Set\) and
\(\CaseJML\), to lookup and update ghost variables, respectively (the
\(\CaseJML\) statement abbreviates a list of conditional ghost
variable updates).  The standard program semantics ignores these
statements, but the annotated program semantics evaluates these, and
updates the store of the specification accordingly.  Further, methods
can be annotated with pre- and postconditions, and classes with
invariants. To support our annotation generation algorithm, for each
method we define special annotations, called
\(\preset\), \(\postset\) and \(\excset\). These annotations describe 
the updates to the ghost variables at method entry, exit and
exceptional exit, respectively. The annotation generation algorithm
proceeds in two steps: first we generate the special pre- and post-set
annotations, using the \(\CaseJML\) construct, then we translate this
further into ``standard'' JML.

\subsection{Natural Semantics}\label{SecSemantics}
The behaviour of a program is described using a big step semantics. We
closely follow Von Oheimb's formalisation of Java~\cite{Oheimb01},
with simplifications wherever possible because of our simplified
program syntax. We use the following notations:
$\stp{s,\sigma}{\sigma'}$ denotes that execution of statement $s$
transforms state $\sigma$ into $\sigma'$ in the context of program P,
while $\etp{e,\sigma}{v,\sigma'}$ denotes that expression $e$
evaluates to $v$, while transforming state $\sigma$ into $\sigma'$ in
the context of program \(P\). A basic program state \(\Pstate\) is
composed of an optional exception and a store.  The store maps every
field and local variable to a value.

\[
\begin{array}{rcl}
\Pstate & = \opr & \ex : \Excp_{\bot}, \st : \PStore \clr\\
\PStore & = \opr & \fvs : \Name \mapsto \Val, \lvs : \Name \mapsto \Val \clr
\end{array}
\]


We only distinguish a between runtime and user defined exceptions:
\(\Excp =  \NullPointer \mid \Throwable\). When statements or
expressions are evaluated, uncaught exceptions are
propagated. Exceptions can only by caught explicitly within a
\(\TryCatch\) statement. All evaluation rules require explicitly that
the initial state is not exceptional. Most of the evaluation rules are
standard, and we do not give them explicitly here, but instead refer
to Von Oheimb. 

\begin{figure}[t]
\[
\begin{array}{c}
%\begin{array}{lc}
%\br{\Call}     &
%\begin{array}{c}
%\Norm(\progstate(\sigma_0))\\
%\etp{o, \sigma_0}{r,\tau_1}\\
%\etp{p, \tau1}{\act, \tau_2}\\
%\tau_3 =  \pif{\exc(\progstate(\tau_2)) \neg= \bot \wedge r = \Null}
%              {\tau_2 \with \progstate.\ex := \NullPointer}{\tau_2}\\
%\md = lookup\_mthd(P, r, \mn, \act)\\
%\gammain(P, \md, r, \tau_3, \tau_4) \\
%\oldval = \tau_4.\progstate.\st.\lvs (\md.\param.\name)\\
%\tau_5 = \tau_4 \with \progstate.\st.\lvs := (\md.\param \mapsto \act) \\
%%\_3 = \sigma_2(lvs:=init\_vars(\md.lvars[this \mapsto a][\md.pn \mapsto pv]))\\
%\stp{\md.body, \tau_5}{\tau_6}\\
%\etp{\md.\res, \tau_6}{v,\tau_7}\\
%\pif{\exc(\progstate(\tau_6)) = \bot}{\gammanorm(P, \md, r, \tau_7,
%\tau_8)}{\gammaexc(P, \md, r, \tau_7, \tau_8)}\\
%\hline
%\etp{\Call(o,\mn,p), \Norm(\sigma_0)}{v, \tau_8 \with
%\progstate.\st.\lvs := \oldval}
%\end{array}
%\end{array}
%\medskip\\
%\begin{array}{ccc}
\begin{array}{lc}
\br{\Set}     &
\begin{array}{c}
\ex(\progstate(\sigma_0)) = \perp\\
\deltaset(P, \sigma_0, n, e, \sigma_1)\\
\hline
\stp{\Set(n, e), \sigma_0}{\sigma_1}
\end{array}
\end{array}
%&\ \ &
%\begin{array}{lc}
%\br{\CaseJML}     &
%\begin{array}{c}
%\Norm(\progstate(\sigma_0))\\
%\deltacase(P, \sigma_0, b, \sigma_1)\\
%\hline
%\stp{\CaseJML(b), \sigma_0}{\sigma_1}
%\end{array}
%\end{array}
%\end{array}

\end{array}
\]
\caption{Evaluation rule for \(\Set\) statement}\label{FigEvalRules}
\end{figure}

However, in our setting we need to define both the semantics of an
(annotated) program and of a monitored program (as defined in the next
section). We do this by defining a single uniform semantics and
instantiating this as standard program semantics, annotated program
semantics and monitored program semantics. Since annotated or
monitored programs and/or their states contain more information than
basic programs, the evaluation rules are defined over parametric types
\(\FullProgram\) and \(\FullState\). For each instantiation we give
mappings \program and \progstate to the basic program type \Program
and the basic program state \Pstate.

The main difference in the different semantics is the treatment of
method calls. Therefore, we parametrise the method call rule with
special relations that describe how the annotations or monitoring
automaton are handled at method entry (\(\gammain\)), and after normal
and exceptional return of the method (\(\gammanorm\) and
\(\gammaexc\), respectively), where \(\gammain, \gammanorm, \gammaexc
: \FullProgram
\times \Name \times \Val \times \FullState \times \FullState \rightarrow
\mathbb{B}\), \emph{i.e.},~given the full program, method
name and reference to the object they relate two full program states. 

The other difference is in the treatment of the JML-annotation
statements \Set, \EvalG\ and \CaseJML. We follow a similar approach and
use parameters \deltaset, \deltaeval and \deltacase to define their
evaluation. As an example, Figure~\ref{FigEvalRules} shows the
evaluation rule for the \Set statement; the rules for the other JML
annotations are similar. Given the program and the relevant
JML-annotation statement, the relations specify whether two full
program states are related. In case of ghost variable evaluation, the
parameter \(v\) corresponds to the outcome of the evaluation.

\paragraph{Standard program semantics}
To evaluate a program without considering the specifications, 
\(\FullProgram\) and \(\Program\) and
\(\FullState\) and \(\Pstate\) are identical, thus \program and
\progstate are identify functions. The specification evaluation
functions are instantiated as identity relations, \emph{i.e.,}
\(\gammain(P, \md, r, \tau_1, \tau_2) = \gammanorm(\ldots) =
\gammaexc(\ldots) = (\tau_1 = \tau_2)\), and \(\deltaeval(P,
\EvalG(n), \tau_1, v, \tau_2, \ldots) = \deltaset(\ldots) = \deltacase(\ldots) = (\tau_1 =
\tau_2)\).  

\begin{figure}[t]
\[
\begin{array}{rcl}
\gammain(P, \md, r, \tau_1, \tau_2) & = & 
\exists \sigma_1, \sigma_2.
\begin{array}[t]{l}
\mathit{inv} = \mathit{lookup\_inv}(P, r) \wedge 
\beta(P, inv, \tau_1, \sigma_1) \wedge \\
\beta(P, \pre(md), \_sigma_21, \tau_2) \wedge\\
\stp{\preset(md), \tau_1}{\tau_2} \wedge\\
\st(\pstate(\tau_1)) = \st(\pstate(\tau_2))
\end{array}
\smallskip\\

\beta(P, a, \tau_1, \tau_2) & = & 
(\etp{a, \tau_1}{\ttt, \tau_1} \wedge \tau_1 = \tau_2) \vee\\
&& (\etp{a, \tau_1}{\fff, \tau_1} \wedge \tau_2 = \tau_1(\ex := \JMLExc))
%\gammanorm(P, \md, \tau_1, \tau_2) & = & \\
%\gammaexc(P, \md, \tau_1, \tau_2) & = & 
\smallskip\\

%\deltaeval(P, \EvalG(n), \tau_1, v, \tau_2) & = & \\
\deltaset(P, \Set(e, n), \tau_1, \tau_2) & = & 
\exists \tau, v. 
\begin{array}[t]{l}
\etp{e, \tau_1}{v, \tau} \wedge\\
(\ex(\pstate(\tau)) = \perp \wedge \tau_2 = \tau (\gvs.n := v) \vee\\
\bp \ex(\pstate(\tau)) \not= \perp \wedge \tau_2 = \tau) \wedge\\
\st(\pstate(\tau_1)) = \st(\pstate(\tau_2))
\end{array}
\\
%\deltacase(P, \CaseJML(b), \tau_1, \tau_2) & = & \\
\end{array}
\]
\caption{Instantation of semantics for runtime annotation evaluation}
\label{FigAnnotatedSem}
\end{figure}

\paragraph{Annotated program semantics}


The program state of an annotated program is extended with a store for
ghost variables:
\[
\Astate = \opr \pstate : \Pstate, \gvs : \Name \mapsto \Val \clr
\]
Again, \FullProgram and \Program coincide, but \FullState is now
instantiated as \Astate, and the mapping \progstate is defined as
\pstate. Figure~\ref{FigAnnotatedSem} shows some of the 
instantiations of the specification evaluation relations; the other
instantiations are similar. The function \gammain uses an auxiliary
relation \(\beta\) which checks an annotation \(a\) and raises
a special \JMLExc if the annotation does not hold. Just before
executing the method body, the evaluation rule for method calls
evaluates \gammain. This will lookup the correct class invariant for
the reference \(r\) (this is the conjunction of all invariants of the
superclasses of \(r\)'s runtime class) and evaluate it. If it fails, a
\JMLExc is thrown, otherwise the method's precondition is
evaluated. If it fails, again a \JMLExc is thrown, otherwise the
method's \preset statement is executed. Finally, we ensure that the
annotation evaluation did not affect the program store. The function
\deltaset updates a ghost variable: it first evaluates the expression
and if this did not result in an exceptional state, it updates the
value of the ghost variable\footnote{We use \(\tau(\gvs.n := v)\) to
abbreviate that the \(n\) entry of the \gvs entry of \(\tau\) is
updated.} appropriately. In addition, it ensures that the program
store is not affected by evaluation of the annotation.


\subsubsection{PVS formalisation}
To formalise the program semantics in PVS is not completely
straightforward. PVS does not allow one to define mutually recursive
definitions, and moreover for every recursive method call, termination
has to be shown. As a solution, we define a function
\texttt{deriv\_expr} parametrised with 
natural number \(n\) and function \texttt{deriv\_stmt}, where the
argument \texttt{deriv\_stmt} is only applicable to natural numbers
strictly less than \(n\). The number \(n\) provides an upperbound on
the number of recursive method calls that are going to be made.  The
function \texttt{deriv\_stmt}, applied to natural number \(m\) can
then directly call the \texttt{deriv\_expr} function, with
\texttt{deriv\_stmt} as argument, but restricted to calls with arguments
strictly less than \(m\). The parameters \gammain, \gammanorm
\emph{etc.} are all parametrised with \texttt{deriv\_expr} and
\texttt{deriv\_stmt}, but again restricted to be applicable only for
strictly smaller natural numbers. We can then prove that the natural
number argument is always strictly decreasing, and this is sufficient
to guarantee termination.







