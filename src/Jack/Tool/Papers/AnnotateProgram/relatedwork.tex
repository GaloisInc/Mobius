\section{Related Work}\label{SecRelated}
% Discuss briefly the work by Schneider "Enforceable security policies" and its
% follow up by Ligatti. Talk about it language to specify security properties.

Security automata, as introduced by Schneider~\cite{Schneider99}, are
widely used for monitoring security properties. The originality of our
work lies in considering them as specifications, with the ultimate
goal of static verification.

Closely related to our approach is work by Aktug \emph{et
al.}~\cite{Aktug07,AktugDG08}. They define a formal language for
security policy specifications, ConSpec, that is similar to our
PA. They prove that a monitor can be inlined into the program text,
\emph{i.e.}, the run-time checks can be merged into the program. This
allows to run the program in isolation, with runtime checking of the
security policy enabled. In contrast, we transform the monitor into a
specification of the program, and eventually we want to prove
adherence to the specification statically.

Cheon and Perumandla propose an extension to JML to specify allowed
sequences of methods calls in a regular expression-like
notation~\cite{Cheon07}.  This results in succint specifications, but
of limited expressiveness. Even our simple example is out of their
scope, because it contains a counter used only by the
specification. Further, they only target runtime verification.

Several tools exist that translate temporal properties into JML
annotations: F2J ~\cite{Hubbers03} translates finite state machine
specifications into JML annotations and can also generate a code
skeleton for a smart card applet; JAG~\cite{Giorgetti06} translates
properties in (a subset of) temporal logic, including liveness
properties.  However, they typically do not distinguish between method
entry and exit, and moreover, correctness of the translation algorithm
has not been proven.

%Use of Aspects to do monitoring?
