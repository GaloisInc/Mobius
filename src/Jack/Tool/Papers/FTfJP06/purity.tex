\section{Pure methods}
JML's pure methods are methods that can be used in specifications.
They cannot mutate already existing objects but they can allocate new objects.
Nonetheless, the pure keyword is not an alias for JML {\tt modifies $\backslash$nothing}, 
it implies also that the methods terminates, giving a result or throwing an 
exception.
For instance if a constructor only modifies the object that is being 
created and terminates properly
it can be considered as pure.
A mean to verify whether a method is pure or not according to JML
can be found in \cite{salcianu05}. 



In dynamic program verification pure methods are usually built from their source code. 
The method is first thought on the Java level, without side effects, and afterward
the user writes its specifications on the JML level; in order to be able
to use it in JML annotations.

In static program verification,  pure methods can be built directly
from their specifications, since most of the tools replace  pure method's calls 
 by the instanciation of the pure method's specifications.


\subsection{Jack's implementation}
In Jack the notion of purity used is as in JML a kind of observational purity \cite{naumann05}, 
but a constructor that
only modifies the fields of the newly created objects is not considered 
as pure.
In Jack's weakest precondition calculus the specifications are considered 
as lightweight: the method calls are replaced by their specifications 
inside the calculus.
The replacement with its specifications is done with the normal 
specifications in case the method terminated normally or with the 
exceptional specification if the pure method terminated on an exception.
 
For a method defined in a Java file: 
\btab
 /*\=@ requires tab != null;\+\\
  @  modifies $\backslash$nothing;\\
  @ ensures   $\backslash$result == (0 $\le$ i) \&\& (i $\le$ tab.length);\\
  @ exsures false;\\
  @*/\-\\
publi\=c static /*@ pure @*/  withinBounds(int[] tab, int i) \{\+\\
       return (0 $\le$ i) \&\& (i $\le$ tab.length);\-\\
\}
\etab

with this method call within the annotations: 
\btab
withinBounds(tab,i)
\etab

the method call will be directly replaced in the weakest precondition calculus by:
\btab
(tab $!=$ null) \rarrow \ (0 $\le$ i) \conj \ (i $\le$ tab.length)
\etab
Since the specification
of the method has an {\tt exsures false} clause, there is no exceptional case.
In a way, this method will be replaced by its specifications like for a macro.



\subsection{Specification macros}


When specifying a program with JML one of the main problem is the 
growth of the size of the annotations. 
The way static verification tools usually define the handling 
of pure methods, we can use them to do some specification macros.
The method calls will be replaced by their specifications when the 
annotations will be interpreted. It is useful to avoid the growth.

If we have for instance a property to tell an array is sorted we would 
prefer read the annotation:
\btab
is\_sorted(tab)
\etab
instead of:
\btab
 $\backslash$forall \=int i; 0 $\le$ i \&\& i $<$ tab.length;\+\\ 
 $\backslash$forall int j; \=0 $\le$ j \&\& j $<$ tab.length; \+\\(i $<$ j) ==$>$ tab[i] $\le$ tab[j];
\etab
This method makes the annotations clearer, but as annotations 
grows big, proof obligations grows big too. In order to ease the readability 
of the proof obligations, we would like to keep track of the pure method name
that was used as the macro in order to see what part of the specification we 
are proving. That's why we changed the pure method's substitution in Jack.

In Jack, we decided to have a couple Definition / hypothesis.
Now a functional definition is generated of the form:
\btab
mypurefun\_norm  Args Result := (requires Args) \rarrow \ (ensures Args Result)\\
mypurefun\_exc  Args Result := (requires Args) \rarrow \ (exsures Args Result)
\etab
where {\tt requires} is a predicate that is on the arguments of the pure function and 
which correspond to JML {\tt requires} clause the same for {\tt ensures} and {\tt exsures} 
which are predicates that correspond to JML's {\tt ensures} and {\tt exsures} clause respectively.
These functions are then called within the hypothesis at the places where they were used in the code. 

It is nearly what is done in Krakatoa\cite{MPMU-04-JLAP}, as
Krakatoa use a functional definition of the pure method if it can generate it
but otherwise use an axiomatisation of it like in ESC/Java\cite{COKK-04-ESCJ}.
The axiomatisation is done in 3 parts: the pure method is first declared as a variable, 
there is some hypothesis  using it and giving it its properties (which correspond to its
specifications), and then the variable
is used within the lemma which has to be proved (for more detailed comparison between 
the different technique see: \cite{COK-04-METH, DarvasMueller-05}).

This way of defining Definition/Hypothesis doesn't change anything for automatic 
proof of the proof obligations with prover like Simplify. 
%However, with Coq 
%it add an extra step to the proof which is to unfold the definition 
%within the hypothesis. Nevertheless,  
With Coq,
it facilitate the readability of the proof obligation for the user which 
is a critical point, notably when doing an interactive proof.

\subsection{Pure as Predicates}
Some of the properties we have to express are not so easy to deal with on the JML level. 
We want to be able to prove lemmas concerning pure methods, and also have 
relations over  variables without specifying any property on the relation. 

So we decided to be able to define pure methods directly within the language in which the proof 
obligations are generated or the JML annotations are interpreted. 
We added a new keyword to JML in order to allow it: the {\tt native} keyword. 
If a method is declared within a specification as native, the method will not be defined nor specified
 in JML at all, it will only be declared. Its specifications will be to the target prover or environment 
discretion.

Since the native methods are declared within the specifications they must be pure:
they must not have any side-effect, they can only
create new objects, they have to be terminating. But native is
more restrictive than pure: a native method must not throw any exception.


For instance we can have the property {\tt withinBounds} declared as native, inside the specification:
\btab
//@ public native static boolean withinBounds(int [] tab, int i); 
\etab
If interpreted with a dynamic program verification tool, it
can be defined with the Java method:
\btab
public \= static boolean withinBounds(int [] tab, int i) \{\+\\
    return (tab $!=$ null) \&\& (0 $\le$ i) \&\& (i $\le$ (tab.length));\-\\
\}
\etab
If interpreted with a static program verification tool,
it can be defined this way in Coq:
\btab
Def\=inition withinBounds := \+\\
fun \= (tab i) =>\+\\
       (and (not (tab = null)) (and (0 $\le$ i) (i $\le$ (arraylength tab))).
\etab
In Simplify it will be seen as an uninterpreted function symbol, just a relation on the arguments.

In Jack, the binding from the JML declaration to the {\tt native} language is done automatically.
The arguments passed to the method are the same as the one whose the method was declared with
except:
\begin{itemize}
\item if the method is an instance method, an extra argument {\tt this} is added by Jack 
  at the beginning of the method when it is translated
\item if one of the argument is an array, the array dereferencing relation
(to do array access) and its length relation are also given
\end{itemize}


For static program verification, this construct can be really useful, especially if 
it is used in the pure macro fashion. 
Even though we lose the ability to express JML's behaviour
with these specification macros, 
we can now easily prove properties over specifications in the target prover language. 
Once these properties are proved, they can be added as a help
to ease the automatic solving to some of the proofs of the proof obligations.

In  ESC/Java or Krakatoa it is permitted to define a pure method in
specifications only, but its definition/specifications must be written in Java.
Krakatoa is indeed a front-end for Java and JML to the Why tool \cite{Why-Tool}. 
In this tool there exists a mechanism 
which allow similar definitions as the native keyword: the {\tt parameter} construct.
The main difference with the native keyword is that {\tt parameter} is more tool dependent, 
 it is used implicitly within annotations and it is not used on the JML level.


