The verification framework we are targetting relies on program and
aspects specifications that are precise enough to make the
verification conditions generated provable.  The annotation language
we use is Pipa (an extension of JML for AspectJ).  The subset of the
language is a JML level 0~\cite{Leavens-etal07} like subset of Pipa. 
Pointcuts specifications~\cite{pointcuts07}  and universe types 
will be ignored. Nevertheless some non level 0 constructs like model or pure
methods are allowed.
Behavioural specifications are allowed too because these specifications can
be desugared~\cite{RaghavanL00}.

\subsection{JML} 
JML is a behavioural specification language for Java. It is made of
numerous keyword: you can express methods pre and post conditions with
it (the keywords {\tt requires} and {\tt ensures}), exceptional
postcondition ({\tt exsures}). There are notions of frame conditions
(the {\tt assignable} clauses). One can also express assertions ({\tt
assert} construct), and loop invariants. Some data structures can be defined
only on the specification level, the model classes, fields and methods.

\paragraph{Invasive model methods} 
Model methods are specification methods that can be with or without
side-effects, their effects being determined by their specifications.
They can have a body, but in our framework we are interested by
bodyless model methods. They are used to assume an effect over the
program, and so state that if their requires are satisfied, the given
effect (given by the ensure clause) will be satisfied. The model methods can
be defined as invasive, because just like aspect they can have unexpected 
side effects on their environment.

\vspace{-0.4cm}
\begin{figure}
\begin{center}
\begin{tabular}{lll}
\begin{minipage}{3cm}
\bcode
ghost int i;\\
...\\
requires i > 0;\\
assignable i;\\
ensures i == 1;\\
model void m();
\ecode
\end{minipage} & 
\ \ \ \ \ \ 
&
\begin{minipage}{3cm}
\bcode
...\\
i++;\\
//@ m();\\
//@ assert(i == 1);\\
...
\ecode \end{minipage}

\end{tabular}
\end{center}
\caption{Model method definition and use}
\label{model_meth}
\end{figure}

\vspace{-1cm}
\paragraph{Model methods call}
To be able to use model methods with the full expressivity desired, we
add a new annotation to JML, the simple annotation method call. Its
syntax would be simply the model method call in the middle of
annotations as shown on Figure \ref{model_meth}. It can be easily 
translated into guarded commands (like the one there \cite{BarnettL05}),
but we will define it more precisely in Subsection \ref{gc}.

\subsection{Pipa}
Pipa is a behavioural specification language based on JML.  
The specification of an advice is similar to the one of a method call. It
has a pre- and post- condition, an exceptional postcondition and a frame
condition. The specifications are not different from JML's method's
specification, but they are used on advices.  Pipa mainly adds two
constructs specific to around advice.

\paragraph{Around advice specifications} 
The difficulty of specifying an around advices is due to the presence
of the proceed construct. It has to be stated in the method
specification, and in JML no keywords exist to represent it.  The
solution commonly used was proposed by Clifton and
Leavens~\cite{clifton02spectators}: we need a {\tt proceed} 
and a {\tt then} construct, to express what happens before and after
the proceed call. Therefore the specification of an around advice is
divided into two parts the part before the proceed (before the
execution of the target instruction) and the part after the
proceed. These two parts have both pre and post conditions as well as
a frame condition. The first part has the construct proceed which
take a boolean condition that determine if the instruction, target of
the proceed, can be executed.

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
int f;\\
...\\
/*\=@ \ \ \=requires f > 0;\+ \\
@ \>ensures f == 1;\\
@ \>proceeds true;\\
@ then\\
@ \> requires f == 2;\\
@ \> ensures f == 3;\\
@*/\-\\
void \= around() : call (void m()) \{\\
\>...\\
\} \ecode\end{minipage}



\end{tabular}
\end{center}

\caption{Around annotations}
\label{arround_annot}
\end{figure}


\subsection{The annotated program}
To continue with the Security Manager example, at this step we have to
annotate the Security Manager and the base program.  The Security
Manager (Figure \ref{sm_annot}) has to be annotated, and especially
its main advice are annotated. We specify that the advice
modifies nothing, and that an exception will be thrown if the package
name of the called method is {\tt b}, and otherwise nothing will be
done. To be able to use the field {\tt s} in the specifications it is
made {\tt spec\_public}. Please note that all the methods called in
the specifications at this stage are side-effect free.

\begin{figure}[h]
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
pu\=blic aspect SecurityManager \{\+\\
//@ public invariant s != null;\\
 Set$<$String$>$ /*@ spec\_public @*/ s = new HashSet$<$String$>$();\\
\ \\
po\=intcut anyPublicMethod(Object o) : \=target(o) \&\& \\
           \>!within(SecurityManager) \&\& call( public *(*))\\
/*\=@ requires o != null \&\& s != null;\+\\
  @ assignable $\backslash$nothing;\\
  @ ensures \= s.contains(o.getClass().getPackage().toString())\\
  @         \> \&\& !(o.getClass().getPackage().equals("b"));\\
  @ exsures (SecurityE\=xception) !s.contains("b")\\
  @                     \>\&\& (o.getClass().getPackage().equals("b"));\\
  @*/\-\\
before(Object o) : anyPublicMethod(o) \{\+\\
    ...\-\\
\}\-\\
\}
\ecode
\end{minipage}
\end{tabular}
\end{center}
\caption{The annotated Security Manager}
\label{sm_annot}
\end{figure}

The base program is annotated with normal JML specification 
(Figure \ref{prog_annot}).
Though, if we want to manage to verify it, the specifications must take
into account the aspect that will be weaved afterward. Therefore the 
specifications of the base program have to reflect the advice specifications.
Here, an exception is thrown if there is a call on package {\tt b} and this 
is the first try (otherwise the field {\tt s} would already contain the package
representation String).
\begin{figure}
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
  /*\=@ assignable $\backslash$nothing \+\\
    @ ensures s.contains("b");\\
    @ exsures !s.contains("b");\\
    @*/\-\\
  pub\=lic static void main(String[] args) \{\+\\
    b.A a = new b.A();\-\\
  \}\\
\ecode
\end{minipage}
\end{tabular}
\end{center}
\caption{The annotated base program}
\label{prog_annot}
\end{figure}

\subsection{Desugaring specifications}
\label{desugar}
In the seminal paper about Pipa~\cite{ZhaoR03}, the authors stated
that annotations written with Pipa could be translated back to JML
annotations, and they propose to weave Pipa annotations to JML
annotations, being unclear how to do it. What we understand by
translating Pipa annotation to JML annotations is removing most of the
Pipa specific annotations. We turn the advices into methods so 
we can apply the behaviours desugaring described in Raghavan and Leavens
paper~\cite{RaghavanL00}.

\paragraph{proceed}
Proceed construct is transformed into the predicate {\tt
proceed(bool)} and conjuncted to the ensures specifications of the
part before the {\tt then} of the given case.  If the proceed was omitted it
is added in the ensures as {\tt proceed(false)}.

\paragraph{then}
The {\tt then} is the only Pipa construct that cannot be desugared
into proper JML. It is used in the contract of around advices, and it
modifies the semantic of the {\tt proceed()} instruction in the code.
Behaviours of around advices is desugared around the {\tt then}
construct: each part of each behaviour taking place before the {\tt
then} construct are desugared with each other as stated for standard
JML behaviour in~\cite{clifton02spectators}.  And the part after the
{\tt then} construct is given the same treatment.

