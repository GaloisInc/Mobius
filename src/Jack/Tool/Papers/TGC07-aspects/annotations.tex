The verification framework we are targetting relies on program and
aspects specifications that are precise enough to make the
verification conditions generated provable.  The annotation language
we use is Pipa~\cite{ZhaoR03} (the extension of JML for AspectJ).  The
choice was obvious since it is to our knowledge the only proper
annotation language defined for aspects. Here we won't treat point
cuts specification that Pipa allows.  We will use a JML level
0~\cite{Leavens-etal07} like subset of Pipa.  We won't allow universe
types, but we will allow other non level 0 constructs like the model
methods, and some constructs to handle aspects found in Pipa.
We will also permit behavioural specifications because JML's can
be desugared as shown in \cite{RaghavanL00}.

\subsection{JML} 
JML is a behavioural specification language for Java. It is made of
numerous keyword: you can express methods pre and post conditions with
it (the keywords {\tt requires} and {\tt ensures}), exceptional
postcondition ({\tt exsures}). There are notions of frame conditions
(the {\tt assignable} clauses). One can also express assertions ({\tt
assert} construct), and loop invariants.

\paragraph{Invasive model methods} 
Model methods are an interesting construct of JML: these are
specification methods that can be with or without side-effects, their
effects being determined by their specifications.  They can have a
body, but in our framework we are interested by bodyless model
methods. They are used to assume an effect over the program, and so
state that if their requires are satisfied, the given effect (given by
the ensure clause) will be satisfied.  In this paper we won't talk
about pure model methods which could be use in specifications. Here we
rather talk about invasive ones: just like invasive aspects they are
meant to state that the program has been modified non explicitly.
\begin{figure}
\begin{center}
\begin{tabular}{lll}
\begin{minipage}{3cm}
\bcode
ghost int i;\\
...\\
requires i > 0;\\
assignable i;\\
ensures i == 1;\\
model void m();
\ecode
\end{minipage} & 
\ \ \ \ \ \ 
&
\begin{minipage}{3cm}
\bcode
...\\
i++;\\
//@ m();\\
//@ assert(i == 1);\\
...
\ecode \end{minipage}

\end{tabular}
\end{center}
\caption{Model method definition and use}
\label{model_meth_def}
\end{figure}


\paragraph{Model methods call}
To be able to use model methods with the full expressivity desired, we
add a new annotation to JML, the simple annotation method call. Its
syntax would be simply the model method call in the middle of
annotations as shown on figure \ref{model_meth}. It can be easily 
translated into guarded commands (like the one there \cite{BarnettL05}),
but we will define it more precisely in Subsection \ref{gc}.

\subsection{Pipa}
Pipa is a behavioural specification language based on JML.  You can
specify advices as well as pointcuts~\cite{pointcuts07} with Pipa.  In
this paper we will only treat the advices specifications.  The
specification of an advice is similar to the one of a method call. It
has a pre and post condition, an exceptional postcondition and a frame
condition. The specification are not different for JML's method's
specification, being applied on advices.  Pipa mainly adds two
construct plus a specific semantic we are interested in: the specific
constructs for around advices, and their semantic of the ensure
clause.

\paragraph{Around advice specifications} 
The difficulty of specification of around advices is due to the
presence of the proceed construct. It has to be stated in the method
specification and in JML there are no keywords to represent it. To
represent the proceed in specification, Pipa uses the predicate {\tt
proceed} as well as the {\tt then} construct as what was stated in
Clifton and Leavens paper~\cite{clifton02spectators}.  The
specification of an around advice is divided in two the part before
the proceeds (the part before the execution of the target instruction)
and the part after the proceeds. These two parts have both pre and
post conditions as well as a frame condition. There is also for the
first part a new keyword proceeds which take a boolean condition which
is an invariant for an around advice which determined if the
instruction must be executed.

\begin{figure}
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
int f;\\
...\\
/*\=@ \ \ \=requires f > 0;\+ \\
@ \>ensures f == 1;\\
@ \>proceeds true;\\
@ then\\
@ \> requires f == 2;\\
@ \> ensures f == 3;\\
@*/\-\\
void \= around() : call (void m()) \{\\
\>...\\
\} \ecode\end{minipage}



\end{tabular}
\end{center}

\caption{Around annotations}
\label{arround_annot}
\end{figure}


\subsection{The annotated program}
To verify our program we have to specify with Pipa the Security Manager
as well as the base program.
 
The Security Manager (Figure \ref{sm_annot}) as an advice has to be
annotated. The annotations tells that the advice modifies nothing, and
that an exception will be thrown if the package name of the called
method is {\tt b}, and otherwise nothing will be done. To be able to
use the field {\tt s} in the specifications it is made {\tt
spec\_public}. Please note that all the methods called in the
specifications are side-effect free.

\begin{figure}
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
pu\=blic aspect SecurityManager \{\+\\
Set$<$String$>$ /*@ spec\_public @*/ s = new HashSet$<$String$>$();\\
\ \\
/*\=@ requires o != null \&\& s != null;\+\\
  @ modifies $\backslash$nothing;\\
  @ ensures \= s.contains(o.getClass().getPackage().toString())\\
  @         \> \&\& !(o.getClass().getPackage().equals("b"));\\
  @ exsures (SecurityE\=xception) !s.contains("b")\\
  @                     \>\&\& (o.getClass().getPackage().equals("b"));\\
  @*/\-\\
po\=intcut(Object o) : \=target(o) \&\& !within(SecurityManager)\+ \\
           \>\&\& call(public * funName(..)) \{\\
    ...\-\\
\}\-\\
\}
\ecode
\end{minipage}
\end{tabular}
\end{center}
\caption{The annotated Security Manager}
\label{sm_annot}
\end{figure}

The base program is annotated with normal JML specification 
(Figure \ref{prog_annot}),
although if the verification must be doable we have to annotate it taking
into account the aspect that will be weaved afterward. Therefore the 
specifications of the base program have to reflect the advice specifications.
Here, an exception is thrown if there is a call on package {\tt b} and this 
is the first try (otherwise the field {\tt s} would already contain the package
representation String).
\begin{figure}
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
  /*\=@ modifies $\backslash$nothing \+\\
    @ ensures s.contains("b");\\
    @ exsures !s.contains("b");\\
    @*/\-\\
  pub\=lic static void main(String[] args) \{\+\\
    b.A a = new b.A();\-\\
  \}\\
\ecode
\end{minipage}
\end{tabular}
\end{center}
\caption{The annotated base program}
\label{prog_annot}
\end{figure}

\subsection{Desugaring specifications}
\label{desugar}
In the seminal paper about Pipa~\cite{ZhaoR03}, the authors stated
that annotations written with Pipa could be translated back to JML
annotation, and they propose to weave Pipa annotation to JML
annotation, being unclear how to do it.  Here what we understand by
translating Pipa annotation to JML annotations is removing most of the
Pipa specific annotations. We turn the advices into methods so 
we can apply the behaviours desugaring described in Raghavan and Leavens
paper~\cite{RaghavanL00}.

\paragraph{proceed}
Proceed construct is transformed into the predicate {\tt
proceed(bool)} and conjuncted to the ensures specifications of the
part before the then of the given case.  If the proceed was omitted it
is added in the ensures as {\tt proceed(false)}.


\paragraph{then}
The {\tt then} is the only Pipa construct that cannot be desugared
into proper JML. It is used in the contract of around advices, and it
modifies the semantic of the {\tt proceed()} instruction in the code.
Behaviours of around advices is desugared around the {\tt then}
construct: each part of each behaviour taking place before the {\tt
then} construct are desugared with each other as stated for standard
JML behaviour in~\cite{clifton02spectators}.  And the part after the
{\tt then} construct is given the same treatment.

