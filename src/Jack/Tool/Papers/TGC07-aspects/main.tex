% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.3 for LaTeX2e
%
\documentclass[draft]{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage[inline, nomargin]{fixme}
\usepackage{listings}
\usepackage{float}
%
\begin{document}

\newcommand{\rarrow}{$\rightarrow$}
\newcommand{\conj}{$\wedge$}
\newcommand{\disjonc}{$\vee$}
\newcommand{\s}{\,}
\newcommand{\btab}{\begin{tt}\begin{tabbing}}
\newcommand{\etab}{\end{tabbing}\end{tt}}
\newcommand{\bcode}{\begin{tt}\begin{small}\begin{tabbing}}
\newcommand{\ecode}{\end{tabbing}\end{small}\end{tt}}
%
\frontmatter          % for the preliminaries
%

\mainmatter              % start of the contributions
%
\title{Taking into account Java's Security Manager for static verification}
%
\titlerunning{Taking in account Java's Security Manager}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Julien Charles \and C\'esar Kunz}
%
\authorrunning{Julien Charles and C\'esar Kunz}   % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Julien Charles, C\'esar Kunz}
%
\institute{INRIA Sophia-Antipolis\\
\email{\{julien.charles, cesar.kunz\}@inria.fr}}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The Security Manager is an important system component in the Java Virtual Machine (JVM). It forbids access
to some specific methods depending on a given security policy. It modifies both the behavior of 
the Java system libraries and of the JVM, for it throws exceptions in case of security policy 
violation.  The difficulty for the verification of a environment containing it 
lies in the fact that its use mixes library calls (easy to specify) as well as
direct VM calls (hard to take in account because they modifies directly the Java semantic of the execution). 
Moreover its use  could be modelled solely as a JVM level component, which would make the
use of this component more homogenous as well as the application of its security policies it applies 
more trustable.

In this article we use a JVM-level modelisation of a SecurityManager seen as an Aspect component, 
and we define a verification framework to verify statically programs that takes in account the presence 
of this component. 
\end{abstract}
%
\section{Introduction}
Java is a language commonly used on small device, and more specifically on Trusted Personnal Devices, devices
of heterogenous nature like cellphones or JavaCards. Thus the verification of the different components Java
platform is made of is crucial; and even more so taking in account their specific caracteristic which would
change the general behaviour of a JVM. Verification of specific components is scattered through litterature: 
there has been verifications of Bytecode Verifiers, as well as Access Contoller. As far as our knowledge goes
though, the SecurityManager of the Virtual Machine has never been taken into account for
the verification of a Java program, especially for the checks it does on the Virtual Machine level.

The main goal of this paper is to verify an implementation of a Security Manager, and especially to use 
this verification as a mean to specify more precisely the behaviour of Java Virtual Machine in order to
verify more accurately Java programs.

\subsection{The Security Manager}
The Security Manager applies the security policies on two levels. First on the library level, each time a
writing or reading operation is called for instance a call to the Security Manager is made and if the
caller has not respected a given security policy, a SecurityException is thrown, several other operations
of the same type are handled. Second on the Virtual Machine level, each time a class is loaded, it checks on
a meta level with the use of the ClassLoader (which for this paper will be considered as a part of the
JVM) if the currently inspected class has the right to access a specified type from an outside package.
The second set of property is hard to take in account for a program verification, because it changes the 
behavior of type resolution which is done to the program.
A practical way to model these changes  would be to consider the Security Manager as an Aspect which
would weave at the cutting points representing type resolution.
\begin{figure}
\bcode
pa\=ckage a;\\
public class Main \{\+\\
  st\=atic \{\+\\
    Sy\=stem.setSecurityManager(new SecurityManager() \{\+\\
      pu\=blic void checkPackageAccess(String target) \{\+\\
        if\=(target.equals("b"))\\
          \>throw new SecurityException("That is true");\\
      \}\});\-\-\\
  \}\\
 \\
  public static void main(String[] args) \{\+\\
    System.out.println("Nextline will throw an exception");\\
    b.A a = new b.A();\-\\
  \}\-\\
\}
\ecode
The output of the program:
\bcode
Next line will throw an exception\\
Excepti\=on in thread "main" java.lang.SecurityException: That is true\+\\
	at a.b.Main\$1.checkPackageAccess(Main.java:9)\\
	\dots
\ecode
\caption{An invasive Security Manager}
\end{figure}
\subsection{Verification of Aspects}
Aspect Oriented Programming (AOP) is a recent paradigm that offers modularity though it is ortogonal to 
the usual Object Oriented Programming paradigm. AOP enables to weave code directly into a program
thus changing the behaviour of given constructs. Two new notions have been introduced through AOP:
\begin{itemize}
\item the concept of cutting points, points in the program where code could be inserted, and
\item advice, the code to be inserted at the specified cutting point.
\end{itemize}
Adding Aspect code to a program most of the time doesn't change its general behaviour, and in these case
the modular properties of the program are kept.
There is a classification of aspects into three groups: speculative, regulative or invasive \fixme{quote the 
article}.

Speculative and regulative Aspects enables modularity. 
\fixme{talk about model checking, JML verification + Cesar work}


In this paper we will restrict to the Aspects that can easily represent a Security Manager, the invasive
ones. This focus removes all the modularity that was aimed at in the other verification framework
mentionned above,
because it's the specific case where the Aspects have effects and likely break the original behaviour of
the program.

\subsection{A Security Manager modeled as Aspects}
Modeling the Security Manager as an invasive Aspect is quite natural: as we have seen in the above example 
when used it can change the behaviour of the JVM at the type access step. The type is checked only on the
first call, and
%
\begin{figure}
\bcode
pu\=blic aspect SecurityManager \{\+\\

Set$<$String$>$ s = new HashSet$<$String$>$();\\
po\=intcut(Object o) : \=target(o) \&\& !within(SecurityManager)\+ \\
           \>\&\& call(public * funName(..)) \{\\
    String pkg = o.getClass().getPackage();\\
    if\=(!s.contains(pkg)) \{\+\\     
       s.add(pkg);\\
       if\=(pkg.equals("b"))\\
           \>throw new SecurityException("That is true");\\\-\\ 
    \}\-\\
\}\-\\
\}
  
\ecode
\caption{An Aspect implementation of the invasive SecurityManager}
\end{figure}
\section{The verification framework}
The verification framework we are building in this paper is an adaptation of static
verification based on weakest precondition calculus for aspects. Here we will consider
the SecurityManager as an invasive aspect, so we must have a weakest precondition made
for taking into account Aspects, that what this section is about.

A first approach that was to mind was compiling the Cutting point together with
the aspect as a predicate transformer. This approach is bad because recursive 
Aspects won't be computable with this simple technique.
Instead we choose an approach similar to Kunz's Aspects Hoare logic but les modular because of the nature
of the SecurityManager which is purely invasive. To make the infringement into the real 
world more palpable, we also chose a weakest precondition calculus that would be easy to
implement as part of the tool Jack or the more recent MobiusDirectVCGen.

The annotation language we will choose to use is similar to JML and moreover to Pipa (the extension
of JML for Aspects), but for our case study we will limit ourselves to that JML-level 0 or 'Pipa-level 0'
if sucha beast exists. So basically no concern about behavioural specifications, but rather we will use
the precondition (requires), framecondition (assignable) and postcondition with the same semantic that 
was specified in Pipa. This semantic bring differences, especially on the level of ensures of 
JML methods specifications. We advocate that JML's semantic is not expressive enough and the latter one
should be used uniformly for the postcondition specifications in our verification framework.

Our approach is not modular in essence: they are made out of three steps.
First all the advices have to be {\it compiled}: the weakest precondition calculus
will be parametized with their definition.
After, the program will be verified using this parametized weakest precondition Calculus.

\subsection{Definition of the predicate transformer compilation}

The base weakest precondition calculus is a standard one. Here we define it
for the instructions: 
\begin{figure}
\begin{small}\begin{verbatim}
static\_call();
dyn\_call();
var\_decl
if(b){
}
else {
}
while (b) {
}
return v
static { }
{ }
String_lit
throw
\end{verbatim}
\end{small}
\caption{The base language}
\end{figure}
The aspect are compiled into a list of predicate transformer.
The predicate transformers associated with an advice is similar to the weakest precondition
clause toward an invasive method call i.e. a method call that would be able to modify local variables
as well as the other program variables.

One of the amusing fact about this approach is that the weakest precondition calculus is parametized by a new 
semantic which is given by the aspects.

General form of the final wp rule:
\bcode

wp\_weaver \= (stmt, (stmt ==> pt) :: aspects, post) = \\
\>wp\_weaver (stmt, aspects, (pt post))\\
wp\_weaver (stmt, nil, post) =  post\\

wp (stmt1; stmt2, post) = \\
\> wp\_\=weaver(stmt1; stmt2, befores, \\
 \>\>      wp(stmt1, wp(stmt2, wp\_weaver(stmt1; stmt2, afters, post))\\
\ecode
where befores, arounds and afters are the compiled predicate
\subsection{Definition of the weakest precondition calculus on the programs}
\subsection{Proof of Correctness}
%
\section{Verifying a security manager}
\subsection{Intro/Definition/related work: sys component verif}
\subsection{An aspect modelisation}
\subsection{An instanciation example}
\section{Conclusion}
\subsection{Future work: reflexivity anyone?}
\subsection{Configurable PCC}
%
% ---- Bibliography ----
%
\begin{thebibliography}{}
%


\end{thebibliography}

\end{document}
