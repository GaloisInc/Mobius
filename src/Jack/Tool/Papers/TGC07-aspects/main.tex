% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.3 for LaTeX2e
%
\documentclass[draft]{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage[inline, nomargin]{fixme}
\usepackage{listings}
\usepackage{float}
\usepackage{macros}
%
\begin{document}

\newcommand{\rarrow}{$\rightarrow$}
\newcommand{\conj}{$\wedge$}
\newcommand{\disjonc}{$\vee$}
\newcommand{\s}{\,}
\newcommand{\btab}{\begin{tt}\begin{tabbing}}
\newcommand{\etab}{\end{tabbing}\end{tt}}
\newcommand{\bcode}{\begin{tt}\begin{small}\begin{tabbing}}
\newcommand{\ecode}{\end{tabbing}\end{small}\end{tt}}
%
\frontmatter          % for the preliminaries
%

\mainmatter              % start of the contributions
%
\title{Taking into account Java's Security Manager for static verification}
%
\titlerunning{Taking in account Java's Security Manager}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Julien Charles \and C\'esar Kunz}
%
\authorrunning{Julien Charles and C\'esar Kunz}   % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Julien Charles, C\'esar Kunz}
%
\institute{INRIA Sophia-Antipolis\\
\email{\{julien.charles, cesar.kunz\}@inria.fr}}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The Security Manager is an important system component in the Java Virtual Machine (JVM). It forbids access
to some specific methods depending on a given security policy. It modifies both the behavior of 
the Java system libraries and of the JVM, for it throws exceptions in case of security policy 
violation.  The difficulty for the verification of a environment containing it 
lies in the fact that its use mixes library calls (easy to specify) as well as
direct VM calls (hard to take in account because they modifies directly the Java semantic of the execution). 
Moreover its use  could be modelled solely as a JVM level component, which would make the
use of this component more homogenous as well as the application of its security policies it applies 
more trustable.

In this article we use a JVM-level modelisation of a SecurityManager seen as an Aspect component, 
and we define a verification framework to verify statically programs that takes in account the presence 
of this component. 
\end{abstract}
%
\section{Introduction}
Java is a language commonly used on small device, and more specifically on Trusted Personnal Devices, devices
of heterogenous nature like cellphones or JavaCards. Thus the verification of the different components Java
platform is made of is crucial; and even more so taking in account their specific caracteristic which would
change the general behaviour of a JVM. Verification of specific components is scattered through litterature: 
there has been verifications of Bytecode Verifiers, as well as Access Contoller. As far as our knowledge goes
though~\cite{HartelMoreau01}, the SecurityManager of the Virtual Machine is not taken into account when
doing static verification of Java programs.


The main goal of this paper is to verify an implementation of a Security Manager, and especially to use 
this verification as a mean to specify more precisely the behaviour of Java Virtual Machine in order to
verify more accurately Java programs.

\subsection{The Security Manager}
The Security Manager applies the security policies on two levels. First on the library level, each time a
writing or reading operation is called for instance a call to the Security Manager is made and if the
caller has not respected a given security policy, a SecurityException is thrown, several other operations
of the same type are handled. Second on the Virtual Machine level, each time a class is loaded, it checks on
a meta level with the use of the ClassLoader (which for this paper will be considered as a part of the
JVM) if the currently inspected class has the right to access a specified type from an outside package.
The second set of property is hard to take in account for a program verification, because it changes the 
behavior of type resolution which is done to the program.
A practical way to model these changes  would be to consider the Security Manager as an Aspect which
would weave at the cutting points representing type resolution.
\begin{figure}
\bcode
pa\=ckage a;\\
public class Main \{\+\\
  st\=atic \{\+\\
    Sy\=stem.setSecurityManager(new SecurityManager() \{\+\\
      pu\=blic void checkPackageAccess(String target) \{\+\\
        if\=(target.equals("b"))\\
          \>throw new SecurityException("That is true");\\
      \}\});\-\-\\
  \}\\
 \\
  public static void main(String[] args) \{\+\\
    System.out.println("Nextline will throw an exception");\\
    b.A a = new b.A();\-\\
  \}\-\\
\}
\ecode
The output of the program:
\bcode
Next line will throw an exception\\
Excepti\=on in thread "main" java.lang.SecurityException: That is true\+\\
	at a.b.Main\$1.checkPackageAccess(Main.java:9)\\
	\dots
\ecode
\caption{An invasive Security Manager}
\end{figure}


\subsection{A Security Manager modeled as Aspects}
Aspect Oriented Programming (AOP) is a recent paradigm that offers modularity
though it is ortogonal to  
the usual Object Oriented Programming paradigm. AOP enables to weave code
directly into a program 
thus changing the behaviour of given constructs. Two new notions have been
introduced through AOP: 
\begin{itemize}
\item the concept of cutting points, points in the program where code could be
inserted, and 
\item advice, the code to be inserted at the specified cutting point.
\end{itemize}

Modeling the Security Manager as an invasive Aspect is quite natural: as we have seen in the above example 
when used it can change the behaviour of the JVM at the type access step. The type is checked only on the
first call, and
%
\begin{figure}
\bcode
pu\=blic aspect SecurityManager \{\+\\

Set$<$String$>$ s = new HashSet$<$String$>$();\\
po\=intcut(Object o) : \=target(o) \&\& !within(SecurityManager)\+ \\
           \>\&\& call(public * funName(..)) \{\\
    String pkg = o.getClass().getPackage();\\
    if\=(!s.contains(pkg)) \{\+\\     
       s.add(pkg);\\
       if\=(pkg.equals("b"))\\
           \>throw new SecurityException("That is true");\\\-\\ 
    \}\-\\
\}\-\\
\}
\ecode
\caption{An Aspect implementation of the invasive SecurityManager}
\end{figure}



\subsection{Related Work}
\input{related}

\paragraph{Contents of the paper?}
In this paper we will restrict to the Aspects that can easily represent a
Security Manager, the invasive 
ones. This focus removes all the modularity that was aimed at in the other
verification framework mentioned above,
because it's the specific case where the Aspects have effects and likely break
the original behaviour of the program.




\section{The verification framework}
\input{framework_intro}


\subsection{Specifications}
\input{annotations}

\subsection{Compilation to invasive model methods}
\input{compilation}
\subsection{Weaving of the models}
\input{weaving}

\subsection{The weakest precondition calculus}

In our framework aspects are considered as methods calls that are transferred the whole
control flow, and are permitted to modify local variables in the caller methods. Therefore when aspects are weaved
there wp is just like the one of a method call.
For instance if an advice is weaved before an instruction i, the effective execution of the program
will be of

The aspect are compiled into a list containing the.
The predicate transformers associated with an advice is similar to the weakest precondition
clause toward an invasive method call i.e. a method call that would be able to modify local variables
as well as the other program variables.

One of the amusing fact about this approach is that the weakest precondition calculus is parametized by a new 
semantic which is given by the aspects.

General form of the final wp rule:
\bcode

\\
\ecode
where befores, arounds and afters are the compiled predicate
\subsection{Definition of the weakest precondition calculus on the programs}
\subsection{Proof of Correctness}
%
\section{Verifying a security manager}
\subsection{Intro/Definition/related work: sys component verif}
\subsection{An aspect modelisation}
\subsection{An instanciation example}
\section{Conclusion}
\subsection{Future work: reflexivity anyone?}
\subsection{Configurable PCC}
%
% ---- Bibliography ----
%


\bibliographystyle{plain}
\bibliography{bibli,aspects}
%




\end{document}
