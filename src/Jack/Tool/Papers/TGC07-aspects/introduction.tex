Java is a language commonly used on small device, and more
specifically on Trusted Personnal Devices, devices of heterogenous
nature like cellphones or JavaCards. Thus the verification of the
different components Java platform is made of is crucial; and even
more so taking in account their specific caracteristic which would
change the general behaviour of a JVM. Verification of specific
components is scattered through litterature: there has been
verifications of Bytecode Verifiers, as well as Access Contoller. As
far as our knowledge goes though~\cite{HartelMoreau01}, the
SecurityManager of the Virtual Machine is not taken into account when
doing static verification of Java programs.


The main goal of this paper is to verify an implementation of a
Security Manager, and especially to use this verification as a mean to
specify more precisely the behaviour of Java Virtual Machine in order
to verify more accurately Java programs.

\subsection{The Security Manager}
The Security Manager applies the security policies on two
levels. First on the library level, each time a writing or reading
operation is called for instance a call to the Security Manager is
made and if the caller has not respected a given security policy, a
SecurityException is thrown, several other operations of the same type
are handled. Second on the Virtual Machine level, each time a class is
loaded, it checks on a meta level with the use of the ClassLoader
(which for this paper will be considered as a part of the JVM) if the
currently inspected class has the right to access a specified type
from an outside package.  The second set of property is hard to take
in account for a program verification, because it changes the behavior
of type resolution which is done to the program.  A practical way to
model these changes would be to consider the Security Manager as an
Aspect which would weave at the cutting points representing type
resolution.
\begin{figure}
\bcode
pa\=ckage a;\\
public class Main \{\+\\
  st\=atic \{\+\\
    Sy\=stem.setSecurityManager(new SecurityManager() \{\+\\
      pu\=blic void checkPackageAccess(String target) \{\+\\
        if\=(target.equals("b"))\\
          \>throw new SecurityException("That is true");\\
      \}\});\-\-\\
  \}\\
 \\
  public static void main(String[] args) \{\+\\
    System.out.println("Nextline will throw an exception");\\
    b.A a = new b.A();\-\\
  \}\-\\
\}
\ecode
The output of the program:
\bcode
Next line will throw an exception\\
Excepti\=on in thread "main" java.lang.SecurityException: That is true\+\\
	at a.b.Main\$1.checkPackageAccess(Main.java:9)\\
	\dots
\ecode
\caption{An invasive Security Manager}
\end{figure}


\subsection{A Security Manager modeled as Aspects}
Aspect Oriented Programming (AOP) is a recent paradigm that offers
modularity though it is ortogonal to the usual Object Oriented
Programming paradigm. AOP enables to weave code directly into a
program thus changing the behaviour of given constructs. Two new
notions have been introduced through AOP:
\begin{itemize}
\item the concept of cutting points, points in the program where code
could be inserted, and
\item advice, the code to be inserted at the specified cutting point.
\end{itemize}

Modeling the Security Manager as an invasive Aspect is quite natural:
as we have seen in the above example when used it can change the
behaviour of the JVM at the type access step. The type is checked only
on the first call, and
%
\begin{figure}
\bcode
pu\=blic aspect SecurityManager \{\+\\

Set$<$String$>$ s = new HashSet$<$String$>$();\\
po\=intcut(Object o) : \=target(o) \&\& !within(SecurityManager)\+ \\
           \>\&\& call(public * funName(..)) \{\\
    String pkg = o.getClass().getPackage();\\
    if\=(!s.contains(pkg)) \{\+\\     
       s.add(pkg);\\
       if\=(pkg.equals("b"))\\
           \>throw new SecurityException("That is true");\\\-\\ 
    \}\-\\
\}\-\\
\}
\ecode
\caption{An Aspect implementation of the invasive SecurityManager}
\end{figure}



\subsection{Related Work}
\input{related}

\paragraph{Contents of the paper?}
In this paper we will restrict to the Aspects that can easily
represent a Security Manager, the invasive ones. This focus removes
all the modularity that was aimed at in the other verification
framework mentioned above, because it's the specific case where the
Aspects have effects and likely break the original behaviour of the
program.

