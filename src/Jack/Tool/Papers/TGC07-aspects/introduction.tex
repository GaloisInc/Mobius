Java is a language commonly used on small device, which can be of
heterogenous nature like cellphones or JavaCards. Thus the
verification of the different components Java platform is important
and taking into account their specific caracteristic is crucial
especially if these components change the general behaviour of a
JVM. Verification of specific components is scattered through
litterature: there has been verifications of bytecode verifiers, as
well as access contoller. As far as our knowledge goes
though~\cite{HartelMoreau01}, the SecurityManager of the Virtual
Machine has not been verified and its semantic is not taken into
account when doing static verification of Java programs.


The main goal of this paper is to verify an implementation of a
Security Manager, and also to give a framework to more generally verify
programs taking into account the semantic differences that different
component of the JVM can bring to executions of program inside 
a JVM.


\subsection{The Security Manager}
The Security Manager applies the security policies on two
levels. First on the library level, each time a writing or reading
operation is called for instance a call to the Security Manager is
made and if the caller has not respected a given security policy, a
SecurityException is thrown, several other operations of the same type
are handled. Second on the Virtual Machine level, each time a class is
loaded, it checks on a meta level with the use of the ClassLoader
(which for this paper will be considered as a part of the JVM) if the
currently inspected class has the right to access a specified type
from an outside package.  The second set of property is hard to take
in account for a program verification, because it changes the behavior
of type resolution which is done to the program.  A practical way to
model these changes would be to consider the Security Manager as an
Aspect which would weave at the cutting points representing type
resolution.
\begin{figure}
\bcode
pa\=ckage a;\\
public class Main \{\+\\
  st\=atic \{\+\\
    Sy\=stem.setSecurityManager(new SecurityManager() \{\+\\
      pu\=blic void checkPackageAccess(String target) \{\+\\
        if\=(target.equals("b"))\\
          \>throw new SecurityException("That is true");\\
      \}\});\-\-\\
  \}\\
 \\
  public static void main(String[] args) \{\+\\
    System.out.println("Nextline will throw an exception");\\
    b.A a = new b.A();\-\\
  \}\-\\
\}
\ecode
The output of the program:
\bcode
Next line will throw an exception\\
Excepti\=on in thread "main" java.lang.SecurityException: That is true\+\\
	at a.b.Main\$1.checkPackageAccess(Main.java:9)\\
	\dots
\ecode
\caption{An invasive Security Manager}
\end{figure}


\subsection{A Security Manager modeled with AspectJ}
Aspect Oriented Programming (AOP) is a recent paradigm that offers
modularity though it is ortogonal to the usual Object Oriented
Programming paradigm. AOP enables to weave code directly into a
program thus changing the behaviour of given constructs. Two new
notions have been introduced through AOP:
\begin{itemize}
\item the concept of cutting points, points in the program where code
could be inserted, and
\item advice, the code to be inserted at the specified cutting point.
\end{itemize}
AspectJ is one of the most popular of the AOP languages. It is to be
used with Java, so it was a natural choice for us to choose this
language for modelling the Security Manager through aspects.

Implementing the Security Manager as an invasive Aspect is easy.  As
we have seen in the above example, a minimal Security Manager could
change the behaviour of the JVM at the type access step. The
difficulty here would be that the type is checked only on the first
call but it is easily solved like what is done in Figure \ref{base_implem}.
%
\begin{figure}
\bcode
pu\=blic aspect SecurityManager \{\+\\

Set$<$String$>$ s = new HashSet$<$String$>$();\\
po\=intcut anyPublicMethod(Object o) : \=target(o) \&\& !within(SecurityManager)\+ \\
           \>\&\& call( public *(*))\-\\
before(Object o) : anyPublicMethod(o) \{\+\\
    String pkg = o.getClass().getPackage().toString();\\
    if\=(!s.contains(pkg)) \{\+\\     
       s.add(pkg);\\
       if\=(pkg.equals("b"))\\
           \>throw new SecurityException("That is true");\\\-\\ 
    \}\-\\
\}\-\\
\}
\ecode
\caption{An Aspect implementation of the invasive SecurityManager}
\label{base_implem}
\end{figure}


\subsection{The verification framework}
\label{framework}
The verification framework we are building in this paper is an
adaptation of static verification techniques based on weakest
precondition calculus. It is based upon Java extended static verification
tools using guarded commands language like ESC/Java2~\cite{CokK04} and
what is planned to be done using BoogiePL for the Mobius
PVE~\cite{MobiusPVE07}.


The verification process is made of several steps:
First the program and the aspects are annotated:
\begin{enumerate}
\item the program and its aspects are annotated using Pipa,
\item the behavioural specifications are desugared
\item the specifications of the aspects are compiled into model
methods
\end{enumerate}
Then the proper compilation of aspects is done:
\begin{enumerate}
\item the program is compiled to bytecode with its specifications
\item the program is transformed into guarded commands
\item the model methods are weaved to the program
\end{enumerate}
Finally a weakest precondition calculus is made on the transformed
program, and verification conditions are generated in order to be
solved automatically or interactively.

\subsection{Related Work}
\label{related}
\input{related}


\subsubsection{Outline:}
First, in Section \ref{specs} we will show how the program has to be
 properly annotated. Then in Section \ref{transf} we will
transform the program to ease its verification: the aspects will be turned
into model methods and the main program code into guarded commands.
In section \ref{verif} we will explain how to verify the transformed program
and finally give a conclusion in Section \ref{conclusion}.

