Java is a language commonly used on small device, which can be of
heterogenous nature like cellphones or JavaCards. Thus the
verification of the different components Java platform is important
and taking into account their specific caracteristic is crucial
especially if these components change the general behaviour of a
JVM. Verification of specific components is scattered through
litterature: there has been verifications of bytecode verifiers, as
well as access contoller. As far as our knowledge goes
though~\cite{HartelMoreau01}, the SecurityManager of the Virtual
Machine has not been verified and its semantic is not taken into
account when doing static verification of Java programs.


The main goal of this paper is to verify an implementation of a
Security Manager, and also to give a framework to more generally verify
programs taking into account the semantic differences that different
component of the JVM can bring to their execution.


\subsection{The Security Manager}
The Security Manager applies the security policies on two
levels. First on the library level, each time a writing or reading
operation is called for instance a call to the Security Manager is
made and if the caller has not respected a given security policy, a
SecurityException is thrown, several other operations of the same type
are handled. Second on the Virtual Machine level, each time a class is
loaded, it checks on a meta level with the use of the ClassLoader
(which for this paper will be considered as a part of the JVM) if the
currently inspected class has the right to access a specified type
from an outside package.  The second set of property is hard to take
in account for a program verification, because it changes the behavior
of type resolution which is done to the program.  A practical way to
model these changes would be to consider the Security Manager as an
Aspect which would weave at the cutting points representing type
resolution.
\begin{figure}
\bcode
pa\=ckage a;\\
public class Main \{\+\\
  st\=atic \{\+\\
    Sy\=stem.setSecurityManager(new SecurityManager() \{\+\\
      pu\=blic void checkPackageAccess(String target) \{\+\\
        if\=(target.equals("b"))\\
          \>throw new SecurityException("That is true");\\
      \}\});\-\-\\
  \}\\
 \\
  public static void main(String[] args) \{\+\\
    System.out.println("Nextline will throw an exception");\\
    b.A a = new b.A();\-\\
  \}\-\\
\}
\ecode
The output of the program:
\bcode
Next line will throw an exception\\
Excepti\=on in thread "main" java.lang.SecurityException: That is true\+\\
	at a.b.Main\$1.checkPackageAccess(Main.java:9)\\
	\dots
\ecode
\caption{An invasive Security Manager}
\end{figure}


\subsection{A Security Manager modeled with AspectJ}
Aspect Oriented Programming (AOP) is a recent paradigm that offers
modularity though it is ortogonal to the usual Object Oriented
Programming paradigm. AOP enables to weave code directly into a
program thus changing the behaviour of given constructs. Two new
notions have been introduced through AOP:
\begin{itemize}
\item the concept of cutting points, points in the program where code
could be inserted, and
\item advice, the code to be inserted at the specified cutting point.
\end{itemize}
AspectJ is one of the most popular of the AOP languages. It is to be
used with Java, so it was a natural choice for us to choose this
language for modelling the Security Manager through aspects.

Implementing the Security Manager as an invasive Aspect is easy.  As
we have seen in the above example, a minimal Security Manager could
change the behaviour of the JVM at the type access step. The
difficulty here would be that the type is checked only on the first
call but it is easily solved like what is done in Figure \ref{base_implem}.
%
\begin{figure}
\bcode
pu\=blic aspect SecurityManager \{\+\\

Set$<$String$>$ s = new HashSet$<$String$>$();\\
po\=intcut(Object o) : \=target(o) \&\& !within(SecurityManager)\+ \\
           \>\&\& call(public * funName(..)) \{\\
    String pkg = o.getClass().getPackage();\\
    if\=(!s.contains(pkg)) \{\+\\     
       s.add(pkg);\\
       if\=(pkg.equals("b"))\\
           \>throw new SecurityException("That is true");\\\-\\ 
    \}\-\\
\}\-\\
\}
\ecode
\caption{An Aspect implementation of the invasive SecurityManager}
\label{base_implem}
\end{figure}



\subsection{Related Work}
\input{related}

\paragraph{Contents of the paper?}
In this paper we will restrict to the Aspects that can easily
represent a Security Manager, the invasive ones. This focus removes
all the modularity that was aimed at in the other verification
framework mentioned above, because it's the specific case where the
Aspects have effects and likely break the original behaviour of the
program.

