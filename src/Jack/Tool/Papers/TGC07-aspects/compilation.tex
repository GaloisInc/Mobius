The main idea is to compile aspects to their effects, which would be modeled by methods that are defined
solely by their specifications. 
They are specifically
\subsubsection{Translation of the specifications}
The annotations are translated directly to the model methods. The method has the same signature
that of the aspect, and the specifications are copied entirely to the model method. It works smoothly
for most of the case except for the around advice which is split into 2 model methods: the one corresponding
to the before part, with added the proceed instruction as conjuncted in the ensures.
\subsubsection{Translation of pointcuts}
The pointcuts are not directly translated to the model methods, though the conditions over the pointcut undecidable
at compile time are added to the require clause.
\subsection{Weaving of the models}
First all the pointcut are abstracted as a syntactical pointcut. Then they are ordered using the compilation
order.
They are ordered in a list made of couples (instr, (model\_list)) where model\_list is the list of model methods 
that correspond to a specific syntactical match.

%
\begin{figure}
\bcode
weave \=(instr; Linstr, (instr, (model :: model\_list)) :: Lmatch) -> \\
\>model:: weave (instr; Linstr, (instr, (model\_list)) :: Lmatch);\\
weave \=(instr; Linstr, (instr, (instr :: model\_list)) :: Lmatch) -> \\
\>instr:: weave (instr; Linstr, (instr, (model\_list)) :: Lmatch);\\
weave (instr:: Linstr, (instr', (model :: model\_list)) :: Lmatch) -> \\
\>instr <> instr',  weave (instr; Linstr, Lmatch);\\
weave (instr:: Linstr, (instr, (nil)) :: Lmatch) -> \\
\>weave (Linstr, Lmatch);\\
weave (instr:: Linstr, nil) -> \\
\>instr :: weave (Linstr, Lmatch).
\ecode
\caption{The algorithm to weave method}
\label{weaving_algo}
\end{figure}
Then for each program point that matches