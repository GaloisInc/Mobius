The verification framework we are building in this paper 
is an adaptation of static 
verification based on weakest precondition calculus for aspects. 
Here we will consider 
the SecurityManager as an invasive aspect, 
so we must take into the weaving process. 

The verification is made of several steps:
\begin{enumerate}
\item the program and it's aspects are annotated using Pipa,
\item the behavioural specifications are desugared
\item the specifications of the aspects are compiled into model methods
\item the model methods are weaved to the program
\item a weakest precondition calculus is made on the transformed program, and verification
conditions are generated, and finally,
\item the verification conditions can be discharged automatically or interactively.
\end{enumerate}
This verification procedure is indeed made of 3 main parts: the annotation
part (step 1 and 2), the compilation and program transformation part (step 3 and 4)
and the verification part (steps 5 and 6).
The crucial part here being the second, since the third can be done with any verification tool
supporting static verification with Java and JML, and part 1 is only simple desugaring, and has been
extensively described in \cite{RaghavanL00}.


\subsection{Specifications}
\input{annotations}

\subsection{Compilation to invasive model methods}
\input{compilation}
\subsection{Weaving of the models}
\input{weaving}

\subsection{The weakest precondition calculus}

In our framework aspects are considered as methods calls that are
transferred the whole control flow, and are permitted to modify local
variables in the caller methods. Therefore when aspects are weaved
there wp is just like the one of a method call.  For instance if an
advice is weaved before an instruction i, the effective execution of
the program will be of

The aspect are compiled into a list containing the.  The predicate
transformers associated with an advice is similar to the weakest
precondition clause toward an invasive method call i.e. a method call
that would be able to modify local variables as well as the other
program variables.

One of the amusing fact about this approach is that the weakest
precondition calculus is parametized by a new semantic which is given
by the aspects.

General form of the final wp rule:
\bcode

\\
\ecode
where befores, arounds and afters are the compiled predicate
