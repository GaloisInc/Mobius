\section{Generating JML Annotations}\label{SecAnnotGen}

While JML is easily accessible to Java developers, actually writing
the specifications of a smart card application is labour-intensive and
error-prone, as it is easy to forget some annotations. There
exist tools which assist in writing these annotations,
\emph{e.g.}~Daikon~\cite{ErnstCGN01} and Houdini~\cite{FlanaganL01}
use heuristic methods to produce annotations for simple safety and
functional invariants.  However, these tools cannot be guided by the
user---they do not require any user input---and in particular cannot
be used to synthesise annotations from realistic security policies.

Within JACK, we have implemented several algorithms to generate
annotations. We can distinguish two sorts of applications for
annotation generation. The first goal is to generate as much
``obvious'' annotations as possible, to reduce the burden of
annotation writing. Given an existing, unannotated, application, one
first tries to generate preconditions automatically, before specifying
the more interesting parts of the specification. The second goal is to
encode high-level properties by encoding these with simple JML
annotations, that are inserted at all appropriate points in the
application, so that they can be checked statically.

JACK implements algorithms for both goals, and both will be described
in this section.


\subsection{Generation of Preconditions and Frame Conditions}
JACK implements two different algorithms to generate ``obvious''
annotations. The first algorithm is a simple static analysis on the
program text, which generates modifies clauses. Whenever it sees
assignments or method calls that change (specification) publicly
visible fields, these fields are added to the method's modifies
clause. The algorithm uses a safe over-approximation: whenever it
encounters references that might be aliased, it will simply generate a
clause \texttt{modifies \bsl everything;}.

JACK also implements an algorithm to generate the minial preconditions
to avoid nullpointer and array-out-of-bounds exceptions. This
algorithm re-uses the implementation of the weakest precondition
calculus: it computes the weakest precondition for the specification
\texttt{exsures (NullPointerException) false} (\texttt{exsures
(ArrayIndexOutOfBoundsException) false}) and inserts this as an
annotation in the code. 

As an example, Figure~\ref{FigAnnotSpec} shows the annotations that
are generated for a fragment of the class QuickSort that was presented in
Figure~\ref{FigJMLSpec}. 
\begin{figure}[t!]
{\small
\begin{verbatim}
public class QuickSort {
  private int [] tab;

  /*@ requires this.tab!=null;
      modifies \everything;
      exsures (Exception ) false;
    @*/
  public void sort() {if(tab.length > 0) sort(0, tab.length -1);}

   /*@ requires this.tab!=null&& 
                0<=j&& j<this.tab.length&&
                0<=i&& i<this.tab.length;
       modifies \everything;
       exsures (Exception ) false;
    @*/
  public void swap(int i, int j) {int tmp; tmp = tab[i]; 
                                  tab[i] = tab[j]; tab[j] = tmp;}

  ...
}
\end{verbatim}
}
\caption{Annotations Generated for a Fragment of Class
\texttt{QuickSort}}\label{FigAnnotSpec} 
\end{figure}
It is important to realise that, even though the specifications that
are generated are not very spectacular, the fact that they can be
generated \emph{automatically} can help significantly to reduce the
burden of annotation writing.

Notice that the annotation generation can be further improved by doing
some simple analysis on the generated annotations. Often it is the
case that the preconditions that are generated for the fields of the
class are the same for (almost) all the methods. In that case, this
condition is most likely a class invariant, and instead of generating
it as a precondition for each method, it would be more appropriate to
generate a single class invariant. In the class \texttt{QuickSort} in
Figure~\ref{FigAnnotSpec}, this would lead to a clause
\texttt{invariant this.tab!=null;}. It is future work to implement
this improvement.

\subsection{Encoding of Security Policies}

Another problem when writing annotations is that a conceptually simple
high-level property can give rise to many different annotations,
scattered through the code, that encode this property. This is
typically the case for many security policies. Current software
practice for the development of applications for trusted personal
devices is that security policies give rise to a set of rules that
should be obeyed by the implementation. Obedience to these rules is
established by manual code inspection.

However, many of these rules can be formalised as simple automata,
which are amenable to formal verification. Therefore, we propose a
method that given a rule to guarantee a security policy, automatically
annotates an application, in such a way that if the application
respects the annotations then it also respects the security
policy. The generation of annotations proceeds in two phases:
synthesising and weaving.
\begin{enumerate}
\item Based on the security policy we \emph{synthesise} core annotations, 
specifying the behaviour of the methods directly involved.
\item Next we propagate these annotations to all methods directly or
indirectly invoking the methods that form the core of the security
policy, thus \emph{weaving} the security policy throughout the
application.
\end{enumerate} 
The need for such the propagation phase stems from the fact that we
are interested in doing static verification. The annotations that we
generate all use JML static ghost variables; since we use only static
ghost variables, the properties are independent of the particular
class instances available. Notice that it is important to have tool
support for the propagation, because a typical security property may
involve methods from different classes, as will be illustrated by an
example below.

As a typical example of the kind of security rules our approach can
handle, we consider the atomicity mechanism in Java Card (Java for
smart cards) (\cite{PavlovaBBHL04cardis} gives more examples of such
security rules). A smart card does not include a power supply, thus a
brutal retrieval from the terminal could interrupt a computation and
bring the system in an incoherent state. To avoid this, the Java Card
specification prescribes the use of a transaction mechanism to control
synchronised updates of sensitive data. A statement block surrounded
by the methods \texttt{beginTransaction()} and
\texttt{commitTransaction()} can be considered atomic.
If something happens while executing the transaction (or if
\texttt{abortTransaction()} is executed), the card will
roll back its internal state to the state before the transaction was
begun. To ensure the proper functioning and prevent abuse of this
mechanism, several security properties can be specified.

\begin{quote}
\textbf{No nested transactions} Only one level of transactions
is allowed.\smallskip\\
\textbf{No exception in transaction} All exceptions that may be thrown
inside a transaction, should also be caught inside the
transaction.\smallskip\\
\textbf{Bounded retries}
No pin verification may happen within a transaction.
\end{quote} 
The second property ensures that the \texttt{commitTransaction} will
always be executed. If the exception is not caught, the
\texttt{commitTransaction} would be ignored and the transaction would
not be finished. The last property excludes pin verification within a
transaction. If this would be allowed, one could abort the transaction
every time a wrong pin code has been entered. As this rolls
back the internal state to the state before the transaction was
started, this would also reset the retry counter, thus allowing an
unbounded number of retries. Even though the specification of the Java
Card API prescribes that the retry counter for pin verification cannot
be rolled back, in general one has to check this kind of properties.

These properties can be easily encoded with automata, describing in
which states a certain method is allowed to be called. Based on this
automata, we then generate the core-annotations.

For example, the core-annotations related to the atomicity properties
specify the methods related to the transaction mechanism declared in
class
\texttt{JCSystem} of the Java Card API. A static ghost variable 
\begin{verbatim}
/*@ static ghost int TRANS == 0; @*/
\end{verbatim}
is declared, that is used to keep track of whether there is a
transaction in progress.  To specify the \textbf{No nested
transactions} property, the core-annotations for method
\texttt{beginTransaction} are the following. 

\begin{verbatim}
/*@ requires TRANS == 0;
  @ assignable TRANS;
  @ ensures TRANS == 1; @*/
public static native void beginTransaction() 
                          throws TransactionException;
\end{verbatim}
Similar annotations are synthesised for \texttt{commitTransaction} and
\texttt{abortTransaction}. After propagation, these annotations are 
sufficient to check for the
absence of nested transaction (\cite{PavlovaBBHL04cardis} also
describes the synthesised core-annotations for the other properties).

\marginpar{MH: we could add more example encodings, but I think it would get a
bit too long}

%To check for the absence of uncaught exceptions inside transactions,
%we use a special feature of JACK, namely pre- and postcondition
%annotations for statement blocks (as mentioned in
%Section~\ref{SecArchicture}). Block annotations are similar to method
%specifications. As core-annotation, we add the following annotation
%for \texttt{commitTransaction}.
%\begin{verbatim}
%/*@ exsures (Exception) TRANS == 0; @*/
%public static native void commitTransaction() 
%                          throws TransactionException;
%\end{verbatim}
%This specifies that exceptions only can occur if no transaction is in
%progress. Propagating these annotations to statement blocks ending
%with a commit guarantees that if exceptions are thrown, they have to
%be caught within the transaction.

%%that these only can raise exceptions, if they
%%do not start a transaction.

%%An exceptional postcondition is added claiming that an exeption can be
%%thrown only if no transaction is open.  The propagation of this
%%exceptional postcondition mechanism leads to annotate the block that
%%terminates with the commit of the transaction and all calling methods.

%Finally, in order to check that only a bounded number of retries of
%pin-verification is possible, we annotate the method \texttt{check}
%(declared in the interface \texttt{Pin} in the
%standard Java Card API) with a precondition, requiring that no
%transaction is in progress.
%\begin{verbatim}
%/*@ requires TRANS == 0; @*/
%public boolean check(byte[] pin, short offset, byte length);
%\end{verbatim}

The next step is to propagate the annotations. To understand why this
is necessary, suppose we are checking the \textbf{No nested
transactions} property for an application, containing the following
fragment (where \texttt{m} does not call any other methods, and does
not contain any set annotations). 

\begin{verbatim}
void m() { ... // some internal computations
           JCSystem.beginTransaction();
           ... // computations within transaction
           JCSystem.commitTransaction(); }
\end{verbatim}

When applying static verification on this code fragment, rhe
core-annotation that is synthesised for \texttt{beginTransaction} will
give rise to a proof obligation that the precondition of the method
\texttt{m} implies that there is no transaction in progress,
\emph{i.e.}\ \texttt{TRANS == 0} (since \texttt{TRANS} is not modified
by the code that precedes the call to 
\texttt{beginTransaction}). Thus, the only way this proof obligation
could be established is if the precondition of
\texttt{beginTransaction} is propagated as a precondition for method
\texttt{m}. However, the
precondition for \texttt{commitTransaction} (\texttt{TRANS == 1}) does
not have to be propagated to the specification of \texttt{m}; instead
it has to be established by the postcondition of
\texttt{begin\-Transaction}, because the variable \texttt{TRANS} is
modified by this method. 

In a similar way, the postcondition for the method
\texttt{commitTransaction} is propagated to the postcondition of
method \texttt{m}. This information can then be used for the
verification of yet another method, that contains a call to method
\texttt{m}. 

The propagation method not only propagates preconditions and normal
and exceptional postconditions, it also propagates modifies
clauses. We have shown that the algorithm that we use corresponds to
an abstract version of the weakest precondition calculus (where we do
not consider concrete variables). We have exploited this
correspondence in the implementation, by re-using the weakest
precondition calculus infrastructure to implement the propagation
algorithm. For a more formal treatment of the propagation algorithm, and
the correspondence statement, we refer to~\cite{PavlovaBBHL04cardis}. 

To illustrate the effectiveness of our approach, we tested our method on realistic examples of
industrial smart card applications, including the so-called Demoney
case study, developed as a research prototype by Trusted
Logic\footnote{{\tt http://www.trusted-logic.fr}}, and the PACAP case
study\footnote{{\tt
http://www.gemplus.com/smart/r\_d/publications/case-study}}, developed
by Gemplus. Both examples have been explicitly developed as test cases
for different formal techniques, illustrating the different issues
involved when writing smart card applications. We used the
core-annotations as presented above, and propagated these throughout
the applications.

For both applications we found that they contained no nested
transactions, and that they did not contain attempts to verify pin
codes within transactions. However, in the PACAP application we found
transactions containing uncaught exceptions. All proof obligations
generated \emph{w.r.t.}~these properties are trivial and can be
discharged immediately. However, to emphasise once more the usefulness
of having a tool for generating annotations, in the PACAP case study
we encountered cases where a single transaction gave rise to
twenty-three annotations in five different classes. When writing these
annotations manually, it is very easy to forget some of them.

% Consider for example the following code fragment.
%\begin{verbatim}
%void appExchangeCurrency(...) { 
%  ...
%  /*@ exsures (Exception) TRANS == 0; @*/ 
%  { ...
%  JCSystem.beginTransaction();      
%  try {balance.setValue(decimal2); ...}
%  catch (DecimalException e) {
%    ISOException.throwIt(PurseApplet.DECIMAL_OVERFLOW); }
%  JCSystem.commitTransaction();
%  } ... }
%\end{verbatim}
%The method \texttt{setValue} that is called can actually throw a
%decimal exception, which would lead to throwing an ISO exception, and
%the transaction would not be committed. This clearly violates the
%security policy as described in
%Section~\ref{SecHighLevelSecProp}. After propagating the
%core-annotations, and computing the appropriate proof obligations,
%this violation is found automatically, without any problems.



