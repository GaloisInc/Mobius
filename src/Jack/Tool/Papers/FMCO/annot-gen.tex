
\section{Generating JML Annotations}\label{SecAnnotGen}

While JML is easily accessible to Java developers, actually writing
the specifications of an application is labour-intensive and
error-prone, as it is easy to forget some annotations. There exist
tools which assist in writing these annotations,
\emph{e.g.}, Daikon~\cite{ErnstCGN01} and Houdini~\cite{FlanaganL01}
use heuristic methods to produce annotations for simple safety and
functional invariants.  However, these tools cannot be guided by the
user---they do not require any user input---and in particular cannot
be used to generate annotations from realistic security policies.

Within JACK, we have implemented several algorithms to generate
annotations. We can distinguish two goals for annotation
generation. The first is to reduce the burden of annotation writing by
generating as much ``obvious'' annotations as possible. Given an
existing, unannotated, application, one first generates these obvious
annotations automatically, before developing the more interesting
parts of the specification. The second goal is to encode high-level
properties by encoding these with simple JML annotations, that are
inserted at all appropriate points in the application, so that they
can be checked statically.  JACK implements algorithms for both goals,
as described in this section.


\subsection{Generation of Preconditions}

%The first algorithm is a simple static analysis on the
%program text, which generates frame conditions. Whenever it sees
%assignments or method calls that change (specification) public fields,
%these fields are added to the method's assignable clause. The
%algorithm uses a safe over-approximation: whenever it encounters
%references that might be aliased, it generates a clause
%\texttt{assignable \bsl everything;}.

%JACK implements two different algorithms to generate ``obvious''
%annotations. 
JACK implements an algorithm to generate ``obvious'' minimal
preconditions to avoid null-pointer and array-out-of-bounds
exceptions. This algorithm re-uses the implementation of the
wp-calculus: it computes the weakest precondition for the
specification
\texttt{signals (NullPointerException) false;} (resp. \texttt{signals
(ArrayIndexOutOfBoundsException) false;}) and inserts this as 
annotations in the code.

%\marginpar{MH: Example with more useful assignable clause?}

\begin{figure}[t!]
{\small
\begin{verbatim}
/*@ requires this.tab!=null;
    signals (Exception) false;
  @*/
public void sort() {if(tab.length > 0) sort(0, tab.length -1);}

/*@ requires this.tab!=null && 0<=j && j<this.tab.length &&
             0<=i && i<this.tab.length;
    signals (Exception) false;
 @*/
public void swap(int i, int j) {int tmp; tmp = tab[i]; 
                                tab[i] = tab[j]; tab[j] = tmp;}
\end{verbatim}
}
\caption{Obvious annotations generated for a fragment of class
\texttt{QuickSort}}\label{FigAnnotSpec} 
\end{figure}

As an example, Figure~\ref{FigAnnotSpec} shows the annotations that
are generated for some methods of the class \texttt{QuickSort} of
Figure~\ref{FigJMLSpec}.  It is important to realise that the
specifications that are generated might not be very spectacular, but
that they are generated \emph{automatically}. % can help significantly to
% reduce the
%burden of annotation writing.

The annotation generation can be further improved by applying a simple
analysis on the generated annotations. Often it is the case that the
preconditions that are generated for the fields of the class are the
same for (almost) all methods. In that case, this condition is likely
to be a class invariant, and instead of generating a precondition for
each method, it would be more appropriate to generate a single class
invariant. For example, for the class
\texttt{QuickSort}, this would produce an annotation
\texttt{invariant this.tab!=null;}. %It is future work to implement
%this.

\subsection{Encoding of Security Policies}

Another difficulty when writing annotations is that a conceptually
simple high-level property can give rise to many different
annotations, scattered through the code, to encode this property. This
is typically the case for many security policies. Current software
practice for the development of applications for trusted personal
devices is that security policies give rise to a set of \emph{security
rules} that should be obeyed by the implementation. Obedience to these
rules is established by manual code inspection; however it is
desirable to have tool support for this, because a typical security
property may involve several methods from different classes.  Many of
the security rules can be formalised as simple automata, which are
amenable to formal verification. Therefore, we propose a method that
given a security rule, automatically annotates an application, in such
a way that if the application respects the annotations then it also
respects the security policy. Thus, it is not necessary for the user
to understand the generated annotations, he just has to understand 
the security rules.

The generation of annotations proceeds in two phases: first we
generate core-annotations that specify the behaviour of the methods
directly involved, and next we propagate these annotations to all
methods directly or indirectly invoking the methods that form the core
of the security policy. The second phase is necessary because we are
interested in static verification. The annotations that we generate
all use only JML static ghost variables; therefore the properties are
independent of the particular class instances available. 

As a typical example of the kind of security rules our approach can
handle, we consider the atomicity mechanism in Java Card (Java for
smart cards) (\cite{PavlovaBBHL04} gives more examples of such
security rules). A smart card does not include a power supply, thus a
brutal retrieval from the terminal could interrupt a computation and
bring the system in an incoherent state. To avoid this, the Java Card
specification prescribes the use of a transaction mechanism to control
synchronised updates of sensitive data. A statement block surrounded
by the methods \texttt{beginTransaction()} and
\texttt{commitTransaction()} can be considered atomic.
If something happens while executing the transaction (or if
\texttt{abortTransaction()} is executed), the card will
roll back its internal state to the state before the transaction was
begun. To ensure the proper functioning and prevent abuse of this
mechanism, applications should respect for example the following
security rules. 

\begin{quote}
\textbf{No nested transactions} Only one level of transactions
is allowed.\smallskip\\
\textbf{No exception in transaction} All exceptions that may be thrown
inside a transaction, should also be caught inside the
transaction.\smallskip\\
\textbf{Bounded retries}
No pin verification may happen within a transaction.
\end{quote} 
The second rule ensures that a transaction will always be closed;
if the exception would not be caught, \texttt{commitTransaction}
would not be executed. The last rule avoids the possibility to abort
the transaction every time a wrong pin code has been entered. As this
would roll back the internal state to the state before the transaction
was started, this would also reset the retry counter, thus allowing an
unbounded number of retries. Even though the specification of the Java
Card API prescribes that the retry counter for pin verification cannot
be rolled back, in general one has to check this kind of properties.

Such properties can be easily encoded with automata, describing in
which states a certain method is allowed to be called. Based on this
automata, we then generate core-annotations. For example, the
atomicity properties above give rise to core-annotations for the
methods related to the transaction mechanism declared in class
\texttt{JCSystem} of the Java Card API. A static ghost variable 
\begin{verbatim}
/*@ static ghost int TRANS == 0; @*/
\end{verbatim}
is declared, that is used to keep track of whether there is a
transaction in progress.  To specify the \textbf{No nested
transactions} property, the core-annotations for method
\texttt{beginTransaction} are the following. 

\begin{verbatim}
/*@ requires TRANS == 0;
  @ assignable TRANS;
  @ ensures TRANS == 1; @*/
public static native void beginTransaction() 
                          throws TransactionException;
\end{verbatim}
Similar annotations are generated for \texttt{commitTransaction} and
\texttt{abort\-Trans\-action} (\cite{PavlovaBBHL04} also
describes the generated core-annotations for the other
properties). After propagation, these annotations are sufficient to
check for the absence of nested transaction.  To understand why
propagation is necessary, suppose we are checking the \textbf{No
nested transactions} property for an application, containing the
following fragment (where
\texttt{m} does not call any other methods, and does not contain any
set annotations).

\begin{verbatim}
void m() { ... // some internal computations
           JCSystem.beginTransaction();
           ... // computations within transaction
           JCSystem.commitTransaction(); }
\end{verbatim}

When applying static verification on this code fragment, the
core-annotations for \texttt{beginTransaction} will give rise to a
proof obligation that the precondition of method
\texttt{m} implies that there is no transaction in progress,
\emph{i.e.}, \texttt{TRANS == 0} (since \texttt{TRANS} is not modified
by the code that precedes the call to \texttt{beginTransaction}). The
only way this proof obligation can be established is if the
precondition of \texttt{beginTransaction} is propagated as a
precondition for method \texttt{m}. In contrast, the precondition for
\texttt{commitTransaction} (\texttt{TRANS == 1}) does not have to be
propagated to the specification of \texttt{m}; instead it has to be
established by the postcondition of \texttt{begin\-Transaction},
because the variable \texttt{TRANS} is modified by this method.

In a similar way, the postcondition for the method
\texttt{commitTransaction} is propagated to the postcondition of
method \texttt{m}. This information can then be used for the
verification of yet another method, that contains a call to method
\texttt{m}. 

The propagation method not only propagates preconditions and normal
and exceptional postconditions, it also propagates assignable
clauses. We have shown that the algorithm that we use corresponds to
an abstract version of the wp-calculus (where we only consider
static variables). We have exploited this correspondence in the
implementation, by re-using the wp-calculus infrastructure to
implement the propagation algorithm. For a more formal treatment of
the propagation algorithm, and the correspondence statement, we refer
to~\cite{PavlovaBBHL04}.

To illustrate the effectiveness of our approach, we tested our method
on several industrial smart card applications, including the so-called
Demoney case study, developed as a research prototype by Trusted
Logic\footnote{See {\tt http://www.trusted-logic.fr}.}, and the PACAP
case study\footnote{See {\tt
http://www.gemplus.com/smart/r\_d/publications/case-study}.},
developed by Gemplus. Both examples have been explicitly developed as
test cases for different formal techniques, illustrating the different
issues involved when writing smart card applications. We used the
core-annotations as presented above, and propagated these throughout
the applications.  For both applications we found that they contained
no nested transactions, and that they did not contain attempts to
verify pin codes within transactions. However, in the PACAP
application we found transactions containing uncaught exceptions. All
proof obligations generated \emph{w.r.t.}~these properties are trivial
and can be discharged immediately. However, to emphasise the
usefulness of having a tool for generating annotations: we encountered
cases where a single transaction gave rise to twenty-three annotations
in five different classes. When writing these annotations manually, it
is all too easy to forget some.




