
\section{Conclusions}\label{SecConcl}

This paper describes the main characteristics of JACK, the Java Applet
Correctness Kit, a tool set for the validation of security and
functional behaviour properties for Java applications. We have focused
in particular on the features that distinguish JACK from other similar
tools:
\begin{itemize}
\item the integration into a standard IDE;
\item a user interface that helps to understand the proof obligations;
\item the implementation of an algorithm to generate
``obvious'' annotations;
\item the implementation of an algorithm to encode high-level security
properties with JML annotations; 
\item support for the verification of both source code \emph{and}
bytecode; and
\item support for interactive verification, both practical
(development of user interface and tactics) and theoretical (\native
construct to link annotations with the logic of the
underlying theorem prover).
\end{itemize}

The JACK tool has been used for several small to medium-scale case
studies. First of all, we have shown how BML annotations can be used
to guarantee resource policies related to memory consumption of
bytecode applications~\cite{BarthePS05}. In addition, we have also
shown how the verification of exception-freeness at bytecode level can
be used to reduce the footprint of Java-to-native compilation
schemes. Executable code typically contains run-time checks to decide
whether an exception should be thrown. But if it can be proven
statically that the exception \emph{never} will be thrown, there is no
need for the executable code to contain the run-time
checks~\cite{DBLP:conf/cardis/CourbotPGV06}.


Development and maintenance of a verification tool for a realistic
programming language is a major effort. During the last decade several
such tools have been developed (see the related work section
below). This has resulted in a drastic improvement of the technologies
available to verify applications. However, we believe that now the
moment has come to combine the different technologies, and to bundle
this into one powerful verification tool. Development of such a tool
is one of the goals of the IST \textsf{Mobius} project. It is foreseen
that all technology developed around JACK that distinguish it from
other verification tools will be integrated in this single
verification tool.

%Work around this single \textsf{Mobius} tool should also address
%limitations of the JML technology, and increase support for
%automation, both at the level of specification and verification. In
%addition, future work should also provide support for refinement in
%JML, as well as for using automated testing techniques for proof
%obligations that have not been discharged automatically. This would
%make the use of formal techniques in Java validation cost effective,
%and provide rigorous and automated support to facilitate the security
%evaluations of applications for trusted personal devices.

\paragraph{Related work}
Several other tools exist aiming at the static verification of
JML-annotated Java code, but JACK distinguishes itself from these
tools by the features described in this paper. We briefly describe the
most relevant other tools. ESC/Java~\cite{CokK04} is probably the most
used tool. It also aims at a high level of automation, but makes an
explicit trade-off between soundness, completeness and automation.
The Jive tool~\cite{MeyerP00} uses a Hoare-logic for program
verification, requiring much more user interaction. The Key
tool~\cite{BeckertHS07} uses a dynamic logic approach, where program
verification resembles program simulation. The LOOP
tool~\cite{BergJ01} translates both the program and the annotations
into specifications in the logic of the PVS theorem prover. Both a
Hoare logic and a weakest precondition calculus have been proven sound
in PVS, and can be used to verify whether the program respects its
specification.

Krakatoa~\cite{MarcheP-MU04} translates JML-annotated
programs into an intermediate format, for which the Why tool generates
proof obligations. Krakatoa allows the user to specify algebraic
specifications as part of the annotations, and use these in the
verification. This resembles the \native construct, however, the
\native construct directly allows one to use the full expressiveness
of the logic of the underlying prover, and to directly reuse any
(library) results already proven about the data types. Moreover, the
use of the native construct allows one to keep on using a Java-like
syntax in the annotations.

The Spec\#/Boogie project~\cite{BarnettLW04} aims at the specification
and verification of annotated C\# programs. As JACK, the tool also
provides support for verification at source code and bytecode
level. However, they do not compile source code specifications into
bytecode specifications, that can be shipped with the
application. Further, the project mainly aims at automatic
verification, and does not provide support for annotation generation.

There are several projects that aim at annotating bytecode: JVer is a
tool to verify annotated bytecode~\cite{ChanderEILN05b}, but they do
not have a special bytecode specification language.  The Extended
Virtual Platform project aims at developing a framework that allows to
compile JML annotations, to allow run-time
checking~\cite{AlagicR05}, but they do not allow to write
specifications directly at bytecode level.

Most approaches to ensuring high-level security properties are based
on run-time monitoring, see
\emph{e.g.}, \cite{bartetzko01assertions,Schneider99,Erlingsson03,ColcombetF00}. However,
run-time monitoring is not an option for trusted personal devices: for
the user it would be unacceptable to be blocked in the middle of an
application, because of a security violation.


%\subsection*{Acknowledgements}
