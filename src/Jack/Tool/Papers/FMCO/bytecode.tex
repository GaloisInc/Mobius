
\section{Specification and Verification of Bytecode}\label{SecBytecode}

JACK allows one to verify applications not only at source code level,
but also at bytecode level. This is in particular important to support
proof carrying code~\cite{Necula97}, where bytecode applications are
shipped together with their specification and a correctness
proof. However, the possibility to verify bytecode also has an
interest on its own: sometimes security-critical applications are
developed directly at bytecode level, in order not to rely on the
correctness of the compiler. To be able to formally establish the
correctness of such an application, one needs support to verify
bytecode directly.

This section describes the different parts in the bytecode
subcomponent of JACK. First of all, we present a specification
language tailored to bytecode, and we specify how these specifications
can be encoded in the class file format. Our specification language,
called BML for Bytecode Modeling Language~\cite{BurdyHP07}, is the
bytecode cousin of JML. We define and implement a compiler from JML to
BML specifications. Such a compiler is in particular useful in a proof
carrying code scenario, where the application developer can verify the
application at (the more intuitive) source code level, and then
compile both the application and the specification to bytecode
level. Finally, we also define a verification condition generator for
bytecode applications annotated with BML, implementing a wp-calculus
for bytecode. This allows to generate the proof obligations for a
bytecode application to satisfy its BML specification.

\subsection{A Specification Language for Bytecode: BML}

BML has basically the same syntax as JML with two exceptions:
\begin{enumerate}
\item specifications are not written directly in the program code,
they are added as special attributes to the bytecode; and
\item the grammar for expressions only allows bytecode expressions.
\end{enumerate}

\begin{figure}[t]

\begin{tabular}{lll}
\multicolumn{2}{l}{\varHook{predicate} ::= \(\ldots\)}\smallskip\\
\multicolumn{2}{l}{\varHook{unary-expr-not-plus-minus} ::= \(\ldots\)}\\
\hspace*{1cm} & \(\mid\) \varHook{primary-expr} [\varHook{primary-suffix}]\(\ldots\)\\ 

\multicolumn{3}{l}{\varHook{primary-suffix} ::= \codeHook{.} \varHook{ident}
\(\mid\) \codeHook{(} [\varHook{expression-list}] \codeHook{)}
 \(\mid\) \codeHook{[} \varHook{expression} \codeHook{]}}\\

\multicolumn{2}{l}{\varHook{primary-expr} ::= 
\codeHook{\#}\varHook{natural}} & \% reference in the constant pool \\
&\(\mid\) \codeHook{lv[}\varHook{natural}\codeHook{]} &\% local variable \\
&\(\mid\) \varHook{bml-primary}\\
&
\multicolumn{2}{l}{\(\mid\) \varHook{constant} \(\mid\)
\codeHook{super}
\(\mid\) \codeHook{true} \(\mid\) \codeHook{false} \(\mid\)
\codeHook{this} \(\mid\) \codeHook{null} 
\(\mid\) \codeHook{(}\varHook{expression}\codeHook{)}
\(\mid\) \varHook{jml-primary}}\\

\multicolumn{2}{l}{\varHook{bml-primary} ::= \codeHook{cntr}} &\% counter of the operand stack\\
&\(\mid\) \codeHook{st(}\varHook{additive-expr}\codeHook{)} &\% stack
expressions\\
&\(\mid\) \codeHook{length(}\varHook{expression}\codeHook{)} &\% array
length 
\end{tabular}

\caption{Fragment of grammar for BML predicates and specification expressions}\vspace*{-1em}
\label{FigBMLGrammar}
\end{figure}

Figure~\ref{FigBMLGrammar} displays the most interesting part of the
grammar for BML predicates, defining the syntax for primary
expressions and primary suffixes\footnote{See
\texttt{http://www-sop.inria.fr/everest/BML} for the full grammar.}.
Primary expressions, followed by zero or more primary suffixes, are
the most basic form of expressions, formed by identifiers, bracketed
expressions \emph{etc}.

Since only bytecode expressions can be used, all field names, class
names \emph{etc.}\ are replaced by references to the constant pool (a
number, preceded by the symbol \codeHook{\#}), while registers are
used to refer to local variables and parameters. The grammar also
contains several bytecode specific keywords, such as \codeHook{cntr},
denoting the stack counter, \codeHook{st(\(e\))} where \(e\) is an
arithmetic expression, denoting the \(e^{th}\) element on the stack, and
\codeHook{length(\(a\))}, denoting the length of array \(a\). In
addition, the specification-specific JML keywords are also available.




\begin{figure}[t]
{\small
\begin{verbatim}
requires this.#14 != null && 0 <= lv(1) && lv(1) < length(this.#14) &&
         0 <= lv(2) && lv(2) < length(this.#14) && true
assignable #14.this[lv(2)],#14.this[lv(1)]
ensures this.#14[lv(1)] == \old(this).\old(#14)[\old(lv(2))] && 
        this.#14[lv(2)] == \old(this).\old(#14)[\old(lv(1))]
 0 aload_0
 1 getfield #14 
 4 iload_1
 5 iaload
 6 istore_3
 7 aload_0
 8 getfield #14 
11 iload_1
12 aload_0
13 getfield #14 
16 iload_2
17 iaload
18 iastore
19 aload_0
20 getfield #14 
23 iload_2
24 iload_3
25 iastore
26 return
\end{verbatim}
}
\vspace*{-1em}\caption{Bytecode + BML specification for method \codeHook{swap} in class \codeHook{QuickSort}}\label{FigBMLSpec}
\end{figure}

To show a typical BML specification, Figure~\ref{FigBMLSpec} presents
the BML version of the JML specification of method
\codeHook{swap} in Figure~\ref{FigJMLSpec}. 
Notice that the field \codeHook{tab} has been assigned the number 14
in the constant pool, and that it is always explicitly qualified with
\codeHook{lv[0]} (denoting \codeHook{this}). The method's parameters
\texttt{i} and \texttt{j} are now denoted by the expressions
\texttt{lv[1]} and \texttt{lv[2]}, respectively. Notice further that
the BML specification directly corresponds to the original JML
specification.


 
\subsection{Encoding of BML Specifications in the Class File Format}

To store BML specifications together with the bytecode it specifies,
we encode them in the class file format. The Java Virtual Machine
Specification~\cite{JVMspec} prescribes the mandatory elements of the
class file: the constant pool, the field information and the method
information. User-specific information can be added to the class file
as special user-specific attributes (\cite[\S4.7.1]{JVMspec}).  We
store BML specifications in such user-specific attributes, in a
compiler-independent format. The use of special attributes ensures
that the presence of BML annotations does not have an impact on the
application's performance, \emph{i.e.}, it will not slow down loading
or normal execution of the application.

For each class, we add the following information to the class file:
\begin{itemize}
\item a second constant pool which contains constant references
      for the BML specification expressions;
\item an attribute with the ghost fields used in the specification;
\item an attribute with the model fields used in the specification;
\item an attribute with the class invariants (both static and object); and
\item an attribute with the constraints (both static and object).
\end{itemize}
Apart from the second constant pool, all extra class attributes
basically consist the name of the attribute, the number of elements it
contains, and a list with the actual elements.  As an example,
Figure~\ref{FigAttributes} presents the format of the ghost field
attribute. This should be understood as follows: the name of the
attribute is given as an index into the (second) constant pool. This
constant pool entry will be representing a string
\texttt{"Ghost\_Field"}. Next we have the length of the attribute,
which should be 2 + 6*\textbf{fields\_count} (the number of fields
stored in the list). The \textbf{fields} table stores all ghost
fields. For each field we store its access flag (\emph{e.g.}\
\texttt{public} or
\texttt{private}), and its name and descriptor index, both
referring to the constant pool. The first must be a string,
representing the (unqualified) name of the variable, the latter is a
field descriptor, containing \emph{e.g.}\ type information.  The tags
\textbf{u2} and \textbf{u4} specifies the size of the attribute, 2 and
4 bytes, respectively. The other attributes are specified in a similar
way.



\begin{figure}[t]
\textbf{
\begin{tabular}[t]{l}
Ghost\_Field\_attribute \{\\
\hspace*{1em}
\begin{tabular}{l}
u2  attribute\_name\_index; \\
u4  attribute\_length;\\
u2  fields\_count;\\
\{\begin{tabular}[t]{l} 
    u2 access\_flags; \\  
    u name\_index;\\
    u2 descriptor\_index;\\
  \end{tabular}\\
\} fields[fields\_count]; \} \\
\end{tabular}
\end{tabular}
}
\caption{Attributes for ghost field declarations}
\label{FigAttributes}
\end{figure}



\subsection{Compiling JML Specifications into BML Specifications}

We have implemented a compiler from JML specifications into BML
specifications~--~stored in the class file. The JML specification is
compiled separately from the Java source code. In fact, the compiler
takes as input an annotated Java source file
\emph{and} the class file produced by a non-optimising compiler
with the debug flag set. 

From the debug information, we use in particular the
\textbf{Line\_ Number\_Table} and the \textbf{Local\_Variable\_Table}
attributes. The \textbf{Line\_Number\_Table} links line numbers in the
source code with the bytecode instructions, while the
\textbf{Local\_Variable\_Table} describes the local variables that
appear in a method.  

JML specifications are compiled into BML specifications in several
steps:

\begin{enumerate}

\item compilation of ghost and model field declarations;


\item linking and resolving of source data structures to bytecode structures;

\item locating instructions for annotation statements; this
information is added as a special \textbf{index} entry in the
attribute (a heuristic algorithm is used to find the entry point of a
loop, for more details see~\cite{Pavlova:phd});

 
\item compilation of JML predicates, taking into account that not all
source code level primitive types are directly supported at bytecode
level; and

\item generation of user-specific class attributes.
    
\end{enumerate}


\subsection{Verification of Bytecode}
To generate proof obligations, we have implemented a wp-calculus for
bytecode in JACK. Just as the source code level wp-calculus, it
works directly on the bytecode; the program is not transformed into a
guarded command format. Again, this has the
advantage that we can easily trace proof obligations back to the
relevant bytecode and BML fragment.

The JACK implementation supports all Java bytecode sequential
instructions, except for floating point arithmetic instructions and 64
bit data (\java{long} and \java{double}). Thus in particular, it
handles exceptions, object creation, references and subroutines. The
calculus is defined over the method's control flow graph.


The verification condition generator proceeds as follows. For each
method proof obligations are generated for each execution path by
applying the weakest predicate transformer to every instruction where
the method might end (\emph{i.e.}\ \texttt{return} or \texttt{athrow}
instructions), and at each loop exit point. The wp-calculus then
follows control flow backwards, until it reaches the entry point
instruction.

The weakest precondition transformer takes three arguments: the
instruction for which we calculate the precondition, the instruction's
normal postcondition $\psi$ and the instruction's exceptional
postcondition $\phi^{\mathit{Exc}}$. For the full wp-calculus for
BML-annotated bytecode, and its soundness proof we refer
to~\cite{Pavlova:phd}. Here we show as an example the wp-rule for the
instruction \texttt{load\(_i\)}.
\[
\mathsf{wp}(\texttt{load}_i, \psi, \psi^{\mathit{Exc}})  = 
\psi[\texttt{cntr} \leftarrow \texttt{cntr} + 1][\texttt{st(cntr +1)}
\leftarrow \texttt{lv[i]}]
\]
Since the \texttt{load}\(_i\) instruction will always terminate
normally, only the normal postcondition is involved, after updating it
to reflect the changes that are made to the stack, \emph{i.e.}\ the
value that was stored in the local variable register \texttt{lv[i]} is
now at the top of the stack (at position \texttt{st(cntr + 1)}),  and 
the stack counter is increased.



Finally we would like to remark that there is a close correspondence
between the proof obligations generated by JACK at source code level,
and the proof obligations that are generated once the application and
the specification are compiled at bytecode level (provided that the
application is compiled with a non-optimising compiler): modulo names
and the handling of shorts, bytes and boolean values, the proof
obligations are equivalent. This means that proofs for proof
obligations at source code level can be re-used for proof obligations
at bytecode level (see also~\cite{gta05:fast} for a compilation source
code level proofs to bytecode level proofs). This is in particular
important for the proof carrying code scenario~\cite{Necula97}, where
the code producer develops a proof at source code level, and then
ships bytecode level application and specification, because modulo the
necessary re-namings, he can ship directly his proofs, and the code
client can verify these using a verification condition generator at
bytecode level.


