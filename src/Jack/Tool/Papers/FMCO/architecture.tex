\section{General Architecture of JACK}\label{SecArchitecture}

The development of the JACK tool started in 2002 at the formal methods
research laboratory of the French smart card producer Gemplus (now
part of gemalto). Successful case studies with ESC/Java and the LOOP
tool on an electronic purse smart card
application~\cite{BreunesseCHJ03} had sufficiently demonstrated that
verification of JML annotations could help to increase the quality of
smart card applications. However, the existing tools where either not
precise enough, or they were to0 cumbersome to use, to expose
application developers to them. The JACK tool was designed to overcome
these problems. The next section will discuss how the tool has been
made accessible to application developers by integration within the
IDE Eclipse, and the development of a special ``JACK view'', this
section describes the general architecture of the tool, and how it
aims at a high-level of precision.

In 2003, the tool has been transfered to the Everest project at INRIA
Sophia Antipolis, and been further developed within this team since
then. The other features of JACK described in this paper have been
developed after this transfer.

In the development of the JACK architecture, the main design
principles were the following:
\begin{itemize}
\item integration within a widely-used IDE, so that developers do not
have to learn a new environment, and do not have to switch between tools;
\item automatic generation of proof obligations by
implementation of weakest precondition calculus;
\item proof obligations are first-order logic formulae; and
\item prover independence, \emph{i.e.}\ proof obligations for
a single application can be verified with different provers.
\end{itemize}

The weakest precondition (wp) calculus that is implemented is a
so-called ``direct'' calculus, meaning that it works directly on a AST
representation of the application, and it does not use a
transformation into guarded commands, as is done by \emph{e.g.}\
ESC/Java.  The wp-calculus is based on the classical wp-calculus
proposed by Dijkstra~\cite{Dijkstra75}, but adapted to Java by
extending it with side-effects, exceptions and other abrupt
termination constructs (\emph{cf.}\
\emph{e.g.}~\cite{Jacobs04}). This direct wp-calculus has the advantage
that it is easy to generate proof obligations for each path through a
method, and then to connect the proof obligation with the path through
the method that gave rise to this particular proof obligation (to
achieve this, also some program flow information is associated to each
proof obligation). This connection makes the understanding of the
generated proof obligations easier. Another advantage of this approach
is that the algorithms for annotation generation as described below in
Section~\ref{SecAnnotGen} directly could make use of the weakest
precondition infrastructure.
\marginpar{MH: Please check what I say here! Should we say something about
drawbacks?}

To ensure that lemma generation can be done completely automatically
and to avoid exponential explosion of the number of proof obligations,
JACK adds several new keywords for loop specifications:
\texttt{loop\_modifies} and
\texttt{loop\_exsures}, and it allows to specify code blocks (where a
block specification resembles a method specification). The
\texttt{loop\_modifies} keyword declares the variables that may be
modified in the body of the loop. The wp-calculus universally 
quantifies the loop invariant with those variables when it generates
the appropriate proof obligations. The block specifications, and the
\texttt{loop\_exsures} clauses improve the understandability and they
reduce the number of proof obligations, because they reduce the number
of path through a method that have to be considered.


The proof obligations that are generated by JACK are represented in an
abstract formula language (called JPOL, for JACK Proof Obligation
Language), representing first-order logic formulae. It is
straightforward to translate the abstract formulae into a proof
obligation for a particular prover. Adding a new prover as a plugin to
the tool is simple: one develops a background theory formalising
Java's type system and memory model, and one defines how abstract JPOL
formulae are translated into concrete proof obligations for this
particular prover. Initially, JACK was designed to use the AtelierB
prover~\cite{bbook}, currently Simplify and Coq are the
best supported back-end provers for JACK.




