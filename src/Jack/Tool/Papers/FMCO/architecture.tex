
\section{General Architecture of JACK}\label{SecArchitecture}

This section describes the general architecture of JACK, and how it
aims at a high-level of precision.  The next section will then discuss
how JACK has been made accessible to application developers by
integration within the IDE Eclipse, and the development of the special
JACK perspective, For the development of the JACK architecture, the
main design principles were the following:
\begin{itemize}
\item integration within a widely-used IDE, so that developers do not
have to learn a new environment, and do not have to switch between tools;
\item automatic generation of proof obligations by
implementation of weakest precondition (wp) calculus;
\item proof obligations are first-order logic formulae; and
\item prover independence, \emph{i.e.}\ proof obligations for
a single application can be verified with different provers.
\end{itemize}

The wp-calculus that is implemented is a
so-called ``direct'' calculus, meaning that it works directly on a AST
representation of the application, and it does not use a
transformation into guarded commands, as is done by \emph{e.g.}\
ESC/Java.  The wp-calculus is based on the classical wp-calculus
proposed by Dijkstra~\cite{Dijkstra75}, but adapted to Java by
extending it with side-effects, exceptions and other abrupt
termination constructs (\emph{cf.}\
\emph{e.g.}~\cite{Jacobs04}). This direct wp-calculus has the advantage
that it is easy to generate proof obligations for each path through a
method, and then to connect the proof obligation with the path through
the method that gave rise to this particular proof obligation (to
achieve this, also some program flow information is associated to each
proof obligation). This connection makes the understanding of the
generated proof obligations easier. Another advantage of this approach
is that the algorithms for annotation generation as described below in
Section~\ref{SecAnnotGen} could make direct use of the weakest
precondition infrastructure. A drawback of this approach is that the
size of the generated proof obligation may be exponential in the size
of the code fragment being checked~\cite{FlanaganS01}.


%\marginpar{MH: Please check what I say here! Should we say something about
%drawbacks?}

To avoid this blow up in the size of the proof obligation, and to
ensure that proof obligations can be generated automatically, JACK
adds uses several new specification constructs, introduced
in~\cite{BurdyRL03}: loops can be annotated with frame conditions
(\texttt{loop\_modifies}) and exceptional postconditions
(\texttt{loop\_exsures}), and any code block can be specified with a
block specification (similar to a method specification). The loop
frame condition is used in the the wp-calculus to make a universal
quantification over the loop invariant when generating the appropriate
proof obligations. Block specifications and
\texttt{loop\_exsures} clauses improve readability and reduce the
number of proof obligations, because they reduce the number of paths
through a method that have to be considered.


JACK generates its proof obligations in an abstract formula language,
representing first-order logic formulae. It is straightforward to
translate the abstract formulae into a proof obligation for a
particular prover. Adding a new prover as a plugin to the tool is
simple: one develops a background theory formalising Java's type
system and memory model, and one defines how the abstract formulae are
translated into concrete proof obligations for this particular
prover. Initially, JACK was designed to use the AtelierB
prover~\cite{Abrial96}, now Simplify and Coq are the best
supported back-end provers for JACK.




