\section{General Architecture of JACK}\label{SecArchitecture}

The development of the JACK tool started in 2002 at the formal methods
research laboratory of the French smart card producer Gemplus (now
part of gemalto). Successful case studies with ESC/Java and the LOOP
tool on an electronic purse smart card
application~\cite{BreunesseCHJ03} had sufficiently demonstrated that
verification of JML annotations could help to increase the quality of
smart card applications. However, the existing tools where either not
precise enough, or they were too cumbersome to use, to expose
application developers to them. The JACK tool was designed to overcome
these problems. The next section will discuss how the tool has been
made accessible to application developers by integration within the
IDE Eclipse, and the development of a special JACK view, this
section describes the general architecture of the tool, and how it
aims at a high-level of precision.

In 2003, the tool has been transfered to the Everest project at INRIA
Sophia Antipolis, and been further developed within this team since
then. The other features of JACK described in this paper have been
developed after this transfer.

For the development of the JACK architecture, the main design
principles were the following:
\begin{itemize}
\item integration within a widely-used IDE, so that developers do not
have to learn a new environment, and do not have to switch between tools;
\item automatic generation of proof obligations by
implementation of weakest precondition (wp) calculus;
\item proof obligations are first-order logic formulae; and
\item prover independence, \emph{i.e.}\ proof obligations for
a single application can be verified with different provers.
\end{itemize}

The wp-calculus that is implemented is a
so-called ``direct'' calculus, meaning that it works directly on a AST
representation of the application, and it does not use a
transformation into guarded commands, as is done by \emph{e.g.}\
ESC/Java.  The wp-calculus is based on the classical wp-calculus
proposed by Dijkstra~\cite{Dijkstra75}, but adapted to Java by
extending it with side-effects, exceptions and other abrupt
termination constructs (\emph{cf.}\
\emph{e.g.}~\cite{Jacobs04}). This direct wp-calculus has the advantage
that it is easy to generate proof obligations for each path through a
method, and then to connect the proof obligation with the path through
the method that gave rise to this particular proof obligation (to
achieve this, also some program flow information is associated to each
proof obligation). This connection makes the understanding of the
generated proof obligations easier. Another advantage of this approach
is that the algorithms for annotation generation as described below in
Section~\ref{SecAnnotGen} directly could make use of the weakest
precondition infrastructure.
%\marginpar{MH: Please check what I say here! Should we say something about
%drawbacks?}


To ensure that proof obligations can be generated automatically and to
avoid exponential explosion of the number of proof obligations, JACK
adds uses several new specification constructs, introduced
in~\cite{BurdyRL03}: loops can be annotated with frame conditions
(\texttt{loop\_modifies}) and exceptional postconditions
(\texttt{loop\_exsures}), and any code block can be specified with a
block specification (similar to a method specification). The loop
frame condition is used in the the wp-calculus to make a universal
quantification over the loop invariant when generating the appropriate
proof obligations. Block specifications and
\texttt{loop\_exsures} clauses improve readability and reduce the
number of proof obligations, because they reduce the number of paths
through a method that have to be considered.


JACK generates its proof obligations in an abstract formula language,
representing first-order logic formulae. It is straightforward to
translate the abstract formulae into a proof obligation for a
particular prover. Adding a new prover as a plugin to the tool is
simple: one develops a background theory formalising Java's type
system and memory model, and one defines how the abstract formulae are
translated into concrete proof obligations for this particular
prover. Initially, JACK was designed to use the AtelierB
prover~\cite{Abrial96}, currently Simplify and Coq are the best
supported back-end provers for JACK.




