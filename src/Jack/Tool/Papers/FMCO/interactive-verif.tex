


\section{Support for Interactive Verification}\label{SecInteractive}
When automatic provers fail to solve a proof obligation,
the user can try to solve it interactively, using the interactive verification
support of JACK.
More specifically, the proof obligation inspection 
perspective of JACK, we saw in section
\ref{SecUI}, allows to edit every proof that 
failed automatic verification separately.
The interactive verification process is done mainly
with the theorem prover Coq. 

First we will discuss the architecture of JACK's Coq plugin, then its 
integration within JACK and the IDE Eclipse, and finally we will talk of
 JACK's specific annotation keyword for interactive verification, the 
{\tt native} keyword. 

\subsection{The Coq Plugin}
The Coq Plugin translates the JACK's proof obligations
into the Coq language.
The proof readability and proof reusability is crucial in interactive 
verification,
therefore we developed a set of facilities for variable name handling,
pretty printing, the reuse of proofs, the ease to build the proofs.

In JACK, a difference is made between short variable names, 
when no other variable is named this way,
 and long variable names, when there can be an ambiguity. 
When doing interactive verification the scope of these disambiguations 
can be mistaken as JACK generates all the names for one file in one row.
This disambiguation is redone in the Coq Plugin for each proof obligations.
This add better proof readability as the variable names are shorter.

The main pretty printing is done directly through Coq's own features for
 printing. Each proof obligation is passed to Coq top-level and the result of 
Coq's parsing is the proof obligation given to the user to view.


A special attention has also be given when generating the proof obligations 
into a file. First it has a human-readable name so the user can retrieve 
the proof obligation with Jack whenever he wants it. 
This way, if the lemma is regenerated or reopened
 the proof it was containing can be replayed 
(and eventually fail if the conditions have changed too much).

The normal hypothesis are separated from the invariants and
are given different names.
It is specifically useful when a goal has been modified (and considered 
unproved) by the modification of an invariant. If the proof was not involving
the use of any invariant; it can be replayed without any changing.

The Coq Plugin also allows automatic resolution of proof obligations
using generic proof scripts or user-defined ones.
It evaluates the selected proof scripts on the proof obligations.






\subsection{Jack with Coq in Eclipse}
Jack's Coq plugin relies on a translation of Jack's Java logic in
Coq as well as several user extensions. Since everything is generated
inside the Eclipse's workspace, and the user extensions have to be 
developped as part of the interactive verification process,
 a smoother interaction of Coq within
the Eclipse environment was necessary.

\paragraph{Coq editor}
We added a way to interact directly with Coq through Eclipse's Java 
environment. It is a way to directly use Coq and edit Coq files within
Eclipse. It is alike what has been done for Isabelle in Proof General Eclipse 
\cite{WintersteinAL05}, but for Coq and in a more light-weight fashion.
It has keyboard shortcuts similar to CoqIde (the current Coq graphical
interface which is written in OCaml). 
The main feature we have is the outline view; 
which sums up the view of a Coq file in a tree-like fashion (especially useful
with to see modules hierarchy). There is a search by tags feature which
permits to search a whole project for the definition of a specific keyword; and
it is done incrementaly with Eclipse's builder feature. Of course, there is 
syntax highlighting for Coq files and you can interactively play a Coq file
as in the usual interactive provers IDE.


\paragraph{User extensions; tactics}

One of the key point in interactive verification is the level of difficulty
to manipulate the proof assistant in order to solve a proof obligation.
In order to help the user build proof scripts that are both intuitive
to read and to make, we have used the tactic mechanism of Coq.
These tactics are written in a pseudo language named Ltac \cite{DEL-00-LTAC}
which permits to combine primitive tactics.
The Coq plugin contains a library of those which, based on Jack's Coq 
implemented Java logic, can help for obvious or really specific proof steps
in Jack's proof obligations. All these tactics are situated in a library 
used when a new proof obligation is loaded. Tactics can also be used in 
really specific user oriented context. There is a special file called 
'user extension' which is meant to contain user-defined
special lemmas and special tactics.



\subsection{Towards native specifications}
\begin{figure}[t!]
{\small In JML we define:
\begin{verbatim}
/*@ public native class IntList {
     public native IntList cons (int i);
     public native static IntList create();
     ...
     public native static IntList toList (int [] tab);
   } @*/ \end{verbatim}}

{\small And in Coq:
\begin{verbatim}
Definition IntList := list t_int.
Definition IntList_create : IntList := nil .  
Definition IntList_cons:  t_int -> list t_int ->list t_int := 
            fun (i: t_int) (this: list t_int)  => (i :: this).
... \end{verbatim}}
\caption{The definition of native type \texttt{IntList}}\label{CoqAnnot} 
\end{figure}
User-extensions through the use of tactics are useful;
but sometimes users would like more expressivity: instead of having
tactics and extensions based solely on Jack's Java logic, a user could
build his own logic and use it with JML annotations. He could 
even use pre-existing logics and use them with his annotations. That is 
exactly the purpose of the native construct.


The native construct can be used to express some notions contained within
the annotation directly in the logic of the prover. If we define a native type 
IntList and we bind it to Coq list of integer type (Fig. \ref{CoqAnnot}), 
we can use the list library of Coq to do our proofs. The annotation of the
{\tt sort} method can be defined as annotations for our new type 
(Fig. \ref{sortnat}). We get more readable annotations;
the annotations are more natural for a Coq user because of relying upon Java
logic over the array, we get it defined with a Coq library.
The user can also define more easily lemmas to help prove some of the proof
obligations and to add automations for proof scripts.


\begin{figure}[t!]
{\small In JML we define:
\begin{verbatim}
//@ ghost IntList list;
/*@ requires (tab!=null) && list.equals(IntList.toList(tab))
    assignable tab[0 .. (tab.length -1)], list;
    ensures list.equals(IntList.toList(tab)) &&
             list.isSorted() && list.isPermutation();
 @*/
public void sort() {if(tab.length > 0) sort(0, tab.length -1);}\end{verbatim}}
\caption{\texttt{Sort} with natives}\label{sortnat} 
\end{figure}




