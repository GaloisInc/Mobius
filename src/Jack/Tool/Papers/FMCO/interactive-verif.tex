


\section{Support for Interactive Verification}\label{SecInteractive}
When automatic provers fail to solve a proof obligation,
the user can try to change the specifications of the program or
 solve the proof obligation interactively.
Using the interactive verification support of JACK,
the user will be able to solve the proof obligation in case
the automatic prover was not powerful enough or he will be able to analyse 
thoroughly the proof obligation to find the source of the error.
This verification is done mainly with the Coq proof assistant. 

First we will discuss the architecture of JACK's Coq plugin, then its 
integration within the IDE Eclipse. Finally we will talk of
 JACK's specific annotation keyword for interactive verification, the 
\native keyword. 

\subsection{The Coq Plugin}
Proof readability and proof reusability is crucial in interactive 
verification: in automatic verification it is not the case because proof
obligations are simply given to the automatic prover and no concern is made
out of whether the proof obligation is readable or not.
Therefore we developed a set of facilities to
pretty print, to reuse the proofs, especially when the specifications 
have changed to be able to try to replay the proofs, and to the build the proofs.

JACK, uses short variable names in proof obligations as much as possible, 
but in case of ambiguity long variable names are used.
The scope of these disambiguations can be mistaken: JACK generates all 
the names for all the proof obligations of one file in a row whereas 
in interactive verification the variables are only 
used within a single proof obligation.
The Coq Plugin corrects this in redoing the disambiguation for each proof obligation.
This adds better proof readability as the variable names are shorter.
The main pretty printing is done directly through Coq's own pretty printing features. 


A special attention has also been given when generating the proof obligations 
into a file. First it has a human-readable name so the user can retrieve 
the proof obligation with Jack whenever he wants it. 
This way, if the lemma is regenerated or reopened
 the proof it was containing can be replayed 
(and eventually fail if the conditions have changed too much), and it does not have
to be rewritten.
The normal hypothesis are separated from the invariants and
are given different names.
It is specifically useful when a goal has been modified (and considered 
unproved) by the modification of a class invariant. If the proof was not involving
the use of any invariant; it can be replayed without any changing. This facilitates
greatly the reuse of proofs.

One of the key point in interactive verification is the level of difficulty
to manipulate the proof assistant in order to solve a proof obligation.
In order to help the user to build proof scripts that are both intuitive
to read and to make, we have used the tactic mechanism of Coq~\cite{DEL-00-LTAC}.
As JACK generates proof obligations for automatic verification, numerous hypothesis are 
added to help the automatic theorem prover. For interactive verification 
these hypothesis are usually useless. Therefore there are some tactics made
to clean up the proof obligations. There are also tactics to solve proof patterns
generated by JACK: the ones to solve arithmetic goals,
when the solving of a proof leads to an absurd case, the ones to help solving
array specific proof obligations and the ones to solve assignment proof obligations.
This library of tactics\footnote{
A full description of the different tactics is available here:
\texttt{http://www-sop.inria.fr/everest/soft/Jack/doc/plugin/coq/Prelude/} .}
is useful but usually the user likes to define his own application
specific tactics. The Coq Plugin also allows automatic resolution of proof obligations
using generic proof scripts.
A user can define his own tactic in the Coq Plugin in a file 
dedicated to that purpose; so he can use them in the interactive solving or with the 
automatic resolution.








\subsection{JACK with Coq in Eclipse}
An important feature of JACK is that everything can be done inside the same IDE, Eclipse.
The Coq Plugin complies to this rules and to do so it contains an editor for Coq, 
CoqEditor. This permits to solve efficiently the proof obligations generated by JACK as
well as to easily develop user extensions for the Coq Plugin all inside of Eclipse.

Coq editor is a way to interact directly with Coq through Eclipse's Java 
environment. The user can evaluate and edit Coq files within the
Eclipse IDE. It is similar what has been done for Isabelle in 
Proof General Eclipse \cite{WintersteinAL05}, in a more light-weight fashion.
It has keyboard shortcuts similar to CoqIde (the current Coq graphical
interface which is written in OCaml)\footnote{It is available with the
distribution of Coq (\texttt{http://coq.inria.fr}).}. 
CoqEditor has an outline view,
which sums up the structures of the currently edited Coq file 
in a tree-like fashion (especially useful with to see modules hierarchy). 
CoqEditor has also an incremental indexing feature which allows the user
to jump from a keyword to its definition.
Of course, there is syntax highlighting for Coq files 
and one can interactively evaluate a Coq file
as in the usual interactive provers IDE.


\subsection{Towards native specifications}
\begin{figure}[t!]
{\small In JML we define:
\begin{verbatim}
/*@ public native class IntList {
     public native IntList cons (int i);
     public native static IntList create();
     ...
     public native static IntList toList (int [] tab);
   } @*/ \end{verbatim}}

{\small And in Coq:
\begin{verbatim}
Definition IntList := list t_int.
Definition IntList_create : IntList := nil .  
Definition IntList_cons:  t_int -> list t_int ->list t_int := 
            fun (i: t_int) (this: list t_int)  => (i :: this).
... \end{verbatim}}
\caption{The definition of native type \texttt{IntList}}\label{CoqAnnot} 
\end{figure}
Sometimes users would like more expressivity: instead of having
tactics and extensions based solely on Jack's Java logic, a user may want to
build his own logic and use it with JML annotations. That is 
exactly the purpose of the \native construct \cite{Charles06}.

The \native construct is made to express some notions contained within
the annotation directly in the logic of the prover. It can be used 
as \native types and as  \native methods.
A \native method is a specification method that is like a {\tt pure} method 
but  it does not throw any exception and is used uniquely through the specifications. 
A \native type is a type to use with specification methods (\native methods as well as 
JML's {\tt model} methods). Both are references to a constructs 
defined in the proof obligation's target language: usually \native types are bounded to 
types and \native methods to functions definitions.


If we define a \native type IntList and we bind it to a list of integer type 
 (Figure \ref{CoqAnnot}), we can use the list library of the target prover (here Coq) 
in the proofs. The specifications of the
{\tt sort} method can be defined as specifications using our new type 
(Figure \ref{sortnat}). We get more readable annotations;
the annotations are more natural for the user because instead
 of relying upon Java logic over the array, we get it defined directly into
our target proof obligations language syntax.
The user can also define more easily lemmas to help prove some of the proof
obligations and to add automations for proof scripts.


\begin{figure}[t!]
{\small In JML we define:
\begin{verbatim}
//@ ghost IntList list;
/*@ requires (tab!=null) && list.equals(IntList.toList(tab))
    assignable tab[0 .. (tab.length -1)], list;
    ensures list.equals(IntList.toList(tab)) &&
             list.isSorted() && list.isPermutation();
 @*/
public void sort() {if(tab.length > 0) sort(0, tab.length -1);}\end{verbatim}}
\caption{\texttt{Sort} with natives}\label{sortnat} 
\end{figure}




