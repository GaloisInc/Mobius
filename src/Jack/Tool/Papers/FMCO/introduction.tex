\section{Introduction}\label{SecIntro}

\paragraph{Motivation}

Over the last years, the use of trusted personal devices (TPD), such
as mobile phones, PDAs and smart cards, has become more and more
widespread. As these devices are often used with security-sensitive
applications, they are an ideal target for attacks. Traditionally,
research has focused on avoiding hardware attacks, where the attacker
has physical access to the device to observe or tamper with
it. However, TPD are more and more connected to networks and moreover,
provide support to execute complex programs. This has increased the
risk of logical attacks, which are potentially easier to launch than
physical attacks (they do not require physical access, and are easier
to replicate from one device to the other), and may have a huge
impact.  In particular, a malicious attacker spreading over the
network and massively disconnecting or disrupting devices could have
significant consequences.

An effective means to avoid such attacks is to improve the quality of
the software deployed on the device. %This is in particular important
%for TPD, where post-issuance corrections are
%expensive due to their particular deployment process and their mass
%production. 
This paper describes JACK (the Java Applet Correctness Kit), a tool
that can be used to improve the quality of applications for TPD. Such
devices typically provide the Java Virtual Machine (or one of its
variations)\footnote{The standard Java set-up for such devices is the
Connected Limited Device Configuration, see
\texttt{http://java.sun.com/products/cldc/}, together with the MIDP
profile, see \texttt{http://java.sun.com/products/midp/}.}. Therefore
JACK is tailored to applications written in Java (bytecode). However,
the described techniques are also relevant to other execution
platforms for TPD.


%\item they feature mechanisms that contribute to the security of the
%platform and the applications that execute over it;
%\item detailed informal specifications of the Java platform are publicly
%available, and can be scrutinized.

\paragraph{Characteristics of JACK}
JACK allows to verify Java applications that are annotated with the
Java Modeling Language (JML)\footnote{See
\texttt{http://www.jmlspecs.org}.}. An advantage of using JML is that
there is wide range of tools and techniques available that use JML as
specification language, 
\emph{i.e.}\ for testing, simulation and verification 
(see~\cite{BurdyCCEKLLP03} for an overview). We distinguish two kinds
of verification: at runtime, using
\texttt{jmlc}, or statically. Several tools provide
static verification of JML-annotated programs, adopting different
compromises between soundness and automation (see the related work
section below for an overview).  JACK implements a weakest
precondition calculus, that automatically generates proof obligations
that can be discharged both by automatic and interactive theorem
provers. The automatic prover that is used is
Simplify~\cite{DetlefsNS05}, the interactive theorem prover that is used
is Coq~\cite{Coq04}.


The development of the JACK tool started in 2002 at the formal methods
research laboratory of the French smart card producer Gemplus (now
part of gemalto). Successful case studies with ESC/Java and the LOOP
tool on an electronic purse smart card
application~\cite{final:Form.Met} had sufficiently demonstrated that
verification of JML annotations could help to increase the quality of
smart card applications. However, the existing tools where either not
precise enough, or they were too cumbersome to use, to expose
application developers to them. The JACK tool was designed to overcome
these problems, in particular via the integration of JACK within the
IDE Eclipse, and the development of a special JACK perspective.

In 2003, the tool has been transfered to the Everest project at INRIA
Sophia Antipolis, and been further developed within this team since
then. The other features of JACK described in this paper have been
developed after this transfer.

The main characteristics of JACK that distinguish it from other static
verification tools are the following:
\begin{itemize}
\item full integration within Eclipse IDE\footnote{See
\texttt{http://www.eclipse.org}.}, including the development of a
special JACK perspective that allows to inspect the different proof
obligations, and from where in the code they originate;
\item implementation of annotation generation algorithms: to
generate ``obvious'' annotations, and to encode high-level security
properties;
\item support for verification of bytecode programs; and
\item support for interactive verification, by the development of an interface
and tactics for Coq and by use of the \native construct, that allows to
link JML specifications with the logic of the underlying theorem
prover. 
\end{itemize}
This paper illustrates how these characteristics make JACK
particularly suited for the development of secure applications for
TPD.

\paragraph{Application Scenarios}
JACK provides different kinds of support for the application
developer, ranging from the the automatic verification of a collection
of common security properties to the interactive verification of
advanced functional specifications.

To support the automatic verification of high-level security
properties, JACK provides an algorithm to automatically generate
annotations encoding such properties, and to weave and propagate these
in the application. These annotations give rise to proof obligations,
whose discharge (typically automatically) guarantees adherence to the
security policy. Since JACK also provides support for the verification
of bytecode, and allows to compile source code level JML annotations
into bytecode level specifications (written in the Bytecode Modeling
Language (BML)~\cite{BurdyHP07}), this enables a proof carrying code
scenario~\cite{Necula97}. In such a scenario, the applications come
equipped with a specification and a proof that allow the client to
establish trust in the application. Since the applications usually are
shipped in bytecode format, also the specification and the
verification process need to be defined at this level. This scenario
is even further facilitated by the fact that the compiler from JML to
BML provided by JACK basically preserves proof obligations (see
also~\cite{gta05:fast}. Thus, a software developer can verify its
application at source code level, and ship the application with
compiled bytecode level specifications and proofs. Notice that,
provided the proof obligations can be discharged automatically, this
whole process is automatic.

However, as JACK is a general-purpose tool, it can be also be used to
verify complex functional-behaviour specifications, by providing
advanced support for specification development and interactive
verification. First of all, because of the tight integration with
Eclipse, the developer does not have to change tools to validate the
application. A special JACK view is provided, that allows to inspect
the generated proof obligations in different views (in a Java-like
syntax, or in the language of the prover). Moreover, syntax colouring
of the original source code allows to see to which parts of the
application and specification the proof obligation relates. Second,
one of the drawbacks of using JML-like annotations for specifications
is that writing them is labour-intensive and error-prone and it is
easy to forget some. Therefore JACK also can generate ``obvious''
annotations that are easy to forget, \emph{i.e.}\ frame conditions and
preconditions that are sufficient to avoid runtime
exceptions. Finally, to support interactive verification, several
advanced Coq tactics have been developed, and a Coq editor has been
integrated into Eclipse. In addition, to be able to write expressive
specifications, a
\native construct has been proposed for JML, that allows to
link JML constructs directly with the logic of the underlying
prover. This allows to develop the theory about these constructs
directly in the logic of the theorem prover, which makes specification
and verification simpler.


\paragraph{Overview of the Paper}
The next section gives a quick overview of the relevant JML features,
and presents an example that we will use to illustrate the different
features of JACK. Section~\ref{SecArchitecture} t briefly outlines the
general architecture of JACK, while Section~\ref{SecUI} focuses on its
user interface. Section~\ref{SecAnnotGen} describes the different
annotation generation algorithms that JACK
implements. Section~\ref{SecBytecode} presents the bytecode
subcomponents of JACK, while Section~\ref{SecInteractive} explains the
features that JACK provides to support interactive
verification. Finally, Section~\ref{SecConcl} concludes and discusses
how this work will be continued.

Parts of the results described in this paper have been published
elsewhere (\cite{BurdyRL03} describes the general architecture of
JACK, \cite{PavlovaBBHL04} the annotation generation algorithm
for security policies, \cite{BP06JSV} the framework for the
verification of bytecode, and \cite{Charles06} the native
construct). However, this is the first time a complete overview of
JACK and its main features are given in a single paper.


