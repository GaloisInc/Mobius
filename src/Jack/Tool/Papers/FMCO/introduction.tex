\section{Introduction}\label{SecIntro}

\paragraph{Motivation}
Over the last years, the use of trusted personal devices, such as
mobile phones, PDAs and smart cards, has become more and more
widespread. As these devices are often used with security-sensitive
applications, they are an ideal target for attacks. Traditionally,
research has focused on avoiding hardware attacks, where the attacker
has physical access to the device to observe or tamper with
it. However, trusted personal devices are more and more connected to
networks and moreover, provide support to execute complex
programs. This development has increased the risk of logical attacks,
which are potentially easier to launch than physical attacks (they do
not require physical access, and are easier to replicate from one
device to the other), and may have a huge impact.  In particular, a
malicious attacker spreading over the network and massively
disconnecting or disrupting devices could have significant
consequences.

An effective means to avoid such attacks is to improve the quality of
the software deployed on the device. This is in particular important
for trusted personal devices, where post-issuance corrections are
expensive due to their particular deployment process and their mass
production. This paper describes JACK (the Java Applet Correctness
Kit), a tool that can be used to improve the quality of applications
for trusted personal devices. Such devices typically provide (a
variation of) the Java Virtual Machine\footnote{The standard Java
set-up for such devices is the Connected Limited Device Configuration,
see \texttt{http://java.sun.com/products/cldc/}, together with the
MIDP profile, see \texttt{http://java.sun.com/products/midp/}.},
therefore JACK is tailored to applications written in Java
(bytecode). However, the described techniques are also relevant to
other execution platforms for trusted personal devices.


%\item they feature mechanisms that contribute to the security of the
%platform and the applications that execute over it;
%\item detailed informal specifications of the Java platform are publicly
%available, and can be scrutinized.

\paragraph{Characteristics of JACK}
JACK allows to verify Java applications that are annotated with the
Java Modeling Language (JML)\footnote{See
\texttt{http://www.jmlspecs.org}.}. An advantage of using JML is that
there is wide range of tools and techniques available that use JML as
specification language, 
\emph{i.e.}\ for testing, simulation and verification. We
distinguish two kinds of verification: at runtime, using
\texttt{jmlc}, or statically. Several tools provide
static verification of JML-annotated programs, adopting different
compromises between soundness and automation (see the related work
section below for an overview).  JACK implements a weakest
precondition calculus, that automatically generates proof obligations
that can be discharged both by automatic and interactive theorem
provers. The automatic prover that is used is
Simplify~\cite{Simplify}, the interactive theorem prover that is used
is Coq~\cite{Coq}.


The main characteristics of JACK that distinguish it from other static
verification tools are the following:
\begin{itemize}
\item full integration within Eclipse IDE\footnote{See
\texttt{http://www.eclipse.org}.}, including the development of a
special JACK view that allows to inspect the different proof
obligations, and from where in the code they originate;
\item implementation of annotation generation algorithms: to
generate ``obvious'' annotations, and to encode high-level security
properties;
\item support for verification of bytecode programs; and
\item support for interactive verification, by the development of an interface
and tactics for Coq and by use of the ``native'' construct, that allows to
link JML specifications with the logic of the underlying theorem
prover. 
\end{itemize}
This paper illustrates how these characteristics make JACK
particularly suited for the development of secure applications for
trusted personal devices.

In particular, JACK provides an algorithm to automatically generate
annotations encoding high-level security policies, and to weave and
propagate these in the application. These annotations give rise to
proof obligations, whose discharge (typically automatically)
guarantees adherence to the security policy. Since JACK also provides
support for the verification of bytecode, and allows to compile source
code level JML annotations into bytecode level specifications (written
in the Bytecode Modeling Language (BML)~\cite{BurdyHP07}), this
enables a proof-carrying code scenario. In such a scenario, the
applications come equipped with a specification and a proof that allow
the client to establish trust in the application. Since the
applications usually are shipped in bytecode format, also the
specification and the verification process need to be defined at this
level. This scenario is even further facilitated by the fact that the
compiler from JML to BML provided by JACK basically preserves proof
obligations. Thus, a software developer can verify its application at
source code level, and ship the application with compiled bytecode
level specifications and proofs. Notice that, provided the proof
obligations can be discharged automatically, this whole process is
automatic.

However, JACK is a general-purpose tool, and besides the verification
of high-level security policies, it can be also be used to verify
complex functional behaviour specifications, by providing advanced
support for specification development and interactive
verification. First of all, because of the tight integration with
Eclipse, the developer does not have to change tools to validate the
application. A special JACK view is provided, that allows to inspect
the generated proof obligations in different views (in a Java-like
syntax, or in the language of the prover). Moreover, syntax colouring
of the original source code allows to see to which parts of the
application and specification the proof obligation relates. Second,
one of the drawbacks of using JML-like annotations for specifications
is that writing them is labour-intensive and error-prone and it is
easy to forget some. Therefore JACK also can generate ``obvious''
annotations that are easy to forget, \emph{i.e.}\ frame conditions and
preconditions that are sufficient to avoid runtime
exceptions. Finally, to support interactive verification, several
advanced Coq tactics have been developed, and a Coq editor has been
integrated into Eclipse. In addition, to be able to write expressive
specifications, a
\texttt{native} construct has been proposed for JML, that allows to
link JML constructs directly with the logic of the underlying
prover. This allows to develop the theory about these constructs
directly in the logic of the theorem prover, which makes specification
and verification simpler.


\paragraph{Overview of the Paper}
The next section gives a quick overview of the relevant JML features,
and presents an example that we will use to illustrate the different
features of JACK. Section~\ref{SecArchitecture} t briefly outlines the
general architecture of JACK, while Section~\ref{SecUI} focuses on its
user interface. Section~\ref{SecAnnotGen} describes the different
annotation generation algorithms that JACK
implements. Section~\ref{SecBytecode} presents the bytecode
subcomponents of JACK, while Section~\ref{SecInteractive} explains the
features that JACK provides to support interactive
verification. Finally, Section~\ref{SecConcl} concludes and discusses
how this work will be continued.

Parts of the results described in this paper have been published
elsewhere (\cite{BurdyRL03} describes the general architecture of
JACK, \cite{PavlovaBBHL04cardis} the annotation generation algorithm
for security policies, \cite{BP06JSV} the framework for the
verification of bytecode, and \cite{Charles06} the native
construct). However, this is the first time a complete overview of
JACK and its main features are given in a single paper.


