\documentclass[a4paper]{llncs}

\usepackage{epsfig}     %% om xfig gegenereerde pstexs te includen

% to be removed in final version
\pagestyle{plain}

\title{Formal specification and static checking of Gemplus' electronic
purse using ESC/Java}

\author{
  N\'estor Cata\~no
\and
  Marieke Huisman
}

\institute{
  INRIA Sophia-Antipolis, France \\ 
  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
}

\newcommand{\noth}{\(\backslash\)\texttt{nothing}}
\newcommand{\fieldsof}{\(\backslash\)\texttt{fields\_of}}
\newcommand{\reach}{\(\backslash\)\texttt{reach}}
\newcommand{\comment}[1]{\marginpar{\framebox{\begin{minipage}{\marginparwidth}{#1}\end{minipage}}}}

\begin{document}
%\input{texdefs.tex}

\maketitle


\begin{abstract}
This paper presents a case study in formal specification of smart card
programs, using ESC/Java. It discusses an electronic purse
application, provided by Gemplus, that we have annotated with
functional specifications (\emph{i.e.}~pre- and
postconditions, modifies
clauses and class invariants), that are as detailed as possible. The
specification is based on the informal documentation of the
application. The implementation has been checked \emph{w.r.t.}~the
specification, using ESC/Java.  This revealed several errors or
possibilities for improvement in the source code (\emph{e.g.}~removing
unnecessary tests).

Our paper shows that a relatively
lightweight use of formal specification techniques can already have
a serious impact on the quality of a program and its
documentation. Furthermore, we also present some ideas on how ESC/Java
could be further improved, both
\emph{w.r.t.}~specification and verification.
\\
\textbf{Keywords:} static checking, specification, ESC/Java, smart cards.
\end{abstract}

\section{Introduction}
\label{SectIntro}

\subsubsection{Background}
When developing a large software application, a significant part of
the work is spent on writing clear and concise documentation. This
documentation serves several purposes. First of all, it helps the
developers of the application to do maintenance, as the documentation
helps to understand the implementation decisions taken by a colleague,
but also to understand ones own decisions after a certain period of
time. Further, software documentation also is useful when somebody
else builds a new application, using features provided by the
application at hand.

However, such program documentation is only useful if it correctly
describes the implementation, thus one would like to have some trust
in its appropriateness. A way to achieve this is to write a formal
specification, \emph{i.e.}~a description of the program behaviour in
logic, and then prove the correctness of the implementation
\emph{w.r.t.}~this specification, but this is difficult (as it
requires a good understanding of the semantics underlying the
specification and programming language), and labour-intensive (see
\emph{e.g.}~\cite{HuismanJB01,BreunesseJB02} for examples of full program
verification). Thus, although it is feasible to do formal
specification and verification, the costs in general do not outweigh
the benefits.

Recently, several projects have started developments to overcome these
problems. First of all, to encourage application developers to write
formal specifications, specifications are written in a language that
is close to the language in which the specified programs are written:
the specification languages reuses the expression syntax from the
programming language.  The assertions that can be written in an Eiffel
program~\cite{Meyer97} are a first example of such a specification
style, and recently several annotation languages for Java have been
proposed, following the same strategy: JML~\cite{LeavensBR00},
ESC/Java~\cite{ESCJavaUrl}, and the Jass annotation
language~\cite{JassUrl}. For JML and ESC/Java, effort has been put
into making these specification languages converge~\cite{EscJmlDiff},
so that the respective tools can be used for both languages. Typical
for these languages is that expressions are written as Java
expressions, extended with some specification-specific constructs.

Secondly, together with the ESC/Java language, a static checker has
been developed~\cite{ESCJavaUrl}, which can be used to check
automatically simple, but useful properties. This static checker tries
to check that a program satisfies its annotations, by using a
dedicated, automated theorem prover. This automated theorem prover has
been fine-tuned to find common programming problems like
\texttt{Null\-pointer\-Exception}s, and
\texttt{Array\-Index\-Out\-Of\-Bound\-Exception}s, but it also can be
used to check other annotations. If the theorem prover cannot
establish that a certain specification is satisfied, ESC/Java issues a
warning. Such a warning does not necessarily mean that the program is
wrong, as the ESC/Java approach is neither sound, nor complete. When
designing the tool, a compromise has been made between soundness,
completeness, and efficiency. The result is an efficient, automatic
checker, that can increase the confidence in the correctness of
programs, and that finds many common programming errors. However, if
one wishes to establish formally the correctness of a complicated
algorithm, other (possibly interactive) verification techniques have
to be used, as advocated in
\emph{e.g.}~the LOOP project~\cite{LOOPUrl} or the Jive
project~\cite{MeyerP00}. But even for such complex algorithms it pays
to use ESC/Java first, in order to find quickly and automatically a
first approximation of the errors in the algorithm and/or
specification, before diving into the complete formal verification.



\subsubsection{This paper}
To demonstrate the usefulness of this approach, this paper describes
the ESC/Java annotation of a smart card application. This case study
shows that annotating programs with ESC/Java specifications can be
helpful to create reasonably quick, clear, concise and unambiguous
documentation for a software application, which is in correspondence
with the implementation.  The original source code of the case study
-- which implements an electronic purse -- comes from
Gemplus~\cite{PurseUrl}. In this paper we discuss the annotations of
the source code, and several possibilities for improvement that we
encountered.  The result of this work does not give a fully verified
specification, but it gives a reasonable description of the electronic
purse implementation, which could serve as a basis for further formal
verification, \emph{e.g.}~by using the LOOP compiler.

The main contribution of this paper is that it shows that by making
light\-weight use of formal verification techniques, as provided by
ESC/Java, it is feasible to
\emph{(i)} write a formal specification of an application, and
\emph{(ii)} have the implementation checked \emph{w.r.t.}~the 
specification so as to increase confidence in the correctness of the
implementation. When specifying the purse we have found several
(simple) properties which are informally documented, but are not
satisfied by the implementation. It is straightforward to formally
specify these properties and ESC/Java immediately finds the places
where these properties are not preserved in the implementation.

Furthermore, to the best of our knowledge this case study is one of
the first larger case studies using ESC/Java, and we found several
points for improvement in the static checker and its specification
language. This leads us to a wish list on improvements in the
specification language and to the development of a checker for
so-called modifies clauses. This checker will be described in a
separate paper~\cite{CatanoH02b}.%, but we use it in this case study
%to get further
%confidence in the accurateness of the specification.

The rest of this paper is organised as
follows. Section~\ref{SectGenPurse} describes the general outline of
the case study. Section~\ref{SectStatic} gives a brief introduction
into the static checker ESC/Java.  Section~\ref{SectSpecPurse}
describes the annotations of the purse in general, and discusses
several aspects of the specification in more
detail. Section~\ref{SectESC} comments on the use of ESC/Java and
gives suggestions for improvement. Finally, Section~\ref{SectConcl}
gives conclusions and presents future work.






\section{General outline of the Electronic Purse}
\label{SectGenPurse}

The electronic purse is a JavaCard application~\cite{JavaCardURL}, published
as an advanced smart card programming case study by
Gemplus~\cite{PurseUrl}. A JavaCard smart card is capable of running
programs developed in {JavaCard}, a dialect of
standard Java. {JavaCard} does not provide concepts such as dynamic
class loading, security management, multi-threading and
synchronization, object cloning and large primitive date types (float,
double, long and char).  JavaCard applications are called
\emph{applets}.  The electronic purse applet provides  the ability to 
perform banking operations to the card holder. Typical operations are
credit, debit, and currency changes.

\begin{description}
\item [\bf The \textit{debit} operation.]
%\paragraph
Debit operations which involve an amount greater than
\texttt{maxDebitWOPIN} are protected by a pin code. During one session, 
a user can do several of these transactions by presenting his pin code
only once. To protect the card against attacks, the number of
transactions that can be performed without presenting a pin code is
limited to \texttt{maxTransactionWOPIN}.
\\

%During a debit
%operation, if severals transactions are carried out in the same
%session, it is possible that the card user presents once his pin code
%for amounts greater than
%\texttt{maxDebitWithOutPIN}. This variable
%represents the biggest quantity that certain client may credit without
%presenting his pin code. For
%security reasons, the card holder can do at most
%\texttt{maxTransactionWithoutPIN} transactions in a same session. 

\item[\bf The \textit{credit} operation.]
%\paragraph
If the balance on the card is not sufficient to execute a certain
debit operation, the balance can be increased by performing a credit
operation. To do this, the point of sale terminal asks the bank of the
card holder for credit permission. If the permission is obtained, the
account is credited and a confirmation is sent to the bank.
\\
\item [\bf The \textit{currency change} operation.]
%\paragraph 
The balance
of the purse is expressed in a certain currency. When the card holder
travels, the current currency can be changed. In order to do this, the
terminal requests a new exchange rate and a certificate from the
bank. The purse verifies that the bank is really the expected bank and
validates the exchange rate. After changing the balance value, the
purse must modify all variables related to the currency. 
\end{description}
The purse applet interacts with so-called \textit{loyalty applets}
(implementing \emph{e.g.}~a frequent flyer program) that may be
present on the card. Within the loyalty applet, the card holder gets
loyalty points having made certain purchases, and these points can be
used later to make other purchases. Further, a \textit{card issuer
applet} should be available on the card, which can initialise the
purse. Finally, the purse applet also communicates with the 
\emph{point of sale terminal}. 
%These applets send and receive
%information concerning on the card user operations. 

The purse application consists of three packages$:$ \texttt{utils},
\texttt{purse} and \texttt{pacap\-interfaces}. The {\tt utils} package
implements basic classes such as \texttt{Annee} (year), 
\texttt{Mois} (month) \texttt{Jour} (day), and \texttt{Decimal}
(floating point numbers).  The \texttt{pacap\-interfaces} package
declares shareable interfaces which enable the purse applet to
communicate with \emph{e.g.}~the loyalty applets on the card.  The
\texttt{purse} package is the core of the purse application.  It
contains the class
\texttt{PurseApplet}, which manages the operations related with 
installation, selection and deselection of the applet, and which
communicates with the point of sale terminal.  The basic purse
functionalities are implemented in the class
\texttt{Purse}. This class performs the communication
with the loyalty applets, using the interfaces described in the
\texttt{pacapinterfaces} package.  Also, this class keeps track of the 
balance of the purse, the transactions done by the purse (stored as a
\texttt{TransactionRecord}), the different currency changes that have
taken place (in an \texttt{ExchangeRecord}) and the different
loyalty programs that the card holder is subscribed to (in a
\texttt{LoyaltiesTable}). 

%This class uses instance variables for
%implementing its functionalities. So, for instance, the different
%transactions carried out by the purse are stored in a variable of type
%\texttt{TransactionRecord}, where its individual components are of
%type \texttt{Transaction}. A similar situation occurs with the current
%currency and the different loyalties managed by the purse.

Certain operations can only be performed by a restricted set of users,
\emph{e.g.}~because a pin code is needed.
The class \texttt{AccessCondition} defines the different access
conditions, and the class \texttt{AccessControl} binds the access conditions
to the operations. So, when a card holder intends to perform a certain
operation, the purse application will check that the card holder has
the appropriate permissions. %The class
%\texttt{AccessControlTable} permits to declare
%all of different access controls that purse uses. 
%When the currency change takes place, the 
%\texttt{Purse} class uses an \texttt{ExchangeSession} class instance to 
%record the information corresponding to a session. The record of
%different currency exchanges is registered using a
%\texttt{ExchangeRecord} instance variable. 
The class \texttt{Currencies} stores the different currencies used by
the purse application.  Finally, the purse application contains several classes
implementing cryptographic concepts, namely, \texttt{PacapCertificate},
\texttt{PacapCipher}, \texttt{PacapKey}, \texttt{PacapRandom},
\texttt{PacapSecureMessaging} and \texttt{PacapSignature}. These
classes are not studied in full detail in this case study.






\section{Static checking of Java programs}
\label{SectStatic}


%\subsection{\sc \bf ESC/Java}
\label{SubSectEscJava}

ESC/Java is a verification tool developed at Compaq SRC, which permits
a user to find common errors in Java programs. The basic idea is that
a user specifies the desired behaviour of a class and its methods and
the ESC/Java tool checks whether the implementation satisfies the
specification. If it cannot establish this, it issues a warning. As
explained above, such a warning does not necessarily mean that there
is an error, as ESC/Java is neither sound, nor complete.
%specify conditions that class and methods have to provide, and
%after using the tool for checking them. ESC/Java contrasts the done
%specification against the source code and it issues a warning
%message. This warning message indicates a \emph{possible} incoherence
%in the implementation w.r.t the implementation (the specification is
%supposed being correct).

The specifications are given as
\textit{pre-} and \textit{postconditions} of methods and as
\textit{class
invariants}. The specifications are written as special Java comments,
thus they do not change the annotated program.  The properties are
specified as Java expressions, enriched with several
specification-specific constructs. Here, we present some ESC/Java
specification constructs, together with an example of their use. Their
full description can be found in~\cite{LeinoNS00}.

\subsection{ESC/Java pragmas to specify method and class behaviour}
%\subsubsection{Pragmas for specifying methods}
\begin{itemize}
\item{\texttt{requires P}.}
This pragma specifies a method precondition {\tt P}.
When ESC/Ja\-va checks the body of the
method, it assumes that \texttt{P} holds initially, but when
ESC/Java checks a method call, it will issue a warning if
it can not establish that \texttt{P} holds at the call site.

\item{\texttt{ensures Q}.}
This pragma specifies a method postcondition \texttt{Q}. The
postcondition is supposed to hold if the method terminates normally,
\emph{i.e.}  without throwing an exception.

\item{\texttt{exsures (E) R}.}
This pragma specifies a exceptional condition. This condition is
supposed to hold if the method finishes abruptly and if
the exception \texttt{e} that is thrown is a subclass of \texttt{E}.

\item{\texttt{modifies L}.}
This pragma specifies that a method \emph{may} modify the state
components listed in \texttt{L}, where these state components are
variable names, field or array accesses and array range expressions
(denoting the elements within an array). Within a method body, the
method parameters and the local variables always may be modified. When
checking a method call, ESC/Java assumes that only the state
components denoted by the modifies clauses may have been changed, but it
does not check the correctness of the modifies clause.
\texttt{L}

\item{\texttt{assert P}.} This pragma states that the property
\texttt{P} should be true whenever control reaches this program point.

\item{\texttt{invariant I}.} This pragma specifies a class invariant,
\emph{i.e.}~the property \texttt{I} has to be established by the
constructor of the class and it has to be preserved by all the
methods in the class. 
\end{itemize}



\subsection{Specification expressions}
\begin{itemize}
\item{\texttt{==>}} is the logical implication. So, \texttt{P
==> Q} is true if and only if \texttt{P} is false or \texttt{Q} is
true, where \texttt{P} and \texttt{Q} are specification expressions of 
\texttt{boolean} type. Further, \texttt{<==>} denotes
logical equivalence and \texttt{<=!=>} specifies non-equivalence.

\item {($\backslash$\texttt{forall T V; E)} and
($\backslash$\texttt{exists T V; E})} are quantifier expressions (of
type \texttt{boolean}).  The first one denotes that \texttt{E} is true
for all substitutions of values of type \texttt{T} for the bound
variable \texttt{V}. The second one denotes that \texttt{E} is true
for a substitution of a value of type \texttt{T} for the bound
variable \texttt{V}.

\item{\texttt{$\backslash$old(E)}} is used within a postcondition, where it denotes the value of \texttt{E} in the pre-state of the method invocation.

\item {\tt$\backslash$result} represents the value returned by
a non-void method method. It can only be used within an
\texttt{ensures} clause.
\end{itemize}


\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
/*@
  modifies nbData, data[nbData];
  ensures (\old(nbData) < MAX_DATA) ?
            (nbData == \old(nbData) + 1 && data[\old(nbData)] == cur) :
            (nbData == \old(nbData));
*/
void addCurrency(byte cur){
   if(nbData < MAX_DATA) {
      data[nbData] = cur ;
      nbData++ ;
   }
}
\end{verbatim}
\caption{Example ESC/Java specification}
\label{fig-add-cur}
\rule{\linewidth}{0.3mm}
\end{figure}


Figure~\ref{fig-add-cur} shows a typical annotation example using
ESC/Java. This example was taken from the specification of the
electronic purse case study. The \texttt{addCurrency} method belongs
to the class \texttt{Currencies}. This class stores all currencies
supported by the purse application. The method
\texttt{addCurrency} adds a new currency to the list of valid
currencies. This list is represented by the
array \texttt{data}. The \texttt{modifies} clause declared in the
method's header specifies that
this method may modify \texttt{nbData} and
\texttt{data} in the position \texttt{nbData}\footnote{More precisely, it
specifies that the method only may modify these instance variables and
the local variables and formal parameters of the method.}. The
postcondition of the method \texttt{addCurrency} (written as
\texttt{ensures} clause) expresses that if \texttt{nbData} has not
yet reached the threshold value \texttt{MAX$\_$DATA}, \texttt{nbData}
will increase its value by one and the value of the formal parameter
\texttt{cur} will be assigned to \texttt{data[\(\backslash\)old(nbData)]}. 
Inside the postcondition, the expression
\texttt{$\backslash$old(nbData)} refers to the value of
\texttt{nbData} before the method invocation.






\section{Specification of the Electronic Purse}
\label{SectSpecPurse}


\subsection{The general specification approach}
ESC/Java forces one to start writing specifications for the classes
that are `used' by many other classes, either because they are used as 
components or because they are inherited from. In the electronic purse 
case study most classes inherit directly from classes as
\emph{e.g.}~\texttt{Object}, \texttt{Exception} or -- in the case of
interfaces -- \texttt{Shareable}, so the inheritance structure is not
very complex. Therefore, we started by specifying classes that
provide basic (and general) features, \emph{e.g.}~those in the
\texttt{utils} package,
that are used by the classes in the \texttt{purse} package. The
specifications for these basic classes form the basis for the
specification of the more application-specific classes, so it is
important that they are sufficiently detailed.

For every method, we specify the precondition (as a \texttt{requires} clause
in ESC/Java), the postcondition (\texttt{ensures}), the modifies
clause (\texttt{modifies}), and the exceptional postcondition
(\texttt{exsures}). ESC/Java does not have a keyword to specify that a
method may not modify any variables, but this is implied by the
absence of a modifies clause. To make our specifications explicit
about this, in such a case we added a comment
\texttt{modifies \noth;} -- as in JML. Further, ESC/Java requires 
that every exception that is mentioned in the exceptional
postcondition is also mentioned in the \texttt{throws} clause of the
method. To avoid having to add \texttt{throws} clauses to every method,
in many cases we chose to have the assertion \texttt{exsures
(Exception) false;} as a comment, without having it checked by
ESC/Java. However, everywhere where there can be any doubt about the
correctness of the \texttt{exsures} clause, we add the \texttt{throws}
clauses and have it checked by ESC/Java.

When writing method specifications, two different styles can be used:
either a precondition is given which ensures that no exceptions
will be thrown, or one specifies a light precondition
(\emph{e.g.}~true), and an exceptional postcondition which describes
under which conditions an exception will be thrown. For example, given
the left specification, one has to show that \texttt{P} is satisfied
before the method is called, and then it is guaranteed that the method
cannot produce an exception, while the right hand specification makes
no requirements on the method call, but specifies that if an exception
occurs, this is because \texttt{P} did not hold.
\begin{verbatim}
/*@ modifies M;                       /*@ modifies M;
    requires P;                           requires true;
    ensures Q;                            ensures Q;
    exsures (E) false;                    exsures (E) !P;
*/                                    */
void m() {                            void m () {
...                                   ...
}                                     }
\end{verbatim}

In our specifications, we usually follow the first approach,
%, which
%is close to the \emph{design by contract} approach~\cite{Meyer97},
unless the informal documentation clearly suggests that the second
approach is intended.

Furthermore, we specify appropriate class invariants for each class,
typically restricting the set of legal values for the instance
variables. In some cases, the class invariant immediately follows from
the informal documentation (\emph{e.g.}~the documentation in class
\texttt{Decimal} states:
\texttt{the decimal part must be done in the interval 
[000,999]}~\cite{PurseUrl})
and in other cases the appropriate class
invariant follows from closer inspection of the code, \emph{e.g.}~a
variable is never \texttt{null}.  Section~\ref{SectSpecDetails}
discusses the specification of class invariants in more detail.

Sometimes discrepancies between the informal documentation and the
implementation occur. In general we try to follow the informal
documentation, and we correct the implementation where necessary
(and document these changes). In several cases we consulted the case
study developers at Gemplus, to get a better understanding which
behaviour was actually intended.

In the case study, several functions from the JavaCard
API~\cite{JavaCardAPI} are used. When we specify methods using API
functionalities, we use the API specification as constructed by Erik
Poll and Hans Meijer (see \emph{e.g.}~\cite{MeijerP01}).  In the
classes \texttt{Purse} and \texttt{PurseApplet}, several classes are
used that we do not have access to. To overcome this problem, we
construct specification files, declaring the methods and fields that we need,
but without making any assumptions about their behaviour.

Our aim is to give a functional specification of the behaviour of the
purse. However, we did not study the algorithms to manage secret keys,
and therefore we only give a lightweight specification
(\emph{i.e.}~specifying the precondition and modifies clauses, but no
postcondition) of the classes dealing with key generation and
certification. This enables us to write and check the specifications of
the classes \texttt{Purse} and \texttt{PurseApplet}. How to specify
and verify cryptographic algorithms is a topic of future research.


We aim at giving specifications which describe the behaviour of the
application as complete as possible. As ESC/Java is not complete, it
will sometimes produce a warning for a correct specification. 
Typically, if a complex control structure occurs in a method
(\emph{e.g.}~loops in which method calls are made) ESC/Java is unable
to establish complicated postconditions. If one wishes to certify
these methods, other verification techniques, as advocated
\emph{e.g.}~in the LOOP project~\cite{LOOPUrl}, should be
used. However, in the case study at hand such complex control
structures are not very frequent and ESC/Java is able to check most of
the specifications without any problems. In the final version of the
specifications, the only remaining warnings are caused by ESC/Java's
incompleteness. When we encountered other warnings during the
specification and checking process, we adapted the implementation or
specification appropriately.

At~\cite{CatanoH01Url} the full annotated version of the purse case
study can be found. In the code it is documented which postconditions
cannot be established by ESC/Java. It is also documented which changes 
we have had to make to the code.


\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
/*@
  requires d != null;
  ensures \result == (intPart>d.intPart ||
                     (intPart == d.intPart && 
                        (decPart == d.decPart||decPart > d.decPart)));
*/
public boolean isGreaterEqualThan(Decimal d){
  boolean resu = false ;
  if(intPart>d.getIntPart()) resu = true ;
  else if(intPart<d.getIntPart()) resu = false ;
  else if(intPart==d.getIntPart()){
    if((decPart>d.getDecPart()) || (decPart>d.getDecPart())) resu=true ;
    else if(decPart<d.getDecPart()) resu = false ;
  }
  return resu ;
}
\end{verbatim}
\caption{Method {\tt isGreaterEqualThan}}
\label{fig-cla-dec}
\rule{\linewidth}{0.3mm}
\end{figure}


\subsection{Interesting aspects of the specification}\label{SectSpecDetails}
Below, several interesting aspects of the specification are discussed
in more detail. First we elaborate on some implementation errors that
we found in the purse application.  Then we discuss the specification
of class invariants, and how this can help to simplify the
code. Finally, we discuss miscellaneous aspects of the case study, and
present some possible improvements. The problems that we have found
probably also would have been found by doing thorough testing, but
using theorem proving techniques one is sure not to forget some cases,
without having to put much effort in developing test scenarios.  Also,
writing the formal specifications forces one to think very precisely
about the intended behaviour of programs, which helps in finding
errors.






\subsubsection{Implementation mistakes}
This section presents some examples of common programming
errors, and how we found them using ESC/Java.
% At the begining, when we start to assert this application, we
%had only on hands an informal specification of the classes, seldom
%complete. Several mails after we achieved to have a more detailed informal
%specifications of classes from the GemPlus team, which reflected what
%the source code actually intended for. By taking this informal
%specification, making assertions ESC/Java specification for classes
%and methods and finally running ESC/Java on this asserted code, we
%have found gap points where the source code, specifically classes and
%methods, does not provide their specification. This kind of errors
%could has been found by hand, but using a tool like ESC/Java give us
%the certainty all cases will be considered.



\paragraph{The isGreaterEqualThan method}


The class \texttt{Decimal} 
represents a floating point number 
composed of a decimal part and an integer part,
represented by instance variables \texttt{decPart}
and \texttt{intPart}, respectively. The
method \texttt{isGreaterEqualThan} (see Figure~\ref{fig-cla-dec})
belongs to this class and (as suggested by its name and the informal
documentation) it is supposed to decide whether the
decimal represented by \texttt{this} is greater or equal than the
decimal represented by parameter
\texttt{d}. This behaviour is specified in the method specification.

However, after running ESC/Java on this asserted method, a warning is
issued, suggesting that the postcondition
might not hold. Inspection of the code reveals a
\emph{``copy paste''} error in the fourth \texttt{if} statement, where 
the condition \texttt{decPart > d.getDecPart()}
is tested twice, on both side of an \texttt{||}
(or) operator. Replacing the whole expression
%on line $6$. On this
%line, the same
%condition is checked in both sides of the \emph{or} Java operator. A
%detailed revision of this code show us that this source code really
%implements a supposed \emph{isGreatherThan} method. So, if for example 
%the \texttt{if} guard is replaced 
by \texttt{decPart >= d.getDecPart()} would solve the problem,
although it would probably be better to rewrite the method in such a
way that it simply tests the condition as expressed in the
postcondition.

% this source
%code would implement really what its informal specification aims,
%although this one it would not be the most reduced one. One nicer
%way to do it would consist of taking the \texttt{ensure} clause self,
%for instead.






\paragraph{Final modifiers}

\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
/*@
  modifies jour, mois, annee;
  requires j >= Jour.MIN  && j <= Jour.MAX;
  requires m >= Mois.MIN  && m <= Mois.MAX;
  requires a >= Annee.MIN && a <= Annee.MAX;
  ensures jour == j && annee == a && mois == m;
*/
public void setDate(byte j, byte m, byte a) throws DateException{...} 
\end{verbatim}
\caption{Fragment of class {\tt Date}}
\label{fig-cla-dat}
\rule{\linewidth}{0.3mm}
\end{figure}



The class \texttt{Annee} represents a \textit{year}. It 
declares two
static variables called \texttt{MIN} and \texttt{MAX}, which represent
the minimum and maximum year allowed by the application.
Its declarations are as follows:
\begin{verbatim}
public static byte MIN = (byte)99 ;
public static byte MAX = (byte)127 ;
\end{verbatim}

The class \texttt{Annee} also defines a method \texttt{check}, which is
used to determine whether a value is between \texttt{MIN} and \texttt{MAX}. The
class \texttt{Date} has three instance variables, representing the
components of a date: \texttt{jour} (day),
\texttt{mois} (month), and \texttt{annee} (year). The method
\texttt{setDate} (see Figure~\ref{fig-cla-dat})
in this class assigns its arguments to these
instance variables, provided they are in a valid interval (see the
\texttt{requires} pragma). %In the particular case of the parameter
%that represents a year, \texttt{setDate} uses the
%method \texttt{check} of the \texttt{Annee} class to check this
%value is in range. 
Surprisingly, ESC/Java complains when it
finds a statement such as
\mbox{\tt date.setDate((byte)1, (byte)1, (byte)110);} (where date is a
instance of class \texttt{Date}). The warning message states that the
the third precondition of this call might not hold, even though 110 is 
between 99 and 127.
%third does not verify the third condition. This warning is shown in
%spite of this call respect the
%requires condition, i.e, $110>=99\ \&\&\ 110<= 127$.

The problem is caused by the erroneous declaration of the variables 
\texttt{MIN} and \texttt{MAX} in class \texttt{Annee}.
Since these variables are not declared 
\texttt{final}\footnote{According to the Java semantics, final
variables may only be modified when they are initialised, and
afterwards they remain constant.}, their values can be changed at
runtime by a direct assignment (as they are declared public), and thus
ESC/Java warns correctly that the precondition of \texttt{setDate}
might not be satisfied.








\subsubsection{Class invariants}
Typically, invariants are used to restrict the state space of a class,
\emph{i.e.}~the set of allowed values for its instance variables. The
most common example is an invariant which states that a reference may
never be a null pointer, \emph{e.g.}~the variable
\texttt{purse}, as declared in the class \texttt{PurseApplet}
should never be null.
\begin{verbatim}
//@ invariant purse != null;
\end{verbatim}
Another common example of an invariant is to restrict the possible
values of a numeric variable to a certain range. As remarked above,
the class \texttt{Decimal} says that the value of the decimal fraction
part must be between 0 and 999. Inspection of the code reveals that
the integer part of the decimal number is supposed to be a positive
short, and combining this gives the following class
invariant:\footnote{\texttt{MAX\_DECIMAL\_NUMBER} is equivalent to the
maximal value of a short and the clause \texttt{intPart <=
MAX\_DECIMAL\_NUMBER} of the invariant will thus be ensured by the
type of the variable. We chose to state this explicitly for clarity of
specification.}
\begin{verbatim}
/*@
  invariant decPart >= 0 && decPart < PRECISION ;
  invariant intPart >= 0 && intPart <= MAX_DECIMAL_NUMBER;
*/
\end{verbatim}

Another way to use class invariants, is to improve the simulatation of
enumeration types, which are not available in Java(Card).  To simulate
them, typically several constants with suggestive names are defined
and a variable is silently assumed to contain always one of these
values. This implicit assumption can be made explicit by specifying
invariants. For example, the class \texttt{Transaction} contains the
following declarations.
\begin{verbatim}
public static final byte INDETERMINE		= (byte)0;

public static final byte TYPE_CREDIT		= (byte)50;
public static final byte TYPE_DEBIT		= (byte)51;
    
/* the transaction type: debit or credit*/
/*@ spec_public*/ private byte type;
\end{verbatim}

The documentation above suggests that the variable \texttt{type}
always should have a value \texttt{TYPE\_CREDIT} or
\texttt{TYPE\_DEBIT}. However, in the code (in the method
\texttt{reset()}), an assignment \texttt{type = INDETERMINE;} occurs,
suggesting that this is also a correct value for
\texttt{type}. Having a specification which states the allowed values
for this variable avoids all confusion\footnote{However, notice that
this does not give type safety, in contrast to real enumeration types.}.
\begin{verbatim}
/*@ invariant type == INDETERMINE ||
              type == TYPE_CREDIT || 
              type == TYPE_DEBIT;
*/
\end{verbatim}

Invariants of this kind often occur in the specification of the
electronic purse. It is easy to specify them, and useful as well, as
there are examples in the electronic purse where such implicitly assumed
invariants are violated.
For example, the class \texttt{AccessCondition} declares constants to
state the different access conditions for the actions in the
purse. Following~\cite{BretagneMGL00}, variables that denote access conditions
should be restricted as follows.
\begin{verbatim}
/*@ invariant condition == FREE ||
              condition == LOCKED ||
              condition == SECRET_CODE ||
              condition == SECURE_MESSAGING ||
              condition == (SECRET_CODE | SECURE_MESSAGING);
*/
\end{verbatim}

However, in the constructor of this class, the variable
\texttt{condition} is set to 0, which breaks this
invariant\footnote{As none of these constants is equal to
0.}. Correcting this and maintaining the invariant also allows to
improve other parts of the implementation in this class. For example,
in the method \texttt{verify()}, the following statement occurs:
\begin{verbatim}
switch(condition) {
  case FREE: ...
  case SECRET_CODE: ...
  case SECURE_MESSAGING: ...
  case SECRET_CODE | SECURE_MESSAGING: ...
  case LOCKED: ...
  default: //@ assert false;
           t = AccessConditionException.CONDITION_COURANTE_INVALIDE;
           AccessConditionException.throwIt(t);
  }
\end{verbatim}
Because of the invariant we know that the default case will never
be reached (as ensured by the \texttt{//@ assert false;} annotation,
which states that false should hold, every time this program point is
reached), and thus that the exception never will be thrown. Thus, the
default case can be removed from the code.

Similar cases occur frequently with \texttt{try-catch} statements. An
operation is executed within a \texttt{try}, but as the class invariants
assure that the operation never will throw an exception, the
\texttt{catch} clause will never be executed. In the specification, we 
have annotated these cases with \texttt{//@ assert false;}. We think
that the removal of this ``dead code'' can improve the readability of
the class and, importantly for smart cards, it reduces the 
size of the byte code.


\subsubsection{Miscellaneous aspects of the specification}
There are many other aspects of the specification that are worth
mentioning. Here we mention some.

\begin{itemize}
\item As explained above, in the class \texttt{Decimal}, two shorts
are maintained denoting the integer and the decimal part
(\texttt{intPart} and \texttt{decPart}, respectively) of a decimal
number. The integer part ranges between 0 and
\texttt{MAX\_DECIMAL\_NUMBER} (which is 32767, the maximal value for
shorts). It is left unspecified whether numbers such as
\texttt{MAX\_DECIMAL\_NUMBER}.999 are allowed. However, 
a method \texttt{round()} is defined, which
according to the documentation returns a decimal number with
\texttt{decPart} set to 0 and \texttt{intPart} set to the closest
integer value. An obvious specification of this method reads as
follows:
\begin{verbatim}
/*@ 
  modifies intPart, decPart;
  ensures decPart == 0;
  ensures intPart == (\old(decPart) >= (PRECISION/2) ?
                          (short)(\old(intPart) + 1) :
                             (short)(\old(intPart)))
*/
public Decimal round(){ ... }
\end{verbatim}
But, as pointed out by ESC/Java, an implementation of this
specification breaks the class invariant \texttt{intPart >= 0}. The
counterexample that is produced has
\texttt{intPart} set to \texttt{MAX\_DECIMAL\_NUMBER} and
\texttt{decPart} \emph{e.g.}~to 999. Possible solutions are to
specify explicitly the outcome of \texttt{round()} in the case that
\texttt{intPart == MAX\_DECIMAL\_NUMBER}, or to restrict the set of
valid decimal numbers by further strengthening of the class invariant
through addition of the following clause:
\begin{verbatim}
//@ invariant intPart == MAX_DECIMAL_NUMBER ==> decPart == 0;
\end{verbatim}
We chose this last solution. 

\item Among the developers of the electronic purse application there
apparently have been different ideas about the implementation of the
class \texttt{Decimal} (which could have been avoided if the class
invariants immediately would have been specified explicitly in the
class). The implementation of several
\texttt{setValue(...)} methods
reveal that \texttt{intPart} is assumed to be greater or equal than
0, but on the other hand there are methods
\texttt{isNegatif()} and \texttt{isPositif()}, which test whether a
decimal value is negative or positive, respectively. As we
specify\footnote{\emph{cf.} our email exchange with H. Martin,
Gemplus.} that \texttt{intPart} should be greater or equal than 0
these methods become obsolete. We can show this by specifying that
their results can be predicted, \emph{e.g.}~\texttt{isNegatif()} we
specify as follows:
\begin{verbatim}
/*@ 
  ensures \result == false;
*/
public boolean isNegatif(){ ... }
\end{verbatim}


\item Two classes, \texttt{TransactionRecord} and
\texttt{ExchangeRecord} implement a cyclic table (of
\texttt{Transaction}s and
\texttt{ExchangeSession}s (storing currency changes),
respectively).  These implementations are clearly copied from each
other, but this is nowhere documented. Also the fact that a
cyclic data structure is implemented is not clearly documented. Class
\texttt{TransactionRecord} contains a single remark that it is
implemented as a cyclic table, and for class
\texttt{ExchangeRecord} this is only stated in the documentation of a
private method. Also, no specification of the operations on the cyclic
data structure are given.
As a result, in class \texttt{ExchangeRecord}, part of the code that
<<<<<<< verificard02.tex
is crucial for its ???? has been commented out by other
=======
is crucial for its behaviour has been commented out by other
>>>>>>> 1.19
developers of the electronic purse. Having a formal specification
would probably have been helpful to explain the complexity of the
implementation to the other developers, and the ``wrong correction''
would have been signaled earlier\footnote{Of course, having a general 
implementation of a cyclic table and instantiating this for the
different kinds of data would have been even more elegant.}.

Finally, when writing the formal specifications of the cyclic tables,
we found an error in the implementation. When a delete operation is
called for an element that is not in the range of the table, the
operation nevertheless will be executed and as a side-effect it will
corrupt the table by erroneously moving its first element outside the
range of the table.
\end{itemize}

\section{On the use of ESC/Java}
\label{SectESC}
We find ESC/Java a useful tool, which is pleasant to work with, but
nevertheless we have some suggestions for improvements, both for the
specification language and for the checker.

Concerning the specification language, we feel that certain
specification constructs that are available in JML~\cite{LeavensBR00},
should be provided in ESC/Java as well in order to be able to write
clear and concise specifications. 

First of all, it would be convenient to have some extra specification
constructs for modifies clauses, \emph{e.g.}~\fieldsof(\(E\)), to denote all
the fields of an object, and \noth. This could easily be implemented
as syntactic sugar, in particular \texttt{modifies \noth}.


Another improvement that would be easy to implement, is to enable the
specification of runtime exceptions in \texttt{exsures} clauses,
without mentioning them in the \texttt{throws} clause of the method.

Also we feel that having some extra quantifiers, such as
\texttt{\(\backslash\)min},
\texttt{\(\backslash\)max}, and \texttt{\(\backslash\)choose} could be 
useful to increase expressiveness of the specification
language. However, to implement this would require an extension of the 
theorem prover underlying ESC/Java, so that it also can deal with
these language constructs.

Finally, we would like to be able to use method
names in specifications, as is allowed in JML for so-called
\emph{pure} methods, \emph{i.e.}~methods without
side-effects, but this would require a major change to ESC/Java.


\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
    /*@
      modifies \fields_of(this), \fields_of(date), \fields_of(heure),
               id[*], terminalTC[*], terminalSN[*];
      requires es != null ;
      requires es.id != terminalTC & es.id != terminalSN &
               es.terminalTC != terminalSN;
      ensures this.equal(es);
      exsures (TransactionException e) 
                  e._reason == TransactionException.BUFFER_FULL 
                  && JCSystem._transactionDepth == 1; 
      exsures (NullPointerException) false;
      exsures (ArrayIndexOutOfBoundsException) false;
    */
    void clone(ExchangeSession es) { ...
    } 
\end{verbatim}
\caption{Specification of \texttt{clone} in \texttt{ExchangeSession}
in ideal ESC/Java}
\label{FigIdealESC}
\rule{\linewidth}{0.3mm}
\end{figure}

Figure~\ref{FigIdealESC} shows as an example the
specification of the method \texttt{clone()} in class
\texttt{ExchangeSession} the way we would prefer it (see~\cite{CatanoH01Url} for the
ESC/Java specification as it is). We only specify that all the fields
of the current class may be modified, without explicitly mentioning
them\footnote{In JML this whole modifies clause also can be written
as \texttt{\fieldsof(\reach(this))}, which would probably also be
useful in many cases, but has a more complex semantics.}. As
the fields of the component classes \texttt{date} and
\texttt{heure} may be modified as well, we mention this
explicitly. Similarly, we mention explicitly that the elements in the
arrays \texttt{id}, \texttt{terminalTC} and \texttt{terminalSN} may be
modified. Further, instead of
having postconditions stating that all the fields are ensured to be
equal to the corresponding fields of \texttt{es}, this is denoted by
writing \texttt{this.equal(es)}, where \texttt{equal} is overwritten
appropriately in \texttt{ExchangeSession}.




With respect to the verification that is done by ESC/Java, we found
that it is unfortunate that ESC/Java does not try to check the modifies
clauses, because an incorrect modifies clause can influence the
acceptance of other specifications. For example, suppose one has the
following (annotated) methods$:$
\begin{verbatim}
/*@ modifies x;
    ensures x == 3;
*/
void m() { x = 3;
           n (); }

void n() { x = 4; }
\end{verbatim}
Remember that a method without a modifies clause is assumed to modify
only freshly allocated memory, if any~\cite{LeinoNS00}. The
specification for method \texttt{m()} is thus accepted by ESC/Java,
although it is incorrect. When annotating existing programs, as we
did, it is easy to forget to mention that a variable may be modified,
and we felt the need to overcome this problem.

Therefore, we have implemented a static checker for modifies
clauses. In the tradition of ESC/Java, this checker is designed to be
efficient, but it is neither sound, nor complete. It does a syntactic
analysis of the annotated program to recognise the various assignment
statements and then checks whether the variables that are the
``destination'' of an assignment are appropriately specified in the
corresponding modifies clauses. This checker will be described in more
detail in a separate paper~\cite{CatanoH02b}.

Finally, we feel that it would be an important improvement if the
ESC/Java theorem prover would deal more precisely with arithmetic
operations (also on bytes and shorts). For example, the current
version of ESC/Java issues a warning for the following specification.
\begin{verbatim}
/*@ requires b == (byte)4 & d == (byte)8;
    ensures \result >= 0;
*/
byte m(byte d) {return (byte)(b | d);}
\end{verbatim}
We found that almost all spurious warnings that are produced by
ESC/Java are caused by arithmetic operations\footnote{Warnings about
loops are not considered to be spurious, as they are inherent to how
ESC/Java works.} and it would be a significant improvement if less of
these warnings would be generated.

%For example, several times we needed
%for \emph{e.g.}~a byte \texttt{b} with a value between 0 and 10, but
%after
%the operation \texttt{b++} this variable still has a positive value.






\section{Conclusions}
\label{SectConcl}

We have presented a case study in formal specification of smart card
programs, using ESC/Java. We have taken an electronic purse
application and annotated it with a functional specification,
describing its behaviour, basing ourselves on the informal
documentation of the application. We have checked the implementation
\emph{w.r.t.}~the specification, using ESC/Java, thereby revealing
several errors in the implementation. Using ESC/Java we were also able 
to find that some parts of the program will never be reached, thus
allowing reduction of the code size -- which is important for smart
card applications. 

The whole case study consists of 42 classes and 432 kB in total (736
kB with annotations).  It has taken approximately three months to
write the complete specifications. Most of the specifications are
written by the first author, who beforehand did not have any
experience with ESC/Java, or with writing formal specifications in
general. The second author -- who had experience in writing formal
specifications, but not with ESC/Java -- supervised the work and made
suggestions to extend the specifications. Of the time spend on writing
the specifications, approximately one third was used on getting to
know ESC/Java, and understanding the electronic purse application, the
remaining time was used on writing and checking the actual
specifications.


The errors that we found in general are not very intricate, they could
have been found by careful code-inspection or testing. But, writing
the formal specification (for existing code) forces one to do
code-inspection, and having the theorem prover ensures that all
cases are considered, when checking the specification, without having
to put effort in writing appropriate test scenarios.

The specifications that we have constructed for the electronic purse
application are not very complex, but describe the functional
behaviour of methods as precisely as possible. Nevertheless, we found
errors in the code, and we would like to emphasise that even simple
formal verification can help significantly to increase confidence in a
program. In particular, explicitly specifying class invariants --
which are often implicitly assumed by the program -- turns
out to be very useful.

\subsubsection{Future work} We plan to work in the field of
specification languages for Java: how to improve them, and how to
develop appropriate verification techniques for them. In particular,
we will focus on the following points.
\begin{itemize}
\item We plan to develop a full smart card application from scratch, with
annotations. We are interested whether this will affect the quality of 
the specification and/or the program. Also we would like to know how
easy it is to construct the specifications at the same time as
developing the code. We would like to evaluate the tradeoff between
usability -- because one gets immediate
feedback on an implementation -- and the extra time that
is spend on keeping the specification up-to-date.
\item Future versions of JavaCard will probably allow
multi-threading. Therefore we plan to study how ESC/Java (and JML)
can be used to specify (and check) concurrent programs.
\item Related with this is an extension of JML with
temporal logic. Currently we are studying how to integrate temporal
logic in the specification language, future work will be to study
appropriate verification techniques. 
\item Most loop structures that are used in typical smart card
programs are very restricted and it is relatively easy to show their
termination. We plan to develop an automated verification technique for
termination of loops in the tradition of ESC/Java, covering the most
common cases.
\item We skipped the cryptographic aspects of the application at
hand. It is future work to see whether ESC/Java (or JML) is useful to
specify such algorithms more precisely, and to develop appropriate
(automated) verification techniques.
\end{itemize}

\section*{Acknowledgements}
We thank Erik Poll, Dilian Gurov and Arnd Poetzsch-Heffter for useful
feedback on the specifications and on earlier versions of this
paper. Also we would like to thank Rustan Leino and his team for their 
help with ESC/Java.
\bibliographystyle{plain}
\bibliography{../specification}

\end{document}

