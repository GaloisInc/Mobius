\section{Conclusion and Future Work}\label{conclusion}
This article describes a bytecode weakest precondition calculus applied to a bytecode specification language (BCSL).
BCSL is defined as suitable extensions of the Java class file format.
Implementations for a proof obligation generator and a JML compiler to BCSL have been developed and are part of the Jack 1.8 release\footnote{http://www-sop.inria.fr/everest/soft/Jack/jack.html}.
At this step, we have built a framework for Java program verification. This validation can be done at source or at bytecode level in a common environment: for instance, to prove lemmas ensuring bytecode correctness all the current and future provers plugged in Jack can be used.

 We envisage several directions for future work:
\begin{itemize}
  \item perform case studies
  \item find an appropriate representation of code certificates for the PCC architecture described in Section \ref{architecture}
  where the proofs are done interactively over the source code. We aim to establish formally that nonoptimizing source compilation
preserves proof obligations modulo names and basic types as discussed in the previous Section \ref{pogEquiv}.
   
% As we discussed in Section \ref{results} in the performed tests the 
%proof obligations generated over a source program and over its compilation with non optimizing compiler are
% syntactically the same modulo names and basic types. We aim to establish formally this property.  
  \item an extension of the framework applying previous research results in automated annotation generation for
 Java bytecode (see~\cite{PBBHL}). The client thus will establish that the code respects his security policy %have the possibility to verify a security policy by
by first propagating automatically annotations in the loaded code and then verifying the resulting annotated code.

\end{itemize}

%\todo{je ne sais pas ou mettre la reference de Jver}


