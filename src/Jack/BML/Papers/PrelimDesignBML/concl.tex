\section{Conclusions and related work}\label{SecConcl}

This paper presents the Bytecode Modeling Language (BML). Its syntax
and semantics are directly inspired by JML, and it is possible to
translate JML specifications into BML specifications in a fairly
direct way. The BML language as we have defined it now, corresponds
roughly to JML level 0, \emph{i.e.}\ that part of JML whose semantics
is relatively well understood. However, more advanced constructs of
JML can be easily added to BML, if required. 

\begin{figure}[t]
\includegraphics[width=\textwidth]{toolset.eps} 
\caption{Overview of \mobius tool set}\label{FigToolSet}
\end{figure}
As part of the \mobius project, we plan to develop a tool set that
supports both JML and BML. Figure~\ref{FigToolSet} outlines the
general architecture of this tool set. Thus, both Java/JML and
bytecode/BML can be used as input application. For both specification
languages, verification condition generators are used to generate
appropriate proof obligations that can be discharged with a theorem
prover (either automatic or interactive). To support the proof
carrying code platform, the provers will be instrumented to produce
certificates. In addition, source code applications annotated with JML
can be compiled into bytecode annotated with BML.

The development of the JML subcomponent of the tool set will be based
on experiences with ESC/Java~\cite{CokK04} and JACK~\cite{BurdyRL03}.
Several tools and algorithms (notably the compiler and the
verification condition generator) for BML have already been
implemented, see~\cite{BurdyP06}, but more work is needed to cover the
whole language. Moreover, to make the tool set usable in practice, we
will also need a tool to inspect and write directly BML
specifications, and a run-time checker for BML specifications. The
latter can be implemented by a code transformation, inserting explicit
run-time checks in the bytecode, or by extending the virtual machine
to take the user-specific attributes with specifications into account;

Our initial experiments with compilation of specifications has shown
that there exists indeed a correspondence between the proof
obligations generated at source and at bytecode level, modulo
differences in elimination of trivial goals, handling of arithmetic
expressions, and the naming convention of generated
variables. Moreover, when the proofs are done with the Coq prover,
different names are generated for hypotheses at source code and
bytecode level. It is future work to clean up the compilation, so
there is a one-to-one correspondence.




 

\subsection*{Related work}
The interest in specification and verification of bytecode
applications is quite recent, and not too much work has been done in
that direction. Several logics have been developed to reason about
bytecode, \emph{e.g.}~by Bannwart \& M\"uller~\cite{BannwartMueller05}
and within the MRG project~\cite{AspinallEtAl:TPHOLs2004}. However,
in this work, no attention is given to how one can conveniently write
understandable specifications for bytecode.

The development of BML is clearly inspired by the development of the
JML specification language~\cite{JMLReferenceManual05}. Both JML and
BML follow the Design by Contract principle introduced first in
Eiffel~\cite{Meyer97}. The Boogie project~\cite{BarnettCDJL05}
introduces in similarly the Design by Contract principles into the C\#
programming language, both at source code level and for CIL, the .NET
intermediate language.  The possibility to check a property at
run-time, using the \texttt{assert} construct, has been long 
adopted in the C programming language and recently also in Java (Java
1.5, see \cite[\S 14.10]{JLS}). 

Finally, we should mention the Extended Virtual Platform
project\footnote{See
\url{http://www.cs.usm.maine.edu/~mroyer/xvp/}.}. This project aims at
developing a framework that allows to compile JML annotations, to
allow run-time checking~\cite{AlagicXVP05}. However, in contrast to
our work, they do not intend to do static verification of bytecode
programs. Moreover, their platform takes JML-annotated source code
files as starting point, while with BML one is able to annotate
bytecode applications directly\footnote{Some security-critical
applications are written in bytecode directly, to avoid security
problems related with compilation. Thus, for such applications one
needs to be able to specify and verify them directly at this level.}.



\subsection*{Acknowledgements}
We thank Lennart Beringer and Olha Shkaravska for discussions about
the semantics of BML. 
