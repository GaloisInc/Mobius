\documentclass[a4paper]{llncs}

% \usepackage{latexsym}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{url}
\usepackage{alltt}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{listings}
\usepackage{longtable}

\def\lstlanguagefiles{../../THESIS/Jml.sty}
\lstloadlanguages{Jml}
\lstset{language=Jml,flexiblecolumns=false}


\input{cmd.tex}

% to be removed in final version
\pagestyle{plain}

\title{Preliminary Design of BML: A Behavioral Interface Specification 
Language for Java bytecode}

\author{
  Lilian Burdy
\and 
  Marieke Huisman
\and
  Mariela Pavlova}

\institute{
  INRIA Sophia Antipolis, France \\ 
  \email{Lilian.Burdy@sophia.inria.fr, 
         Marieke.Huisman@sophia.inria.fr,
         Mariela.Pavlova@sophia.inria.fr}
}



\begin{document}

\maketitle


\begin{abstract}
\end{abstract}



\section{Introduction}
\label{IntroSectLab}
Program verification important in general, and for bytecode programs.

Before going further, we discuss what advocates the need of a low
level specification language.  Traditionally, specification languages
were tailored for high level languages.  Source specification allows
to express complex functional or security properties about programs.
Thus, they are successfully be used for software audit and
validation. Still, source specification in the context of mobile code
does not help a lot for several reasons.


First, the executable or interpreted code may not be accompanied by
its specified source. Second, it is more reasonable for the code
receiver to check the executable code than its source code, especially
if he is not willing to trust the compiler. Third, if the client has
complex requirements and even if the code respects them, in order to
establish them, the code should be specified. Of course, for
properties like well typedness this specification can be inferred
automatically, but in the general case this problem is not
decidable. Thus, for more sophisticated policies, an automatic
inference will not work.


Over the last few years, JML has become the \emph{de facto}
specification language for Java source code programs. Different tools
exist that allow to validate, verify or generate JML specifications
(see~\cite{BurdyCCEKLLP05} for an overview). Several case
studies have demonstrated that JML can be used to specify realistic
industrial examples, and that the different tools allow to find errors
in the implementations (see e.g.~\cite{BreunesseCHJ04}). One
of the reasons for its success is that JML uses a Java-like
syntax. Specifications are written using preconditions, postcondition,
class invariants and other annotations, where the different predicates
are side-effect-free Java expressions, extended with
specification-specific keywords (e.g.~logical quantifiers and a
keyword to refer to the return value of a method). Other important
factors for the success of JML are its expressiveness and
flexibility. In Deliverable D1.2 we show how JML can be used (and
extended) to express the different security requirements that have
been identified to be of interest for the project.


Therefore, to specify Java bytecode programs, we define a variation
of JML, which is especially tailored to bytecode. This section
presents this specification language, which we call BML, short for
Bytecode Modeling Language. BML is designed to be the counterpart of
JML at bytecode level. It allows to compile specifications at source
code level into specifications at bytecode level, basically by
compiling the source code predicates into bytecode predicates and
leaving all other parts of the specification unchanged.

BML supports the most important features of JML. Thus, we can express
functional properties of Java bytecode programs in the form of method
pre and postconditions, class and object invariants, assertions for
particular program points like loop invariants. To our knowledge BML
does not have predecessors that are tailored to Java bytecode.

In section~\ref{SecJMLOverview}, we give a quick summary of the main
features of JML. Section~\ref{SecBML} then gives a detailed
account of BML, describing its syntax, the relationship with JML and where
its semantics differs from the JML
semantics. Section~\ref{SecClassfile} then proposes a
format in which BML specifications can be stored in the appropriate
class files (just as JML specifications can be written as special
comments in the Java source code). Finally, Section~\ref{SecJMLtoBML}
discusses the compilation process from JML to BML, while
Section~\ref{SecConcl} wraps up, and in particular discusses future
work.


\ref{sec:bml:overview}.  As we stated before, we support also a compiler
from the high level specification language JML into BML. The
compilation process from JML to BML is discussed in section
\ref{BCSLcompile}.  The full specification of the new user defined
Java attributes in which the JML specification is compiled is given in
the appendix.

Below, we will first present the syntax of BML, discuss its relation
with JML and give a specification example. 

The semantics of BML specifications can be described in terms of the
\mobius base logic. The next section proposes a
deep embedding of an assertion language. This deep embedding gives a
meaning to BML predicates, which is then used in
Section~\ref{sec:bmltobase} to define a translation
of BML specifications into judgements of the \mobius base logic.

\section{A short overview of JML}\ref{SecJMLOverview}

JML~\cite{JMLRefMan} (short for Java Modeling Language) is a behavioral interface specification 
language tailored to Java applications which follows the design-by-contract approach (see~\cite{M97oos}).

% useful language
Over the last few years, JML has become the de facto specification language for
 Java source code programs. Several case studies have demonstrated that JML can be used to specify realistic
industrial examples, and that the different tools allow to find errors
in the implementations (see~e.g. \/~\cite{BreunesseCHJ04}). One
of the reasons for its success is that JML uses a Java-like
syntax.  Other important factors for the success of JML are its expressiveness and
flexibility.

% tool support 
JML is supported by several verification tools.
 Originally, it has been designed as a language of the runtime assertion checker~\cite{jmlrac} created by G.T. Leavens and \todo{who are the others}. 
The JML runtime assertion checker compiles both the Java code and the JML specification into executable bytecode and thus, 
in this case, the verification consists in executing the resulting bytecode. Several static checkers based 
on formal logic exist which use JML as a specification language. Esc/java~\cite{escjava}  whose first version used a subset 
 of JML \footnote{the current version of the tool esc/java 2  supports almost all JML constructs} is among the first tools supporting JML.
Among the static checkers with JML  are
the Loop tool developed by the Formal group at the University of Nijmegen,
the Jack tool developed at Gemplus, the Krakatoa tool created by the Coq group at Inria, France.
The tool Daikon \cite{ECG01DDL}  tool uses a subset of JML for detecting loop invariants by run of programs.
 A  detailed overview of the tools which support JML can  be found in~\cite{BurdyCCEKLLP05}.



% technical details
    Specifications in JML are written using different predicates
    which are side-effect free Java expressions, extended with
    specification-specific keywords. JML specifications are written as comments so they are not
    visible by Java compilers. The JML syntax is close to the Java syntax: JML extends the Java
    syntax with few keywords and operators. 
    For introducing method precondition and postcondition the keywords \jmlKey{requires} and \jmlKey{ensures} are used  
    respectively,  \jmlKey{modifies} keyword introduces the locations that can be modified by the method, 
    \jmlKey{loop\_invariant} stands for a loop invariant, the \jmlKey{loop\_modifies} keyword gives the 
    locations modified by a loop etc. The latter is not standard in JML and is an extension introduced in~\cite{BRL-JACK}.
    Special JML operators are, for instance, \jmlKey{$\backslash$result} which stands for the value that a method returns if it is not
    void, the \jmlKey{$\backslash$old(expression)} operator 
    designates the value of \jmlKey{expression} in the prestate of a method and is usually
    used in the method's postcondition.


     
Figure~\ref{replaceSrc} gives an example of a Java class that models a list stored in a private array field. 
The method \texttt{replace} will search in the array for the first occurence of the object \texttt{obj1} passed as first argument
 and if found, it will be replaced with the object passed as second argument \texttt{obj2} and the method will return true; otherwise it 
returns false. Thus the method  specification between lines 5 and 9 which exposes the method contract states the following.
First the precondition (line 5 ) requires from any caller to assure that the instance variable \texttt{list} is not \texttt{null}.
The frame condition (line  6) states that the method may only
modify any of the elements in the instance field \texttt{list}. The method postcondition (lines 7---9) states the method will return 
\texttt{true} only if  the replacement has been done.
The method body contains a loop (lines 17---22) which is specified with a loop fame condition and a loop invariant (lines 13---16).
  The loop invariant (lines 14---16) says that all the elements of the list that are inspected up to now are 
different from the parameter object \texttt{obj1} as well as the local variable \texttt{i}  is a valid index in the array \texttt{list}.
The loop frame condition (line 13)  states that only
 the local variable \texttt{i} and any element of the array field \texttt{list} may be modified in the loop.

\lstset{numbers=left,numberstyle=\small,stepnumber=1,numbersep=5pt}
\begin{figure}[ht!]
\begin{lstlisting}[frame=trbl] 
public class ListArray {
  
  private Object[] list;
  
  //@ requires list != null;
  //@ modifies list[*];
  //@ ensures \result ==(\exists int i; 
  //@         0 <= i && i < list.length && 
  //@         \old(list[i]) == obj1 && list[i] == obj2);
  public boolean replace(Object obj1,Object obj2){
    int i = 0;
    
    //@ loop_modifies i, list[*];
    //@ loop_invariant i <= list.length && i >=0 
    //@ && (\forall int k;0 <= k && k < i ==> 
    //@     list[k] != obj1);
    for (i = 0; i < list.length; i++ ){
      if ( list[i] == obj1){
        list[i] = obj2;
        return true;	
      }
    }
    return false;
  }
}
\end{lstlisting}
\caption{\sc class \mbox{\rm \lstinline!ListArray!} with JML annotations} 
\label{replaceSrc}
\end{figure}

 JML also allows the declaration of special JML variables, that are used only for specification purposes. 
 These variables are declared in comments with the \jmlKey{ghost} modificator and may be used only in specification clauses. Those variables 
 can also be assigned. Ghost variables are usually used  for expressing properties which can not be expressed with the program variables.

 Fig. \ref{bml:ghost} is an example for how ghost variables are used. The example shows the class \texttt{Transaction}
 which manages transactions in the program. The class is provided with a method for opening transactions \texttt{beginTransaction } and 
 a method for closing transactions (\texttt{commitTransaction}).  The specification declares a ghost variable
 \texttt{TRANS} (line 3) which keeps track if there is  a running transaction or not, i.e. if the value of  \texttt{TRANS} is 0
 then there is no running transaction and if it has value 1 then there is
 a running transaction. The specification of the methods \texttt{beginTransaction } and \texttt{commitTransaction}
 models the property for no nested transactions. Thus, when the method  \texttt{beginTransaction } is invoked the precondition (line 5) requires
 that there should be no running transaction and when the method is terminated the postcondition guarantees (line 6) that there is already a transaction running.
 We can also remark that the variable  \texttt{TRANS} is set to its new value (line 8) in the  body  \texttt{beginTransaction}.
 Note that this high level property is difficult to express without the presence
 of the ghost variable \texttt{TRANS}.  

\begin{figure}[ht!]
\begin{lstlisting}[frame=trbl] 
public class Transaction {

  //@ ghost static private int TRANS = 0; 
  
  //@ requires TRANS == 0;
  //@ ensures TRANS == 1;
  public void  beginTransaction() {
    //@ set TRANS = 1;
     ...
  }

  //@ requires TRANS == 1;
  //@ ensures TRANS == 0;
  public void  commitTransaction() {
    //@ set TRANS = 0; 
     ...
  }
  
}
\end{lstlisting}
\caption{\sc specifying No Nested Transaction property with ghost variable} 
\label{bml:ghost}
\end{figure}

% light and heavy weight specification
A useful feature of JML is that it allows two kinds of method specification, a \light  \ and \heavy \ weight specification. 
An example for a \light \  specification is the annotation of method \texttt{replace} (lines 5---9) in Fig. \ref{replaceSrc}. The specification in 
the example states what is the expected behavior of the method and under what conditions it might be called.
The user, however in JML, has also the possibility
to write very detailed method specifications. This style of specification is called a \heavy  \ weight specification.
 It is introduced by the JML keywords \jmlKey{normal\_behavior} and \jmlKey{exceptional\_behavior}. As the keywords
suggest every of them specifies a specific normal or exceptional behavior of a method.  (see \cite{PD06LBR}). 

The keyword  \jmlKey{normal\_behavior} introduces a precondition, frame condition and postcondition 
such that if the precondition holds in the prestate of the
 method then the method will terminate normally and the postcondition will hold in the poststate.
 Note that this clause guarantees that the method will not terminate on an exception and thus the exceptional postcondition 
for any kind of exception (i.e. for the exception class  \texttt{Exception}) is  \jmlKey{false}.
% example for heavy weight specification
An example for a \heavy \ weight specification is given in Fig. \ref{bml:heavySp}. In the figure, method \texttt{divide} has 
two behaviors, one in case the method terminates normally (lines 11---14) and the other (lines 17---20) in case the method
 terminates by throwing an object reference of \texttt{ArithmeticException}.
 In the normal behavior case, the exceptional postcondition is ommitted  specification as by default if the precondition (line 12 )
 holds this assures that no exceptional
 termination is possible. Another observation over the example is that the exceptional behavior is introduced with the JML keyword \jmlKey{also}. 
 The keyword  \jmlKey{also} serves for introducing every new behavior of a method except the first one. Note that the keyword \jmlKey{also} 
 is used in case a  method overrides a method from the super class. In this case, the method specification (\heavy \ or \light \ weight) is preceded by the keyword \jmlKey{also} 
 to indicate that the method should respect also the specification of the super method.


   
\begin{figure}
\begin{lstlisting}[frame=trbl]
public class C {
    int a;
    
    //@ public instance invariant a > 0 ;
    
    //@ requires val > 0 ;
    public C(int val){
       a = val ;
    }
   
    //@ public normal_behavior
    //@ requires b > 0;
    //@ modifies a;
    //@ ensures  a == \old(a) / b;  
    //@
    //@ also 
    //@ public exceptional_behavior
    //@ requires b == 0;
    //@ modifies \nothing;
    //@ exsures (ArithmeticException) a == \old(a);
    public void divide(int b) {
        a = a / b;
    }
}
\end{lstlisting}
\caption{\sc An example for a method with a heavy weight specification in JML} \label{bml:heavySp}
\end{figure}

JML can be used to specify not only methods but also properties of a class or interfaces. 
A Java class may be specified with an invariant or history constraints. An invariant of a class is a predicate which holds at all visible states of
  every object of this class (see for the definition of visible state in the JML reference manual \cite{december-jml}). An invariant may be either static 
 (i.e. talks only about static fields) or instance (talks about instance fields).
  A Class history constraints is a property which relates the initial and terminal state of every method in the corresponding class. 
 The class \texttt{C}  in Fig.\ref{bml:heavySp} has also an instance invariant which states that the instance variable \texttt{a} is
 always greater than \texttt{0}.



\section{The Bytecode Modeling Language}
\label{SecBML}


\subsection{Syntax of BML}

Basically, BML has the same syntax as JML with two exceptions:
\begin{enumerate}
\item specifications are not written directly in the program code,
they are added as special attributes to the bytecode; and
\item the grammar for expressions only allows bytecode expressions.
\end{enumerate}

With respect to the expression syntax, this means concretely that
field names, class names etc.\ are replaced by constants, using
the constant pool, while registers are used to refer to local
variables. In addition, we can use stack expressions and the stack
counter to describe intermediate states of a computation. These will
typically only appear in intermediate assertions, we do not use them
in method specifications. Finally, we add a special expression
\texttt{length(\(a\))}, denoting the length of array \(a\). Since the 
source code expression \texttt{\(a\).length} is compiled into a
special bytecode instruction \texttt{arraylength}, we also need a
special specification construct for this at bytecode level.

BML contains equivalent constructs for all specification constructs of
JML Level 0 (see~\cite[\S2.9]{JMLReferenceManual05}), which defines
the features that should be understood and checked by all JML
tools. In addition, it contains several constructs from JML level 1,
that we find important to be able to write meaningful specifications
for the example applications studied in the \mobius project. These
constructs are:
\begin{itemize}
\item static invariants;
\item object and static history constraints; and 
\item loop variants (using the \texttt{decreasing} keyword).
\end{itemize}

At the moment, the use of pure methods is not part of the BML grammar,
as there is still ongoing research on the exact semantics of method
calls used in specifications. However, we believe that if the
theoretical issues have been settled, eventually the
\mobius tool set should support this, both at source code and at 
bytecode level. Finally, experiences with verification of realistic case
studies have shown that it is beneficial to have a special clause
\texttt{loop-modifies}, which is specified together with the loop
invariant. This clause specifies which variables
\emph{may} be modified by a loop (as an \texttt{assignable} clause does
for a method). This \texttt{loop-modifies} clause allows to write
concise specifications, and to efficiently generate proof obligations
using a weakest precondition calculus.

\begin{figure}[t]

\begin{tabular}{lll}
\multicolumn{2}{l}{\emph{primary-suffix} := \texttt{(} [\emph{expression-list}] \texttt{)}}\\
\hspace*{1cm}& \(\mid\) \texttt{[} \emph{expression} \texttt{]}\\
\multicolumn{2}{l}{\emph{primary-expr} ::= 
\texttt{\#}\emph{natural}} & \% reference in the constant pool \\
&\(\mid\) \texttt{lv[}\emph{natural}\texttt{]} &\% local variable \\
&\(\mid\) \texttt{length(}\emph{expression}\texttt{)} &\% array
length \\
&\(\mid\) \texttt{cntr} &\% counter of the operand stack\\
&\(\mid\) \texttt{st(}\emph{additive-expr}\texttt{)} &\% stack
expressions\\
&\(\mid\) \emph{constant} \(\mid\)
\texttt{super}\\
&\(\mid\) \texttt{true} \(\mid\) \texttt{false} \(\mid\)
\texttt{this} \(\mid\) \texttt{null} \\
&\(\mid\) \texttt{(}\emph{expression}\texttt{)}\\
&\(\mid\) \emph{jml-primary}\\
\\
\multicolumn{2}{l}{\emph{store-ref-expression} := \emph{store-ref-name}
[\emph{store-ref-name-suffix}]}\\
\multicolumn{2}{l}{\emph{store-ref-name} := 
\texttt{\#}\emph{natural}} &\% reference in the constant pool \\
&\(\mid\)\texttt{super} \(\mid\) \texttt{this}\\
\multicolumn{2}{l}{\emph{store-ref-name-suffix} := 
\texttt{(}\emph{store-ref-expression}\texttt{)}}\\
&\(\mid\) \texttt{[}\emph{spec-array-ref-expr}\texttt{]}
\end{tabular}

\caption{Grammar for BML predicates and specification expressions}
\label{FigBMLGrammar}
\end{figure}

Since the bytecode and BML specifications are two separate entities,
they should be parsed independently. Concretely this means that the
grammar of BML is similar to the grammar of type specifications,
method specifications and data groups of JML~\cite[\S A.5, A.6,
A.7]{JMLReferenceManual05}, restricted to the constructs in JML level
0, plus the constructs of JML level 1 mentioned, but with the changes
to the grammar for predicates and specification expressions, as
mentioned above. Figure~\ref{FigBMLGrammar} displays the most
interesting part of this grammar for predicates and specification
expressions, defining the syntax for primary expressions, primary
suffixes, store-ref expressions and store-ref expressions (see
Appendix~\ref{AppBML} for a short explanation of the syntax notation
and the full grammar of predicates and specification
expressions). Primary expressions, followed by zero or more primary
suffixes, are the most basic form of expressions, formed by
identifiers, bracketed expressions
\emph{etc}. Store ref expressions (followed by zero or more store ref 
suffixes) are the expressions that can be used in an assignable
clause.

As mentioned above, all identifiers are replaced by references to the
constant pool (a number, preceded by the symbol
\texttt{\#}) or to local registers. The local register \texttt{lv[0]}
of a non-static method always contains the implicit argument
\texttt{this}, the other registers contain the parameters and the
local variables declared inside a method body. As explained above, we
add special keywords to be able to express properties about the length
of an array, the current stack counter (\texttt{cntr}), and to refer
to an element on the stack (\texttt{st(\(e\))}, where \(e\) is some
arithmetic expression). In BML, a field access is written as a function
application. For example, suppose we have the source code qualified expression
\texttt{obj.f}, where \texttt{obj} is the first parameter of a
method, and \texttt{f} is a field of this object. This becomes
\texttt{\#\(n\)(lv[1])} in BML, where \(n\) is the index in the
constant pool to the field constant reference denoting the field
\texttt{f}, while \texttt{lv[1]} is the register in the local variable
array in which the parameter \texttt{obj} is stored.  Therefore the
grammar for \emph{primary-suffixes} and \emph{store-ref-name-suffixes}
does not provide any grammar for qualified expressions.


In JML, many special keywords are preceded by the symbol
\texttt{\bsl}, to ensure that they will not clash with variable
names. For BML, we do not have to worry about this: all
variable names are replaced by references to the constant pool or
local variable registers. Therefore, the new keywords are written
without a special preceding symbol. However, for convenience, we keep
the symbol for keywords that are also JML keywords.

Finally, statement annotations are described as a special attribute,
mapping line numbers to annotations. To parse these annotations, we
reuse the relevant parts of the grammar for statements and annotation
statements~\cite[\S A.9]{JMLReferenceManual05}.

Type checking of the specification can be done in the obvious way,
using the type information stored in the constant pool.

\subsection{An example BML specification}
\label{sec:bml:example}


\begin{figure}
{\small
\begin{verbatim}
{| requires lv[1] > 0 
   ensures #24 <= \old(#24) + lv[1] * (lv[1] + 1) / 2 |}
 0 iconst_1
 1 istore_2
 2 goto 22 (+20)
 5 aload_0
 6 aload_0
 7 getfield #24 <Bill.sum>
10 aload_0
11 iload_2
12 invokevirtual #26 <Bill.round_cost>
15 iadd
16 putfield #24 <Bill.sum>
19 iinc 2 by 1
loop_invariant lv[2] <= lv[1] + 1 && #24 <= \old(#24) + (lv[2] + 1) * lv[2]/2
entry loop:
22 iload_2
23 iload_1
24 if_icmple 5 (-19)
27 iconst_1
28 ireturn
29 astore_3
30 iconst_0
31 ireturn
\end{verbatim}
}
\caption{Bytecode + BML specification for method \texttt{produce\unsc bill} in class \texttt{Bill}}\label{FigBMLSpec}
\end{figure}

To show a typical BML specification, Figure~\ref{FigBMLSpec} presents
the BML version of the specification of method \texttt{produce\_bill}
of the running example (see Figure~\ref{fig:running-example} on
page~\pageref{fig:running-example} for the JML specification). Notice
that the field \texttt{sum} has been assigned the number 24 in the
constant pool. Further, \texttt{lv[1]} denotes the parameter
\texttt{n}, and \texttt{lv[2]} denotes the local variable \texttt{i}.
 
The class invariant gives rise to the following BML specification
(stored in the class file as a special user-specific attribute, as
explained below):

\begin{verbatim}
invariant:  #24 >= 0
\end{verbatim}

%This class contains a
%private, but \texttt{spec\unsc public} (i.e.~publicly visible
%in specifications) field
%\texttt{list}, which is an array of objects. The class invariant says
%that \texttt{list} is not null, and in addition, its elements are
%never null.  Further, the class contains a method \texttt{replace},
%which checks if its first parameter \texttt{obj1} occurs in
%\texttt{list}, and if this is the case, replaces it (once) by its
%second parameter \texttt{obj2}. 

%\begin{figure}[t!]
%{\small
%\begin{verbatim}
%public class ListArray {
%//*@ spec_public @*/ private Object[] list;
%//@ invariant list != null && \nonnullelements(list);
	
%/*@ requires obj2 != null;
%  @ assignable list[*];
%  @ ensures \result == (\exists int i; 0 <= i && i < list.length && 
%  @                                    \old(list[i]) == obj1 && list[i] == obj2);
%  @*/ 
%  public boolean replace(Object obj1,Object obj2)
%  {
%    int i = 0;
%    /*@ loop_modifies this[*];
%      @ loop_invariant 0 <= i && i <= list.length && 
%      @                (\forall int k; 0 <= k && k < i ==> list[k] != obj1);
%      @*/ 
%    for (i = 0; i < list.length; i++ ) {
%      if ( list[i] == obj1) { list[i] = obj2; return true; }}
%    return false; }
%}
%\end{verbatim}
%}
%\caption{JML specification for class \texttt{ListArray}}\label{FigJMLSpec}
%\end{figure}


\subsection{Evaluation of BML expressions}

When defining the evaluation of BML expressions, a subtle point that
has to be taken into account is the fact that at bytecode level no
explicit boolean values are used, they are encoded as integers (but
variables can still be of type \texttt{boolean} --- this information is
used by the BCV). Thus, to make sure that expressions such as
\texttt{\bsl result == \bsl exists i. i >= 0} are correctly evaluated,
the evaluation of the quantified expression is wrapped up by a
conditional function, returning 1 if the condition is true, 0
otherwise.



\section{Encoding BML specifications in the class file format}
\label{SecClassfile}

To store BML specifications together with the bytecode that it
specifies, we need a way to encode them in the class file format. We
do this using so-called user-specific attributes for Java class files.

\begin{itemize}
\item \textbf{Java compiler independance } 
Class files containing BML specification must not depend on any non
optimizing compiler.
    
      To do this, the process of the Java source compilation is
      separate from the JML compilation. More particularly, the
      \JMLtoBML (short for the compiler from JML to BML) \ compiler
      takes as input a Java source file annotated with JML
      specification and its Java class produced by a non optimizing
      compiler containing a debug information.% As we shall see later
      in the coming sections, the debug data plays a role in the
      compilation of the JML specification into BML.
      
      %In other words, we would like that the compilation of BML specification  is not attached to a particular Java compiler. 
      %This makes BML independant from Java source compilation.
      % Note, however that we impose as a restriction that the compiler should be not optimizing. 
       % generating debug information~\footnote{the debug information is necessary for the compilation
      % from JML to BML as we shall see in the coming sections}.

\item \textbf{JVM compatibility } 
            The class files augmented with the BML specification must
            be executable by any implementation of the JVM
            specification.  % why do we do so?  Because the JVM
            specification does not allow inlining of any user specific
            data in the bytecode instructions BML annotations must be
            stored separately from the method body (the list of
            bytecode instructions which represents its body).
	  
	    
	    % how 

In particular, the BML specification is written in the so called user
defined attributes in the class file.  The JVM specification defines
the format of those attributes and mandates that any user specific
information should be stored in such attributes. Note, that attribute
which encodes the specification referring to a particular bytecode
instruction contains information about the index of this
instruction. For instance, BML loop invariants are stored in a user
defined attribute in the class file format which contains the
invariant as well as the index of the entry point instruction of the
loop.
	    
	    %comparison

	    Thus, BML encoding is different from the encoding of JML
	    specification where annotations are written directly in
	    the source text as comments at a particular point in the
	    program text or accompany a particular program
	    structure. For instance, in Fig. \ref{replaceSrc} the
	    reader may notice that the loop specification refers to
	    the control structure which follows after the
	    specification and which corresponds to the loop.  This is
	    possible first because the Java source language is
	    structured, and second because writing comments in the
	    source text does not violate the Java or the JVM
	    specifications.
	  

            %  However, on bytecode level we
	    %  could not write directly in the bytecode of a method body, as this will corrupt the performance of any standard Java Virtual Machine.
	    %  That's why specification is written outside the bytecode text and contains also information about the instruction to which the specification
	    %  refers. Then, as bytecode does not have control structures specification will always refer to a particular instruction in the bytecode. 
	    %  For instance, loops on bytecode are identified by a unique loop entry instruction and thus, a loop invariant must hold basically every time
	    %  the corresponding loop entry instruction is reached.

\item \textbf{Compactness} and \textbf{Efficiency}

      Although opposite, we consider those two features together
      because they are mutually dependent. By the first, we mean that
      the class files augmented with BML should be as compact as
      possible.  The second feature refers to that tools supporting
      BML should not be slowed down by the processing of the BML
      specification and more precisely we refer verification condition
      generator tools.  This is an important condition if verification
      is done on devices with limited resources.

      For fulfilling these conditions, BML is designed to correspond
      to a subset of the desugared version of JML.  In particular, it
      brings a relative compactness of the class file as well as makes
      the verification procedure more efficient.

      % compactness   

      We first see in what sense this allows the class file
      compactness. Because every kind of BML specification clause is
      stored in a different user defined attribute, supporting all
      constructs of JML would mean that class files may contain a
      large number of attributes which would increase considerably the
      class file size. Of course, the size of a BML specification
      depends also on how much detailed is the specification, the more
      detailed it is, the larger size it would have.
      
      % efficiency

      Because BML corresponds to a desugared version of JML, this
      means that on verification time the BML specification does not
      need much processing and thus, it can be easily translated to
      the data structures used in the verification scheme. This makes
      BML suitable for verification on devices with limitted
      resources.
      
\end{itemize}


Recall that a class file contains all the information related to a
single class or interface, i.e.~its class name, interfaces
implemented by the class, its super class and the methods and fields
it declares. The Java Virtual Machine Specification~\cite{JVMspec} 
prescribes the mandatory elements of the class
file: the constant pool, the field information and the method
information. The constant pool is the table which is used to construct
the runtime constant pool upon class or interface creation. This will
serve for loading, linking and resolution of references used in the
class. The JVM specification allows to add user-specific information to the 
class
file (\cite[\S4.7.1]{JVMspec}), by defining user-specific attributes,
following the structure prescribed by the JVM specification. 
We use these to encode
the BML specifications. For each class, we add the following global
user-specific attributes:
\begin{itemize}
\item lists of the model and ghost fields used in the specification;
if a model or a ghost field is dereferenced in the specification, then
a constantFieldRef is added to the constant pool as the Java compiler
would do for any dereferenced Java field\footnote{The JVM
specification does not
allow to create a separate constant pool for specification-only
variables, since every constant that occurs in the class file
\emph{must} occur in the standard constant pool.};
\item a list of the class invariants (both static and object); and
\item a list of the history constraints (both static and object).
\end{itemize}

The lists of model and ghost fields have the following format:\\ 

\textbf{
\begin{tabular}{l}
Ghost\unsc Field\unsc attribute \{\\
\hspace*{1em}
\begin{tabular}{l}
u2  attribute\unsc name\unsc index; \\
u4  attribute\unsc length;\\
u2  fields\unsc count;\\
\{\begin{tabular}[t]{l} 
    u2 access\unsc flags; \\  
    u2 name\unsc index;\\
    u2 descriptor\unsc index;\\
  \end{tabular}\\
\} fields[fields\unsc count];\\
\end{tabular}\\
\}
\end{tabular}
}\\

This should be understood as follows: the name of the attribute is
given as an index into the constant pool. This constant pool entry
will be representing a string (either \texttt{"Model\unsc Field"} or
\texttt{"Ghost\unsc Field"}). Next we have the length of the
attribute, which should be 2 + 6*\textbf{fields\unsc count} (the number of
fields stored in the list). The \textbf{fields} table then stores all
ghost and model fields. For each field we store its access flags
(e.g.~\texttt{public} or \texttt{private}), and the name index and 
descriptor index, both referring to the constant pool. The first must be a
string, representing the (unqualified) name of the variable, the
latter is a field descriptor, containing e.g.~type
information.  The information as
\textbf{u2} and \textbf{u4} specifies the size of the attribute, 2 and
4 bytes, respectively.

In a similar way, we specify the format for the attributes containing
the list of class invariants and history constraints. The type of
invariants and history constraints is specified by the 
\textbf{type} entry: when it is \textbf{1} the invariant (or history
constraint) is defined over objects, when it is \textbf{0} the
invariant (or constraint) is static.

\noindent
\begin{center}
\begin{tabular}{p{7cm}p{10cm}}
\textbf{
\begin{tabular}{l}
JMLClassInvariant\unsc attribute \{ \\
\hspace*{0.1em}\begin{tabular}{l}
u2 attribute\unsc name\unsc index;\\ 
u4 attribute\unsc length;\\ 
u2  invariant\unsc count;\\
\{\begin{tabular}[t]{l} 
        u1 type;\\
	formula invariant;\\ 
\end{tabular}\\
\} invariants[invariant\unsc count];  
\end{tabular}\\
\}  
\end{tabular}
}
&
\textbf{
\begin{tabular}{l}
JMLHistoryConstraints\unsc attribute \{ \\ 
\hspace*{1em}\begin{tabular}{l}
u2 attribute\unsc name\unsc index;\\ 
u4 attribute\unsc length;\\ 
%formula attribute\unsc formula;\\ 
u2  history\unsc constr\unsc count;\\
\{\begin{tabular}[t]{l} 
        u1 type;\\
	formula constraint;\\ 
\end{tabular}\\
\} history\unsc constr[history\unsc constr\unsc count];
\end{tabular}\\
\}
\end{tabular}
}
\end{tabular}
\end{center}

The JVM specification prescribes that the table with method 
information at least
contains the code of each method. We add attributes for the method
specification, a table with set statements, a table with assert
statements, a table with assume statements and a table with loop
specifications.  The attribute with the lightweight behaviour
specifications is formatted as follows (heavyweight behaviour
specifications are handled similarly): 

\noindent\begin{flushleft}\textbf{    
\begin{tabular}{l}
JMLMethod\unsc attribute \{ \\ 
\hspace*{1em}
\begin{tabular}[t]{l}
u2 attribute\unsc name\unsc index;\\ 
u4 attribute\unsc length;\\ 
formula requires\unsc formula;\\
u2 spec\unsc count;\\
\{\begin{tabular}[t]{l}
  formula spec\unsc requires\unsc formula; \\
  u2 assignable\unsc count;\\
  formula assignable[assignable\unsc count];\\
  formula ensures\unsc formula;\\
  u2 exsures\unsc count;\\
  \{\begin{tabular}[t]{l}
    u2 exception\unsc index; \\
    formula exsures\unsc formula;\\
    \end{tabular}\\
  \} exsures[exsures\unsc count];\\
  \end{tabular}\\
\} spec[spec\unsc count];   \\
\end{tabular}\\
\}
\end{tabular}
}
\end{flushleft}

The global requires formula is the disjunction of all preconditions in
the different specification cases of the method. For each
specification case, we then have a precondition
(\textbf{spec\unsc requires\unsc formula}), a list of assignable expressions,
a postcondition (\textbf{ensures\unsc formula}) and a list of exceptional
postconditions (stored in the \textbf{exsures} attribute). If a clause
is not explicitly specified, its default value will be stored
here. Notice that for each list of elements we get two attributes: one
to store the number of elements, and one attribute actually containing
the elements.

The tables with set, assert and assume statements are very
similar. For each statement we use \textbf{index} to denote the point
in the bytecode to which the statement is associated. For the set
statement, expression \textbf{e1} is a ghost variable, \textbf{e2}
denotes the expression that will be assigned to \textbf{e1}. For the
assert and assume statements, the formula \textbf{predicate} is the
predicate that is supposed to hold at this point in the program
execution. We only give the format for the assert statement table
here, the assume statement table is similar.\\

\begin{tabular}{p{8cm}p{8cm}}
\textbf{  
\begin{tabular}[t]{l}
Set\unsc attribute \{\\
\hspace*{1em}\begin{tabular}{l}
u2 attribute\unsc name\unsc index;\\
u4 attribute\unsc length;\\
u2 set\unsc count;\\
\{\begin{tabular}[t]{l}
  u2 index; \\
  expression e1; \\
  expression e2; \\
  \end{tabular}\\
\} set[set\unsc count];\\
\end{tabular}\\
\}
\end{tabular}
}

&
\textbf{
\begin{tabular}[t]{l}
Assert\unsc attribute \{\\
\begin{tabular}{l}
u2 attribute\unsc name\unsc index;\\
u4 attribute\unsc length;\\
u2 assert\unsc count;\\
\{\begin{tabular}[t]{l}
  u2 index; \\
  formula predicate; \\
\end{tabular}\\
\} assert[assert\unsc count];\\
\end{tabular}\\
\}
\end{tabular}
}
\end{tabular}\\


Finally, loop specifications consist of the following elements: an
\textbf{index} to the bytecode instruction that corresponds to the
entry of the loop, a list of variables that may be modified by the
loop, a loop invariant, and a \textbf{decreases} clause, which is the
loop variant, i.e.~the expression that allows to prove
termination of the loop. If the specification does not contain a loop
variant, we indicate this, using a special tag for the
\textbf{decreases} clause. This gives the following attribute format.\\

\textbf{     
\begin{tabular}{l}
JMLLoop\unsc specification\unsc attribute \{\\
\begin{tabular}{l}
u2 attribute\unsc name\unsc index;\\
u4 attribute\unsc length;\\
u2 loop\unsc count;\\
\{\begin{tabular}{l}
  u2 index;\\
  u2 modifies\unsc count;\\
  formula modifies[modifies\unsc count];\\
  formula invariant;\\
  expression decreases;\\
  \end{tabular}\\
\} loop[loop\unsc count];\\
\end{tabular}\\
\}
\end{tabular}
}\\

\section{Compiling JML specifications into BML specifications}
Requirements on the class file format
\begin{itemize}
  \item \textbf{Debug Information} \\ A requirement to the class file
  format is that it must contain a debug information, more
  particularly the \textbf{Line\_Number\_Table} \\ and
  \textbf{Local\_Variable\_Table} attributes. The presence in the Java
  class file format of these attribute is optional \cite{VMSpec}, yet
  almost all standard non optimizing compilers can generate these
  data. The \textbf{Line\_Number\_Table} is part of the compilation of
  a method and describes the link between the Java source lines and
  the Java bytecode.  The \textbf{Local\_Variable\_Table} describes
  the local variables that appear in a method.  This debug information
  is necessary for the compiler from JML to BML, as we shall see later
  in Section \ref{BCSLcompile}.

\item  \textbf{Reducible control flow graph} \\ 
       The control flow graph corresponding to the list of bytecode
       instructions resulting from the compilation of a method body
       must be a reducible control flow graph. An intuition to the
       notion of reducibility is that every cycle in the graph must
       have exactly one entry point, or in other words a cycle can not
       be jumped from outside inside (see \cite{ARUCom1986} for the
       definition of reducibility). This condition is necessary for
       the compilation phase of the loop invariants as well as for the
       verification procedure (Section \ref{wpGeneral}).  Note, that
       this restriction is realistic as nonoptomizing Java compilers
       produce reducible control flow graphs and in practice even hand
       written code is in most cases reducible.
\end{itemize}

In this section, we turn to the \JMLtoBML \ compiler.  As we shall
see, the compilation consists of several phases, namely compiling the
Java source file, preprocessing of the JML specification, resolution
and linking of names, locating the position of intra --- method
specification, processing of boolean expressions and finally encoding
the BML specification in user defined class file attributes.  (their
structure is predefined by JVMS).  In the following, we look in
details at the phases of the compilation process:
\begin{enumerate}
\item Compilation of the Java source file \\
  This can be done by any Java compiler that supplies for every method
  in the generated class file the \textbf{Line\_Number\_Table} \\ and
  \textbf{Local\_Variable\_Table} attributes. % The presence in the
  Java class file format of % these attribute is optional
  \cite{VMSpec}, yet almost all standard non optimizing compilers can
  generate these data. % The \textbf{Line\_Number\_Table} describes
  the link between the source line and the bytecode of a method.  %
  The \textbf{Local\_Variable\_Table} describes the local variables
  that appear in a method. Those attributes are important for the next
  phases of the JML compilation.

\item Compilation of Ghost field declarations \\
      JML specification is invisible by the Java compilers. Thus Java
      compilers omit the compilation of ghost variables declaration.
      That is why it is the responsibility of the \JMLtoBML \ compiler
      to do this work. For instance, the compilation of the
      declaration of the ghost variable from Fig. \ref{bml:ghost} is
      given in Fig.\ref{bml:compiler:ghost} which shows the data
      structure \textbf{Ghost\_field\_Attribute} in which the
      information about the field \texttt{TRANS} is encoded in the
      class file format. Note that, the constant pool indexes
      \textbf{\#18} and \textbf{\#19} which contain its description
      were not in the constant pool table of the class file
      \texttt{Transaction.class} before running the \JMLtoBML \
      compiler on it.
\begin{figure}[t]
\textbf{     
\begin{tabbing}
 Gho\=st\_field\_Attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= access\_flag 10;\\
\> \> name\_ index = \#18; \\
\> \> descriptor\_index = \#19 \\
\> \} ghost[1];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{access\_flag}: The kind of access that is allowed to the field

\item \textbf{name\_index}:  The index in the constant pool which contains information about the source name of the field

\item \textbf{descriptor\_index}: The index in the constant pool which contains information about the name of the field type  
\end{itemize}


\caption{\sc Compilation of ghost variable declaration}
\label{bml:compiler:ghost}
\end{figure}

\item Desugaring of the JML specification \\
      %BML supports less specification clauses than JML for the sake
      of keeping compact the class file format.  % In particular BML
      does not support heavy weight behaviour specification clauses or
      nested specification, neither an incomplete % method
      specification(see \cite{JMLRefMan}).  % Thus, a step in the
      compilation of JML specification into BML specification is the
      desugaring of the JML heavy weight The phase consists in
      converting the JML method heavy-weight behaviours and the light
      - weight non complete specification into BML specification
      cases.  It corresponds to part of the standard JML desugaring as
      described in \cite{RT03djml}.  For instance, the BML compiler
      will produce from the specification in Fig.\ref{bml:heavySp} the
      BML specification given in Fig.\ref{bml:heavySpBML}
      



\item Linking with source data structures \\
      When the JML specification is desugared, we are ready for the
      linking and resolving phases.  In this stage, the JML
      specification gets into an intermediate format in which the
      identifiers are resolved to their corresponding data structures
      in the class file.  The Java and JML source identifiers are
      linked with their identifiers on bytecode level, namely with the
      corresponding indexes either from the constant pool or the array
      of local variables described in the
      \textbf{Local\_Variable\_Table} attribute.

      For instance, consider once again the example in
      Fig. \ref{bml:heavySp} and more particularly the first
      specification case of method \texttt{divide} whose precondition
      \texttt{ b > 0 } contains the method parameter identifier
      \texttt{b}.  In the linking phase, the identifier \texttt{b} is
      resolved to the local variable $\locVar{1}$ in the array of
      local variables for the method \texttt{divide}.  We have a
      similar situation with the postcondition \texttt{ a == \old{a} /
      b } which mentions also the field \texttt{a} of the current
      object.  The field name \texttt{a} is compiled to the index in
      the class constant pool which describes the constant field
      reference.  The result of the linking process is in
      Fig.\ref{bml:heavySpBML}.

      % how ghost fields are compiled If, in the JML specification a
      field identifier appears for which no constant pool index
      exists, it is added in the constant pool and the identifier in
      question is compiled to the new constant pool index. This
      happens when declarations of JML ghost fields are compiled.
     

  





      

\item Locating the points for the intra ---method specification \\

      In this phase the specification parts like the loop invariants
      and the assertions which should hold at a certain point in the
      source program must be associated to the respective program
      point in the bytecode. For this, the
      \textbf{Line\_Number\_Table} attribute is used. The
      \textbf{Line\_Number\_Table} attribute describes the
      correspondence between the Java source line and the instructions
      of its respective bytecode.  In particular, for every line in
      the Java source code the \textbf{Line\_Number\_Table} specifies
      the index of the beginning of the basic block\footnote{a basic
      block is a sequence of instructions which does not contain jumps
      except may be for the last instruction and neither contains
      target of jumps except for the first instruction. This notion
      comes from the compiler community and more information on this
      one can find at \cite{ARUCom1986}} in the bytecode which
      corresponds to the source line. Note however, that a source line
      may correspond to more than one instruction in the
      \textbf{Line\_Number\_Table}.
     
      This poses problems for identifying loop entry instruction of a
      loop in the bytecode which corresponds to a particular loop in
      the source code. % which is important for the % compilation of
      the JML loop invariants (as we should know exactly where they
      must hold in the bytecode). For instance, for method
      \texttt{replace} in the Java source example in
      Fig. \ref{replaceSrc} the java compiler will produce two lines
      in the \textbf{Line\_Number\_Table} which correspond to the
      source line \textbf{17} as shown in
      Fig. \ref{bml:compiler:loopEntry}.  The problem is that none of
      the basic bloks determined by instructions \textbf{2} and
      \textbf{18} contain the loop entry instruction of the
      compilation of the loop at line \textbf{17} in
      Fig. \ref{replaceSrc}. Actually, the loop entry instruction in
      the bytecode in Fig. \ref{bml:loopBML} (remember that this is
      the compilation in bytecode of the Java source in
      Fig. \ref{replaceSrc}) which corresponds to the in the bytecode
      is at index \textbf{19}.
  
       Thus for identifying loop entry instruction corresponding to a
       particular loop in the source code, we use an heuristics.  It
       consists in looking for the first bytecode loop entry
       instruction starting from one of the \textbf{start\_pc} indexes
       (if there is more than one) corresponding to the start line of
       the source loop in the \textbf{Line\_Number\_Table}. The
       algorithm works under the assumption that the control flow
       graph of the method bytecode is reducible.  This assumption
       guarantees that the first loop entry instruction found starting
       the search from an index in the \textbf{Line\_Number\_Table}
       corresponding to the first line of a source loop will be the
       loop entry corresponding to this source loop.  However, we do
       not have a formal argumentation for this algorithm because it
       depends on the particular implementation of the compiler.  From
       our experiments, the heuristic works successfully for the Java
       Sun non optimizing compiler.
 
\begin{figure}[t]
\textbf{Line\_Number\_Table} 
\textbf{     
\begin{tabbing}
start\_pc \= line \\
\ldots \> \\
2 \> 17 \\ 18 \> 17 \\
\end{tabbing}
}

\caption{\textbf{Line\_Number\_Table}  {\sc for the method } \texttt{replace} {\sc in Fig.  \ref{replaceSrc}  } }
\label{bml:compiler:loopEntry}
\end{figure} \todo{une presentation tres laide }

      
      
\item Compilation of the JML boolean expressions into BML \\
      
     

Another important issue in this stage of the JML compilation is how
the type differences on source and bytecode level are treated. By type
differences we refer to the fact that the JVM (Java Virtual Machine)
does not provide direct support for integral types like byte, short,
char, neither for boolean. Those types are rather encoded as integers
in the bytecode. Concretely, this means that if a Java source variable
has a boolean type it will be compiled to a variable with an integer
type.


 For instance, in the example for the method
\texttt{replace} and its specification in Fig.\ref{replaceSrc} the postcondition states the equality between the JML expression  
\result \ and a predicate. This is correct as the method \texttt{replace} in the Java source is declared with return type boolean  and thus,
 the expression \result \ has type boolean. Still, the bytecode
 resulting from the compilation of the method \texttt{replace} returns
 a value of type integer. This means that the JML compiler has to
 ``make more effort'' than simply compiling the left and right side of
 the equality in the postcondition, otherwise its compilation will not
 make sense as it will not be well typed. Actually, if the JML
 specification contains program boolean expressions that the Java
 compiler will compile to bytecode expression with an integer type,
 the JML compiler will also compile them in integer expressions and
 will transform the specification condition in equivalent
 one\footnote{when generating proof obligations we add for every
 source boolean expression an assumption that it must be equal to 0 or
 1. A reasonable compiler would encode boolean values in a similar
 way}.

Finally, the compilation of the postcondition of method
\texttt{replace} is given in Fig. \ref{postCompile}. From the
postcondition compilation, one can see that the expression \result \
has integer type and the equality between the boolean expressions in
the postcondition in Fig.\ref{replaceSrc} is compiled into logical
equivalence.
% The example also 
% shows that local variables and  fields are respectively linked to the index of the register table for the method and to the corresponding 
% index of the constant pool table 
% (\#19 is the compilation of the field name \texttt{list} and $\locVar{1}$ stands for the method parameter \texttt{obj}). 

\begin{figure}[t]
 $$\begin{array}{l} \result = 1 \\ \\ \iff \\ \exists
 \bound\_{\mbox{\rm \textsf{0}}}, \biggl(\begin{array}{l} \ 0 \leq
 \bound\_{\mbox{\rm \textsf{0}}} \wedge\\ \bound\_{\mbox{\rm
 \textsf{0}}} < len(\#19(\locVar{0})) \wedge \\
 \arrayAccess{\#19(\locVar{0})}{\bound\_{\mbox{\rm \textsf{0}}} } =
 \locVar{1} \end{array} \biggr) \end{array} $$
\caption{\sc The compilation of the postcondition in Fig. \ref{replaceSrc}}
\label{postCompile}
\end{figure}





\item Encoding BML specification  into user defined class attributes\\
  The specification expression and predicates are compiled in binary
  form using tags in the standard way. The compilation of an
  expression is a tag followed by the compilation of its
  subexpressions.
    
 Method specifications, class invariants, loop invariants are newly
 defined attributes in the class file.  For example, the
 specifications of all the loops in a method are compiled to a unique
 method attribute whose syntax is given in
 Fig.~\ref{loopAttribute}. This attribute is an array of data
 structures each describing a single loop from the method source code.
 From the figure, we notice that every element describing the
 specification for a particular loop contains the index of the
 corresponding loop entry instruction \textbf{index}, the loop
 modifies clause (\textbf{modifies}), the loop invariant
 (\textbf{invariant}), an expression which guarantees termination
 (\textbf{decreases}).


\end{enumerate}

\begin{figure}[t]
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{index}: The index in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described

\item \textbf{modifies[]}: The array of locations that may be modified

\item \textbf{invariant }: The predicate that is the loop invariant. It is a compilation of the JML formula in the low level specification language

\item \textbf{decreases}: The expression which decreases at every loop iteration
\end{itemize}
\caption{\sc Structure of the Loop Attribute}
\label{loopAttribute}
%\end{frameit}
\end{figure}

% The JML compiler does not depend on any specific Java compiler, but it requires the presence of a debugging information,
%namely the presence of the \textbf{Line\_Number\_Table} attribute for the correct compilation of inter method
% specification, i.e. loops and assertions. We think that this is an acceptable restriction as few bytecode programs even handwritten are not reducible.
% The most problematic part of the compilation is to identify which source loop corresponds to which bytecode loop in the control flow
% graph.
%  To do this, we assume that the control flow graph is reducible (see~\cite{ARUCom1986}), i.e. there are no
% jumps from outside a loop inside it; graph reducibility allows to establish the same order between loops in the
% bytecode and source code level and to compile the invariants to the correct places in the bytecode.
% \todo{put it elsewhere}

%\todo{limitations : registers that are used with two different types in the method bytecode}

\section{Conclusions and future work}

\bibliographystyle{plain}
\bibliography{bytecode,../../THESIS/biblio}

\appendix
\input{BML-grammar}
\end{document}
