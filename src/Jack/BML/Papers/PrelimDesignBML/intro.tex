\begin{abstract} 

We present the Bytecode Modeling Language (BML), the Java bytecode
cousin of JML. BML allows the application developer to specify the
behaviour of an application in the form of annotations,
\emph{directly} at the level of the bytecode. An extension of the class file
format is defined to store the specification directly with the
bytecode. This is a first step towards the development of a platform
for Proof Carrying Code, where applications come together with their
specification and a proof of correctness. BML is designed to be
closely related with JML. In particular, JML specifications can be
compiled into BML specifications. We briefly discuss the tools that
are currently being developed for BML, and that will result in a tool
set where an application can be validated throughout its development,
both at source code and at bytecode level.

\end{abstract}

\section{Introduction}\label{IntroSectLab}

The use of formal methods to show conformance of an implementation
\emph{w.r.t.}\ a specification has become an accepted technique 
for the development of security-critical applications. Various tools
exist that allow to specify and validate complex functional or
security properties, using different techniques such as runtime
assertion checking, testing and verification condition generation.
However, often these techniques are restricted to source code level
programs, while for many applications, and in particular for mobile
code, one needs to be able to also specify and verify the executable
(or interpreted) code.

Different possible reasons for this exist: the executable code may not
be accompanied by its (specified) source, or one simply does not trust
the compiler. And in an attempt to avoid \emph{all} possible security
threats, sometimes security-critical applications are directly
developed at the executable level. Thus, it is essential to have the
means to specify \emph{and} to verify an application directly at this
level, without the use of a compiler, and both specification and
verification techniques should be tailored directly to the
particularities of executable code. Moreover, in order to capture all
relevant security requirements, the specification language used should
be expressive enough for this.

Proof Carrying Code (PCC) is a typical example where the need to
specify and verify executable code directly is imperative, in
particular when one wishes to capture complex security policies that
cannot be checked with a typechecker.  PCC is a possible solution to
support the secure downloading of applications on a mobile device. The
executable code of an application comes together with a specification,
and the necessary evidence from which the code client can easily
establish that the application respects its specification. In such a
scenario, the code producer, who \emph{has} to produce a correctness
proof, will often prefer to do the verification at source code level,
and then compile the specification and the proof into the level of
executable code. Realising a platform to support this scenario is one
of the goals of the \mobius project\footnote{See
\texttt{http://mobius.inria.fr}.}. 

This paper describes the low-level specification language that we
propose to specify the security requirements for mobile device
applications. Since the most common execution framework for mobile
devices is the J2ME platform, our low-level specification language is
tailored to Java bytecode. Our language is designed to support the
verification of \emph{unstructured} code. And, as we want to be able to
translate source code level specifications into bytecode level
specifications, our specification language is also designed to be
closely related to the Java Modeling Language (JML)\footnote{See
\texttt{http://www.jmlspecs.org}.}.


Over the last few years, JML has become the \emph{de facto}
specification language for Java source code programs. Different tools
exist that allow to validate, verify or generate JML specifications
(see~\cite{BurdyCCEKLLP05} for an overview). Several case studies have
demonstrated that JML can be used to specify realistic industrial
examples, and that the different tools allow to find errors in the
implementations (see \emph{e.g.}~\cite{BreunesseCHJ04}). One of the
reasons for its success is that JML uses a Java-like
syntax. Specifications are written using preconditions, postcondition,
class invariants and other annotations, where the different predicates
are side-effect-free Java expressions, extended with
specification-specific keywords (\emph{e.g.}\ logical quantifiers and
a keyword to refer to the return value of a method). Other important
factors for the success of JML are its expressiveness and
flexibility. JML is in particular suited to express many of the
different security requirements that have been identified to be of
interest for mobile device applications~\cite{Deliverable1.2}.


Therefore, we define a variation of JML especially tailored to
bytecode, called BML, short for Bytecode Modeling Language.
BML supports the most important features of JML. Thus, we can express
functional properties of Java bytecode programs in the form of
\emph{e.g.}\ pre- and postconditions, class and object invariants, and
assertions for particular program points like loop invariants. Because
of the close connection with JML, JML source code level specifications
can be compiled into BML bytecode level specifications without too
much difficulty, basically by compiling the source code predicates
into bytecode predicates.  This allows to do development and
verification at source code level, while still being able to ship
bytecode level proofs.  To the best of our knowledge, no other
specification language with similar design goals exists for Java
bytecode.

Section~\ref{SecJMLOverview} gives a quick summary of the relevant
features of JML. Section~\ref{SecBML} then gives a detailed account of
BML, describing its syntax and semantics, while
Section~\ref{SecClassfile} proposes a format in which BML
specifications can be stored in the class file (just as JML
specifications can be written as special comments in the Java source
code). Section~\ref{SecJMLtoBML} then discusses the compilation
process from JML to BML, while Section~\ref{SecConcl} wraps up and
discusses tool support and related and future work.


