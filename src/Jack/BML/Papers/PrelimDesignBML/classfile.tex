\section{Encoding BML specifications in the class file format}
\label{SecClassfile}

To store BML specifications together with the bytecode it
specifies, we need a way to encode them in the class file
format. Recall that a class file contains all the information related
to a single class or interface, \emph{i.e.}\ its class name, interfaces
implemented by the class, its super class and the methods and fields
it declares. The Java Virtual Machine Specification~\cite{JVMspec}
prescribes the mandatory elements of the class file: the constant
pool, the field information and the method information. The constant
pool is the table which is used to construct the runtime constant pool
upon class or interface creation. This will serve for loading, linking
and resolution of references used in the class. The JVM specification
allows to add user-specific information to the class file
(\cite[\S4.7.1]{JVMspec}), by defining user-specific attributes,
following the structure prescribed by the JVM specification. When
defining these attributes, we took the following considerations into
account.

\begin{description}
\item [Java compiler independence]
The format of BML specifications in a class file must not depend on
any particular (non-optimising) compiler.
    
      
\item [JVM compatibility]
The class files augmented with the BML specification must be
executable by any implementation of the JVM.  As the JVM specification
does not allow insertion of any user-specific data in the list with
bytecode instructions, BML annotations must be stored separately from
the method body (the list of bytecode instructions which represents
its body).

\item[Efficiency]
For a code user, the fact that BML is used to specify and verify the
application should be transparent. In particular, it should not have
any impact on the application's performance, thus, the class file
augmented with BML should not slow down loading or normal execution of
the application. Notice that this requirement is very important for
mobile device applications, where one often has limited resources.
\end{description}	  


To ensure JVM compatibility, the different specification constructs
are stored in special attributes, and where necessary these contain
information about the index of the instruction that they specify. For
instance, the attribute that stores BML loop invariants contains the
invariant as well as the index of the entry point instruction of the
loop.

For each class, we add the following information to the class file:
\begin{itemize}
\item an attribute with the model fields used in the specification;
\item an attribute with the ghost fields used in the specification;
\item an attribute with the class invariants (both static and object); and
\item an attribute with the history constraints (both static and object).
\end{itemize}

The JVM specification requires that the names of these attributes have
are added to the constant pool.  In addition, if a model or a ghost
field is dereferenced in the specification, then a constantFieldRef is
added to the constant pool as the Java compiler would do for any
dereferenced Java field\footnote{The JVM specification does not allow
to create a separate constant pool for specification-only variables,
since every constant that occurs in the class file
\emph{must} occur in the standard constant pool.};

The attribute with ghost fields has the following format:

\textbf{
\begin{longtable}{lp{8cm}}
Ghost\unsc Field\unsc attribute \{\\
\hspace*{1em}
\begin{tabular}{l}
u2  attribute\unsc name\unsc index; \\
u4  attribute\unsc length;\\
u2  fields\unsc count;\\
\{\begin{tabular}[t]{l} 
    u2 access\unsc flags; \\  
    u2 name\unsc index;\\
    u2 descriptor\unsc index;\\
  \end{tabular}\\
\} fields[fields\unsc count];\\
\end{tabular}\\
\}
&
\end{longtable}
}

This should be understood as follows: the name of the attribute is
given as an index into the constant pool. This constant pool entry
will be representing a string \texttt{"Ghost\unsc Field"}. Next we
have the length of the attribute, which should be 2 +
6*\textbf{fields\unsc count} (the number of fields stored in the
list). The \textbf{fields} table then stores all ghost fields. For
each field we store its access flags (\emph{e.g.}\ \texttt{public} or
\texttt{private}), and the name index and descriptor index, both
referring to the constant pool. The first must be a string,
representing the (unqualified) name of the variable, the latter is a
field descriptor, containing \emph{e.g.}\ type information.  The tags
\textbf{u2} and \textbf{u4} specifies the size of the attribute, 2 and
4 bytes, respectively. The model field attribute is similar.

In a similar way, we the attributes for 
the class invariants and history constraints contain a list of
invariants and constraint entries, respectively. These contain the
predicates, a tag whether the invariant (constraint) is defined over
instances or static, and appropriate visibility modifiers.


%. The type of
%invariants and history constraints is specified by the 
%\textbf{type} entry: when it is \textbf{1} the invariant (or history
%constraint) is defined over objects, when it is \textbf{0} the
%invariant (or constraint) is static.

%\begin{longtable}{p{7cm}p{8cm}}
%\textbf{
%\begin{tabular}{l}
%JMLClassInvariant\unsc attribute \{ \\
%\hspace*{0.1em}\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\ 
%u4 attribute\unsc length;\\ 
%u2  invariant\unsc count;\\
%\{\begin{tabular}[t]{l} 
%        u1 type;\\
%	formula invariant;\\ 
%\end{tabular}\\
%\} invariants[invariant\unsc count];  
%\end{tabular}\\
%\}  
%\end{tabular}
%}
%&
%\bigskip\\
%\textbf{
%\begin{tabular}{l}
%JMLHistoryConstraints\unsc attribute \{ \\ 
%\hspace*{1em}\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\ 
%u4 attribute\unsc length;\\ 
%%formula attribute\unsc formula;\\ 
%u2  history\unsc constr\unsc count;\\
%\{\begin{tabular}[t]{l} 
%        u1 type;\\
%	formula constraint;\\ 
%\end{tabular}\\
%\} history\unsc constr[history\unsc constr\unsc count];
%\end{tabular}\\
%\}
%\end{tabular}
%}
%\end{longtable}

The JVM specification prescribes that the table with method
information at least contains the code of each method. We add
attributes for the method specification, and for set statements,
assert statements, assume statements and loop specifications.  The
attribute with the lightweight behaviour specifications is formatted
as follows (heavyweight behaviour specifications are handled
similarly):

\textbf{    
\begin{longtable}{lp{8cm}}
JMLMethod\unsc attribute \{ \\ 
\hspace*{1em}
\begin{tabular}[t]{l}
u2 attribute\unsc name\unsc index;\\ 
u4 attribute\unsc length;\\ 
formula requires\unsc formula;\\
u2 spec\unsc count;\\
\{\begin{tabular}[t]{l}
  formula spec\unsc requires\unsc formula; \\
  u2 assignable\unsc count;\\
  formula assignable[assignable\unsc count];\\
  formula ensures\unsc formula;\\
  u2 exsures\unsc count;\\
  \{\begin{tabular}[t]{l}
    u2 exception\unsc index; \\
    formula exsures\unsc formula;\\
    \end{tabular}\\
  \} exsures[exsures\unsc count];\\
  \end{tabular}\\
\} spec[spec\unsc count];   \\
\end{tabular}\\
\}
&
\end{longtable}
}


The global requires formula is the disjunction of all preconditions in
the different specification cases of the method. For each
specification case, we then have a precondition
(\textbf{spec\unsc requires\unsc formula}), a list of assignable expressions,
a postcondition (\textbf{ensures\unsc formula}) and a list of exceptional
postconditions (stored in the \textbf{exsures} attribute). If a clause
is not explicitly specified, its default value will be stored
here. Notice that for each list of elements we get two attributes: one
to store the number of elements, and one attribute actually containing
the elements.

The tables with set, assert and assume statements have the same format
as for example the attribute for ghost fields, \emph{i.e.}\ some
general information, and a list of entries. For each statement
annotation, we keep the appropriate predicate or expression, plus the
index to the appropriate point in the bytecode.

%are very
%similar. For each statement we use \textbf{index} to denote the point
%in the bytecode to which the statement is associated. For the set
%statement, expression \textbf{e1} is a ghost variable, \textbf{e2}
%denotes the expression that will be assigned to \textbf{e1}. For the
%assert and assume statements, the formula \textbf{predicate} is the
%predicate that is supposed to hold at this point in the program
%execution. We only give the format for the assert statement table
%here, the assume statement table is similar.

%\begin{longtable}{p{6cm}p{8cm}}
%\textbf{  
%\begin{tabular}[t]{l}
%Set\unsc attribute \{\\
%\hspace*{1em}\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\
%u4 attribute\unsc length;\\
%u2 set\unsc count;\\
%\{\begin{tabular}[t]{l}
%  u2 index; \\
%  expression e1; \\
%  expression e2; \\
%  \end{tabular}\\
%\} set[set\unsc count];\\
%\end{tabular}\\
%\}
%\end{tabular}
%}

%&
%\textbf{
%\begin{tabular}[t]{l}
%Assert\unsc attribute \{\\
%\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\
%u4 attribute\unsc length;\\
%u2 assert\unsc count;\\
%\{\begin{tabular}[t]{l}
%  u2 index; \\
%  formula predicate; \\
%\end{tabular}\\
%\} assert[assert\unsc count];\\
%\end{tabular}\\
%\}
%\end{tabular}
%}
%\end{longtable}


Finally, loop specification attributes consist of the following elements: an
\textbf{index} to the bytecode instruction that corresponds to the
entry of the loop, a list of variables that may be modified by the
loop, a loop invariant, and a \textbf{decreases} clause, which is the
loop variant, \emph{i.e.}\ the expression that allows to prove
termination of the loop. If the specification does not contain a loop
variant, we indicate this, using a special tag for the
\textbf{decreases} clause. This gives the following attribute format.

\textbf{     
\begin{longtable}{lp{8cm}}
JMLLoop\unsc specification\unsc attribute \{\\
\begin{tabular}{l}
u2 attribute\unsc name\unsc index;\\
u4 attribute\unsc length;\\
u2 loop\unsc count;\\
\{\begin{tabular}{l}
  u2 index;\\
  u2 modifies\unsc count;\\
  formula modifies[modifies\unsc count];\\
  formula invariant;\\
  expression decreases;\\
  \end{tabular}\\
\} loop[loop\unsc count];\\
\end{tabular}\\
\}
\end{longtable}
}
