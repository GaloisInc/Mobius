\section{The Bytecode Modeling Language}
\label{SecBML}


\subsection{Syntax of BML}

Basically, BML has the same syntax as JML with two exceptions:
\begin{enumerate}
\item specifications are not written directly in the program code,
they are added as special attributes to the bytecode; and
\item the grammar for expressions only allows bytecode expressions.
\end{enumerate}

With respect to the expression syntax, this means concretely that
field names, class names \emph{etc.}\ are replaced by constants, using
the constant pool, while registers are used to refer to local
variables. In addition, we can use stack expressions and the stack
counter to describe intermediate states of a computation. These will
typically only appear in intermediate assertions, we do not use them
in method specifications. Finally, we add a special expression
\codeHook{length(\(a\))}, denoting the length of array \(a\). Since the 
source code expression \codeHook{\(a\).length} is compiled into a
special bytecode instruction \codeHook{arraylength}, we also need a
special specification construct for this at bytecode level.

BML contains equivalent constructs for all specification constructs of
JML Level 0 (see~\cite[\S2.9]{JMLReferenceManual05}), which defines
the features that should be understood and checked by all JML
tools. In addition, it contains several constructs from JML level 1,
that we find important to be able to write meaningful specifications
for the example applications studied in the \mobius project. These
constructs are:
\begin{itemize}
\item static invariants;
\item object and static history constraints; and 
\item loop variants (using the \codeHook{decreasing} keyword).
\end{itemize}

At the moment, the use of pure methods is not part of the BML grammar,
as there is still ongoing research on the exact semantics of method
calls used in specifications. However, we believe that if the
theoretical issues have been settled, eventually any tool supporting
BML should also support this. In fact, we think that both at source
code and at bytecode level, specifications benefit a lot from being
allowed to use method calls in them. Finally, as mentioned above,
experiences with verification of realistic case studies have shown
that it is beneficial to have a special clause
\codeHook{loop\unsc modifies}, which is specified together with the loop
invariant. This clause specifies which variables
\emph{may} be modified by the loop (as an \codeHook{assignable} clause does
for a method). This \codeHook{loop-modifies} clause allows to write
concise specifications, and to efficiently generate proof obligations
using a weakest precondition calculus.

\begin{figure}[t]

\begin{tabular}{lll}
\multicolumn{2}{l}{\varHook{predicate} ::= \(\ldots\)}\medskip\\
\multicolumn{2}{l}{\varHook{unary-expr-not-plus-minus} ::= \(\ldots\)}\\
\hspace*{1cm} & \(\mid\) \varHook{primary-expr} [\varHook{primary-suffix}]\(\ldots\)\\ 

\multicolumn{2}{l}{\varHook{primary-suffix} ::= \codeHook{.} \varHook{ident}}\\
&\(\mid\) \codeHook{(} [\varHook{expression-list}] \codeHook{)}\\
& \(\mid\) \codeHook{[} \varHook{expression} \codeHook{]}\\
\multicolumn{2}{l}{\varHook{primary-expr} ::= 
\codeHook{\#}\varHook{natural}} & \% reference in the constant pool \\
&\(\mid\) \codeHook{lv[}\varHook{natural}\codeHook{]} &\% local variable \\
&\(\mid\) \codeHook{length(}\varHook{expression}\codeHook{)} &\% array
length \\
&\(\mid\) \codeHook{cntr} &\% counter of the operand stack\\
&\(\mid\) \codeHook{st(}\varHook{additive-expr}\codeHook{)} &\% stack
expressions\\
&\(\mid\) \varHook{constant} \(\mid\)
\codeHook{super}\\
&\(\mid\) \codeHook{true} \(\mid\) \codeHook{false} \(\mid\)
\codeHook{this} \(\mid\) \codeHook{null} \\
&\(\mid\) \codeHook{(}\varHook{expression}\codeHook{)}\\
&\(\mid\) \varHook{jml-primary}%\\
%\\
%\multicolumn{2}{l}{\varHook{store-ref-expression} ::= \varHook{store-ref-name}
%[\varHook{store-ref-name-suffix}]}\\
%\multicolumn{2}{l}{\varHook{store-ref-name} ::= 
%\codeHook{\#}\varHook{natural}} &\% reference in the constant pool \\
%&\(\mid\)\codeHook{super} \(\mid\) \codeHook{this}\\
%\multicolumn{2}{l}{\varHook{store-ref-name-suffix} ::= 
%\codeHook{(}\varHook{store-ref-expression}\codeHook{)}}\\
%&\(\mid\) \codeHook{[}\varHook{spec-array-ref-expr}\codeHook{]}
\end{tabular}

\caption{Fragment of grammar for BML predicates and specification expressions}
\label{FigBMLGrammar}
\end{figure}

Since the bytecode and BML specifications are two separate entities,
they should be parsed independently. Concretely this means that the
grammar of BML is similar to the grammar of type specifications,
method specifications and data groups of JML~\cite[\S A.5, A.6,
A.7]{JMLReferenceManual05}, restricted to the constructs in JML level
0, plus the constructs of JML level 1 mentioned, but with the changes
to the grammar for predicates and specification expressions, as
mentioned above. Figure~\ref{FigBMLGrammar} displays the most
interesting part of this grammar for predicates and specification
expressions, defining the syntax for primary expressions and primary
suffixes (see Appendix~\ref{AppBML} for a short explanation of the
syntax notation and the full grammar of predicates and specification
expressions). Primary expressions, followed by zero or more primary
suffixes, are the most basic form of expressions, formed by
identifiers, bracketed expressions
\emph{etc}. %Store-ref expressions (followed by zero or more store-ref 
%suffixes) are the expressions that can be used in an assignable
%clause.

As mentioned above, all identifiers are replaced by references to the
constant pool (a number, preceded by the symbol
\codeHook{\#}) or to local registers. The local register \codeHook{lv[0]}
of a non-static method always contains the implicit argument
\codeHook{this}, the other registers contain the parameters and the
local variables declared inside a method body. Compilers often reuse
local variable registers throughout the execution of a single
method. Thus, when \emph{e.g.}\ type checking an annotation containing
a local variable, it has to be taken into account at which point in
the code the annotation is evaluated (but notice that this is not more
complicated than reusing the same local variable names in different
block statements). 

As explained above, we add special keywords to be able to express
properties about the length of an array, the current stack counter
(\codeHook{cntr}), and to refer to an element on the stack
(\codeHook{st(\(e\))}, where \(e\) is some arithmetic expression).

In Java source code, one can usually leave the receiver object
\texttt{this} implicit. But compilation into bytecode makes this
object explicit, \emph{i.e.}\ instructions such as \texttt{putfield}
\emph{always} require that the receiver object is loaded on the
operand stack. In analogy with this, BML specifications require that
the receiver object is written explicitly in expressions (see
Figure~\ref{FigBMLSpec} below). 

%In BML, a field access is written as a function
%application. For example, suppose we have the source code qualified expression
%\codeHook{obj.f}, where \codeHook{obj} is the first parameter of a
%method, and \codeHook{f} is a field of this object. This becomes
%\codeHook{\#\(n\)(lv[1])} in BML, where \(n\) is the index in the
%constant pool to the field constant reference denoting the field
%\codeHook{f}, while \codeHook{lv[1]} is the register in the local variable
%array in which the parameter \codeHook{obj} is stored.  Therefore the
%grammar for \varHook{primary-suffixes} and \varHook{store-ref-name-suffixes}
%does not provide any grammar for qualified expressions.


In JML, many special keywords are preceded by the symbol
\codeHook{\bsl}, to ensure that they will not clash with variable
names. For BML, we do not have to worry about this: all
variable names are replaced by references to the constant pool or
local variable registers. Therefore, the new keywords are written
without a special preceding symbol. However, for convenience, we keep
the symbol for keywords that are also JML keywords.

%Finally, statement annotations are described as a special attribute,
%mapping line numbers to annotations. To parse these annotations, we
%reuse the relevant parts of the grammar for statements and annotation
%statements~\cite[\S A.9]{JMLReferenceManual05}.

%Type checking of the specification can be done in the obvious way,
%using the type information stored in the constant pool.

\paragraph{An example BML specification}
\label{sec:bml:example}


\begin{figure}[t]
{\small
\begin{verbatim}
{| requires lv[1] > 0 
   ensures lv[0].#24 <= \old(lv[0].#24) + lv[1] * (lv[1] + 1) / 2 |}
 0 iconst_1
 1 istore_2
 2 goto 22 
 5 aload_0
 6 aload_0
 7 getfield #24 <Bill.sum>
10 aload_0
11 iload_2
12 invokevirtual #26 <Bill.round_cost>
15 iadd
16 putfield #24 <Bill.sum>
19 iinc 2 by 1
loop_invariant 0 <= lv[2] && 0 <= lv[0].#24 && lv[2] <= lv[1] + 1 && 
               lv[0].#24 <= \old(lv[0].#24) + (lv[2] - 1) * lv[2]/2
entry loop:
22 iload_2
23 iload_1
24 if_icmple 5 
27 iconst_1
28 ireturn
29 astore_3
30 iconst_0
31 ireturn
\end{verbatim}
}
\caption{Bytecode + BML specification for method \codeHook{produce\unsc bill} in class \codeHook{Bill}}\label{FigBMLSpec}
\end{figure}

To show a typical BML specification, Figure~\ref{FigBMLSpec} presents
the BML version of the specification of method \codeHook{produce\_bill}
of the JML example in Figure~\ref{FigJMLSpec}. Notice that the field
\codeHook{sum} has been assigned the number 24 in the constant
pool, and that it is always explicitly qualified with \codeHook{lv[0]}
(denoting \codeHook{this}). Further, \codeHook{lv[1]} denotes the
parameter \codeHook{n}, while \codeHook{lv[2]} denotes the local variable
\codeHook{i}.
 
The class invariant gives rise to the following BML specification
(stored in the class file as a special user-specific attribute, as
explained below):

\begin{verbatim}
invariant:  #24 >= 0
\end{verbatim}

This expression is not qualified with \codeHook{lv[0]}, as it is
implicitly quantified over all objects that are an instance of a
subclass of class \texttt{Bill} (\emph{cf.}\ the JML
semantics~\cite[\S 8.2]{JMLReferenceManual05}).

%This class contains a
%private, but \codeHook{spec\unsc public} (i.e.~publicly visible
%in specifications) field
%\codeHook{list}, which is an array of objects. The class invariant says
%that \codeHook{list} is not null, and in addition, its elements are
%never null.  Further, the class contains a method \codeHook{replace},
%which checks if its first parameter \codeHook{obj1} occurs in
%\codeHook{list}, and if this is the case, replaces it (once) by its
%second parameter \codeHook{obj2}. 

%\begin{figure}[t!]
%{\small
%\begin{verbatim}
%public class ListArray {
%//*@ spec_public @*/ private Object[] list;
%//@ invariant list != null && \nonnullelements(list);
	
%/*@ requires obj2 != null;
%  @ assignable list[*];
%  @ ensures \result == (\exists int i; 0 <= i && i < list.length && 
%  @                                    \old(list[i]) == obj1 && list[i] == obj2);
%  @*/ 
%  public boolean replace(Object obj1,Object obj2)
%  {
%    int i = 0;
%    /*@ loop_modifies this[*];
%      @ loop_invariant 0 <= i && i <= list.length && 
%      @                (\forall int k; 0 <= k && k < i ==> list[k] != obj1);
%      @*/ 
%    for (i = 0; i < list.length; i++ ) {
%      if ( list[i] == obj1) { list[i] = obj2; return true; }}
%    return false; }
%}
%\end{verbatim}
%}
%\caption{JML specification for class \codeHook{ListArray}}\label{FigJMLSpec}
%\end{figure}



\subsection{Well-formed BML specifications}
Above, we presented the formal grammar of BML.  However, we are
interested only in the strict subset of \emph{well-formed}
specifications. In particular, a well-formed BML specification should
be well-typed and respect several structural constraints, similar to
the structural constraints that the bytecode verifier imposes over the
class file format.

Examples of type constraints that a BML specification must
respect are the following:
\begin{itemize}
\item array access expression
$\arrayAccess{e_1}{e_2}$ is well-typed only if $e_1$ is of array
type and $e_2$ is of integer type;

\item field access expression
    $\fieldAccess{e}{\ident}$ is well-typed only if $e$ is
    of a subtype of the class where the field described by the constant
    pool element at index $\ident$ is declared;

\item any  expression $ e_1 \oplus e_2$, where \(\oplus\) is an arithmetic 
operator (\(+,-,*,/\) \emph{etc.}) is well-typed only if $e_1$ and $
e_2$ are of a numeric type;
    
\item predicate $e_1 \sim e_2$ where $\sim \in \{\leq,<,\geq,
>\}$ is well-typed only if the expressions $e_1$ and $e_2$ are of a 
numeric type;

\item predicate $e_1 \subtypeSpec e_2$ is well-typed only if the 
expressions $e_1$ and $e_ 2$ are of type \codeHook{java.lang.Class}
(which is the same as the JML type \TYPE); and

\item expression $\elemtype{e}$ is well-typed only if $e$ is of array type.

	  
\end{itemize}

Examples of structural constraints that a BML specification must
respect are the following: 
\begin{itemize}
\item all references to the constant pool must be to an entry of the
appropriate type; for example, given field access expression
$\fieldAccess{e}{\ident}$, we require that $\ident$ must reference a
field in the constant pool; while for the expression $\type{\ident}$,
we require that \(\ident\) is a reference to a constant class in the
constant pool;
    
\item every $\ident$ in a BML specification must be a correct
index in the constant pool table; and
    
\item if the expression $\locVar{i}$ appears in a BML method 
specification, $i$ must be a valid index in the method's local
variables table.
\end{itemize}

These well-formedness checks for BML are best implemented as an
extension of the bytecode verifier.
 

%\subsection{Evaluation of BML expressions}

%When defining the evaluation of BML expressions, a subtle point that
%has to be taken into account is the fact that at bytecode level no
%explicit boolean values are used, they are encoded as integers (but
%variables can still be of type \codeHook{boolean} --- this information is
%used by the BCV). Thus, to make sure that expressions such as
%\codeHook{\bsl result == \bsl exists i. i >= 0} are correctly evaluated,
%the evaluation of the quantified expression is wrapped up by a
%conditional function, returning 1 if the condition is true, 0
%otherwise.

\subsection{Semantics of BML expressions}

The semantics of BML specifications follows the semantics of JML
specifications~\cite{JMLReferenceManual05}. But, just a JML
specification can be mapped into a more fundamental Hoare triple
specification, we have also provided a semantics for BML in terms of a
basic logic for Java bytecode, namely the so-called
\mobius base logic that will be the core of the proof carrying code platform
developed within the project. This logic (see~\cite{BeringerH06} for
an earlier version of the logic, without exceptions) has been proven
sound in Coq \emph{w.r.t.}\ a formalisation of the virtual machine. On
top of this, a direct verification condition generator has been proven
sound, also in Coq. And, as a first step towards efficient tool
development, a translation of bytecode into guarded commands has been
defined and proven correct, \emph{w.r.t.}\ verification condition
generation.

Defining the mapping of BML specifications into this \mobius base
logic is defined in two steps. First the evaluation of predicates is
defined over the program state (\emph{i.e.}\ over the heap, store and
operand stack), and second the complete BML specifications are
translated into judgements of the \mobius base logic. Notice that this
embedding allows to use the verification condition generator for the
\mobius base logic also for BML specifications.

%As mentioned above, a BML specification can contain the following
%constructs: class specifications, method specifications, and statement
%annotations, in particular the \texttt{assert},
%\texttt{assume}, and  \texttt{set} annotations, that can occur at any 
%point in the program text, and loop invariants, loop frame 
%conditions, and loop variants, that are associated to loop blocks.
Judgements in the \mobius base logic are of the form
\(\JudgeF{\ppt}{A}{B}{I}\), where \(\LST\) is a proof context,
and \(\Anno\) the local annotation table, \emph{i.e.}~the table that
associates annotations with particular instructions. Further, \(A\) is
a (local) precondition, relating the state at label \ppt with the
initial state, while \(B\) is a (local) postcondition, relating the
initial, current and final state, and \(I\) is a (local) invariant,
\emph{i.e}\ a predicate that is supposed to hold throughout execution
of the current method.

Mapping class specifications (invariants and history constraints) and
method specifications into the \mobius base logic is straightforward.
Since the \mobius base logic only has one postcondition, the normal
and exceptional postconditions are combined into a single
postcondition, specifying with a case distinction which conditions
should hold if the state is normal or exceptional, respectively. Frame
conditions are also added to the postconditions, specifying
explicitly which variables are allowed to be changed. Since predicates
in the \mobius base logic specify properties over the whole heap, this
can be expressed directly: all locations that are not mentioned in the
frame condition of the method (evaluated in the prestate of the
method) should be unchanged. Methods with multiple specifications are
translated only after desugaring them into a single method
specification \emph{cf.}~\cite{RaghavanL00}. 

The different statement annotations (assert, assume, set and loop
invariants) are inserted in the local annotation table, at the
appropriate instruction\footnote{In fact, at tthe moment, the \mobius
base logic does not support ghost variables; but these will be added
in the near future.}. 

Loop variants can be transformed into a sequence of assert and set
annotations, after introducing appropriate ghost variables. This
transformation can be done at the level of BML, after which we can use
the mapping of set and assert annotations into the
\mobius base logic. 
The transformation of the BML specification basically proceeds as
follows.  Let \texttt{variant} be the expression declared in the
decreases clause.  We declare ghost variables \texttt{loop\unsc init}
(initially set to true) and \texttt{loop\unsc variant} (the 
preliminary initialisation of which is not essential). 
If \(l\) is the program point where we
enter the loop, then at that point we add an assertion
\begin{verbatim}
//@ assert !loop_init ==> (0 <= variant && variant < loop_variant);
\end{verbatim}
followed by:
\begin{verbatim}
//@ set loop_init = false;
//@ set loop_variant = variant;
\end{verbatim}
This ensures that every time the loop entry point \(l\) is reached
again, the decrease of the loop variant is checked. Only a path that
goes through the loop can set \texttt{loop\unsc init} to false.

For mapping loop frame conditions, we use again that in the
\mobius base logic we can express properties of the heap. 
We make a transformation into a sequence of assert and set
statements, declaring ghost variables to remember the old heap and
all locations mentioned in the loop frame condition, and a ghost
variable \texttt{loop\unsc init} as above. Then we assert at the entry
point of the heap that if \texttt{loop\unsc init} does not hold, any
location that is not mentioned in the loop frame condition should
remain unchanged. Notice that this assertion cannot be directly
expressed in BML, but it can be expressed in the \mobius base
logic. Finally, in the \mobius base logic we add appropriate ghost
variable updates to remember the old heap and the locations of the
loop frame condition when the loop was first entered.









