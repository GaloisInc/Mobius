\section{Compiling JML specifications into BML specifications}\label{SecJMLtoBML} 

Since it is often easier and more intuitive to write specifications
and do verifications at source code level, we have defined a compiler
from JML to BML:
\JMLtoBML. BML is designed to be very close to JML, so that the
correspondence between the original and the compiled specification
remains relatively clear. Notice that in principle, the same can be
done for the proofs,
\emph{i.e.}\ a source code level proof can be transformed into a
bytecode level proof. It is future work to define this in full detail,
but some work in this direction has already been done, see
\emph{e.g.}~\cite{BartheRS05}. 

The compilation of the JML specification is separated from the
compilation of the Java source code. In fact, \JMLtoBML takes as input
an annotated Java source file \emph{and} the Java class file produced
by a non-optimising compiler with the debug flag set. This debug
information helps us to compile the annotations correctly.

From the debug information, we use in particular the
\textbf{Line\_Number\_Table} and the \textbf{Local\_Variable\_Table}
attributes. The presence of these attributes is
optional~\cite{JVMspec}, but almost all standard non-optimising
compilers can generate these. The \textbf{Line\_Number\_Table} is
computed as part of the compilation of a method; it links line numbers
in the Java source code with the Java bytecode instructions.  The
\textbf{Local\_Variable\_Table} describes the local variables that
appear in a method.  

To be able to appropriately compile loop invariants, the control flow
graph corresponding to the list of bytecode instructions resulting
from the compilation of a method body must be a
\emph{reducible control flow graph}. This means basically that every 
cycle in the graph must have exactly one entry point, or in other words
 it is not possible to jump into the middle of a cycle from outside the cycle
(see~\cite{AhoSU86} for the full definition of reducibility). Note
that this is not a serious restriction; all non-optimising Java
compilers produce reducible control flow graphs and in practice even
most hand-written bytecode is reducible.

The compilation from JML specifications into BML compilations is
defined in several steps. As mentioned above, we assume that the Java
source code has been compiled with the debug flag set, and that we
have access to the generated class file.

\begin{description}

\item[Compilation of ghost and model field declarations] 
Ghost and model variables declared in the specification are
compiled into the special class attributes that contains all ghost
variable and model variable declarations. 
%entries are added in the constant pool. 

%\item [Desugaring of the JML specification] This is an optional step,
%to achieve more compact specifications directly. Here one would use
%the standard JML procedure for desugaring~\cite{RaghavanL00}. This
%desugaring can also be applied later on the BML specification directly.

\item[Linking and resolving of source data structures]
The JML specification is transformed into an intermediate format,
where the identifiers are resolved to their corresponding data
structures in the class file.  The Java and JML source identifiers are
linked to their identifiers on bytecode level, \emph{i.e.}\ the
corresponding indexes either from the second constant pool or from the
\textbf{Local\_Variable\_Table} attribute. This is similar to the
linking and resolving stage of the Java source code compiler.

\item[Locating instructions for annotation statements] 
Annotation statements, like loop specifications and asserts are
associated with the appropriate point in the bytecode program, using
the \textbf{Line\_Number\_Table} attribute.

A problem is that a source line may correspond to more than
one instruction in the \textbf{Line\_Number\_Table}. This makes it
complicated to identify the exact loop entry instruction in the
bytecode, and thus to know to which instruction the compiled loop
specification should be associated. 
 
To solve this, we use the following heuristics: if the control
flow graph of the bytecode is reducible and we search from an index
in the \textbf{Line\_Number\_ Table} that corresponds to the first line
of a source loop, then the first loop entry instruction found will be
the loop entry corresponding to this source loop.  We do not have a
formal correctness proof for this algorithm, because it depends on the
particular implementation of the compiler.  However, our experiments
show that the heuristic works successfully for Sun's non-optimising
Java compiler.
 
\item[Compilation of JML predicates]
JML predicates are Java boolean expressions. However, the JVM does not
provide direct support for several integral types, such as byte,
short, char, or for booleans. Instead, they are encoded as integers.
Therefore, the compiler wraps up the boolean expressions in the JML
specification by a conditional function, returning 1 if the predicate
is true, 0 otherwise.

\item[Generation of user-specific class attributes]
Finally, the complete specification is compiled into appropriate
user-specific attributes, using the format defined in the previous
section. 
    
\end{description}

