\documentclass[a4paper]{llncs}

\usepackage{epsfig}     %% om xfig gegenereerde pstexs te includen

% to be removed in final version
\pagestyle{plain}

\title{Formal specification of Gemplus' electronic purse case study}

\author{
  N\'estor Cata\~no
\and
  Marieke Huisman
}

\institute{
  INRIA Sophia-Antipolis, France \\ 
  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
}

\newcommand{\noth}{\(\backslash\)\texttt{nothing}}
\newcommand{\fieldsof}{\(\backslash\)\texttt{fields\_of}}
\newcommand{\reach}{\(\backslash\)\texttt{reach}}
\newcommand{\comment}[1]{\marginpar{\framebox{\begin{minipage}{\marginparwidth}{#1}\end{minipage}}}}

\begin{document}
%\input{texdefs.tex}

\maketitle


\begin{abstract}
This paper presents a case study in formal specification of smart card
programs, using ESC/Java. It discusses an electronic purse
application, provided by Gemplus, that we have annotated with
functional specifications (\emph{i.e.}~preconditions and
postconditions, modifies
clauses and class invariants), that are as detailed as possible. The
specification is based on the informal documentation of the
application. The implementation has been checked \emph{w.r.t.}~the
specification, using ESC/Java.  This revealed several errors or
possibilities for improvement in the source code (\emph{e.g.}~removing
unnecessary tests).

Our paper shows that a relatively
lightweight use of formal specification techniques can already have
a serious impact on the quality of a program and its
documentation. Furthermore, we also present some ideas on how ESC/Java
could be further improved, both
\emph{w.r.t.}~specification and verification.
\end{abstract}

\section{Introduction}
\label{SectIntro}

\subsubsection{Background}
When developing a large software application, a significant part of
the work is spent on writing clear and concise documentation. This
documentation serves several purposes: it helps the developers of the
application (to understand the implementation decisions taken by a
colleague, but also to understand ones own decisions after a certain
period of time), and it also is useful when somebody else builds a new
application, using features provided by the application at hand.

However, such program documentation is only useful if it correctly
describes the implementation, thus one would like to have some trust
in its appropriateness. A way to achieve this is to write a formal
specification, \emph{i.e.}~a description of the program behaviour in
logic, and then prove the correctness of the implementation
\emph{w.r.t.}~this specification, but this is difficult (as it
requires a good understanding of the semantics underlying the
specification and programming language), and labour-intensive (see
\emph{e.g.}~\cite{HuismanJB00a} for an example of full program
verification). Thus, although it is feasible to do formal
specification and verification, the costs in general do not outweigh
the benefits.

Recently, several suggestions have been made to overcome these
problems. First of all, to encourage application developers to write
formal specifications, specification languages have been developed
which are close to programming languages. The annotation language for
Eiffel~\cite{Meyer97} is the first example of such a specification
language, and recently several annotation languages for Java have been
proposed, following the same strategy:
JML~\cite{LeavensBR99}, ESC/Java~\cite{ESCJavaUrl}, and
the Jass annotation language~\cite{JassUrl}. For JML and ESC/Java,
effort has been put into making these specification languages
converge~\cite{EscJmlDiff}, so that the respective tools can be used
for both languages. Typical for these languages is that
expressions are written as Java expressions, extended with some
specification-specific constructs.

Secondly, together with the ESC/Java language, a static checker has
been developed~\cite{ESCJavaUrl}, which can be used to check simple,
but useful properties. This static checker tries to check that a
program satisfies its annotations, by using a dedicated, automated
theorem prover. This automated theorem prover has been fine-tuned to
find common programming problems like
\texttt{Null\-pointer\-Exception}s, and
\texttt{Array\-Index\-Out\-Of\-Bound\-Exception}s, but it also can be
used to check other annotations. If the theorem prover cannot
establish that a certain specification is satisfied, ESC/Java issues a
warning. Such a warning does not necessarily mean that the program is
wrong, as the ESC/Java approach is neither sound, nor complete. When
designing the tool, a compromise has been made between soundness,
completeness, and efficiency. The result is an efficient checker, that
can increase the confidence in the correctness of programs, and that
finds many common programming errors. However, if one wishes to
establish formally the correctness of a complicated algorithm, other
verification techniques have to be used, as advocated in
\emph{e.g.}~the LOOP project~\cite{LOOPUrl} or the Jive
project~\cite{MeyerP00}. But even for such complex algorithms it pays
to use ESC/Java first, in order to find a first approximation
of the errors in the algorithm and/or specification, before diving
into the complete formal verification.

Annotating programs with ESC/Java specifications can thus be helpful
to create reasonably quick, clear and concise documentation for
a software application, which is according to the implementation.

\subsubsection{This paper}
To demonstrate the usefulness of this approach, this paper describes
the ESC/Java annotation of a smart card application case study, which
is the implementation of an electronic purse. The original source code
of this case study comes from Gemplus~\cite{PurseUrl}. In this
paper we discuss the annotations of the source code, and several
possibilities for improvement that we encountered.

The result of this work does not give a fully verified specification,
but it gives a reasonable description of the electronic purse
implementation, which could serve as a basis for further formal
verification, \emph{e.g.}~by using the LOOP compiler.  The main
contribution of this paper is that it shows that by making light
weight use of formal verification techniques, it is feasible to
\emph{(i)} write a formal specification of an application, and
\emph{(ii)} have the implementation checked \emph{w.r.t.}~the 
specification so as to increase confidence in the correctness of the
implementation. When specifying the purse we have found several
(simple) properties which are informally documented, but are not
preserved by the implementation. It is straightforward to formally
specify these properties and ESC/Java immediately finds the places
where these properties are not preserved in the implementation.

Furthermore, to the best of our knowledge this case study is one of
the first larger case studies using ESC/Java, and we found
several points for improvement in the static checker and its
specification language. This lead us to a wish list on improvements in
the specification language and to the development of a checker for
so-called modifiable clauses. This checker will be described in a
separate paper.%, but we use it in this case study to get further
%confidence in the accurateness of the specification.

The rest of this paper is organised as
follows. Section~\ref{SectGenPurse} describes the general outline of
the case study. Section~\ref{SectStatic} describes the tools that we
used for the static checking of the specification: ESC/Java and our
own modifiability checker. Section~\ref{SectSpecPurse} describes the
annotations of the purse in more detail, and discusses several
interesting aspects of the specification. Section~\ref{SectESC}
comments on the use of ESC/Java and gives suggestions for
improvement. Finally, Section~\ref{SectConcl} gives conclusions and
presents future work.






\section{General outline of the Electronic Purse}
\label{SectGenPurse}

The electronic purse is a JavaCard application~\cite{JavaCardURL}, published
as an advanced smart card programming case study by
Gemplus~\cite{PurseUrl}. A JavaCard smart card is capable of running
programs developed in {JavaCard}, a dialect of
standard Java. {JavaCard} does not provide concepts such as dynamic
class loading, security management, multi-threading and
synchronization, object cloning and large primitive date types (float,
double, long and char).  JavaCard applications are called
\emph{applets}.  The electronic purse applet provides  the ability to 
perform banking operations to the card holder. Typical operations are
credit, debit, and changing the currency.

\paragraph{\bf The \textit{debit} operation.} 
Debit operations that involve an amount greater than
\texttt{maxDebitWOPIN} are protected by a pin code. During one session, 
a user can do several of these transactions by presenting his pin code
only once. To protect the card against attacks, the number of
transactions that can be performed without presenting a pin code is
limited to \texttt{maxTransactionWOPIN}.

%During a debit
%operation, if severals transactions are carried out in the same
%session, it is possible that the card user presents once his pin code
%for amounts greater than
%\texttt{maxDebitWithOutPIN}. This variable
%represents the biggest quantity that certain client may credit without
%presenting his pin code. For
%security reasons, the card holder can do at most
%\texttt{maxTransactionWithoutPIN} transactions in a same session. 



\paragraph{\bf The \textit{credit} operation.} 
If the balance on the card is not sufficient to execute a certain debit
operation, the balance can be increased by performing a credit
operation. To do this, the terminal asks the bank for credit
permission. If the permission is obtained, the account is credited and 
a confirmation is sent to the bank.


\paragraph{\bf The \textit{currency change} operation.} The balance
of the purse is expressed in a certain currency. When the card holder
travels, he can change the current currency. In order to do this, the
terminal requests a new exchange rate and a certificate from the bank
. The purse verifies that the bank is really the expected bank and
validates the exchange rate. After changing the balance value, the
purse must modify all variables related to the currency. \\

The purse applet interacts with so-called \textit{loyalty applets}
(implementing \emph{e.g.}~a frequent flyer program) that may be
present on the card. Within the loyalty applet, the card holder gets
loyalty points having made certain purchases, and these points can be
used later to make other purchases. Further, a \textit{card issuer
applet} should be available on the card, which can initialise the
purse. Finally, the purse applet also communicates with the 
point of sale terminal. 
%These applets send and receive
%information concerning on the card user operations. 

The purse application consists of three packages$:$ \texttt{utils},
\texttt{purse} and \texttt{pacap\-interfaces}. The {\tt utils} package
implements basic classes such as \texttt{Annee} (year), 
\texttt{Mois} (month) \texttt{Jour} (day), and \texttt{Decimal}
(floating point numbers).  The \texttt{pacap\-interfaces} package
declares sharable interfaces which enable the purse applet to
communicate with \emph{e.g.}~the loyalty applets on the card.  The
\texttt{purse} package is the core of the purse application.  It
contains the class
\texttt{PurseApplet}, which manages the operations related with 
installation, selection and deselection, and which communicates with the
point of sale terminal.  The basic purse functionalities are
implemented in the class
\texttt{Purse}. This class performs the communication
with the loyalty applets, using the interfaces described in the
\texttt{pacapinterfaces} package.  Also, this class keeps track of the 
balance of the purse, the transactions done by the purse (stored as a
\texttt{TransactionRecord}), the different currency changes that have
taken place (in a \texttt{ExchangeRecord}) and the different
loyalty programs that the card holder is subscribed to (in a
\texttt{LoyaltiesTable}). 

%This class uses instance variables for
%implementing its functionalities. So, for instance, the different
%transactions carried out by the purse are stored in a variable of type
%\texttt{TransactionRecord}, where its individual components are of
%type \texttt{Transaction}. A similar situation occurs with the current
%currency and the different loyalties managed by the purse.

Certain operations can only be performed by a restricted set of users,
\emph{e.g.}~because a pin code is needed.
The class \texttt{AccessCondition} defines the different access
conditions, and the class \texttt{AccessControl} binds the access conditions
to the operations. So, when a card holder intends to perform a certain
operation, the purse application will check that the card holder has
the appropriate permissions. %The class
%\texttt{AccessControlTable} permits to declare
%all of different access controls that purse uses. 
%When the currency change takes place, the 
%\texttt{Purse} class uses an \texttt{ExchangeSession} class instance to 
%record the information corresponding to a session. The record of
%different currency exchanges is registered using a
%\texttt{ExchangeRecord} instance variable. 
The class \texttt{Currencies} stores the different currencies used by
the purse application.  Finally, the purse application contains several classes
implementing cryptographic concepts, namely, \texttt{PacapCertificate},
\texttt{PacapCipher}, \texttt{PacapKey}, \texttt{PacapRandom},
\texttt{PacapSecureMessaging} and \texttt{PacapSignature}. These
classes are not studied in full detail in this case study.






\section{Static checking of Java programs}
\label{SectStatic}


%\subsection{\sc \bf ESC/Java}
\label{SubSectEscJava}

ESC/Java is a verification tool developed at Compaq SRC, which permits 
a user
to find common errors in Java programs. The basic idea is that a user
specifies the desired behaviour of a class and its methods and
the ESC/Java tool checks whether the implementation satisfies the
specification. If it cannot establish this, it issues a warning.
%specify conditions that class and methods have to provide, and
%after using the tool for checking them. Esc/Java contrasts the done
%specification against the source code and it issues a warning
%message. This warning message indicates a \emph{possible} incoherence
%in the implementation w.r.t the implementation (the specification is
%supposed being correct).

The specifications are given as
\textit{preconditions}, \textit{postconditions} and \textit{class
invariants}. The properties are specified as Java expressions,
enriched with several specification-specific constructs. Here, we
present some Esc/Java constructs (called pragmas), together with an
example of their use. Their full description can be found
in~\cite{LeinoNS00}.

\subsection{ESC/Java pragmas}
\subsubsection{Pragmas for specifying methods}
\begin{itemize}
\item{\texttt{requires P}.}
This pragma specifies a precondition {\tt P}.
When Esc/Java checks the body of the
routine, it assumes that \texttt{P} holds initially, but when
Esc/Java checks a method call, it will issue a warning if
it can not establish that \texttt{P} holds at the call site.

\item{\texttt{ensures Q}.}
This pragma specifies a postcondition \texttt{Q}. The postcondition 
is supposed to hold if the method terminates normally, \emph{i.e.}
without throwing an exception.

\item{\texttt{exsures (E) R}.}
This pragma specifies a exceptional condition. This condition is
supposed to hold if the method finishes abruptly, if
the exception \texttt{e} that is thrown is a subclass of \texttt{E}.

\item{\texttt{modifies L}.}
This pragma specifies that the routine \emph{may} only modify any of
the state components listed in \texttt{L}, the formal parameters of
the method and the variables local to the method.
\end{itemize}



\subsubsection{Specification expressions}
\begin{itemize}
\item{\texttt{==>}} is the logical implication. So, \texttt{P
==> Q} is true if and only if \texttt{P} is false or \texttt{Q} is
true, where \texttt{P} and \texttt{Q} are specification expressions of 
\texttt{boolean} type. Furthermore, \texttt{<==>} represents the
equivalence relation and \texttt{<=!=>} specifies non-equivalence.

\item {($\backslash$\texttt{forall T V; E)} and
($\backslash$\texttt{exists T V; E})} are quantifier expressions (of
type \texttt{boolean}).  The first one denotes that \texttt{E} is true
for all substitutions of values of type \texttt{T} for the bound
variable \texttt{V}. The second one denotes that \texttt{E} is true
for a substitution of a value of type \texttt{T} for the bound
variable \texttt{V}.

\item{\texttt{$\backslash$old($E$)}} is used within a postcondition, where it denotes the value of \texttt{E} in the pre-state of the method invocation.

\item {\tt$\backslash$result} represents the value returned by
a non-void method method. It can only be used within an
\texttt{ensures} clause.
\end{itemize}


\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
/*@
  modifies nbData, data[nbData];
  ensures (\old(nbData) < MAX_DATA) ?
            (nbData == \old(nbData) + 1 && data[\old(nbData)] == cur) :
            (nbData == \old(nbData));
*/
void addCurrency(byte cur){
   if(nbData < MAX_DATA) {
      data[nbData] = cur ;
      nbData++ ;
   }
}
\end{verbatim}
\caption{Example ESC/Java specification}
\label{fig-add-cur}
\rule{\linewidth}{0.3mm}
\end{figure}


Figure~\ref{fig-add-cur} shows a typical annotation example using
Esc/Java. This example was taken from the specification of the
electronic purse case study. The \texttt{addCurrency} method belongs
to the class \texttt{Currencies}. This class stores all currencies
supported by the purse application. The method
\texttt{addCurrency} adds a new currency to the list of valid
currencies. This list is represented by the
array \texttt{data}. The \texttt{modifies} clause declared in the
method's header specifies that
this method may modify \texttt{nbData} and
\texttt{data} in the position \texttt{nbData}\footnote{More precisely, it
specifies that the method only may modify these instance variables and
the local variables and formal parameters of the method.}. The
postcondition of the method \texttt{addCurrency} (written as
\texttt{ensure} clause) expresses that if \texttt{nbData} has not
yet reached the threshold value \texttt{MAX$\_$DATA}, \texttt{nbData}
will increase its value by one and the value of the formal parameter
\texttt{cur} will be assigned to \texttt{data[\(\backslash\)old(nbData)]}. 
Inside the postcondition, the expression
\texttt{$\backslash$old(nbData)} refers to the value of
\texttt{nbData} before the method invocation.






\section{Specification of the Electronic Purse}
\label{SectSpecPurse}


\subsection{The general specification approach}
ESC/Java forces one to start writing specifications for the classes
that are `used' by many other classes, either because they are used as 
components or because they are inherited from. In the electronic purse 
case study most classes inherit directly from classes as
\emph{e.g.}~\texttt{Object}, \texttt{Exception} or -- in the case of
interfaces -- \texttt{Shareable}, so the inheritance structure is not
very complex. Therefore, we started by specifying classes that
provide basic (and general) features, \emph{e.g.}~those in the
\texttt{utils} package,
that are used by the classes in the \texttt{purse} package. The
specifications for these basic classes form the basis for the
specification of the more application-specific classes, so it is
important that they are sufficiently detailed.

For every method, we specify the precondition (\texttt{requires} clause
in ESC/Java), the postcondition (\texttt{ensures}), the modifies
clause (\texttt{modifiable}), and the exceptional postcondition
(\texttt{exsures}). ESC/Java does not have a keyword to specify that a
method may not modify any variables, but this is implied by the
absence of a modifies clause. To make our specifications explicit
about this, in such a case we added a comment
\texttt{modifiable \noth;} -- as in JML. Further, ESC/Java requires 
that every exception that is mentioned in the exceptional
postcondition, is also mentioned in the \texttt{throws} clause of the
method. To avoid having to add \texttt{throws} clauses to every method,
in many cases we chose to have the assertion \texttt{exsures
(Exception) false;} as a comment, without having it checked by
ESC/Java. However, everywhere where there can be any doubt about the
correctness of the \texttt{exsures} clause, we add the \texttt{throws}
clauses and have it checked by ESC/Java.

When writing method specifications, two different approaches can be
taken: either a precondition is given which ensures that no exceptions
will be thrown, or one specifies a light precondition
(\emph{e.g.}~true), and an exceptional postcondition which describes
under which conditions an exception will be thrown. For example, given
the left specification, one has to show that \texttt{P} is satisfied
before the method is called, and then it is guaranteed that the method
cannot produce an exception, while the right hand specification makes
no requirements on the method call, but specifies that if an exception
occurs, this is because \texttt{P} did not hold.
\begin{verbatim}
/*@ modifiable M;                     /*@ modifiable M;
    requires P;                           requires true;
    ensures Q;                            ensures Q;
    exsures (E) false;                    exsures (E) !P;
*/                                    */
void m() {                            void m () {
..                                    ..
}                                     }
\end{verbatim}

In our specifications, we usually follow the first approach, which
is close to the \emph{design by contract} approach~\cite{Meyer97},
unless the informal documentation clearly suggests that the second
approach is intended.

Furthermore, we specify appropriate class invariants for each class,
typically restricting the set of legal values for the instance
variables. In some cases, the class invariant immediately follows from
the informal documentation (\emph{e.g.}~the documentation in class
\texttt{Decimal} states
\texttt{the decimal part must be done in the interval [000,999]}), and
in other cases the appropriate class invariant follows from closer
inspection of the code, \emph{e.g.}~a variable is never \texttt{null}.
Section~\ref{SectSpecDetails} discusses the specification of class
invariants in more detail.

Sometimes discrepancies between the informal documentation and the
implementation occur. In general we try to follow the informal
documentation, and we correct the implementation where necessary
(and document these changes). In several cases we consulted the case
study developers at Gemplus, to get a better understanding which
behaviour was actually intended.

In the case study, several functions from the JavaCard
API~\cite{JavaCardAPI} are used. When we specify methods using API
functionalities, we use the API specification as constructed by Erik
Poll and Hans Meijer (see~\emph{e.g.}\cite{MeijerP01}).  In the
classes \texttt{Purse} and \texttt{PurseApplet}, several classes are
used that we do not have access to. To overcome this problem, we
construct specification files, specifying optimistically
(\emph{cf.}~\cite{FlanaganL01}) the methods and fields that we need,
but without giving an implementation.

Our aim is to give a functional specification of the behaviour of the
purse. However, we did not study the algorithms to manage secret keys,
and therefore we only give a light weight specification
(\emph{i.e.}~specifying the precondition and modifies clauses, but no
postcondition) of the classes dealing with key generation and
certification. This enables us to write and check the specifications of
the classes \texttt{Purse} and \texttt{PurseApplet}. How to specify
and verify cryptographic algorithms is a topic of future research.

\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
/*@
  requires d != null;
  ensures \result == (intPart>d.intPart ||
                     (intPart == d.intPart && 
                        (decPart == d.decPart||decPart > d.decPart)));
*/
public boolean isGreaterEqualThan(Decimal d){
  boolean resu = false ;
  if(intPart>d.getIntPart()) resu = true ;
  else if(intPart<d.getIntPart()) resu = false ;
  else if(intPart==d.getIntPart()){
    if((decPart>d.getDecPart()) || (decPart>d.getDecPart())) resu=true ;
    else if(decPart<d.getDecPart()) resu = false ;
  }
  return resu ;
}
\end{verbatim}
\caption{Method {\tt isGreaterEqualThan}}
\label{fig-cla-dec}
\rule{\linewidth}{0.3mm}
\end{figure}

We aim at giving specifications which produce a minimal amount of
ESC/Java warnings, but not all warnings can be avoided. Typically, if
a complex control structure occurs in a method (\emph{e.g.}~loops in
which method calls are made) ESC/Java is unable to establish
complicated postconditions. If one wishes to certify these methods,
other verification techniques, as advocated \emph{e.g.}~in the LOOP
project~\cite{LOOPUrl}, should be used. However, in the case study at
hand such complex control structures are not very frequent and
ESC/Java is able to check most of the specifications without any
problems.

At~\cite{CatanoH01Url} the full annotated version of the purse case
study can be found. In the code it is documented which postconditions
cannot be established by ESC/Java. It is also documented which changes 
we have had to make to the code.




\subsection{Interesting aspects of the specification}\label{SectSpecDetails}
Below, several interesting aspects of the specification are discussed
in more detail. First we elaborate on some implementation errors
that we found in the purse application.  Then we discuss the
specification of implicit class invariants, and how this can help to
simplify the code. Finally, we discuss some miscellaneous aspects of
the case study, and present some possible improvements. The problems
that we have found probably also would have been found by doing
thorough testing, but using theorem proving techniques one is sure not
to forget some cases. Also, writing the formal specifications forces
one to think very precisely about the intended behaviour of programs,
which helps in finding errors. 






\subsubsection{Implementation mistakes}
This section presents some examples of common programming
errors, and how we found them using ESC/Java.
% At the begining, when we start to assert this application, we
%had only on hands an informal specification of the classes, seldom
%complete. Several mails after we achieved to have a more detailed informal
%specifications of classes from the GemPlus team, which reflected what
%the source code actually intended for. By taking this informal
%specification, making assertions Esc/Java specification for classes
%and methods and finally running Esc/Java on this asserted code, we
%have found gap points where the source code, specifically classes and
%methods, does not provide their specification. This kind of errors
%could has been found by hand, but using a tool like Esc/Java give us
%the certainty all cases will be considered.



\paragraph{The isGreaterEqualThan method}


The class \texttt{Decimal} 
represents a floating point number 
composed of a decimal part and an integer part,
represented by instance variables \texttt{decPart}
and \texttt{intPart}, respectively. The
method \texttt{isGreaterEqualThan} (see Figure~\ref{fig-cla-dec})
belongs to this class and (as suggested by its name and the informal
documentation) it is supposed to decide whether the
decimal represented by \texttt{this} is greater or equal than the
decimal represented by parameter
\texttt{d}. This behaviour is specified in the method specification.

However, after running ESC/Java on this asserted method, a warning is
issued, suggesting that the postcondition
might not hold. Inspection of the code reveals a
\emph{``copy paste''} error in the fourth \texttt{if} statement, where 
the same condition is tested twice, on both side of an \texttt{||}
(or) operator. Replacing this condition 
%on line $6$. On this
%line, the same
%condition is checked in both sides of the \emph{or} Java operator. A
%detailed revision of this code show us that this source code really
%implements a supposed \emph{isGreatherThan} method. So, if for example 
%the \texttt{if} guard is replaced 
by \texttt{decPart >= d.getDecPart()} would solve the problem,
although it would probably be better to rewrite the method so that it
simply tests the condition as expressed in the postcondition.

% this source
%code would implement really what its informal specification aims,
%although this one it would not be the most reduced one. One nicer
%way to do it would consist of taking the \texttt{ensure} clause self,
%for instead.






\paragraph{Final modifiers}

\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
/*@
  modifies jour, mois, annee;
  requires j >= Jour.MIN  && j <= Jour.MAX;
  requires m >= Mois.MIN  && m <= Mois.MAX;
  requires a >= Annee.MIN && a <= Annee.MAX;
  ensures jour == j && annee == a && mois == m;
*/
public void setDate(byte j, byte m, byte a) throws DateException{...} 
\end{verbatim}
\caption{Fragment of class {\tt Date}}
\label{fig-cla-dat}
\rule{\linewidth}{0.3mm}
\end{figure}



The class \texttt{Annee} represents a \textit{year}. It 
declares two
static variables called \texttt{MIN} and \texttt{MAX}, which represent
the minimum and maximum year allowed by the application.
Its declarations are as follows:
\begin{verbatim}
public static byte MIN = (byte)99 ;
public static byte MAX = (byte)127 ;
\end{verbatim}

The class \texttt{Annee} also defines a method \texttt{check}, which is
used to determine whether a value is between \texttt{MIN} and \texttt{MAX}. The
class \texttt{Date} has three instance variables, representing the
components of a date: \texttt{jour} (day),
\texttt{mois} (month), and \texttt{annee} (year). The method
\texttt{setDate} (see Figure~\ref{fig-cla-dat})
in this class assigns its arguments to these
instance variables, provided they are in a valid interval (see the
\texttt{requires} pragma). %In the particular case of the parameter
%that represents a year, \texttt{setDate} uses the
%method \texttt{check} of the \texttt{Annee} class to check this
%value is in range. 
Surprisingly, ESC/Java complains when it
finds a statement such as
\mbox{\tt date.setDate((byte)1, (byte)1, (byte)110);} (where date is a
instance of class \texttt{Date}). The warning message states that the
the third precondition of this call might not hold, even though 110 is 
between 99 and 127.
%third does not verify the third condition. This warning is shown in
%spite of this call respect the
%requires condition, i.e, $110>=99\ \&\&\ 110<= 127$.

The problem is caused by the erroneous declaration of the variables 
\texttt{MIN} and \textsc{MAX} variables in class \texttt{Annee}.
Because these variables are not declared 
\texttt{final}\footnote{According to the Java semantics, final
variables may only be modified when they are initialised, and
afterwards they remain constant.}, their values can be
changed at runtime by
a direct assignment (as they are declared public). Thus, because the
values of \texttt{MIN} and \texttt{MAX} might have changed, ESC/Java
warns that possibly the precondition might not be satisfied.








\subsubsection{Class invariants}
Typically, invariants are used to restrict the state space of a class,
\emph{i.e.}~the set of allowed values for its instance variables. The
most common example is an invariant which states that a reference may
never be a null pointer, \emph{e.g.}~the variable
\texttt{Purse purse}, as declared in the class \texttt{PurseApplet}
should never be null.
\begin{verbatim}
//@ invariant purse != null;
\end{verbatim}
Another common example of an invariant is to restrict the possible
values of a numeric variable to a certain range. As remarked above, in
the class \texttt{Decimal} it says that the value of the decimal
fraction must be between 0 and 999. Inspection of the code reveals 
that the integer part of the decimal number is supposed to be a
positive short, and combining this gives the following class
invariant\footnote{\texttt{MAX\_DECIMAL\_NUMBER} is equivalent to the
maximal value of a short and the clause \texttt{intPart <=
MAX\_DECIMAL\_NUMBER} of the invariant will thus be
ensured by the type of the variable. We chose to state this explicitly
for clarity of specification.}
\begin{verbatim}
/*@
  invariant decPart >= 0 && decPart < PRECISION ;
  invariant intPart >= 0 && intPart <= MAX_DECIMAL_NUMBER;
*/
\end{verbatim}

In Java(Card) there are no enumeration types, and to simulate them
typically several constants are defined with suggestive names, and a
variable is silently assumed to contain always one of these
values. This implicit assumption can be made explicit by specifying
invariants. For example, the class \texttt{Transaction} contains the
following declarations.
\begin{verbatim}
/* the transaction status*/
public static final byte INDETERMINE		= (byte)0;

/* the transaction status*/
public static final byte TYPE_CREDIT		= (byte)50;
/* the transaction status*/
public static final byte TYPE_DEBIT		= (byte)51;
    
/* the transaction type: debit or credit*/
/*@ spec_public*/ private byte type;
\end{verbatim}

This suggests that the variable \texttt{type} always should have a
value \texttt{TYPE\_CREDIT} or \texttt{TYPE\_DEBIT}. However, in the
code (in the method \texttt{reset()}), an assignment \texttt{type =
INDETERMINE;} occurs, suggesting that this is also a correct value for 
\texttt{type}. Having a specification which states the allowed values
for this variable avoids all confusion\footnote{However, notice that it 
does not prevent that other -- arbitrary -- variables can have one of
these values, thus this does not completely simulate enumeration
types.}.
\begin{verbatim}
/*@ invariant type == INDETERMINE ||
              type == TYPE_CREDIT || 
              type == TYPE_DEBIT;
*/
\end{verbatim}

Invariants of this kind occur often in the specification of the
electronic purse. It is easy to specify them, and useful as well, as
there are examples in the electronic purse where such implicit
invariants are violated.
For example, the class \texttt{AccessCondition} declares constants to
state the different access conditions for the actions in the
purse. Following~\cite{BretagneMGL00}, variables that denote access conditions
should be restricted as follows.
\begin{verbatim}
/*@ invariant condition == FREE ||
              condition == LOCKED ||
              condition == SECRET_CODE ||
              condition == SECURE_MESSAGING ||
              condition == (SECRET_CODE | SECURE_MESSAGING);
*/
\end{verbatim}

However, in the constructor of this class, the variable
\texttt{condition} is set to 0, which breaks this
invariant. Correcting this and maintaining the invariant also allows
to improve other parts of the implementation in this class. For
example, in the method \texttt{verify()}, the following statement
occurs:
\begin{verbatim}
switch(condition) {
  case FREE: ...
  case SECRET_CODE: ...
  case SECURE_MESSAGING: ...
  case SECRET_CODE | SECURE_MESSAGING: ...
  case LOCKED: ...
  default: //@ assert false;
           t = AccessConditionException.CONDITION_COURANTE_INVALIDE;
           AccessConditionException.throwIt(t);
  }
\end{verbatim}
Because of the invariant we know that the default case will never
be reached (as assured by the \texttt{//@ assert false;} annotation,
which states that false should hold, every time this program point is
reached), and thus that the exception never will be thrown. Thus, the
default case can be removed from the code.

Similar cases occur frequently with \texttt{try-catch} statements. An
operation is executed within a \texttt{try}, but as the class invariants
assure that the operation never will throw an exception, the
\texttt{catch} clause will never be executed. In the specification, we 
have annotated these cases with \texttt{//@ assert false;}. We think
that the removal of this ``dead code'' can improve the readability of
the class and, importantly for smart cards, it can reduce the 
size of the byte code.


\subsubsection{Miscellaneous aspects of the specification}
There are many other aspects of the specification that are worth
mentioning. Here we mention some.

\begin{itemize}
\item As explained above, in the class \texttt{Decimal}, two shorts
are maintained denoting the integer and the decimal part
(\texttt{intPart} and \texttt{decPart}, respectively) of a decimal
number. The integer part ranges between 0 and
\texttt{MAX\_DECIMAL\_NUMBER} (which is 32767, the maximal value for
shorts). It is left unspecified whether numbers such as
\texttt{MAX\_DECIMAL\_NUMBER}.999 are allowed. However, 
a method \texttt{round()} is defined, which
according to the documentation returns a decimal number with
\texttt{decPart} set to 0 and \texttt{intPart} set to the closest
integer value. An obvious specification of this method reads as
follows:
\begin{verbatim}
/*@ 
  modifies intPart, decPart;
  ensures decPart == 0;
  ensures intPart == (\old(decPart) >= (PRECISION/2) ?
                          (short)(\old(intPart) + 1) :
                             (short)(\old(intPart)))
*/
public Decimal round(){ ... }
\end{verbatim}
But, as pointed out by ESC/Java, an implementation of this
specification breaks the class invariant \texttt{intPart >= 0}. The
counterexample that is produced has
\texttt{intPart} set to \texttt{MAX\_DECIMAL\_NUMBER} and
\texttt{decPart} \emph{e.g.}~to 999. Possible solutions are to
specify explicitly the outcome of \texttt{round()} in the case that
\texttt{intPart == MAX\_DECIMAL\_NUMBER}, or to restrict the set of
valid decimal numbers by further strengthening of the class invariant
through addition of the following clause:
\begin{verbatim}
//@ invariant intPart == MAX_DECIMAL_NUMBER ==> decPart == 0;
\end{verbatim}
We chose this last solution. 

\item Among the developers of the electronic purse application there
apparently have been different ideas about the implementation of the
class \texttt{Decimal}. The implementation of several
\texttt{setValue(...)} methods
reveal that \texttt{intPart} is assumed to be greater or equal than
0, but on the other hand there are methods
\texttt{isNegatif()} and \texttt{isPositif()}, which test whether a
decimal value is negative or positive, respectively. As we specify
that \texttt{intPart} should be greater or equal than
0\footnote{\emph{cf.} our email exchange with H. Martin, Gemplus.}
these methods become obsolete. We can show this by specifying
that their results can be predicted, \emph{e.g.}~\texttt{isNegatif()} we 
specify as follows:
\begin{verbatim}
/*@ 
  ensures \result == false;
*/
public boolean isNegatif(){ ... }
\end{verbatim}


\item Two classes, \texttt{TransactionRecord} and
\texttt{ExchangeRecord} implement a cyclic table (of
\texttt{Transaction}s and
\texttt{ExchangeSession}s (storing currency changes),
respectively).  These implementations are clearly copied from each
other, but this is nowhere documented. Also the fact that a
cyclic data structure is implemented is not very well documented. Class
\texttt{TransactionRecord} contains a single remark that it is
implemented as a cyclic table, and for class
\texttt{ExchangeRecord} this is only stated in the documentation of a
private method. Also, no specification of the operations on the cyclic
data structure are given.

As a result, in class \texttt{ExchangeRecord}, part of the code that
is crucial for its  has been commented out by other
developers of the electronic purse. Having a formal specification
would probably have been helpful to explain the complexity of the
implementation to the other developers, and the ``wrong correction''
would have been signaled earlier\footnote{Of course, having a general 
implementation of a cyclic table and instantiating this for the
different kinds of data would have been even more elegant.}.

Finally, when writing the formal specifications of the cyclic tables,
we found an error in the implementation. When a delete operation is
called for an element that is not in the range of the table, the
operation nevertheless will be executed and as a side-effect it will
corrupt the table by erroneously moving its first element outside the
range of the table.
\end{itemize}


\section{On the use of ESC/Java}
\label{SectESC}
We find ESC/Java a useful tool, which is pleasant to work with, but
nevertheless we have some suggestions for improvements, both for the
specification language and for the verifier.

Concerning the specification language, we feel that certain
specification constructs that are available in JML~\cite{LeavensBR99},
should be provided in ESC/Java as well. They could be implemented as
syntactic sugar only, but would be useful to give clear and concise
specifications.  First of all, we would like to be able to use method
names in specifications, as is allowed in JML for so-called
\emph{pure} methods, \emph{i.e.}~methods without
side-effects. Further, we would like to have some extra specification
constructs for modifies clauses, \emph{e.g.}~\fieldsof, to denote all
the fields of an object, and \noth. Also we feel that having some
extra quantifiers, such as \texttt{\(\backslash\)min},
\texttt{\(\backslash\)max}, and \texttt{\(\backslash\)choose} could be 
useful to increase expressiveness of the specification language.

\begin{figure}[t]
\rule{\linewidth}{0.3mm}
\begin{verbatim}
    /*@
      modifies \fields_of(this), \fields_of(date), \fields_of(heure),
               id[*], terminalTC[*], terminalSN[*];
      requires es != null ;
      requires es.id != terminalTC & es.id != terminalSN &
               es.terminalTC != terminalSN;
      ensures this.equal(es);
      exsures (TransactionException e) 
                  e._reason == TransactionException.BUFFER_FULL 
                  && JCSystem._transactionDepth == 1; 
      exsures (NullPointerException) false;
      exsures (ArrayIndexOutOfBoundsException) false;
    */
    void clone(ExchangeSession es) { ...
    } 
\end{verbatim}
\caption{Specification of \texttt{clone} in \texttt{ExchangeSession}
in ideal ESC/Java}
\label{FigIdealESC}
\rule{\linewidth}{0.3mm}
\end{figure}

Figure~\ref{FigIdealESC} shows as an example how we would like the
specification of the method \texttt{clone()} in class
\texttt{ExchangeSession} to be (see~\cite{CatanoH01Url} for the
ESC/Java specification as it is). We only specify that all the fields
of the current class may be modified, without explicitly mentioning
them. As the fields of the component classes \texttt{date} and
\texttt{heure} may be modified as well, we mention this
explicitly. Similarly, we mention explicitly that the elements in the
arrays \texttt{id}, \texttt{terminalTC} and \texttt{terminalSN} may be
modified\footnote{In JML one can write this modifies clause also
simply as \fieldsof(\reach), which would probably be useful in many
cases as well, but has a more complex semantics.}. Further, instead of
having postconditions stating that all the fields are ensured to be
equal to the corresponding fields of \texttt{es}, this is denoted by
writing \texttt{this.equal(es)}, where \texttt{equal} is overwritten
appropriately in \texttt{ExchangeSession}.

Also, it would be nice if one could specify runtime exceptions in
\texttt{exsures} clauses, while they are not mentioned in the
\texttt{throws} clause of the method.

With respect to the verification that is done by ESC/Java, we found
that is unfortunate that ESC/Java does not try to check the modifiable 
clauses, because an incorrect modifiable clause can influence the 
acceptance of other specifications. Suppose one has the following
(annotated) methods$:$
\begin{verbatim}
  /*@ modifies x;
      ensures x == 3;
  */
  void m() { x = 3;
             n (); }

  void n() { x = 4; }
\end{verbatim}
Remember that a method without a modifies clause is assumed to modify
only freshly allocated memory, if any~\cite{LeinoNS00}. The
specification for method \texttt{m()} is thus accepted by ESC/Java,
although it is incorrect. When annotating existing programs, as we
did, it is easy to forget to mention that a variable may be modified,
and we felt the need to overcome this problem.

Therefore, we have implemented a static checker for modifiable
clauses. In the tradition of ESC/Java, this checker is designed to be
efficient, but it is neither sound, nor complete. It does a syntactic
analysis of the annotated program to recognise the various assignment
statements and then checks whether the variables that are the
``destination'' of an assignment are mentioned in appropriate modifies
clauses. This checker will be described in more detail in a separate
paper.

Finally, we feel that it would be an improvement if the ESC/Java
theorem prover would deal more precisely with arithmetic operations
(also on bytes and shorts). For example, several times we needed
for \emph{e.g.}~a byte \texttt{b} with a value between 0 and 10, but
after
the operation \texttt{b++} this variable still has a positive value.






\section{Conclusions}
\label{SectConcl}

We have presented a case study in formal specification of smart card
programs, using ESC/Java. We have taken an electronic purse
application and annotated it with a functional specification,
describing its behaviour, basing ourselves on the informal
documentation of the application. We have checked the implementation
\emph{w.r.t.}~the specification, using ESC/Java, thereby revealing
several errors in the implementation. Using ESC/Java we were also able 
to find that some parts of the program will never be reached, thus
allowing reduction of the code size -- which is important for smart
card applications. 

The errors that we found in general are not very complex, they could
have been found by careful code-inspection or testing. But, writing
the formal specification forces one to do code-inspection, and having
the theorem prover ensures that all possible cases will be
considered, when checking the specification.

The specifications that we have constructed for the electronic purse
application are not very complex, but describe the functional
behaviour of methods as precisely as possible. Nevertheless, we found
errors in the code, and we would like to emphasise that even simple
formal verification can help significantly to increase confidence in a
program. In particular, explicitly specifying class invariants turns
out to be very useful.

\subsubsection{Future work} We plan to work in the field of
specification languages for Java: how to improve them, and how to
develop appropriate verification techniques for them. In particular,
we will focus on the following points.
\begin{itemize}
\item We plan to develop a full smart card application from scratch, with
annotations. We are interested whether this will affect the quality of 
the specification and/or the program. Also we would like to know how
easy it is to construct the specifications at the same time as
developing the code. Is it useful, because one can get immediate
feedback on an implementation or, is it a burden because more time
is spend on keeping the the specification up-to-date than on
implementing the program.
\item Future versions of JavaCard will probably allow
multi-threading. Therefore we plan to study how ESC/Java (and JML)
can be used to specify (and check) concurrent programs.
\item Related with this is an extension of JML with
temporal logic. Currently we are studying how to integrate temporal
logic in the specification language, future work will be to study
appropriate verification techniques.
\item Most loop structures that are used in typical smart card
programs are very restricted and it is relatively easy to show their
termination. We plan to develop an automated verification technique for
termination of loops in the tradition of ESC/Java, covering the most
common cases.
\item We skipped the cryptographic aspects of the application at
hand. It is future work to see whether ESC/Java (or JML) is useful to
specify such algorithms more precisely, and to develop appropriate
(automated) verification techniques.
\end{itemize}

\bibliographystyle{plain}
\bibliography{../specification}

\end{document}

