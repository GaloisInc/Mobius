\documentclass[a4paper]{llncs}

\title{The \modif~clause: semantics, verification and application}

\author{
  N\'estor Cata\~no and Marieke Huisman  \\
  \institute{
       \inria~Sophia-Antipolis, France \\
       \lemme~Project \\
       2004, route des Lucioles, BP 93 
  } 
  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
}

\newcommand{\lemme}{\textsc{Lemme}}
\newcommand{\inria}{\textsc{Inria}}
\newcommand{\jml}{\textsc{Jml}}
\newcommand{\escj}{\textsc{Esc/Java}}
\newcommand{\jass}{\textsc{Jass}}
\newcommand{\jcontract}{\textsc{JContract}}
\newcommand{\loopp}{\textsc{Loop}}
\newcommand{\java}{\textsc{Java}}
\newcommand{\gplus}{\textsc{GemPlus}}
\newcommand{\eiff}{\textsc{Eiffel}}
\newcommand{\ctl}{\textsc{Ctl}}
\newcommand{\pltl}{\textsc{Pltl}}
\newcommand{\csrc}{\textsc{Compaq Src}}

\newcommand{\modtool}{\texttt{mod$:$tool}}


\newcommand{\modif}{\textit{modifiable}}
\newcommand{\modifies}{\textit{modifies}}
\newcommand{\sem}[1]{\ensuremath{\mbox{[\![} {#1} \mbox{]\!]}\/}}

\newtheorem {df}{Definition}

\usepackage{lscape} % it's needed to turn a page
\usepackage{amsmath} % it is needed by the \sem command
\usepackage{alltt}
\input{prooftree} %showing demonstration

\begin{document}
\fussy
\maketitle

\begin{abstract}
not yet
%We have worked in \jml, which is a specification language
%tailored to Java. \jml~allows us to specify the functional behavior
%of methods$:$ preconditions and postconditions, and apart from that,
%class invariants. Unfortunately, using only the functional
%specification of a
%method is not enough to reason about arbitrary method
%invocations. Therefore, the so-called \modif~clauses are
%introduced. By asserting a
%method with a \modif~clause, it is stated this method may only modify
%the set of expressions represented by its \modif~clause. There are
%several projects studying \modif~clauses such as \jml~and \escj~(a
%subset of \jml). The \jml~specification language gives a definition
%for the \modif~clause, but when the \jml~tool is run on an asserted
%\java~program, it does not do any checking on its \modif~clause
%specification. In the \loopp~project the
%implementation of some \jml~assertions pragmas are defined, including
%the \modif~ one. This implementation is based on a underlying memory
%model
%and the logic representation of \java~and the \jml~pragmas. This
%implementation is not yet an easy and fast method for its verification
%. This paper presents a first solution to achieve this in a context
%without \textit{aliasing}. For this specification we have made
%an implementation, which extends the functionality of the
%\jml~parser. Our approach presents some advantages over the
%\loopp~project approach, namely$:$ $(i)$ it is faster, and $(ii)$ the
%verification carried out is closer to the specification
%language. Additionally, an electronic banking case study has been used
%to demonstrate the usability of our approach~\cite{CH02}.
\end{abstract}

\section{Introduction}
\label{sec-intro}

\paragraph{\bf Background.}
For decades \emph{formal methods} were considered as a merely
theoretical issue in computer science, not suitable for real
problems$:$ \emph{complicated} notations brought from the logic and
the lack of tools supporting formal methods could not compete with the
tools and methods used in industry for software development. Recently, 
this has been changing. There are several reasons for this
change. Firstly, the specification languages are now closer to
programming languages than ever before and the techniques used are
more according to the actual programming paradigms (object oriented
and distributed programming). Secondly, industry has started to feel
the need for certified software. An example$:$ during $1995$,
\textsc{Intel} found a problem with its microprocessors
\textsc{Pentium}. This company was forced to replace around two
millions processors. It realized that the costs of formal
verification would have outweighed the loss caused by this
bug. 

There are three approaches for verification of software systems$:$
\textit{testing}, \textit{model-checking} and
\textit{theorem proving}. Testing checks whether a program produces
correct outputs on certain inputs. This technique is important for
checking some properties before applying a formal technique. A
disadvantage of this approach is that one spends a lot of time in the
process of constructing all possible testing cases. Moreover,
sometimes it is not possible to check all possible
inputs. Model-checking is based on constructing a finite model of a
problem and exhaustively checking the satisfaction of certain
properties. Model-checking is
a strong technique, it is \emph{decidable} for a specific
model, but it presents some limitations$:$ $(i)$ it can validate a
model of certain system but not the system it-self and $(ii)$
verification (even for simple systems) might need huge amounts of
space and time. 

Theoretically, theorem proving techniques are able to
solve any problem proposed in practice, but it presents some
disadvantages$:$ $(i)$ it is \emph{undecidable}, $(ii)$ the tools are
only capable of assisting an engineer in the process of constructing a
prove and $(iii)$ it requires expressing the semantics underlying the
programming language in the logic of the theorem prover, in order to
do program verification. 

Recently, several approaches have been
propose to overcome this kind of problems, and although they can not
actually replace formal verification techniques, constitute
important alternatives for checking the behavior of software
systems. \emph{Run-time
checking} is a kind of extended checking where, in addition to check
the input-output behavior, is checked whether certain specific
conditions are
satisfied at certain points of the program. For checking these
specific conditions, the original program is converted in another one,
which will be then executed. If this execution raises an exception,
this will indicate that the original program does not fulfill the
expected conditions.

The \emph{static checking} techniques, check the behavior of programs
from its source code. Usually, the tools implementing these
techniques are improved with dedicated theorem proving, which
automatically check some specific problems. Typically, this checking
does not take a lot of time.

For expressing these conditions, some specification languages are
commonly used, and they are typically \emph{asserted} as comments in
the
program source code. The annotation language for \eiff~is the first
example of such a specification language, following the \emph{design
by contract} approach~\cite{Mey97}. Currently, several specific
specification languages have been proposed for \java~such as
\jml~\cite{LBR00}, \jcontract~\cite{JContractUrl},
\jass~\cite{JassUrl} and \escj~\cite{LeinoNS00} (a subset of
\jml~\cite{EscJmlDiff}). Usually, these specifications serve to state
the functional behavior of the methods (typically as preconditions and
postconditions) and, apart of that, class invariants. However, the
functional behavior of the methods is often not enough to reason about
arbitrary method invocations. It is thus necessary to specify the
\emph{changeable} behavior of methods. By way of example, ......

The \jass~tool comes with the construct \textit{changeonly}, which
provides only a basic way to specify what expressions a method intends
to change, typically as variables joined by ``.''. \escj~specification
language provides an assertion construct,
\modifies, which specifies the set of expressions which a method
\emph{may} modify, but its tool does not check these kind of
specifications. Therefore, some verification problems occur.






\paragraph{\bf This paper.}We propose an static checker for
\modif~clauses in \java~programs with \jml~assertions\footnote{For
reasons of compatibility between \jml~and \escj~, we will 
use indistinctly the words \emph{modifiable} and \emph{modifies}},
based on a syntactical analysis of the source program. That
checker is neither sound nor complete (following the \escj~approach),
but is useful
for detecting some typical specification errors such as
forgetting to mention some variable
as \modif~when a method implementation actually may modify it, or
declaring a method without side-effects when it modifies some
expression. We can not always detect the most subtle errors because they 
require a detailed analysis, but by using our approach the most
simple errors can be detected quickly. We have defined certain
syntactical rules for every \java~construct, stating which
variables may be modified. Moreover, we have implemented
this approach by extending the \jml~parser and embedding these
conditions as \java~code. The viability of our approach is
shown by presenting some gaps found in the process of expressing the
\emph{changeable} behavior of a realistic case study~\cite{CH02} and
checking these specifications with our tool.


The rest of this paper is organized as follows$:$
Section~\ref{sec-esc-prg} presents briefly the specification language
\escj~together with its most important assertion
constructs. Section~\ref{sec-sem-mod-cla} shows the problems which
arise when the specifications of \modif~clauses are not
checked. Section~\ref{sec-giv-sin-def}
presents our approach for checking \modif~clauses and the definition
of the respective syntactical rules. Section~\ref{sec-imp-iss}
presents a modifiable checker (~\modtool) implementing these
rules. Additionally, we discuss some problems found using our tool on a
realistic case study~\cite{CH02}.
Finally, Section~\ref{sec-con}
gives conclusions and presents future work. 






\section{Static checking of \java~programs with \escj}
\label{sec-esc-prg}
\escj~is a static checker for \java~programs developed
at \csrc~\cite{ESC}, enabling a user to find common programming
errors of \java~programs. It counts on a dedicated theorem prover for
finding problems such as \emph{array index bounds},
\emph{nil deference} and \emph{synchronization} in multi-thread
programs. The basic idea is that
a user specifies the behavior of a class and its methods, by
using the specification language of \escj. This
behavior can be expressed as \textit{preconditions},
\textit{postconditions} and \textit{class invariants}. The \escj~tool
checks whether the implementation satisfies the given
specification and it issues a warning 
message if it can not establish this. Such a
warning does not necessarily mean that the program is
wrong, since the \escj~approach is neither sound nor
complete. 

\escj~is enriched with several
specification-specific pragmas. Below, we present
the main \escj~pragmas together with an example of their
use. Their full description can be found in~\cite{LeinoNS00}. 




\paragraph{\bf Pragmas for specifying methods} 
\begin{itemize}
\item{\texttt{requires P}.} 
This pragma specifies a precondition {\tt P}. 
When \escj~checks the body of a
method, it assumes that \texttt{P} holds initially and when checking
a method call, \escj~will issue a warning if 
it can not establish that \texttt{P} holds at the call point. 
 
\item{\texttt{ensures Q}.} 
This pragma specifies a postcondition \texttt{Q}. This postcondition
is checked against the body of method and assumed for any method
invocation if the method terminates normally (without throwing an
exception).
 
\item{\texttt{exsures (E) R}.}
This pragma specifies an exceptional condition. This condition is 
supposed to hold if the method finishes abruptly and if
the exception \texttt{e} that is thrown is a subclass of \texttt{E}. 
 
\item{\texttt{modifies L}.} 
This pragma specifies that the method \emph{may} only modify any of 
the state components listed in \texttt{L}, the formal parameters of 
the method and the variables local to the method. 
\end{itemize}
 
 
 
\paragraph{\bf Specification expressions} 
\begin{itemize} 
\item{\texttt{==>}} is the logical implication. So, \texttt{P 
==> Q} is true if and only if \texttt{P} is false or \texttt{Q} is 
true, where \texttt{P} and \texttt{Q} are specification expressions of  
\texttt{boolean} type. Furthermore, \texttt{<==>} represents the 
equivalence relation and \texttt{<=!=>} specifies non-equivalence. 
 
\item {($\backslash$\texttt{forall T V; E)} and 
($\backslash$\texttt{exists T V; E})} are quantifier expressions (of 
type \texttt{boolean}).  The first expression denotes that \texttt{E}
is true
for all substitutions of values of type \texttt{T} for the bound 
variable \texttt{V}. The second one denotes that \texttt{E} is true 
for a substitution of a value of type \texttt{T} for the bound 
variable \texttt{V}. 
 
\item{\texttt{$\backslash$old(E)}} is used within a postcondition,
where it denotes the value of the expression \texttt{E} in the
pre-state of the method.
 
\item {\tt$\backslash$result} represents the value returned by 
a non-void method. It can only be used within an
\texttt{ensures} clause.
\end{itemize}
Figure~\ref{fig-add-cur} shows a typical annotation example using 
\escj. This example was taken from the formal specification of an
\emph{electronic purse} presented in~\cite{CH02}\footnote{The overall
specifications of this application can be taken
from~\cite{CH01Url}}. The \texttt{addCurrency} method belongs
to a class \texttt{Currencies}. This class stores all currencies 
supported by the purse application. The method 
\texttt{addCurrency} adds a new currency to the list of valid 
currencies. This list is represented by the 
array \texttt{data}. The \texttt{modifies} clause declared in the 
method's header specifies that 
this method \emph{may} modify \texttt{nbData} and 
\texttt{data} in the position \texttt{nbData}\footnote{More precisely,
it specifies that the method only may modify these instance variables
and the local variables and formal parameters of the method.}. The
postcondition of the method \texttt{addCurrency} (written as 
\texttt{ensures} clauses) expresses that if \texttt{nbData} has not 
yet reached the threshold value \texttt{MAX$\_$DATA}, \texttt{nbData} 
will increase its value by one and the value of the formal parameter 
\texttt{cur} will be assigned to \texttt{data[\(\backslash\)old(nbData)]}.  
Inside the postcondition, the expression 
\texttt{$\backslash$old(nbData)} refers to the value of 
\texttt{nbData} before the method invocation. 
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{verbatim}
/*@
  modifies nbData, data[nbData];
  ensures (\old(nbData) < MAX_DATA) ?
      (nbData == \old(nbData) + 1 && data[\old(nbData)] == cur) :
      (nbData == \old(nbData));
*/
void addCurrency(byte cur){
   if(nbData < MAX_DATA){data[nbData] = cur; nbData++;}
}
\end{verbatim}
\caption{Example of \escj~specification} 
\label{fig-add-cur} 
\rule{\linewidth}{0.25mm} 
\end{figure} 


\section{On the use of \modif~clauses}
\label{sec-sem-mod-cla}
The checking of \modif~clauses is especially important for not
accepting incorrect specifications. Figure~\ref{fig-mod-spe} presents
a typical example, where \escj~accepts an incorrect specification. The
specification of the method
\texttt{m()} states that after a method invocation the length of the
instance variable \texttt{arr} will be greater or equal than $4$. This
property holds after the assignment in the
method body, but to establish this property hold after \texttt{m()},
it is
necessary to check that method \texttt{n()} will not modify the
instance variable \texttt{arr}. What \escj~does is to look at the
modifiable specification of the method \texttt{n()} and from that to
establish
if this method modifies this instance variable. When a method is
asserted without any \modif~clause \escj~takes by default a
\texttt{modifies $\backslash$nothing} specification, but it {\bf does
not} check it. Therefore, in regards to this example, \escj~assumes
the method \texttt{n()} does not modify any variable, \emph{i.e.}, it
assumes \texttt{n()} is a method without side-effects. Consequently,
when using this specification in the method \texttt{m()},
\escj~establishes that after a call to \texttt{m()}, its
postcondition will hold. Hence, it does not reject the specification of
\texttt{m()}.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{verbatim}
public class C{
  int[] arr;
  /*@ modifies arr.length
      ensures arr.length >= 4; */
  public void m(){
    arr = new int[5]; n();
  }

  public void n(){arr = new int [3];}
}
\end{verbatim}
\caption{Modifiable specifications} 
\label{fig-mod-spe} 
\rule{\linewidth}{0.25mm} 
\end{figure} 
This problem is caused because \escj~does not check any \modif~clause,
even though the specification of the \escj~language claims to do so. We
have specified and implemented a static checker for \modif~clauses,
which can detect these kind of inconsistencies in \java~asserted
programs. 

Below we present our method to check \modif~clauses. In
Section~\ref{sec-imp-iss}, we discuss how we implemented this method
in our \modtool~and we show
some problems found in the formal specification of an
\emph{electronic purse}, by using it.






\section{A syntactical method to check \modif~clauses}
\label{sec-giv-sin-def}
We present a set of syntactical rules which check the correct
specification of \modif~clauses in \java~asserted programs. These
rules have been defined taking into account the \jml~grammar
specification and the definition of \modif~clauses (both of them)
presented in~\cite{LBR00}.




\subsection{Modifiable behavior}
Below we present the definition of the specification of the modifiable
behavior of a method.
\begin{df}[clause {\bf \it modifiable}]
\label{def-mod}
A method may modify an expression provided that$:$ 
\begin{itemize}
\item This expression is mentioned in the \modif~clause
\item The expression is a local variable to the method or in a
parameter
\end{itemize}
\end{df}
This definition makes no dependency analysis as introduced by
\emph{model} pragmas (see~\cite{LBR00}). Apart from that, from this
definition can be
gathered that a method can not modify fields of any parameter.

In \jml, the modifiable behavior of a method can be specified with
aid of clauses \modif, as presented for \escj~in
Section~\ref{sec-esc-prg}. The expressions that can be appeared in this
clause covers any
\java~identifiers and all expressions constructed using some
\jml~specific constructs. These constructs are presented below.

\paragraph{\bf \textsc{Jml} specific constructs.}
\begin{itemize} %%%%%%
\item{\texttt{a$[$i$\dots$j$]$}}. It denotes
\texttt{a$[$i$],$a$[$i$+1],\ \dots$ a$[$j$]$}.
\item{\texttt{x$[*]$}}. It denotes \texttt{x$[i]$} for all
\texttt{i}, such as $0\leq$\texttt{i}$\le$\texttt{sizeOf(x)}.
\item{\texttt{$\backslash$fields\_of(x)}}. It denotes
\texttt{x[*]} if \texttt{x} is an array, otherwise it denotes the set
of fields belonging to \texttt{x}.
\item{\texttt{$\backslash$reach(x)}}. It denotes the
minimal set containing \texttt{x}, the fields of \texttt{x} and all
objects reachable from the fields of \texttt{x}.
\end{itemize} %%%%%%
\begin{df}[mod] %%%%%
\label{df-mod}
\textup{S}\ \textit{mod}\ \textsc{Y} $=$ $\forall x \in LC.
x\not\in$ \textsc{Y}$\ \Rightarrow Pre(x) = Post(x)$ \\
where $LC$ is a global set of expressions, $Pre(x)$
refers to the state of $x$ before executing $S$,
$Post(x)$ refers to the state of $x$ after executing
$S$ and \textsc{Y} is the set of variables that can be mentioned
inside a \modif~clause).
\end{df} %%%%%%
Consequently, a derivation rule such as \\
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textup{e}_1\ \textit{mod}\ \textsc{Y}, \cdots ,\textup{e}_n\ \textit{mod}\ \textsc{Y}
\justifies
\textup{f}_1\textup{(e}_1\textup{, f}_2\textup{(e}_2\textup{,}\cdots
\textup{(f}_n\textup{(e}_n\textup{))))}\ \textit{mod}\ \textsc{Y} 
\end{prooftree}\\ \\
states that if some method \texttt{m} specifies it may modify the set
of expressions \textsc{Y}, and in its method body occur expressions or
declarations such as \textup{f}$_1$\textup{(e}$_1$\textup{,
f}$_2$\textup{(e}$_2$\textup{,}$\cdots$
\textup{(f}$_n$\textup{(e}$_n$\textup{))))}, their correctness will be
established in terms of the correctness of each subexpression
\textup{e}$_i$ \emph{w.r.t} \textsc{Y}. 

When trying method
calls we have to make some special
considerations (as we will see later). For this purpose, we
present the following definitions$:$
\begin{df}[$\sqsubseteq$] %%%%%%
\label{def-subseq}
$X \sqsubseteq Y$ iff $\forall x.\ x\underline{\in}X\Rightarrow
x\underline\in Y$.
\end{df} %%%%%
\begin{df}[$\overrightarrow{mod}$] %%%%%%
\label{def-mod-lis}
$X\ \overrightarrow{mod}\ Y$ iff $\forall x.\ x\in X\Rightarrow x\ mod\ Y$
\end{df} %%%%%%
First definition presents the concept of inclusion of modifiable
expressions. This definition is done in terms of not
standard
concept $\underline\in$. This concept will be defined later, but intuitively
includes the standard membership concept $\in$. Second definition
gives a more general specification of concept introduced by
Definition~\ref{df-mod}.






\subsection{Syntactical rules}
We have defined certain syntactical rules for every \java~construct,
stating which variables may be modified. Our rules check for
all \java~construct that the expressions modified by instructions
inside of all method bodies are according to
their modifiable specification. We present the derivation rules for
the most important \java~constructs. The whole set of rules can be found
in~\cite{Cat01}.

\textup{METH-DEC} is the
general rule corresponding to a method declaration
\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{)}, which has
specified it may modify the set of expressions \textsc{Y}.
\begin{table}[hbt]%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
METH-DEC\,\,\, & 
\begin{prooftree}
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{).body}\
\overrightarrow{\textit{mod}}\
\textsc{Y}\cup \{\overrightarrow{\texttt{o}}\}\cup \{
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{).locvars}\} 
\justifies
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{)}\ \textit{mod}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%

This rule states that for this
method declaration is enough to
check every instruction in its method body
\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{).body} with respect
to \textsc{Y}, the set of parameters and the local variables to the
method. As can be seen, this rule essentially rephrases
Definition~\ref{def-mod}. 

We have introduced some other \emph{mod}
constructs, by exploiting the \java~syntax. These \emph{mod}
constructs cover concepts such as \textit{modSTM}, \textit{modEXP},
\textit{modPE}, \textit{modPRM} and \textit{modPS}, which redefine the
original concept \textit{mod} in terms of concepts for
\emph{statements}, \emph{expressions}, \emph{post-expressions},
\emph{primary} and \emph{suffixes} expressions respectively. A primary
\java~expression can be seen as the first expression in a
sequence of \java~expressions joined by the symbol \texttt{``.''}. All 
of the other expressions make up the suffix of the original
expression.

When an instruction is represented by a method invocation
\textup{e}\texttt{.m(}$\overrightarrow{\texttt{q}}$\texttt{)}, it 
must fulfill the \modif~clause specification corresponding to its
method declaration \texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{)}
after changing the formal parameters
$\overrightarrow{\texttt{o}}$ by the real parameters
$\overrightarrow{\texttt{q}}$. Additionally, if \emph{this} appears in 
the formal parameters $\overrightarrow{\texttt{o}}$, it must be
changed by the path \textup{e}.

\begin{table}[hbt]%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
METH-INV\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\sem{\textup{e}\texttt{.m(}\overrightarrow{\texttt{o}})\texttt{.modifies}}
[\overrightarrow{\texttt{o}}\backslash \overrightarrow{\texttt{q}},
\texttt{this}\backslash \textup{e}]\sqsubseteq \textsc{Y},\
\textup{e}\ \textit{modPE}\ \textsc{Y},\
\overrightarrow{\texttt{q}}\ \overrightarrow{\textit{modEXP}}\
\textsc{Y}
\justifies
\textup{e}\texttt{.m(}\overrightarrow{\texttt{q}}\texttt{)}\ \textit{modPE}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%

This fact is shown by the rule
\textup{METH-INV}.  One must also check the formal parameters
of the method by using \emph{modExp} rules
($\overrightarrow{\texttt{q}}\ \overrightarrow{\textit{modEXP}}$) since,
according to the \java~syntax, they can represent expressions. A similar
situation occurs with the path \textup{e}.

When an assignment \textup{e}$_1$\ $\oplus$\
\textup{e}$_2$ occurs inside of a method body, we must check
\textup{e}$_1$ belongs to set of expressions that method may modify
(\textup{e}$_1\underline{\in}$\ \textsc{Y}), since \textup{e}$_1$ is
target of an assignment. Additionally, and according to the
\java~syntax, we must check \textup{e}$_1$ and \textup{e}$_2$ by
using respectively the \textit{modPE} and \textit{modEXP} rules. This
fact is showed by the rule \textup{ASSG}.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
ASSG\,\,\, & 
\begin{prooftree}
\textup{e}_1\underline{\in}\ \textsc{Y},\ \ \textup{e}_1\
\textit{modPE}\ \textsc{Y},\ \ \textup{e}_2\ \textit{modEXP}\
\textsc{Y}
\justifies
\textup{e}_1\ \oplus\ \textup{e}_2\ \textit{modEXP}\ \textsc{Y}
\using
\oplus \in \{ \texttt{=,+=,-=,*=,/=} \}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%

An instruction in a method body can be represented by a local
declaration. In this way, if some variable \texttt{x} is declared and is
provided to it certain initial value, that variable must belong to the
set \textsc{Y} of expressions modifiable by the method. Rule
\textup{VAR-DECL-ASSG} states this fact. Additionally, one must
keep checking \textup{e} by using expressions rules.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
VAR-DECL-ASSG\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{x}\underline{\in}\ \textsc{Y},\ \ \textup{e}\ \textit{modEXP}\ \textsc{Y}
\justifies
\texttt{T x =}\ \textup{e}\ \textit{modEXP}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%% 

Contrary to that, if the variable is not
assigned while is declared, we do not have to do any
membership checking. This fact is presented by the rule
\textup{VAR-DECL}.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
VAR-DECL\,\,\, & 
\begin{prooftree}
\justifies
\texttt{T x}\ \textit{modEXP}\ \textsc{Y}
\using
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%% 

\java~instructions can also be represented by pre and post
expressions. These can be seen as \emph{in place} allocations. Rule
\textup{POST-PLUS} presents the case for post-increment expressions.
That rule states that the expression \textup{e}, which is the target
of an assignment, has to belong to set of expressions \textup{Y}
modifiable by the method. Additionally, \textup{e} must be checked using
expression rules.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
POST-PLUS\,\,\, &
\begin{prooftree}
\textup{e}\underline{\in}\ \textsc{Y},\ \ \textup{e}\ \textit{modPE}\ \textsc{Y}
\justifies
\textup{e}\ \texttt{++}\ \textit{modEXP}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%

The \textup{BINARY} rule is applicable
to arithmetic, relational and logic operators. This rule
does not take into account any consideration about membership of
expressions \textup{e}$_i$ to some set \textsc{Y}, since no expression
is directly modified by these
operators, although eventually some subexpression could modify some
variable. This analysis also works for \java~operators as \texttt{unary},
\texttt{instanceof}, \texttt{()} (\emph{casting}) and $?$, as
presented by rules \textup{UNARY}, \textup{INSTANCE}, \textup{CAST}
and \textup{CONDITIONAL}.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
BINARY & 
\begin{prooftree} 
\textup{e}_1\ \textit{modPE}\ \textsc{Y},\ \ \textup{e}_2\
\textit{modEXP}\ \textsc{Y}
\justifies
\textup{e}_1 \oplus \ \textup{e}_2\ \textit{modEXP}\ \textsc{Y}
\using
\oplus \in \{
	\begin{array}{l}
		\texttt{<,<=,>,>=,==}	\\
		\texttt{!=,||,\&\&,+,-}	\\
		\texttt{*,/,\,\&,\^\ ,|}
	\end{array}
	\}
\end{prooftree}
\\[0.3ex]
UNARY & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\textup{e}\ \textit{modEXP}\ \textsc{Y}
\justifies
\oplus \ \textup{e}\ \textit{modEXP}\ \textsc{Y}
\using
\oplus \in \{ \texttt{+,-,$\sim$,!}\}
\end{prooftree}
\\[3.0ex]
INSTANCE & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\textup{e}\ \textit{modEXP}\ \textsc{Y}
\justifies
\textup{e}\ \texttt{instanceof C}\ \textit{modEXP}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
CAST & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\textup{e}\ \textit{modEXP}\ \textsc{Y}
\justifies
\texttt{(T)}\textup{e}\ \textit{modEXP}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
CONDITIONAL\,\,\, & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\textup{e}_1\ \textit{modEXP}\ \textsc{Y},\ \ \textup{e}_2\
\textit{modEXP}\ \textsc{Y},\ \ \textup{e}3\ \textit{modEXP}\
\textsc{Y}
\justifies
\textup{e}_1?\textup{e}_2:\textup{e}3\ \textit{modEXP}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%

Until now, rules defined enable us to detect the kind of problems
presented in Section~\ref{sec-sem-mod-cla} (see
figure~\ref{fig-mod-spe}). Thus, by applying the rule
\textup{METH-DEC}, the checking condition for the method \texttt{n()}
will become $\mathtt{\{myArr\ =\ new\ int[3]\}}$ \textit{mod}
$\phi$. Then,
by applying the rule \textup{ASSG} we would should be able to
deduce $myArr\underline\in\ \phi$. That is not possible. Hence, the
checking of the method \texttt{n()} will
fail. Figure~\ref{fig-der-cor-fig-esc} presents the whole derivation
corresponding to this problem.
\begin{figure}[tbh]%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{prooftree}
   \[
     \[
       \[
	 \texttt{false}
         \justifies 
         \texttt{myArr}\ \in\ \phi
	 \using
         \textsc{AX}
       \]
       \justifies 
       \texttt{myArr}\ \underline\in\ \phi
       \using
       \textsc{IN-SIMP}
     \]
     \[
       \[
         \proofdotseparation=1.2ex 
         \proofdotnumber=3
         \leadsto 
       \]
       \justifies 
       \texttt{myArr}\ \textit{modPE}\ \phi
     \]
     \[
       \[
         \proofdotseparation=1.2ex 
         \proofdotnumber=3
         \leadsto 
       \]
       \justifies 
       \texttt{new int[3]}\ \textit{modEXP}\ \phi
     \]
     \justifies
     \texttt{myArr = new int[3]}\ \textit{mod}\ \phi
     \using
     \textsc{ASSG}
   \]
   \justifies
   \texttt{m}\ \textit{mod}\ \phi
   \using
   \textsc{METH-DEC}
\end{prooftree}
\caption{Detecting not modifiable definitions}
\label{fig-der-cor-fig-esc}
\rule{\linewidth}{0.25mm}
\end{figure} %%%%%%%%

Following with our initial presentation, \java~expressions can be
represented by primary and suffix expressions. Primary rules
\textup{ID-FLD}, \textup{SUPER}, \textup{THIS}, \textup{STATIC},
\textup{CONST} do not take into account any consideration of
membership of expressions \textup{e}$_i$ to some set, since they do
not change any expression.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
ID-FLD\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{x}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
SUPER\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{super}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
THIS\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{this}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
STATIC\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{A}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
CONST\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{b}\ \textit{modPRM}\ \textsc{Y}
\using 
\texttt{b}\in \textsf{Constant} 
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

Rule \textup{ARR-FLD} shows that for array primary expressions one
must check the corresponding parameter expression \textup{e} using
\textit{modEXP} rules.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
ARR-FLD\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textup{e}\ \textit{modEXP}\ \textsc{Y}
\justifies
\texttt{a[}\textup{e}\texttt{]}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

The rule \textup{METH} expresses the fact that a primary expression
can be represented by a method invocation. This rule is similar to
\textup{METH-INV} presented above. 
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
METH\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\sem{\texttt{this.m(}\overrightarrow{\texttt{o}}\texttt{).modifies}}[\overrightarrow{\texttt{o}}\
\backslash
\overrightarrow{\texttt{q}}]\sqsubseteq \textsc{Y},\ \
\overrightarrow{\texttt{q}}\ \overrightarrow{\textit{modEXP}}\
\textsc{Y}
\justifies
\texttt{m(}\overrightarrow{\texttt{q}}\texttt{)}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%


Rules \textup{NEW-EXP} and \textup{NEW-ARR} show the cases when
primary expressions are represented by \java~\emph{new}
expressions. Both of them express that the expressions passed into as
parameters must be checked by using \textit{modExp} rules. To suffix
expressions, we have rules \textup{ID-FLD}, \textup{ARR-FLD},
\textup{THIS} and \textup{SUPER} similar to those presented to primary
expressions.
\begin{table}[hbt] %%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
NEW-EXP\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\overrightarrow{\textup{e}}\ \overrightarrow{\textit{modEXP}}\ \textsc{Y}
\justifies
\texttt{new T(}\overrightarrow{\textup{e}}\texttt{)}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
NEW-ARR\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textup{e}\ \textit{modEXP}\ \textsc{Y}
\justifies
\texttt{new T[}{\textup{e}}\texttt{]}\ \textit{modPRM}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

\java~instructions can be also represented by statements. In case
of \texttt{if...then...} statements, rule
\textup{IF-THEN} states that its guard must be checked using
\textit{modEXP} rules since, according to the \java~syntax, a guard
correspond to an expression. Its body \textsc{S} can be represented by
a set of
statements (an expression can be seen as a statement), thus it must be
checked by using rules for statements. A similar analysis can be
formulated for \texttt{if...then...else...} and \texttt{while} constructs.
\begin{table}[hbt] %%%%%%%%%%%%
\rule{\linewidth}{0.25mm}
\begin{tabular}{ll}
IF-THEN\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textsc{C}\ \textit{modEXP}\ \textsc{Y},\ \ \textsc{S}\ \textit{modSTM}\ \textsc{Y}
\justifies
\texttt{if(}\textsc{C}\texttt{)}\texttt{\{}\textsc{S}\texttt{\}}
\textit{modSTM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
IF-THEN-ELSE\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textsc{C}\ \textit{modEXP}\ \textsc{Y},\ \ \textsc{S}\
\textit{modSTM}\ \textsc{Y},\ \ \textsc{T}\ \textit{modSTM}\
\textsc{Y}
\justifies
\texttt{if(}\textsc{C}\texttt{)\{}\textsc{S}\texttt{\}}
\texttt{else\{}\textsc{T}\texttt{\}}\ \textit{modSTM}\ Y
\end{prooftree}
\\[3.0ex]
WHILE\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textsc{C}\ \textit{modEXP}\ \textsc{Y},\ \ \textsc{B}\ \textit{modSTM}\ \textsc{Y}
\justifies
\texttt{while(}\textsc{C}\texttt{)}{\tt \{}\textsc{B}{\tt \}}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

Rules \textup{SKIP}, \textup{BREAK}, \textup{BREAK-LBL},
\textup{CONTINUE} and \textup{CONTINUE-LBL}
present the analysis for the \texttt{skip},
\texttt{break}, \texttt{break} \emph{lbl}, \texttt{continue} and
\texttt{continue} \emph{lbl} \java~statements. 
\begin{table}[htb] %%%%%%%%%%%%
\rule{\linewidth}{0.25mm}
\begin{tabular}{ll}
SKIP &  
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{skip}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
BREAK & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{break}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
BREAK-LBL &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex} 
\justifies
\texttt{break}\ \textup{label}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
CONTINUE & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{continue}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree}
\\[3.0ex]
CONTINUE-LBL\,\,\, & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{continue}\ \textup{label}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree}
\\[0.3ex]
RETURN & 
\begin{prooftree} 
\rule[1ex]{0em}{1.5ex}
\justifies
\texttt{return}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

Rule \textup{SEQ} presents the analysis for the composition of
\java~instructions. This rule
states that the composition of instructions \textup{S} and \textup{T}
may modify \textsc{Y} if \textup{S} may modify \textsc{Y} and
\textup{T} may modify \textsc{Y}. This rule enable us to express
modifiable conditions for different \java~instructions as the
sequentialization of their respective conditions.
\begin{table}[hbt] %%%%%%%
\rule{\linewidth}{0.25mm}
\begin{tabular}{ll}
SEQ\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textsc{S}\ \textit{modSTM}\ \textsc{Y},\ \ \textsc{T}\
\textit{modSTM}\ \textsc{Y}
\justifies
\textsc{S}\texttt{;}\textsc{T}\ \textit{modSTM}\ \textsc{Y}
\end{prooftree} 
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%


%-------------------------------------------------------------
%RETURN-EXP & 
%\begin{prooftree} 
%\rule[1ex]{0em}{1.5ex}
%\textup{e}\ \textit{modEXP}\ \textsc{Y}
%\justifies
%\texttt{return}\ \textup{e}\ \textit{modSTM}\ \textsc{Y}
%\end{prooftree}

Finally, an other aspect that must be analyzed is that corresponding
with the different constructs that can appear in modifiable
specifications. According to \jml~specification, 
\texttt{$\backslash$fields}$\_$\texttt{of} and
\texttt{$\backslash$reach} pragmas can occur inside of such modifiable
specifications. Hence, when establishing membership conditions
\textup{e}$_1$\texttt{.}\textup{e}$_2$$\underline\in$ \textsc{Y}, we
also need to define rules taking into account the fact that these constructs can
occur inside of \textsc{Y}. 

Typically, if none of these pragmas occur in the modifiable
clause we fall on the standard definition of membership (see rules
rules \textup{IN-SIMP}, \textup{IN-ARR}, \textup{IN-EXP},
\textup{IN-EXP-ARR}).
\begin{table}[hbt]
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
IN-SIMP &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{this.x}\in \textsc{Y}\vee \texttt{x}\in \textsc{Y}
\justifies
\texttt{this.x}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-ARR &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{this.a[}\textup{e}\texttt{]}\in Y\vee \texttt{a[}\textup{e}\texttt{]}\in \textsc{Y}
\justifies
\texttt{this.a[}\textup{e}\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-EXP &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textup{e}\texttt{.x}\in \textsc{Y}
\justifies
\textup{e}\texttt{.x}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-EXP-ARR\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textup{e}_2\texttt{.a[}\textup{e}_1\texttt{]}\in \textsc{Y}
\justifies
\textup{e}_2\texttt{.a[}\textup{e}_1\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

Moreover, if we are checking simple array membership conditions as
\texttt{a[}\textup{e}\texttt{]}$\underline{\in}$ \textsc{Y}, it will
be enough to find a \jml~construct in \textsc{Y} specifying that
correspoding method may modify any element of \texttt{a} (rule
\textup{TIMES-ARR}) or certain intervale of positions where the value
of \textup{e} is found (rule INTERV-ARR).
\begin{table}[hbt]%%%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
INTERV-ARR\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{a[}i..j\texttt{]}\in \textsc{Y},\ i\leq \textup{e}\leq j
\justifies
\texttt{a[}\textup{e}\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
TIMES-ARR\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{a[*]}\in \textsc{Y}
\justifies
\texttt{a[}\textup{e}\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
          \rule{\linewidth}{0.25mm}
\end{table}%%%%%%%%%


When establishing membership conditions
\textup{e}$_1$\texttt{.}\textup{e}$_2$$\underline\in$ \textsc{Y}, we
have to consider some cases according to shape of \textup{e}$_2$. If
\textup{e}$_2$ is not an array expression, it will be enough to have
\texttt{$backlslash$fields$\_$of(}\textup{e}$_1$\texttt{)} occurring 
in \textsc{Y} for establishing the original condition of membership
(see rules \textup{IN-THIS} and \textup{IN-EXP-FLD}). Otherwise, if
\textup{e}$_2$ is an array expression
\texttt{a[}\textup{e}$_3$\texttt{]}, it will be enough to have
\texttt{$backlslash$fields$\_$of(}\textup{e}$_1$\texttt{.a}\texttt{)} occurring in
\textsc{Y} for establishing the original condition of membership
(see rules \textup{IN-ARR-FLD} and \textup{IN-EXP-ARR-FLD}). 
\begin{table}[hbt]
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
IN-THIS &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}$\_$\texttt{of(}\texttt{this}\textsc{)}\in \textsc{Y}
\justifies
\texttt{this.x}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-EXP-FLD\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}\_\texttt{of(}\textup{e}\texttt{)}\in \textsc{Y}
\justifies
\textup{e}\texttt{.x}\underline{\in} \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%
\begin{table}[hbt] %%%%%%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
IN-ARR-FLD\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}\_\texttt{of(a)}\in \textsc{Y}
\justifies
\texttt{this.a[}\textup{e}_3\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-EXP-ARR-FLD\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}\_\texttt{of(}\textup{e}_1\texttt{.a)}\in \textsc{Y}
\justifies
\textup{e}_1\texttt{.a[}\textup{e}_3\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

Similarly, \texttt{$\backslash$reach}
expressions can occur in \modif~clauses\footnote{According to the
\jml~syntax $\backslash$\texttt{reach} expressions can only occur
inside of a $\backslash$\texttt{fields}$\_$\texttt{of}
expression.}. So, if an expression as
$\backslash$\texttt{fields}$\_$\texttt{of($\backslash$reach(}\textup{e}$_1$\texttt{))}
occurs in \textsc{Y}, and we would like to establish
\textup{e}\texttt{.x}$\underline\in$\textsc{Y}, it will be enough to
have \textup{e}\texttt{.x} belonging to set expressions reachable from
\textup{e}$_1$. This situation is presented by the rule
\textup{IN-EXP-REACH}. Something similar happens when \texttt{x} is an
array expression. This
is presented by rules \textup{IN-REACH}, \textup{IN-ARR-REACH} and
\textup{IN-EXP-ARR-REACH}.
\begin{table}[hbt]%%%%%%%%%%
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{tabular}{ll}
IN-EXP-REACH &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}\_\texttt{of(}\backslash
\texttt{reach(}\textup{e}_1\textsc{))}\in Y,\ \
\textup{e}\texttt{.x}\in \backslash
\texttt{reach(}\textup{e}_1\texttt{)}
\justifies
\textup{e}\texttt{.x}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-REACH &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash
\texttt{fields}$\_$\texttt{of(}\backslash\texttt{reach(}\textup{e}\texttt{))}\in
\textsc{Y},\ \ \texttt{this}\in \backslash
\texttt{reach(}\textup{e}\texttt{)}
\justifies
\texttt{this.x}\underline{\in} \textsc{Y}
\end{prooftree}
\\[3.0ex]
IN-ARR-REACH &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}\_\texttt{of(}\backslash
\texttt{reach(}\textup{e}_1\texttt{))}\in \textsc{Y},\ \
\texttt{this.a}\in \backslash \texttt{reach(}\textup{e}\texttt{)}
\justifies
\texttt{this.a[}\textup{e}\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
IN-EXP-ARR-REACH\,\,\, &
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\backslash \texttt{fields}\_\texttt{of(}\backslash
\texttt{reach(}\textup{e}\texttt{))}\in \textsc{Y},\ \
\textup{e}_2\texttt{.a}\in \backslash
\texttt{reach(}\textup{e}\texttt{)}
\justifies
\textup{e}_2\texttt{.a[}\textup{e}_1\texttt{]}\underline{\in} \textsc{Y}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table}%%%%%%%%%

Annex~\ref{ane-der-exa} shows some derivation examples of checking
\java~asserted programs using rules we presented below. These examples
allow us see how can be detected wrong modifiable specification using
our rules.






\section{A checker for \modif~clauses}
\label{sec-imp-iss}
We present the implementation of a modifiable checker (\modtool)
implementing the syntactical rules presented during
Section~\ref{sec-giv-sin-def}. For doing such implementation we have
taken certain \jml~classes for representing the \java~syntactical
constructs. Additionally, we have used the \jml~parser for parsing
\java~asserted programs, storing the underlying context on which
modifiable specifications are done and embedding the calling of
respective classes which implement our syntactical rules.

Section~\ref{abo-jml-cla-use} gives a general overview about
\jml~classes we used for representing \java~constructs and doing
parsing. Section~\ref{fig-out-met-cal-con} shows how is figured out the
context underlying method specifications and how is done the calling to
methods which implement our syntactical
rules. Section~\ref{mod-and-con-clab} presents classes
\texttt{Context} and \texttt{Modifiable}, which implement the
underlying method contexts and modifiable syntactical rules.




\subsection{About \jml~classes}
\label{abo-jml-cla-use}
We have retaken two \jml~classes for modeling \java~constructs$:$
\texttt{AST} and \texttt{ASTFactory}. Abstract class \texttt{AST}
represents \java~constructs as tree structures and class
\texttt{ASTFactory} defines a set of operations for handling
\texttt{AST} trees. These operations cover \texttt{create{AST}},
\texttt{dupTree{AST}} and \texttt{ASTChild(AST)}, which create,
duplicate and add an child to a tree.

Class \texttt{JmlParser} implements the \jml~syntactical analyzer and
can be extended by embedding \java~source code implementing any
specific functionality.

\subsection{Figuring out contexts of calling}
\label{fig-out-met-cal-con}
We have extended the \jml~parser by adding semantics actions for
figuring out contexts under which instructions are occurred. These
semantics actions have been embedded as \java~code in this parser. A
context for a method consist of its parameters, its local variables
and the set of variables declared as modifiable for it. Figuring out
the context for a method allow us to apply the general rule for method
declarations \textup{METH-DEC} defined during
Section~\ref{sec-giv-sin-def}. Additionally, the contexts enable us to
apply the rest of rules
for any instruction occurring inside of this method, since the context
for any instruction coincide with the context of the method which they
occur in.

Figure~\ref{fig-out-par} shows the source code embedded to the
\jml~parser for adding any parameter to a method
context. Specifically, this code is added in the
\texttt{param$\_$declaration()} method. For doing that, the variable
\texttt{currentContext}, having \texttt{Context} type and which serves
to store the current method context, makes a call to
\texttt{addParameter(AST)} and passes it the parameter just
parsed. Implementation of \texttt{Context} class will be presented is
Section~\ref{mod-and-con-clab}. Similar actions are
considered for the declaration of modifiable and local variables.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{alltt}
   public final void param_declaration() throws \dots \verb!{! 
      \vdots
      AST tmp87_AST = null;
      if(inputState.guessing == 0) \verb!{!
         tmp87_AST = (AST)astFactory.create(LT(1));
         astFactory.addASTChild(currentAST, tmp87_AST);
         {\it//code added for modifiable checker: parameter of the method}
         currentContext.addParameter(astFactory.dupTree(tmp87_AST));
      \verb!}!
      \vdots
   \verb!}!
\end{alltt}
\caption{Figuring out parameters}
\label{fig-out-par}
\rule{\linewidth}{0.25mm}
\end{figure}




\subsection{Making calls to static rules}
\label{mak-cal-sta-rul}
After figuring out the context of each method and its instructions, we
are ready to statically call methods of the \texttt{Modifiable} class
and thus checking its modifiable declarations. Figure~\ref{fig-cal-whi-rul}
shows the case for rule corresponding a \texttt{while} constructs. Its
respective rule \textup{WHILE} is presented below.
\begin{table}[hbt] %%%%%%%%%%%%
\rule{\linewidth}{0.25mm}
\begin{tabular}{ll}
WHILE\,\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textsc{C}\ \textit{modEXP}\ \textsc{Y},\ \ \textsc{B}\ \textit{modSTM}\ \textsc{Y}
\justifies
\texttt{while(}\textsc{C}\texttt{)}{\tt \{}\textsc{B}{\tt \}}
\end{prooftree}
\end{tabular}
\\[0.5ex]
\rule{\linewidth}{0.25mm}
\end{table} %%%%%%%%%%%%%

As can be seen, as far as the method \texttt{statement} parses the
different parts of a \texttt{while} statement, we store the guard
and block constructs as variables of type \texttt{AST}
\texttt{temp4$\_$MOD} and \texttt{temp5$\_$MOD}\footnote{In the rule
above, these correspond to \textsc{C} and \textsc{B}
respectively}. Finally, we use the static Al method \texttt{$\_$WHILE}
of \texttt{Modifiable} class for doing the corresponding checking. In
addition to variables \texttt{temp4$\_$MOD} and \texttt{temp5$\_$MOD},
we have to pass to method \texttt{$\_$WHILE} the context of the method
where this statement is declared and a list of all other known
contexts. Class \texttt{Modifiable} will be presented in
Section~\ref{mod-and-con-clab}.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{alltt}
   public final void statement(boolean in_model_prog) \dots \verb!{!
      \vdots
      case LITERAL_while:
         match(LITERAL_while);\dots match(LPAREN); \dots expression(side_effects_allowed);
         {\it //code added for modifiable checker}
         AST temp4_MOD = (AST)astfactoryMOD.dupTree(returnAST);
         match(RPAREN); \dots statement(in_model_prog);
         {\it //code added for modifiable checker}
         AST temp5_MOD = (AST)astfactoryMOD.dupTree(returnAST);
         Modifiable._WHILE(temp4_MOD,temp5_MOD, currentContext.getY(), contextStack);
    \verb!}!
\end{alltt}
\caption{Calling of {\tt while} rule}
\label{fig-cal-whi-rul}
\rule{\linewidth}{0.25mm}
\end{figure}




\subsection{\texttt{Modifiable} and \texttt{Context} classes}
\label{mod-and-con-clab}
\texttt{Modifiable} class implements rules presented in
Section~\ref{sec-giv-sin-def} as static methods. As an example
Figure~\ref{fig-met-sta-whi} shows method \textup{$\_$WHILE}, which
implements rule \textup{WHILE} presented above. This method makes
calls to \texttt{$\_$modEXP($\dots$)} and
\texttt{$\_$modSTM($\dots$)} static methods, which implement rules
\texttt{modEXP} and \texttt{modSTM} respectively.




\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{alltt}
public static boolean _WHILE(AST C, AST B, Vector Y, Stack contexts)\verb!{!
  return(_modEXP(C,Y,contexts) && {\it //C modEXP Y}
         _modSTM(B, Y, contexts); {\it //B modSTM Y}
        );
\verb!}!


public static boolean _modEXP(AST e, Vector Y, Stack contexts)\verb!{!
  boolean tempRes;
  switch(e.getType())\verb!{!
    case JavaTokenTypes.ASSIGN: case JavaTokenTypes.PLUS_ASSIGN:
    case JavaTokenTypes.MINUS_ASSIGN: case JavaTokenTypes.STAR_ASSIGN:
    case JavaTokenTypes.DIV_ASSIGN: case JavaTokenTypes.BITWISE_ASSIGNMENT_OP:
    tempRes = _in_PRIME(astfactoryMOD.dupTree(e.getFirstChild()),Y,contexts) &&
     _modPE(astfactoryMOD.dupTree(e.getFirstChild()),Y,contexts) &&
     _modEXP(astfactoryMOD.dupTree(e.getFirstChild().getNextSibling()),Y,contexts);
    break;
    \vdots
  \verb!}!
  return tempRes;
\verb!}!
\end{alltt}
\caption{Static method \texttt{$\_$WHILE}}
\label{fig-met-sta-whi}
\rule{\linewidth}{0.25mm}
\end{figure}


\section{Conclusion}
\label{sec-con}







\appendix
\section{Checking specifications}
\label{ane-der-exa}


This appendix present some derivation examples of checking
\java~asserted programs using rules we presented in
Section~\ref{sec-giv-sin-def}.



%We present some derivation examples in
%figures~\ref{fig-der-tre-c-cal-n},~\ref{fig-der-tre-this-m},~\ref{fig-der-tre-val-n}
%and~\ref{fig-der-tre-c-cal-n} corresponding to
%figure~\ref{fig-der-exa}.
%\begin{figure}[tbh]
%\rule{\linewidth}{0.25mm}
%\rule{0em}{0.1ex}
%\begin{tabbing}{l}
%ddd\=ddd\=ddd\=ddd\=ddd\=dddddddddddddddddddddddd \kill
%\>$\mathtt{public\ class\ C\{}$ \\
%\>\>$\mathtt{public\ int\ k\ =\ 0;}$ \\
%\\
%\>\>{\it //@modifies arr$[$pos$]$;} \\
%\>\>$\mathtt{public\ void\ m(int[\ ] arr,\ int\ pos)\{\ arr[pos]\ =\
%this.k;\ \}}$ \\
%\>\>$\mathtt{public\ C\ getC(\ )\{\ return\ this;\ \}}$ \\
%\>$\mathtt{\}}$ \\
%\>$\mathtt{public\ class\ D\{}$ \\
%\>\>$\mathtt{int[\ ]\ myArr\ =\ new\ int[5];}$ \\
%\>\>$\mathtt{int\ myPos\ =\ 3;}$ \\
%\>\>$\mathtt{C\ c\ =\ new\ C(\ );}$ \\
%\\
%\>\>{\it //@modifies $\backslash$fields$\_$of($\backslash$reach(this));} \\
%\>\>$\mathtt{public\ void\ n(int\ val)\{\ c.getC(\ ).k\ =\
%val++;\ c.m(myArr,\ myPos);\ \}}$ \\
%\>$\mathtt{\}}$
%\end{tabbing}
%\caption{Derivation example}
%\label{fig-der-exa}
%\rule{\linewidth}{0.25mm}
%\end{figure} %%%%%%%%%
%%\begin{landscape} %%%%%%%%
%\begin{center} 
%\begin{figure}[tbh]
%\rule{\linewidth}{0.25mm}
%%\\[2.0ex]
%\begin{prooftree}
%   \[
%%      \[
%        \[
%%	  \justifies
%	  \mathtt{arr[pos]}\in\ \textsc{Y}
%	\]
%	\justifies
%	\mathtt{arr[pos]}\underline\in\ \textsc{Y}
%	\using
%	\textsc{\tiny IN-SIMP}
%      \]
%      \[
%	\[
%	  \[
%            \[
%	      \[
%		\justifies
%	 	\texttt{pos}\  \textit{modPRM}\ \textsc{Y}
%		\using
%		\textsc{\tiny CONST}
%	      \]
%	      \justifies
%	      \texttt{pos}\  \textit{modPE}\ \textsc{Y}
%	      \using
%	      \textsc{\tiny EXP-PRM}	      
%	    \]
%	    \justifies
%	    \texttt{pos}\  \textit{modEXP}\ \textsc{Y}
%	    \using
%	    \textsc{\tiny EXP-TO-PE}
%          \]
% 	  \justifies
%	  \mathtt{arr[pos]}\  \textit{modPRM}\ \textsc{Y}
%	  \using
%	  \textsc{\tiny ARR-FLD}
%	\]
% 	\justifies
%	\mathtt{arr[pos]}\  \textit{modPE}\ \textsc{Y}
%	\using
%	\textsc{\tiny EXP-PRM}
%      \]
%      \[ %1
%        \[ %2
%          \[ %2
%	     \[ %3
%	       \justifies
%	       \texttt{this}\ \textit{modPRM}\ \textsc{Y}
%	       \using
%	       \textsc{\tiny THIS}
%	     \] %3
%	     \justifies
%	     \texttt{this}\ \textit{modPE}\ \textsc{Y}
%	     \using
%	     \textsc{\tiny EXP-PRM}
%          \] %2
%	  \[ %3
%	    \justifies
%	    \texttt{k}\ \textit{modPS}\ \textsc{Y}
%	    \using
%	    \textsc{\tiny ID-FLD}
%	  \] %3
% 	  \justifies
%	  \texttt{this.k}\ \textit{modPE}\ \textsc{Y}
%	  \using
%	  \textsc{\tiny PE-TO-PE}
% 	\] %2
% 	 \justifies
%	 \texttt{this.k}\ \textit{modEXP}\ \textsc{Y}
%	 \using
%         \textsc{\tiny EXP-TO-PE}
%     \] %1
%     \justifies
%     \mathtt{arr[pos] = this.k}\  \textit{mod}\ \mathtt{\{arr[pos],arr,pos\}}
%     \using
%     \textsc{\tiny ASSG}
%   \]
%   \justifies
%   \texttt{m(arr,pos)}\ \textit{mod}\ \mathtt{\{arr[pos]\}}
%   \using
%   \textsc{\tiny METH-DEC}
%\end{prooftree}
%\caption{Derivation tree for the method \texttt{m(int$[]$, int)}}
%\label{fig-der-tre-this-m}
%\rule{\linewidth}{0.25mm}
%\end{figure}
%\end{center} %%%%%%%%%%%
%\begin{center} %%%%%%%%%%%
%\begin{figure}[tbh]
%\rule{\linewidth}{0.25mm}
%\\[2.0ex]
%\begin{prooftree}
%\footnotesize
%   \[
%     \[
%       \mathtt{fields\_of(\backslash reach(this))}\in \textsc{Y},\ \
%\mathtt{c.getC()}\in \backslash\texttt{reach(this)}
%       \justifies
%%       \mathtt{c.getC().k}\underline\in\ \textsc{Y} %
%       \using
%       \textsc{\tiny IN-EXP-REACH}
%%     \]
%     \[
%       \[
%	 \[
%	   \justifies
%	   \phi \sqsubseteq \textsc{Y}
%	   \using
%	   \textsc{\tiny AX}
%	 \]
%	 \[
%           \[
%             \proofdotseparation=1.2ex 
%             \proofdotnumber=3
%%             \leadsto 
%           \]
%	   \justifies
%	   \texttt{c}\ \textit{modPE}\ \textsc{Y} 
%	   \using 
%	 \]
%         \justifies
%	 \mathtt{c.getC()}\ \textit{modPE}\ \textsc{Y} 
%%       \]
 %      \[
%         \justifies
%	 \mathtt{k}\ \textit{modPS}\ \textsc{Y} 
%	 \using
%	 \textsc{\tiny ID-FLD}
%       \]
%       \justifies
%       \mathtt{c.getC().k}\ \textit{modPE}\ \textsc{Y} %
%       \using
%       \textsc{\tiny PE-TO-PE}
%     \]
%      \[ %1
%         \[ %2
%           \[ %3
%             \justifies 
%	     \texttt{val}\in \textsc{Y}\
%	     \using
%	     \textsc{\tiny AX}
%	   \] %3
%           \justifies 
%           \texttt{val}\underline\in \textsc{Y}\ 
%	   \using
%	   \textsc{\tiny IN-SIMP}
%	 \] %2
%         \[ %2
%	   \[ %3
%             \justifies
%             \texttt{val}\ \textit{modPRM}\ \textsc{Y}
%	     \using
%	     \textsc{\tiny ID-FLD}	
%	   \] %3  
%           \justifies
%           \texttt{val}\ \textit{modPE}\ \textsc{Y}
%	   \using
%	   \textsc{\tiny EXP-PRM}
%	 \] %2
%       \justifies
%       \mathtt{val ++}\ \textit{modEXP}\ \textsc{Y} %
%       \using
%       \textsc{\tiny POST-PLUS}
%     \] %1
%    \justifies
%     \mathtt{c.getC().k = val ++}\ \textit{modEXP}\
%\mathtt{\{\backslash fields\_of(\backslash reach(this)), val\}}
%     \using
%     \textsc{\tiny ASSG}
%   \] %0
%   \justifies
%   \texttt{n(val)}\ \textit{mod}\ \mathtt{\{\backslash fields\_of(\backslash reach(this))\}}
%   \using
%   \textsc{\tiny METH-DEC}
%\end{prooftree}
%\caption{Derivation tree for $\mathtt{c.getC().k = val ++}$ in {\tt n(int)}}
%\label{fig-der-tre-val-n}
%\rule{\linewidth}{0.25mm}
%\end{figure}
%\end{center}
%
%
%
%
%\begin{center}
%\begin{figure}[tbh]
%\rule{\linewidth}{0.25mm}
%\\[2.0ex]
%\begin{prooftree}
%   \[
%%       \[ %1
%         \[ %---
%         \[ %2
%	   \[ %3
%             \mathtt{\backslash fields\_of(\backslash reach(this))}\in
%\texttt{Y},\ \ \texttt{myArr}\in \mathtt{\backslash reach(this)}
%	     \justifies
%             \mathtt{myArr[myPos]}\underline\in\textsc{Y}
%             \using
%             \textsc{\tiny IN-ARR-REACH}
%	   \] %3
%           \justifies
%	   \mathtt{\{myArr[myPos]\}}\sqsubseteq\textsc{Y}
%	   \using
%	   \sqsubseteq
%         \] %2
%         \[ %2
%	   \[ %3
%             \proofdotseparation=1.2ex 
%             \proofdotnumber=3
% %            \leadsto 
%           \] %3
%%	   \justifies
%	   \texttt{c}\ \textit{modPE}\ \textsc{Y}
%         \] %2
%         \[ %2 
%           \[ %3
%             \proofdotseparation=1.2ex 
%             \proofdotnumber=3
%             \leadsto 
%           \] %3
%	   \justifies
%	   \texttt{myArr}\ \textit{modEXP}\ \textsc{Y}
%	 \]  %2
%	 \[  %2
%           \[ %3
%             \proofdotseparation=1.2ex 
%             \proofdotnumber=3
%             \leadsto 
%           \] %3	
%	   \justifies	
%	   \texttt{myPos}\ \textit{modEXP}\ \textsc{Y}
%	 \]  %2
%         \justifies
%         \texttt{c.m(myArr, myPos)}\ \textit{modPE}\ \textsc{Y}
%         \using
%         \textsc{\tiny EXP-METH}
%        \] %-----
%        \justifies
%         \texttt{c.m(myArr, myPos)}\ \textit{modEXP}\ \textsc{Y}
%         \using
%%         \textsc{\tiny EXP-TO-PE}
%     \] %1
%     \justifies
%     \texttt{c.m(myArr, myPos)}\ \textit{mod}\ \mathtt{\{\backslash
%fields\_of(\backslash reach(this)), val, myArr\}}
%     \using
%     \textsc{\tiny MOD-TO-EXP}
%   \] %0
%   \justifies
%   \texttt{n(val)}\ \textit{mod}\ \mathtt{\{\backslash fields\_of(\backslash reach(this))\}}
%   \using
 %  \textsc{\tiny METH-DEC}
%\end{prooftree}
%\caption{Derivation tree for {\tt c.m(myArr, myPos)} in {\tt n(int)}}
%\label{fig-der-tre-c-cal-n}
%\rule{\linewidth}{0.25mm}
%\end{figure}
%\end{center}
%
%\end{landscape}




\bibliographystyle{alpha}
\bibliography{../bibliography}

\end{document}
