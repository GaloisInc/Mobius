\documentclass[a4paper]{llncs}

\title{A static checker for JML's \emph{assignable} clause}

\author{
  N\'estor Cata\~no
\and
  Marieke Huisman
}

\institute{
  \inria\ Sophia-Antipolis, France \\ 
  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
}

%\author{
%  N\'estor Cata\~no and Marieke Huisman}%  \\
%  \institute{
%       \inria\ Sophia-Antipolis, France %\\
%%       \lemme~Project
%  } 
%  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
%}

\newcommand{\defn}[1]{\:\hat{#1}\:}

\newcommand{\lemme}{\textsc{Lemme}}
\newcommand{\inria}{\textsc{Inria}}
\newcommand{\jml}{\textsc{Jml}}
\newcommand{\escj}{\textsc{Esc/Java}}
\newcommand{\eiffel}{\textsc{Eiffel}}
\newcommand{\jass}{\textsc{Jass}}
\newcommand{\jcontract}{\textsc{JContract}}
\newcommand{\loopp}{\textsc{Loop}}
\newcommand{\java}{\textsc{Java}}
\newcommand{\cPP}{\texttt{C/C}\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf
+}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\newcommand{\gplus}{\textsc{GemPlus}}
\newcommand{\ctl}{\textsc{Ctl}}
\newcommand{\pltl}{\textsc{Pltl}}
\newcommand{\csrc}{\textsc{Compaq Src}}
\newcommand{\insPP}{\textsc{Insure\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf
+}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}}

\newcommand{\modtool}{\texttt{assignable:tool}}

\newcommand{\sem}[1]{\ensuremath{\mbox{[\![} {#1} \mbox{]\!]}\/}}

\newtheorem {df}{Definition}

\newcommand{\FullExp}{\(<\)\textsf{Full-exp}\(>\)}
\newcommand{\SufExp}{\(<\)\textsf{Suf-exp}\(>\)}
\newcommand{\Exp}{\(<\)\textsf{Exp}\(>\)}
\newcommand{\Identifier}{\(<\)\textsf{Identifier}\(>\)}
\newcommand{\MethodCall}{\(<\)\textsf{Identifier}\(>\)(\Exp\ldots\Exp)}
\newcommand{\Static}{\(<\)\textsf{StaticClass}\(>\)}
\newcommand{\Type}{\(<\)\textsf{Type}\(>\)}
\newcommand{\option}{\(\:||\)}

\newcommand{\MOD}[2]{\ensuremath{\mathit{#1}\:\mathsf{mod}\:\ensuremath{\mathit{#2}}}}
\newcommand{\MODFE}[2]{\ensuremath{\mathit{#1}\:\mathsf{modFE}\:\mathit{#2}}}
\newcommand{\MODSuf}[2]{\ensuremath{\mathit{#1}\:\mathsf{modSuf}\:\mathit{#2}}}
\newcommand{\MODS}[2]{\ensuremath{\mathit{#1}\:\overrightarrow{\mathsf{mod}}\:\mathit{#2}}}

\newcommand{\method}[2]{\ensuremath{\mathtt{#1}\texttt{(}
                                    \overrightarrow{\mathtt{#2}}
                                    \texttt{)}}}
\newcommand{\methodbody}[2]{\ensuremath{\method{#1}{#2}\mathtt{.body}}}
\newcommand{\methodloc}[2]{\ensuremath{\method{#1}{#2}\mathtt{.locvars}}}
\newcommand{\methodassign}[2]{\ensuremath{\method{#1}{#2}\mathtt{.assignable}}}


\newcommand{\extmember}[2]{\ensuremath{#1\: \underline\in\: #2}}
\newcommand{\member}[2]{\ensuremath{#1\: \in\: #2}}
\newcommand{\extsubset}[2]{\ensuremath{#1 \sqsubseteq #2}}

\newcommand{\fieldsof}{\texttt{\(\backslash\)fields\_of}}
\newcommand{\fieldsofarg}[1]{\texttt{\(\backslash\)fields\_of(#1)}}
\newcommand{\reach}{\texttt{\(\backslash\)reach}}
\newcommand{\reacharg}[1]{\texttt{\(\backslash\)reach(#1)}}
\newcommand{\nothing}{\texttt{\(\backslash\)nothing}}
\newcommand{\everything}{\texttt{\(\backslash\)everything}}

\usepackage{lscape} % it's needed to turn a page
\usepackage{amsmath} % it is needed by the \sem command
\usepackage{alltt}
\usepackage{epsfig}

\input{prooftree} %showing demonstration

\begin{document}
\fussy
\maketitle
\pagestyle{plain}

\begin{abstract}
This paper proposes a syntactic method to check so-called
\emph{assignable} clauses in \java\ programs, annotated with \jml\
assertions. Assignable clauses describe which variables may be
modified by a method. Their correctness is crucial for reasoning about 
class specifications. 

The method that we propose in this paper is incomplete, as it only
does a syntactic check and it does not take aliasing or expression evaluation
into account, but it provides an efficient check that will find most
common specification errors in assignable clauses in practice. This is 
demonstrated by applying the method to the specification of an
industrial case study.


%The method is a
%syntactic one

%This paper presents a method for checking the specification of
%\emph{assignable} clauses in \java\ programs with assertions \jml. We
%propose syntactical rules for each type of \java\ instruction. These
%rules check for each \java\ instruction occurring in a method
%declaration that locations assigned by the instruction belong to set
%of variable locations the method has specified as
%\emph{assignable}. Hence, our specification does not concern with
%modification but the assignment. We show the feasibility of our
%approach presenting several specifications gaps found in the case
%study \emph{Formal Specification and Static Checking of \gplus's
%Electronic Purse Using \textsc{Esc/Java}}~\cite{CatanoH02a}.
\end{abstract}






\section{Introduction}
\label{sec-intro}

\paragraph{\bf Formal methods}

%This paper discusses a technique to make the use of formal methods
%easier and more efficient. 
Recently, several light weight approaches to formal 
methods~\cite{LeinoNS00,CatanoH02a} have demonstrated that the use of
formal methods in practice is actually feasible.  Up to now, formal
methods merely have been considered as a theoretical issue in computer
science, which could not be applied to ``real'' problems: the
complicated logical notations and the lack of tool support could not
compete with the software development methods and tools used in
industry.

%There are several 
%However, recently this has started to
%change, for several reasons. 
But recently, specification languages have been developed that closer
resemble programming languages, and powerful tools have been developed
which are tailored to these specification languages. At the same time,
industry has started to feel the need for certified software, in
particular after the discovery of bugs such as the one in the
\textsc{Intel} \textsc{Pentium II} microprocessors, which costed the
company several billion dollars.


%Several decades ago, the \emph{formal methods} were considered as a merely
%theoretical issue in computer science, not suitable for real
%problems: \emph{complicated} notations taken from the logic and
%the lack of tools supporting formal methods could not compete with the
%tools and methods used in industry for software development. Recently, 
%this has been changing. There are several reasons for this
%change. Firstly, the specification languages are now closer to
%programming languages than ever before and the techniques used are
%more suitable to the actual programming paradigms (object oriented
%and distributed programming). Secondly, industry has started to feel
%the need for certified software. An
%example~\cite{Borger99programmer}: during $1995$,
%\textsc{Intel} found a problem with its microprocessors
%\textsc{Pentium}. This company was forced to replace around two
%million processors. Thus, it realized that the costs of formal
%verification would have been much lower than the costs required to
%fix this bug.

Traditional formal techniques for program verification 
are \textit{model checking} and
\textit{theorem proving}. Drawbacks of both these
techniques are that they require a good inside in the particular
verification technique and tool (\emph{e.g.}~to construct the model
that is input for the model checker or to formalize the programming
language in the logic of the theorem prover), and that they are often
time and memory consuming. By providing a front-end tool which can
translate the program (and possibly also its specification)
automatically into input for the verification tool, the first drawback
partially can be overcome. But when the program does not satisfy its
specification, one still has to understand the problem in the language of
the verification tool.


%Currently, with the interest of the industry and the academic world,
%the developments in formal methods have become
%increased. These developments are specially concerned with techniques
%such as
%\textit{model-checking} and \textit{theorem proving}.
%Model-checking is technique based on constructing a finite model of a
%problem and exhaustively checking the satisfaction of certain
%properties. Model-checking is
%a strong technique, as it is \emph{decidable}, but it presents some
%limitations: $(i)$\ it can validate a
%model of a certain system but not the system itself, and
%$(ii)$\ verification even for simple systems might need huge amounts
%of space and time. 

%Theoretically, interactive theorem proving techniques are able to
%solve any problem proposed in practice, but it presents some
%disadvantages: $(i)$\ it is \emph{undecidable}, $(ii)$\ the tools are
%only capable of assisting an engineer in the process of constructing a
%proof, and $(iii)$\ it requires expressing and understanding the
%semantics underlying the
%programming language in the logic of the theorem prover, in order to
%do program verification. 
%Testing checks whether a program produces
%correct output on certain input. This technique is important for
%checking some properties before applying a formal technique. A
%disadvantage of this approach is that one spends too much of time in the
%process of constructing all possible testing cases. Moreover,
%sometimes it is not possible to check all possible
%inputs. 

Recent tools try to overcome these drawbacks, by using (time and
memory) efficient checking techniques that work directly on the level
of the program and its specification. Two of such techniques are
\textit{run-time checking} and \textit{static checking}. 
These are what could be called light weight formal techniques, which
do not result in a full correctness proof, but which can be used to
increase the trust in the correctness of the implementation
\emph{w.r.t.}~the specification, as they will find most common
errors in the program.

Run-time checking is a technique where several safety conditions are
checked while running the program, \emph{e.g.}~when making a method
call it is checked that the precondition of the method is not violated
for this particular call, otherwise some error message will be
returned. Typically, run-time checking is implemented by transforming
the program into one that explicitly executes all these
tests. Run-time checking can be seen as extended testing: not only the
input-output behaviour is tested, but also the internal state of the
program at dedicated points. \eiffel~\cite{Meyer97} was the first
programming language which provided this feature as a special compiler
option. More recent run-time checkers are \jml~\cite{LeavensBR00} and
\jass~\cite{bartetzko01assertions}, which check assertions for \java\
programs, and
\insPP~\cite{InsurePP}, which can check memory operations for \cPP
programs. %In this paper we will use the specification language of \jml.


%a program is transformed into a 
%program which tests several safety conditions at run-time,
%\emph{e.g.}~a program can be transformed so that every time a method 
%is called, it is tested whether the precondition of this method is
%satisfied at the calling point. Typically, if such a condition is
%violated the transformed program will throw an exception, indicating
%which condition was violated at which program point.
%The specification
%language \jml\ that is in this paper ships with a run-time assertion
%checker, which can perform such program transformations.  An important advantage of run-time checking is that
%one does not have to change to another formalism, all the work is done
%at the level of the programming language.

%Other examples of run-time checkers are  A special feature of \jass\ are the
%so-called trace assertions, which allow to check that methods are
%invoked in a prescribed order.

%. This checker keeps track of a \cPP\ program and
%complains whether a block of memory is liberated too many times, a memory
%block is used without being initialized or there exist memory leaks.

%Recently, several approaches have been
%proposed to overcome these kind of problems and although they can not
%actually replace formal verification techniques, they constitute
%important alternatives for checking the behavior of software
%systems. \emph{Run-time
%checking} is a kind of extended checking where, in addition to checking
%the input-output behavior, it is checked whether certain specific
%conditions are
%satisfied at particular points in the program. For checking these
%conditions, the original program is expressed into another
%one
%which can be then executed. If the execution throws an exception,
%this indicates that the original program does not fulfill the
%expected conditions.


Complementary to run-time checking is static checking, where one tries
to find problems in a program by using automatically standard program
verification techniques. Static checking can be considered as an
extended form of type checking, because it finds potential run-time
problems already at compile-time. Typically, static checking gives
quick feedback on a program and can find many common errors, so that
more expensive formal verification techniques can concentrate on the
essential parts of the program. An example of a static checker is
\escj~\cite{LeinoNS00}, which generates proof obligations from an
annotated program and sends these proof obligations to an automatic,
dedicated theorem prover.  


% check the behavior of programs
%from its source code. This technique can be complemented with
%an automatic theorem prover which automatically can detect
%some specific problems. It is expected not to expend too much time in
%this process.

%When using static and run-time checking techniques on software systems,
%it is possible to state
%some specifications which we are interested to check. These
%specifications can be provided to the checking tools as part of the
%source code and written by using a suitable
%specific-specification language. 

\paragraph{\bf{Formal methods for \java}}
Recently, much work on (light-weight) formal methods has focused on
\java\ and \textsc{Javacard}. Several specification languages have
been developed which are especially tailored to \java, such as
\jass~\cite{bartetzko01assertions} and \jml~\cite{LeavensBR00}.
\jml\ (\java\ modeling language) is developed by Leavens \emph{et 
al.}~at Iowa State University. As mentioned above, together with the
specification language a run-time checker is developed. \jml\ follows
the \emph{Design by Contract} approach as advocated in
\eiffel~\cite{Meyer97}. It allows for example to state pre- and
postconditions of methods and class invariants. \jml\ predicates are
boolean \java\ expressions, extended with some specification-specific
constructs. \jml\ is designed to be easily understandable for a \java\
programmer.

The \jml\ specification language\footnote{With some variations.} is
used as input for several tools. Apart from the \jml\ tool mentioned
above, it is also used as input for \emph{e.g.}~the
\textsc{Loop} compiler~\cite{LoopURL,BergJ01} , which translates
\jml-annotated \java\ programs into a series of input theories for the 
theorem prover \textsc{pvs}~\cite{OwreRRSS96}, and for
\escj~\cite{ESCJavaUrl,EscJmlDiff}. 

\escj\ tries to check an annotated program by
using an automatic, dedicated theorem prover. It is especially tuned
to find errors such as array out of bound indexing, null pointer
dereferencing, deadlocks and race conditions, but it also can check
arbitrary functional specifications. If it cannot establish a certain
specification, it issues a warning. As \escj\ neither is sound nor
complete, a warning does not necessarily mean that the program is
incorrect.

%proposed
%for \java\ and \cPP. \jml\ \ (\java\ Model
%Language)~\cite{LeavensBR00} is a tool developed at the Iowa State
%University
%doing run-time checking. Its specification language follows the
%\eiff's approach of \emph{Design by
%Contract}~\cite{Meyer97}, hence
%it is possible to state the functional behavior of methods as
%pre- and postconditions as well as class
%invariants. For
%constructing predicates, in addition to the \java\ boolean operators, 
%\jml\ relies on several logical operators such as the equivalence,
%\texttt{<==>}, and the implication \texttt{==>}, and several
%quantifiers as the existential,
%\texttt{$\backslash$exists}, and the universal, \texttt{$\backslash$forall}.
%Additionally, in \jml\  it is possible to use method
%invocations inside the predicates provide that
%those do not have \emph{side effects}.


%\jass\\  (\java\ With Assertions)~\cite{bartetzko01assertions} is a Design
%by Contract extension for \java\ which allows to annotate
%\java\ programs. The \jass\ tool~\cite{JassUrl} is developed at the
%University of Oldenburg by the group Semantics. \jass\ supports the
%concept of \emph{trace assertions} which are used to monitor the
%dynamic behavior of objects in run-time. This language provides a
%construct called \texttt{changeonly} to specify the list of
%attributes than \emph{may} be modified for a method invocation. This
%list of attributes just consist of identifiers separated by ``.''.

%\escj~\cite{ESCJavaUrl} is a specification language developed at
%\csrc, conceived as a subset of the \jml\ specification
%language~\cite{EscJmlDiff}. The \escj\ tool advocates for doing static
%checking of annotated \java\ programs. Additionally it relies on an
%automatic theorem prover for checking some specific problems. These
%problems cover \texttt{ArrayIndexOutOfBoundExceptions},
%\texttt{NullPointerExceptions} and \emph{Deadlock} and \emph{Race}
%problems in multi-thread \java\ programs.


\paragraph{\bf{Static checking of assignable clauses}}
Within this paper, we develop a static checker which extends \escj, by
checking the so-called assignable clauses, \emph{i.e.}~the part of the
specification which states which variables may be changed by a
method. The current implementation of \escj\ does not check
this~\cite{Leino01}.

The checking of methods in \escj\ is done in a modular way, on a
method per method basis.When one encounters a method call in the body
that one is checking, it is not known which method implementation
actually will be called~--~due to dynamic binding. Therefore,
following the behavioural subtype approach~\cite{LiskovW94}, the
method specification in the static class type of the receiver of the
method call will be used\footnote{Additionally, one has to show that
for each overriding method in a subclass, it satisfies the
specification of the superclass.}.

When reasoning in such a way, pre- and postconditions of methods alone 
are not sufficient, one also needs to know which variables may have
been changed by a method. Consider for example the following annotated 
program fragment.

%<<<<<<< floc-2002.tex
%=======
%Recently, several approaches have been
%proposed to overcome these kind of problems and although they can not
%actually replace formal verification techniques, they constitute
%important alternatives for checking the behavior of software
%systems. \emph{Run-time
%checking} is a kind of extended checking where, in addition to checking
%the input-output behavior, it is checked whether certain specific
%conditions are
%satisfied at particular points in the program. For checking these
%conditions, the original program is expressed into another
%one
%which can be then executed. If the execution throws an exception,
%this indicates that the original program does not fulfill the
%expected conditions.

%\emph{Static checking} techniques check the behavior of programs
%from their source code. This technique can be complemented with
%an automatic theorem prover which automatically can detect
%some specific problems. It is expected not to expend too much time in
%this process.

%When using static and run-time checking techniques on software systems,
%it is possible to state
%some specifications which we are interested to check. These
%specifications can be provided to the checking tools as part of the
%source code and written by using a suitable
%specific-specification language. 

%Currently, several specification languages have been proposed
%for \java~and \cPP. \jml~\ (\java~Model
%Language)~\cite{LeavensBR00} is a tool developed at the Iowa State
%University
%doing run-time checking. Its specification language follows the
%\eiff's approach of \emph{Design by
%Contract}~\cite{Meyer97}, hence
%it is possible to state the functional behavior of methods as
%pre- and postconditions as well as class
%invariants. For
%constructing predicates, in addition to the \java~boolean operators, 
%\jml~relies on several logical operators such as the equivalence,
%\texttt{<==>}, and the implication \texttt{==>}, and several
%quantifiers as the existential,
%\texttt{$\backslash$exists}, and the universal, \texttt{$\backslash$forall}.
%Additionally, in \jml~ it is possible to use method
%invocations inside the predicates provide that
%those do not have \emph{side effects}.

%\insPP~is a automatic run-time error detector for
%\cPP~\cite{InsurePP}. This checker keeps track of a \cPP~program and
%complains whether a block of memory is liberated too many times, a memory
%block is used without being initialized or there exist memory leaks.

%\jass\~ (\java~With Assertions)~\cite{bartetzko01assertions} is a Design
%by Contract extension for \java~which allows to annotate
%\java~programs. The \jass~tool~\cite{JassUrl} is developed at the
%University of Oldenburg by the group Semantics. \jass~supports the
%concept of \emph{trace assertions} which are used to monitor the
%dynamic behavior of objects in run-time. This language provides a
%construct called \texttt{changeonly} to specify the list of
%attributes than \emph{may} be modified for a method invocation. This
%list of attributes just consist of identifiers separated by ``.''.

%\escj~\cite{ESCJavaUrl} is a specification language developed at
%\csrc, conceived as a subset of the \jml~specification
%language~\cite{EscJmlDiff}. The \escj~tool advocates for doing static
%checking of annotated \java~programs. Additionally it relies on an
%automatic theorem prover for checking some specific problems. These
%problems cover \texttt{ArrayIndexOutOfBoundExceptions},
%\texttt{NullPointerExceptions} and \emph{Deadlock} and \emph{Race}
%problems in multi-thread \java~programs. \escj~neither is sound nor
%complete, hence whether it issues a warning it does not necessary
%means that some problem occurs. \escj~ships with a specific construct,
%\texttt{modifies}, for specifying the \emph{assignable} behavior of a
%method, but unlike the \jass~tool the variable locations one can
%annotate as assignable can become intricate. Thus, it is possible,
%for instance, to state as assignable all elements of some array
%(\texttt{a[$*$]}) or the fields of some object
%expression $e$ (\texttt{fields\_of($e$)}). \escj~tool does not check
%the correct specification of the assignable behavior of a method,
%hence some verifications problems arise.
%%The annotation language for \eiff~is the first
%%example of such a specification language, following the \emph{design
%%by contract} approach~\cite{Meyer97}. 



%\paragraph{\bf The side-effects freeness problem.}
%The functional behavior as can be expressed by pre- and postconditions
%is not enough to reason about arbitrary method invocations. Suppose we 
%have the example presented below. 
%>>>>>>> 1.16
\begin{alltt}
public class C\verb!{!
  int[] arr;

  //@ ensures arr.length >= 4;
  public void m()\verb!{!arr = new int[5]; n();\verb!}!

  //@ ensures true;
  public void n()\verb!{!arr = new int[2];\verb!}!
\verb!}!
\end{alltt}
To establish whether \texttt{m} will satisfy its postcondition, the
functional specification of \texttt{n} alone does not give enough
information, one also needs to know whether \texttt{n} might change
the variable \texttt{arr}. Therefore, \jml\ and \escj\ allow the user
to specify a so-called assignable clause, using the keyword
\texttt{modifies}\footnote{\jml\ also allows the alternative keywords
\texttt{assignable} and \texttt{modifiable}.}, specifying a set of
locations (typically variables) that may be modified by a method. An
assignable clause can contain variable names, but also more
complicated expressions, \emph{e.g.}~to denote all the elements in an
array. By default, when a method specification does not contain an
assignable clause, the method is supposed to modify nothing. %\jml\
%even allows more general expressions to
%occur in the assignable clause.

The current version of \escj\ does not check assignable clauses, it
only uses them when checking method calls.  As the information in the
assignable clause is crucial in the verification of other methods, we
think this is a significant omission, because specifying assignable
clauses is error-prone. When specifying a real-life application it is
easy to forget to mention some variables in the assignable
clause~--~see for example our experiences with the specification and
static checking of an industrial case
study~\cite{CatanoH02a}. Therefore, in this paper we propose a method
to do static checking of assignable clauses.


%Therefor

%e, we think it is important that assignable clauses are
%checked, b
%An incorrect assignable clause can cause
%other incorrect method specifications to be accepted, which can then cause
%other incorrect method specifications to be accepted, and so
%on... 
% But Therefore, it is important to have a tool
%which checks assignable clauses, even when it is only on a syntactic
%basis, without taking aliasing into account. Such a tool is presented
%in this paper.


The method works on a syntactic basis. For every method, and for every
assignment\footnote{And for all syntactic variations of assignments.}
in this method we check whether it may violate the assignable clause
of the method. Also, for every method call encountered in a method
body, it is checked whether this method call agrees with the
assignable clause of the body that is checked. We have implemented a
tool performing all the checks automatically.

Our method is neither sound nor complete, for example because it does
not handle aliasing and because it does not keep track of variable
updates\footnote{For example, for a program fragment \texttt{\{i++;
a[i] = 3;\}} it will accept an assignable clause \texttt{modifies
a[i];}.}. However, our experiences show that in practice our method is
very useful, because it finds immediately the most common mistake in
an assignable clause: forgetting completely to mention that a variable
may be modified.  We feel that when specifying a method in which
variables are modified in a complicated or tricky way, a specifier
will be careful when writing the assignable clause and will be more
willing to do full verification, while for simple methods he is more
likely to forget to mention some variables and does not want to
do full verification to detect this.

%The functional behavior of \texttt{n} is not enough to \emph{ensure}
%the post-condition of \texttt{m}, \emph{i.e.}, to ensure that the
%length of \texttt{arr} still will be greater or equal than $4$ after
%the invocation of \texttt{n}. Hence, it arises the need of specifying
%the \emph{changeable} behavior of methods,\emph{i.e}, of specifying what
%is set of variables locations a certain method modifies.



%\escj\ ships with a specific construct,
%\texttt{modifies}, 


%for specifying the \emph{assignable} behavior of a
%method, but unlike the \jass\ tool the variable locations one can
%annotate as assignable can become intricate. Thus, it is possible,
%for instance, to state as assignable all elements of some array
%(\texttt{a[$*$]}) or the fields of some object
%expression $e$ (\texttt{fields\_of($e$)}). \escj\ tool does not check
%the correct specification of the assignable behavior of a method,
%hence some verifications problems arise.


%\paragraph{\bf This paper.}We propose a static checker for the correct
%specification of the
%\emph{assignable} (as a subset of \emph{modifiable}) behavior of
%\jml\ annotated programs. For this purpose, we define a set
%of rules for each \java\ construct which state the variable locations
%these instructions \emph{may} modify. This checker carries out an
%syntactical analysis of the source program and checks whether its
%methods declarations fulfill their assignable specifications. By using
%these rules one can detect errors such as
%declaring a method without \emph{side-effects} when it actually modifies 
%some variable location. Our rules are neither sound nor complete
%(following the \escj\ approach), as we can not detect the most subtle
%errors since they require a detailed analysis, but using them the
%most simple errors can be detected quickly. We have developed the tool
%\modtool\ which implements these rules, by using the Abstract syntax
%tree generated by the parser of \jml. The feasibility of our approach is
%shown by presenting some gaps found in the process of checking the
%specification of the
%assignable behavior of a realistic case study~\cite{CatanoH02a}.

\paragraph{\bf{Related work}}
The term \emph{frame problem} finds its origins in the field of
AI~\cite{McCarthyH69}. Borgida \emph{et al.} revealed the relationship
with formal specifications, where one needs to know which part of the
state may be modified. They discuss several approaches, and finally
propose to use so-called change axioms which can describe the possible
changes of the state under a certain condition. They also give a
syntactic method which can be used to generate a first attempt for the
change axioms. A limitation of their approach is that they only look
at single variables, while we also can handle expressions describing a
set of memory locations.

Leino~\cite{Leino98} and M\"uller~\cite{Mueller01} both have studied
how to specify and verify assignable clauses in subclasses and/or
using abstract variables. In this paper we only look at assignable
clauses containing concrete variables. When extending our work to
abstract variables, their work would form the basis to deal with
dependencies. 

Within the \jass\ project~\cite{JassUrl} the non-violation of assignable
clauses can be checked at run-time, but this is restricted to simple
variables only, more complex expressions are not allowed in the
assignable clauses.

Finally, within the \loopp\ project a semantic definition for
assignable clauses is defined. When verifying a method body, one has
to show that each variable not mentioned in the assignable clause is
not changed. This is a heavy proof burden, because it involves
quantifications over the whole state. Therefore, it is useful to first 
check automatically whether the assignable clause is likely to be
correct, before diving into the full verification.

\paragraph{\bf{Organisation}}

The rest of this paper is organized as follows.
Section~\ref{sec-esc-prg} briefly presents the most important
assertion constructs of \jml\ and \escj. Section~\ref{sec-ass}
discusses the meaning of the assignable clause.
Section~\ref{sec-syn-met-che-ass-cla} presents the rules that we use
to check assignable clauses, and Section~\ref{sec-che-for-ass-cla}
presents our implementation on top of the \jml\ parser and discusses
practical experiences.  Finally, Section~\ref{sec-con-and-fut-wor}
gives conclusions and presents future work.






\section{JML and ESC/Java specifications}
\label{sec-esc-prg}
%\escj\ is a static checker for \java\ programs developed
%at \csrc~\cite{ESCJavaUrl}, allowing a user to find common programming
%errors, such as nullpointer exceptions, array index out of bound
%exceptions, deadlocks and race conditions. It does this by generating
%appropriate proof obligations and sending these off to an automatic,
%dedicated theorem prover. A user can specify additional class and
%method specifications (\emph{e.g.}~class invariants, pre and post
%conditions), which the tool will also try to check.  If the underlying
%theorem prover cannot establish a certain proof obligation, the tool
%issues a warning. Such a warning does not necessarily mean that the
%program is wrong, since the \escj\ approach is neither sound nor
%complete. \escj\ expressions are boolean \java\ expressions, extended
%with several specification-specific constructs. 

%It relies on a dedicated theorem prover to
%find specific problems
%The basic idea is that
%a user specifies the behavior of a class and its methods, by
%using the specification language of \escj. This
%behavior can be expressed as \textit{preconditions},
%\textit{postconditions} and \textit{class invariants}. The \escj\ tool
%checks whether the implementation satisfies the given
%specification and 

The \jml\ specification language is designed to be 
easily usable for \java\ programmers. In particular, \jml\ expressions
are side-effect free boolean \java\ expressions, extended with some
specification-specific constructs. The specification language for
\escj\ uses the same design principles. Initially there were several
differences between the two languages, but to enable the use of
different tools on the same specification, effort has been put in
making the two languages converge~\cite{EscJmlDiff}. In this paper, we 
do not really distinguish between the two languages\footnote{In
particular, we do not consider \jml's model variables.}, although we
take the more general \jml\ format for assignable clauses.

Below, we briefly present the main \jml\ and \escj\ constructs,
followed by a simple method specification example. A complete
description can be found in~\cite{LeavensBR00,LeinoNS00}.
\begin{itemize}
\item[] \textbf{Constructs for specifying methods:} 
\begin{itemize}
\item[-]{\texttt{requires P}: precondition {\tt P};}
%This construct specifies a precondition {\tt P}. 
%When \escj\ checks the body of a
%method, it assumes that \texttt{P} holds initially and when checking
%a method call, it will issue a warning if 
%it can not establish that \texttt{P} holds at the call point. 
 
\item[-]{\texttt{ensures Q}: postcondition {\tt Q};} 
%This construct specifies a postcondition \texttt{Q}. This postcondition
%is checked against the body of method and assumed for any method
%invocation if the method terminates normally (without throwing an
%exception).
 
\item[-]{\texttt{exsures (E) R}: exceptional postcondition \texttt{R},
\emph{i.e.}~if the method terminates abruptly with exception of type
\texttt{E}, then \texttt{R} should be satisfied; }
%This construct specifies an exceptional condition \texttt{R}. This
%condition is
%supposed to hold if the method finishes abruptly and if
%the exception \texttt{e} that is thrown is a subclass of \texttt{E}. 

\item[-]{\texttt{modifies L}: locations \texttt{L} that
a method may modify (see Section~\ref{sec-ass}).}
 
\end{itemize}
 
\item[] \textbf{Specification expressions}  
 
\begin{itemize} 
\item[-]{\texttt{==>}, \texttt{<==>}, \texttt{<=!=>}}: logical
implication, equivalence and non-equivalence;
%So, \texttt{P 
%==> Q} is true if and only if \texttt{P} is false or \texttt{Q} is 
%true, where \texttt{P} and \texttt{Q} are specification expressions of  
%\texttt{boolean} type. Furthermore, \texttt{<==>} represents the logical
%equivalence and \texttt{<=!=>} specifies non-equivalence. 
 
\item[-] {($\backslash$\texttt{forall T V; E)}, 
($\backslash$\texttt{exists T V; E})}: universal and existential
quantification;
% are quantifier expressions (of 
%type \texttt{boolean}).  The first expression denotes that \texttt{E}
%is true
%for all substitutions of values of type \texttt{T} for the bound 
%variable \texttt{V}. The second one denotes that \texttt{E} is true 
%for a substitution of a value of type \texttt{T} for the bound 
%variable \texttt{V}. 
 
\item[-]{\texttt{$\backslash$old(E)}}: 
value of expression \texttt{E} in pre-state of method
(in postcondition only);
 
\item[-] {\tt$\backslash$result}: method return value (in postcondition
only).
%returned by 
%a non-void method. It can only be used within an
%\texttt{ensures} clause.
\end{itemize} 
\end{itemize} 

As an example of a method specification, we give the
specification of the method \texttt{addCurrency} from an electronic
purse case study~\cite{CatanoH02a}. This specification has been
checked with \escj.
%A typical annotation example using 
%\escj. This example was taken from the formal specification of an
%\emph{electronic purse} as presented in~\cite{CatanoH02a}\footnote{The whole
%specification can be taken
%from~\cite{CatanoH01URL}.}. 
%%%%%%%
\begin{alltt}
/*@
  modifies nbData, data[nbData];
  ensures (\verb!\!old(nbData) < MAX_DATA) ?
      (nbData == \verb!\!old(nbData) + 1 && data[\verb!\!old(nbData)] == cur) :
      (nbData == \verb!\!old(nbData));
*/
void addCurrency(byte cur)\verb!{!
   if(nbData < MAX_DATA)\verb!{!data[nbData] = cur; nbData++;\verb!}!
\verb!}!
\end{alltt}
%%%%%%%%
The \texttt{addCurrency} method belongs
to a class \texttt{Currencies}, that stores all currencies 
supported by the purse application. The method 
\texttt{addCurrency} adds a new currency to the list of valid 
currencies (the array \texttt{data}). The \texttt{modifies} clause
specifies that this method may modify \texttt{nbData} and 
\texttt{data} in the position \texttt{nbData}. The
postcondition of the method \texttt{addCurrency} (written as 
\texttt{ensures} clauses) expresses that if \texttt{nbData} has not 
yet reached the threshold value \texttt{MAX$\_$DATA}, \texttt{nbData} 
will increase its value by one and the value of the formal parameter 
\texttt{cur} will be assigned to
\texttt{data[\(\backslash\)old(nbData)]}, otherwise \texttt{nbData} is 
unchanged.  Inside the postcondition, the expression
\texttt{$\backslash$old(nbData)} refers to the value of 
\texttt{nbData} before the method invocation. 

\begin{figure}[tbh]
\begin{tabular}{rcl}
%$<$\textsf{Assignable-spec}$>$ &::= &$<$\textsf{Assignable-clause}$>$ $<$\textsf{Assignable-exps}$>$ \\
%$<$\textsf{Assignable-exps}$>$ &::= &$<$\textsf{Assignable-exp}$>$\texttt{,}$<$\textsf{Assignable-exps}$>$ $|| $\\
%                           &    &$<$\textsf{Assignable-exp}$>$ \\

$<$\textsf{Assignable-exp}$>$  
  & ::=  & $<$\textsf{Identifier}$>$ \\
  &$\mid$& $<$\textsf{Identifier}$>$\texttt{[}\textsf{Exp}\texttt{]} \\
  &$\mid$& $<$\textsf{Identifier}$>$\texttt{[}\textsf{Exp}\ldots \textsf{Exp}\texttt{]}  \\
  &$\mid$& $<$\textsf{Identifier}$>$\texttt{[}*\texttt{]} \\
  &$\mid$& $\backslash$\texttt{fields\_of(}$<$\textsf{Field-exp}$>$\texttt{)}  \\
  &$\mid$& $\backslash$\texttt{nothing} \\
  &$\mid$& $\backslash$\texttt{everything} \\

$<$\textsf{Field-exp}$>$ 
  & ::=  & $<$\textsf{Point-identif}$>$  \\
  &$\mid$& \texttt{this} \\
  &$\mid$& $\backslash$\texttt{reach(}$<$\textsf{Point-identif}$>$\texttt{)}  \\
  &$\mid$& \texttt{reach(}\texttt{this}\texttt{)}  \\

$<$\textsf{Point-identif}$>$   
  & ::=  & $<$\textsf{Identifier}$>$\texttt{.}$<$\textsf{Point-identif}$> $ \\
  &$\mid$ & $<$\textsf{Identifier}$>$ \\
%$<$\textsf{Assignable-clause}$>$ &::= &\texttt{assignable}   \\
%                             &    &\texttt{modifiable}   \\
%                             &    &\texttt{modifies} \\
\end{tabular}
\caption{Syntax for an assignable expression}\label{FigAssignableExpr}
\end{figure}


\section{JML's assignable clauses}
\label{sec-ass}

An assignable clause specifies which variables may 
be modified by a method; all other variables \emph{should} remain
unchanged. Within an assignable clause, a list of so-called assignable 
expressions is specified which describe which memory locations may be
modified. The exact syntax for an assignable
expresssion is given in Fig.~\ref{FigAssignableExpr}.

%The syntax of specification of a assignable clause in a
%\java\ annotated program
%is presented by the figure~\ref{fig-syn-mod-spe}. 

An assignable expression can be an identifier or a simple array
indexing expression denoting a single location, but it can also denote
a set of locations. An expression
\texttt{a[i\dots j]} denotes the set of locations
\(\{\texttt{a[}k\texttt{]}\mid \texttt{i} \leq k \leq j\}\), while
\texttt{a[*]} denotes the same as \texttt{a[0\dots a.length - 1]}.
An assignable expression \fieldsofarg{\(e\)} denotes the set of all
the fields of the objects represented by the field expression \(e\).
The field expression \(e\) can be a single object (again possibly
\texttt{this}), or it is the \reach\ of some object \(f\) (possibly
\texttt{this}). The expression \reacharg{\(f\)} denotes the minimal 
set containing \(f\), the fields of \(f\) and all objects reachable
from the fields of \(f\).  Finally, there are special keywords
\nothing\ and \everything, denoting the empty set of locations and the 
complete set of locations, respectively.

%collection of
%variable of reference type, and where
%\texttt{$\backslash$fields\_of(x)} denotes all fields of \texttt{
%denotes \texttt{x[*]} if \texttt{x}
%is an array, otherwise the set of fields of \texttt{x}. The construct
%\texttt{$\backslash$reach} only can occur inside a \texttt{fields\_of}
%construct. An specification like \texttt{$\backslash$reach(x)} denotes
%the minimal set containing \texttt{x}, the fields of \texttt{x} and
%all objects
%reachable from the fields of \texttt{x}. A specification like
%\texttt{modifies \!\!$\backslash$nothing} expresses the method as not
%having
%side-effects. Additionally, a specification like \texttt{modifies
%\!\!$\backslash$everything} expresses that the method may modify any
%variable location.
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%We present a set of syntactical rules which check the correct
%specification of assignable clauses in \java\ asserted programs. These
%rules have been defined taking into account both of the \jml\ grammar
%%specification and the definition of assignable clauses presented
%in~\cite{LeavensBR00}.

Given the set of locations characterised by the assignable
expressions, a \jml\ assignable clause is defined as
follows\footnote{This definition differs
from~\cite{LeavensBR00} in that it does not consider dependencies, 
as we do not consider model variables.}.
%We present the definition concerning the conditions about the assigment
%of expressions in \jml. This definition was taken directly
%from~\cite{LeavensBR00}.
\begin{definition}[Assignable clause]
\label{def-mod}
An \emph{assignable clause} only permits a method to modify a location
\emph{loc} if:
\begin{itemize}
\item \emph{loc} is mentioned in the method's assignable
clause;
\item \emph{loc} is not allocated when the method starts execution; or
\item \emph{loc} is local to the method (\emph{i.e.}, a local
variable or a formal parameter).
\end{itemize}
\end{definition}

Notice that this is a syntactic definition, thus an assignment
\texttt{x = x;} only is permitted if the 
variable \texttt{x} is mentioned in the appropriate assignable clause
or if \texttt{x} is a local variable.

%To ensure that a method implementation respects its assignable clause, 
%one should state proof obligations of the form \(s\:\mathsf{mod}\:Y\),
%for each instruction \(s\) in the method, where \textsf{mod} is
%defined as follows\footnote{Notice that 

%meaning \(s\) may only modify the variables
%denoted by \(Y\).


%We have adapted this definition in the presentation of our \textsf{mod}
%rules. Thereby the definition~\ref{df-mod}.
%%%%%%%%%%%%%%
%\begin{definition}[\textsf{mod}]
%\label{df-mod}
%\[s\:\mathsf{mod}\:Y \defn{=} \forall x \in LC.\,x \not\in Y \Rightarrow 
%\textit{Pre}_s(x) = \textit{Post}_s(x)\]
%%$s$\ \textsf{mod}~$Y$ $\Leftrightarrow$ $\forall x \in LC.\,
%%x\not\in$ \textsc{Y}$\ \Rightarrow Pre(x) = Post(x)$ \\
%where $LC$ is a set of variable locations, $s$ is some
%instruction, $\textit{Pre}_s(x)$
%refers to the value of $x$ before executing $s$,
%$\textit{Post}_s(x)$ refers to the value of $x$ after executing
%$s$ and $Y$ is the set of variables that may be modified by \(s\).
%\end{definition}



%This section 


%We present a set of syntactical rules which define the conditions that
%must be fulfilled for any instruction occurring in a
%\java\ annotated program. We have profited the syntax of \java\ for
%defining our rules. Thus, for instance, we rely on rules for
%expressions, statements, and so on. The basic idea is that for each
%sort of instruction occurring in a method
%declaration, these rules check that the variable locations they assign
%belongs to the set of variable locations that the
%method \emph{may} modify.


%The rest of this section is organized as it follows. Section
%\ref{sub-sec-ass-beh} present the syntax of specification of
%assignable clause and certain other definitions used in the
%specification of our rules. Sections \ref{sub-sec-rul-con-met},
%\ref{sub-sec-rul-con-pri-suf-and-pri-exp}, \ref{sub-sec-rul-con-ass},
%\ref{sub-sec-rul-con-ope}, \ref{sub-sec-rul-con-sta}, and
%\ref{sub-sec-tra-rul} present the rules for the different
%\java\ constructs. Section \ref{sub-sec-the-rel-mem} the definition of
%membership operator used in the specification of our rules.






%\subsection{Assignable Behavior}
%\label{sub-sec-ass-beh}


%%%%%%%%%%%%%%
%These \textsf{mod} rules have beeing reformulated in other more
%specific ones, considering the syntactical structure of
%\java. Consequently, we rely on \textsf{modEXP} for
%expressions, \textsf{modSTM} for statements and so on. 
%on so-called primary
%expressions (


\section{A syntactical method to check assignable clauses}
\label{sec-syn-met-che-ass-cla}

In this section we present a syntactic method to derive for each
method body whether it does not violate its assignable clause. In
particular, for each modification of a location (\emph{i.e.} an
assignment) and for each method call, appropriate checks are done.


\subsection{Preliminaries}
For each language construct \(s\) we will define a rule
which allows us to derive the correctness of statements
\MOD{s}{Y}, with the intuitive meaning: \(s\) only assigns
to variables which are mentioned in \(Y\). Together, these rules
exactly define \textsf{mod}.

In some cases we need to lift the notion \textsf{mod} over a set of
instructions. Therefore, we define the following.

\begin{definition}[$\overrightarrow{\textsf{mod}}$]
\label{def-mod-lis}
Let \(S\) be a set of statements and \(Y\) be an assignable clause,
then the notion \MOD\ is \emph{lifted} over the set of instructions.
\[\MODS{S}{Y} \defn{=}\forall s.\,s\in S\Rightarrow \MOD{s}{Y}\]
%$S\ \overrightarrow{\textsf{mod}}~Y$ iff $\forall s.\ s\in
%S\Rightarrow s\ \textsf{mod}~Y$
\end{definition}

As mentioned in the previous section, the assignable clause can
contain expressions as
\fieldsofarg{this}, thus checking whether a
variable occurs in the assignable clause cannot be done by simply using set
membership \(\in\). Therefore, we use an extended notion of set
membership, subsuming \(\in\), denoted by \(\underline\in\). Below, in 
Subsection~\ref{sub-sec-the-rel-mem} this notion is defined precisely.

Based on the notion of extended set membership, we can also define the
notion of an \emph{extended membership subset}.
%Each rule
%checks that the set of locations modified by the corresponding
%instruction \emph{belongs} to a set of locations specifined as modified for
%the method. This concept $\underline\in$ of membership must be
%formulated considering
%the syntaxis of the assignable declarations (see
%Fig.~\ref{fig-syn-mod-spe}), but intituivaly subsumes the standard
%concept $\in$. Section~\ref{sub-sec-the-rel-mem} shows the definition
%of this concept. 

%Once we count on the definition of membership for assignable
%locations, we should give the definition for the
%inclusion. Figure~\ref{def-subseq} presents the definition of inclusion of
%assignable locations.
%%%%%%%%%%
\begin{definition}[Extended membership subset $\sqsubseteq$]
\label{def-subseq}
Let \(Y_1\) and \(Y_2\) be assignable clauses. The \emph{extended
membership subset} predicate is then defined as follows.
\[\extsubset{Y_1}{Y_2} \defn{=} \forall v.\ \extmember{v}{Y_1}
\Rightarrow \extmember{v}{Y_2}\]
\end{definition} 


We will also define variant notions \textsf{modFE} and
\textsf{modSuf}, which are defined only on so-called \emph{full
expressions} and \emph{suffix expression}, respectively. 
These notions have a similar intuitive meaning as
\textsf{mod}. 

%Notice that \textsf{mod} is
%a syntactic notion, and we cannot give a semantic definition for
%it\footnote{In particular, a semantic definition would never be able
%to find that \texttt{x = x;} could violate an assignable clause.}, but 
%the rules presented below together define 

\begin{figure}[tb]
\begin{tabular}{lr}
\begin{tabular}[t]{rcl}
\FullExp & ::=  & \FullExp[\Exp\(^+\)]  \\
         &$\mid$& \FullExp(\Exp\(^*\))  \\
         &$\mid$& \FullExp.\SufExp  \\
         &$\mid$& \SufExp\\
\\
\end{tabular}
&
\hspace*{2em}
\begin{tabular}[t]{rcl}
\SufExp  & ::=  & \Identifier  \\
         &$\mid$& \texttt{this}  \\
         &$\mid$& \texttt{super}  \\
         &$\mid$& \textsf{Literal}\\
         &$\mid$& \texttt{new} \Type [\Exp]\\
         &$\mid$& \texttt{new} \Type (\Exp\(^*\))\\
%\FullExp & ::= & \FullExp.\SufExp \option \\
%              && \textsf{Literal} \option \\ && \texttt{new}
%              \Type(\Exp) \option \\ && \texttt{new} \Type[\Exp]
%              \option \\ && \FullExp.\MethodCall \option \\ &&
%              \MethodCall \option\\ && \SufExp \\
%\\
%\SufExp & ::= & \Identifier \option \texttt{super} \option
%                \texttt{this} \option \Static \option
%                \Identifier[\Exp]\\
\end{tabular}
\end{tabular}
\caption{Syntax for full expressions and suffix expressions}
\label{FigExpGrammar}
\end{figure}

Full expressions and suffix expressions are defined following the
syntax in Fig.~\ref{FigExpGrammar}. A full expression is an array
indexing expression, a method call, a qualified expression or a suffix
expression. A suffix expresion can be an identifier, a reference to
super or this, a literal or an initialisation of an object or an
array.  This syntax is a simplified version of the the \jml\ and
\java\ grammar~\cite{LeavensBR00,GoslingJSB00}, because we assume that
the program is accepted by the \java\ compiler and/or the
\jml\ tool.% Thus, we can rely on the fact that the syntax will obey
%this grammar.
We assume that we have predicates \textsf{full?} and
\textsf{suffix?} which can decide whether an expression is a full
expression or a suffix expression, respectively.


%%%%%%%%%%
%Definition~\ref{def-mod-lis} generalize the concept introduce by
%Definition~\ref{df-mod}, by extending it for set of instructions.
%%%%%%%%%
%%%%%%%%%%

%We have also introduced some other \emph{mod}
%constructs by exploiting the \java\ syntax. These \emph{mod}
%constructs cover concepts such as \textit{modSTM}, \textit{modEXP},
%\textit{modPE}, \textit{modPRM} and \textit{modPS}, which redefine the
%original concept \textit{mod} in terms of concepts for
%\emph{statements}, \emph{expressions}, \emph{post-expressions},
%\emph{primary} and \emph{suffixes} expressions respectively. A primary
%\java\ expression can be seen as the first expression in a
%sequence of \java\ expressions joined by the symbol \texttt{``.''}. All 
%of the other expressions make up the suffix of the original
%expression.
%
%expresses that if the set of assignable variable locations of certain
%method is represented by locations $Y$, then this method may modify the set
%of expressions \textsc{Y}, and in its method body occur expressions or
%declarations such as \textup{f}$_1$\textup{(e}$_1$\textup{,
%f}$_2$\textup{(e}$_2$\textup{,}$\cdots$
%\textup{(f}$_n$\textup{(e}$_n$\textup{))))}, then their correctness
%will be established in terms of the correctness of each subexpression
%\textup{e}$_i$ \emph{w.r.t} \textsc{Y}. 




\subsection{The rules for \textsf{mod}}

\subsubsection{Method rules}
\label{sub-sec-rul-con-met}
%We have defined certain syntactical rules for every \java\ construct,
%stating which variables may be modified. Our rules check for
%all \java\ constructs that the expressions modified by instructions
%inside all method bodies are according to
%their assignable specification. We present the derivation rules for
%the most important \java\ constructs. The whole set of rules can be found
%in~\cite{CatanoMasterThesis01}.
The first rules that we define are related with methods.
Checking of assignable clauses is always done on a method by method
basis. The first rule therefore deals with method
declarations. Following Definition~\ref{def-mod}, it is sufficient for 
the body of the method to check that it only modifies the variables in 
the assignable clause of the method (denoted as \(Y\)) or the local
variables or formal parameters of the method.


%\textsf{Meth-Dec} is the rule corresponding to a method declaration
%\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{)} that has
%specified may modify the set of variable locations $Y$. This rule
%states that for this method declaration, it is enough to
%check every instruction in its method body
%(\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{).body}) with respect
%to \textsc{Y}, the set of parameters and the local variables to the
%method. As can be seen, this rule essentially formalizes
%Definition~\ref{def-mod}. 
%%%%%
\[
\begin{tabular}{ll}
\textsf{(Meth-Dec)}\,\,\,&
\begin{prooftree} 
\MOD{\methodbody{m}{o}}{(Y \cup \{\overrightarrow{\texttt{o}}\}
                           \cup \{\methodloc{m}{o}\}) }
\justifies
\MOD{\method{m}{o}}{Y}
\end{prooftree}
\end{tabular}
\]
%%%%%

When checking a method body, if one encounters a method invocation the
assignable clause of this method is compared with the assignable
clause of the method body that is currently checked. The assignable
clause of the invoked method should be a subset of the assignable
clause of the current method~--~with appropriate substitutions~--~to
ensure that no other variables than the one mentioned in the
assignable clause can be modified. According to the grammar, method
invocations are always full expressions, thus the method invocation
will be of the form \(\method{\textit{fe}}{o}\) where \textit{fe} is a
full expression. The last element in \textit{fe} will be a method
name, \texttt{this} or \texttt{super}. In all cases, the appropriate
assignable clause can be found by looking at the static type of the
one but last element of \textit{fe}, if it exists, or otherwise by
taking the default value \texttt{this}.  This is sufficient, because
behavioural subtyping ensures that overriding methods in subclasses do
not modify more variables~\cite{?}.

Additionally, it has to be checked that the full expression
\textit{fe} and the actual parameters \(\overrightarrow{\texttt{q}}\)
respect the assignable clause.

The rule for method invocations is only defined on \textsf{modFE}: the 
\java\ grammar ensures that a method call can only occur in this context 
(provided the \java\ program is accepted by the compiler).

%A method invocation
%$e\texttt{.m(}\overrightarrow{\texttt{q}}\texttt{)}$,
%must fulfill the assignable specification corresponding to its
%method declaration $\texttt{m(}\overrightarrow{\texttt{o}}\texttt{)}$
%previous replacing: $(i)$\ \texttt{this} by $e$ and
%$(ii)$\ $\overrightarrow{\texttt{o}}$ by
%$\overrightarrow{\texttt{q}}$. Additionally, the actual parameters
%$\overrightarrow{\texttt{q}}$ must be checked for
%side-effects. It similar to the expression $e$ (see rule
%\textsf{Meth-Inv}). As can be seen this rules use \textsf{modEXP}
%and \textsf{modPE} rules. \textsf{modEXP} stands for expressions and
%\textsf{modPE} for post-fix expressions. A \java\ post-fix
%expression represents a sort of \emph{primary} expressions linked by
%``.''. A typical primary \java\ expression is a \java\ identifier.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Meth-Inv)}\,\, &
\begin{prooftree}
\extsubset{\methodassign{\textit{fe}}{o}
\:[\overrightarrow{\texttt{o}}/\overrightarrow{\texttt{q}},
\texttt{this}/ \textit{fe}]}{Y}
\quad
\MODFE{fe}{Y}
\quad
\MODS{q}{Y}
\justifies
\MODFE{\method{\textit{fe}}{q}}{Y}
\end{prooftree}
\end{tabular}
\]
%%%%%%


\subsubsection{Assignment rules}
\label{sub-sec-rul-con-ass}
When we encounter an assignment $e_1\:\texttt{=}\:e_2$ we must check
that $e_1$ belongs to set of locations that the method may modify
(\(\extmember{e_1}{Y}\)). Additionally we must check that $e_1$ and
$e_2$ do not have unwanted side-effect. Following the \java\ syntax,
we know that for \(e_1\) we have to check \textsf{modFE} only.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Assg)}\,\,\, & 
\begin{prooftree}
\extmember{e_1}{Y}
\quad
\MODFE{e_1}{Y}
\quad
\MOD{e_2}{Y}
\justifies
\MOD{e_1\:\texttt{=}\:e_2}{Y}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%
This rule generalises to all variations on assignments, as provided by
\java (\texttt{+=}, \texttt{*=} \emph{etc.}).
For initialisations of local variables we use a similar rule, although 
by default we know that the local variable will occur in \(Y\)~--~as
this is guaranteed by the rule \textsf{Meth-Decl}.

%An assignment can also be occurred in the declaration of a local
%variable. Suppose we have the declaration of certain variable
%\texttt{x} which is initialized with the value corresponding to
%certain expression $e$. The location
%corresponding a this variable must belong to the set $Y$ of possible
%assignable locations. Rule \textsf{Var-Decl-Assg} states this
%fact. Additionally, one must check the expression $e$ by using
%expressions rules.
%%%%%%%%%%
%\[
%\begin{tabular}{ll}
%\textsf{(Var-Decl-Assg)}\,\, & 
%\begin{prooftree}
%\rule[1ex]{0em}{1.5ex}
%\texttt{x}\underline{\in}Y,\ \ e\ \textsf{modEXP}~Y
%\justifies
%\texttt{T x =}~e\ \textsf{modEXP}~Y
%\end{prooftree}
%\end{tabular}
%\]
%%%%%%%%

A special kind of assignments in \java\ are constructed by using the
pre- and postfix operators (\emph{e.g.}~\texttt{x++} and
\texttt{++x}). Such instructions can be considered as  \emph{in
place} assignments, thus the rules for pre- and postfix operators are
similar to the assignment rule. For example, the rule
\textsf{Post-Plus} states that the expression $e$, which is the
target of an assignment, has to belong to set of expressions $Y$ which
may modified by the method, and that additionally $e$ must be checked for
(unwanted) side-effects.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Post-Plus)}\,\, &
\begin{prooftree}
\extmember{e}{Y}
\quad
\MODFE{e}{Y}
\justifies
\MOD{e\texttt{++}}{Y}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%

\subsubsection{Statement rules}
\label{sub-sec-rul-con-sta}
For all  \java\ constructs used to build statements, such as
\(S\texttt{;}T\), 
\(\texttt{if(}c\texttt{)\{}S\texttt{\}}\) and
%\(\texttt{if(}c\texttt{)\{}S\texttt{\}else\{}T\texttt{\}}\) and
\(\texttt{while(}c\texttt{)\{}S\texttt{\}}\) the rules simply pass on
the check on the assignable clause to the components of the
statement. As an example, we present the rule \textsf{If-Then}.
%$\overrightarrow{s}$\texttt{\}}},
%\texttt{if(}c\texttt{)\{$\overrightarrow{s}$\texttt{\}}else\{$\overrightarrow{t}$\}},
%\texttt{while(c)\{$\overrightarrow{s}$\}}

%. For the first case, for
%instance, the guard $c$ must be checked using
%\textsf{modEXP} rules since a guard
%corresponds to an expression. The set of instructions occurring in its
%body $\overrightarrow{s}$ must be checked using the most general rules
%\textsf{mod}. This is showed by the rule \textsf{If-Then}. For the
%others \java\ statements a similar analysis can be done.
%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(If-Then)}\,\, & 
\begin{prooftree}
\MOD{c}{Y}
\quad
\MOD{s}{Y}
\justifies
\MOD{\texttt{if(}c\texttt{)\{}S\texttt{\}}}{Y}
\end{prooftree}
\end{tabular}
\]

\subsubsection{Expression rules}
\label{sub-sec-rul-con-ope}
For most expressions, the same applies as for statements: the rules
simply passes on the check for side-effects to the arguments of the
expressions. In this way, we define for example the rule
\textsf{BinOp}, which applies to all binary operators (arithmetic,
relational and logical). Similar rules are defined for \emph{e.g.}~the 
unary operators, the \texttt{instanceof} expression, the casting
operator, and the conditional expression.

%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(BinOp)} & 
\begin{prooftree} 
\MOD{e_1}{Y}
\quad
\MOD{e_2}{Y}
\justifies
\MOD{e_1 \oplus e_2}{Y}
\using
\oplus \in \Big\{
	\begin{array}{l}
		\texttt{<},\texttt{<=},\texttt{>},
                \texttt{>=},\texttt{==},\texttt{!=},\texttt{||},	\\
		\texttt{\&\&},\texttt{+},\texttt{-},\texttt{*},
                \texttt{/},\mathtt{\backslash},\texttt{\&},
                \texttt{\^\,}, \texttt{|}
	\end{array}
	\Big\}
\end{prooftree}
%\\[3.0ex] 
%\textsf{(Unary)} & 
%\begin{prooftree} 
%e\ \textsf{modEXP}~Y
%\justifies
%\oplus \ e\ \textsf{modEXP}~Y
%\using
%\oplus \in \{\texttt{+,-,$\sim$,!}\}
%\end{prooftree}
%\\[3.0ex] 
%\textsf{(Instance)} & 
%\begin{prooftree} 
%e\ \textsf{modEXP}~Y
%\justifies
%e\ \texttt{instanceof C}~\textsf{modEXP}~Y
%\end{prooftree}
%\\[3.0ex] 
%\textsf{(Cast)} & 
%\begin{prooftree}
%e\ \textsf{modEXP}~Y
%\justifies
%\texttt{(T)}e\ \textsf{modEXP}~Y
%\end{prooftree}
%\\[3.0ex] 
%\textsf{(Conditional)}\,\, & 
%\begin{prooftree} 
%e_1\ \textsf{modEXP}~Y,\ \ e_2\ \textsf{modEXP}~Y,\ \ e_3\
%\textsf{modEXP}~Y
%\justifies
%e_1\texttt{?}e_2\texttt{:}e_3\ \textsf{modEXP}~Y
%\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%


However, if none of these rules applies to an expression, then it
means that we have a so-called full expression (see
Fig.~\ref{FigExpGrammar}) and we apply the \textsf{To-Fe}.
\[
\begin{tabular}{ll}
\textsf{(To-Fe)}\,\, & 
\begin{prooftree}
\MODFE{e}{Y}
\justifies
\MOD{e}{Y}
\using
\textsf{full?}(e)
\end{prooftree}
\end{tabular}
\]

\subsubsection{Full expression rules}
Following the grammar for full expressions, we define rules defining
\textsf{modFE}. The rule for method invocation \textsf{Meth-Inv} 
already has been presented above. If this rule does not apply, then
one of the following rules (for array, qualified or suffix
expressions, respectively should apply.
\[
\begin{tabular}{c}
\begin{tabular}{p{6cm}p{5cm}}

\begin{tabular}{ll}
\textsf{(Array)}\,\, & 
\begin{prooftree}
\MODFE{fe}{Y}
\quad 
\MODS{\overrightarrow{e}}{Y}
\justifies
\MODFE{fe\texttt{[}\overrightarrow{e}\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
&
\begin{tabular}{ll}
\textsf{(Qualified)} &
\begin{prooftree}
\MODFE{fe}{Y}
\quad
\MODSuf{s}{Y}
\justifies
\MODFE{fe\texttt{.}s}{Y}
\end{prooftree}
\end{tabular}

\end{tabular}

\\[3.0ex]
\begin{tabular}{ll}
\textsf{(To-Suf)}\,\, & 
\begin{prooftree}
\MODSuf{fe}{Y}
\justifies
\MODFE{fe}{Y}
\using
\textsf{suffix?}(\textit{fe})
\end{prooftree}
\end{tabular}
\end{tabular}
\]

\subsubsection{Suffix expression rules}
Finally, we present some rules for suffix expressions. Most
suffix expressions are constant values (\emph{e.g.}~\texttt{this} and
all the literals) which do not modify anything, thus the rules for
these constructs are straightforward. Also the access to an identifier 
does not modify anything~--~and if the identifier is the target of an
assignment, the rule \textsf{Assg} takes care that it is mentioned in
the assignable clause. Thus, the only suffix expressions which are of
some interest are the \texttt{new} expressions. Here, the possible
arguments have to be checked for unwanted side-effects. The creation
of a new object or array does not violate the rules for the assignable 
clause (\emph{cf.}~Definition~\ref{def-mod}).

%\subsubsection{Transition rules}
%\label{sub-sec-tra-rul}
%In addition to define rules for each \java\ construct, we need also
%certain \emph{transition} rules which allow us to pass from more
%general rules to more particular ones, depending on the kind of the
%instruction. So, for example, we need transition rules from the most
%general case to expressions statements (\textsf{Mod-To-Exp} and
%\textsf{Mod-To-Stm}), from expressions to post-fix expressions
%(\textsf{Exp-To-Pe}), and from post-fix expressions to primary suffix
%and primary expressions.
%%%%%%%%%%%
%\[
%\begin{tabular}{ll}
%\textsf{(Mod-To-Exp)}\,\, & 
%\begin{prooftree}
%e\ \textsf{modEXP}~Y
%\justifies
%e\ \textsf{mod}~Y
%\using
%e\in Expression
%\end{prooftree}
%\\[3.0ex]
%\textsf{(Mod-To-Stm)} & 
%\begin{prooftree}
%e\ \textsf{modSTM}~Y
%\justifies
%e\ \textsf{mod}~Y
%\using
%e\in Statement
%\end{prooftree}
%\\[3.0ex]
%\\[3.0ex]
%\textsf{(Pe-To-Ps)} &
%\begin{prooftree}
%e_1\ \textsf{modPE}~Y,\ e_2\ \textsf{modPS}~Y
%\justifies
%e_1\ \texttt{.}~e_2\ \textsf{modPE}~Y
%\end{prooftree}
%\\[3.0ex]
%\textsf{(Pe-to-Prm)} &
%\begin{prooftree}
%e\ \textsf{modPRM}~Y
%\justifies
%e\ \textsf{modPE}~Y
%\using
%e\in \ \textsf{Primary}
%\end{prooftree}
%\end{tabular}
%\]
%%%%%%%%%%%%


%\subsubsection{Rules concerning primary suffix and primary expressions}
%\label{sub-sec-rul-con-pri-suf-and-pri-exp}
%\java\ \emph{post-fix} expressions can be seen as set of \emph{suffix}
%expressions linked by ``.''. The first expression of which must be a
%\emph{primary} expression. Typical primary expressions correspond to
%identifiers, constants, the special \java\ keywords \texttt{this},
%\texttt{static} and \texttt{super}, method invocations (as presented
%before) and \emph{new} expressions. 

%In the case of \emph{new} expressions (see rule \textsf{New-Exp}), the
%expressions passed as parameters must be checked for side-effects by
%using \textsf{modEXP} rules. The other cases of primary expression do
%not require an additional analyze.
%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(New-Exp)}\,\, & 
\begin{prooftree}
\MODS{\overrightarrow{e}}{Y}
\justifies
\MODSuf{\texttt{new T(}\overrightarrow{e}\texttt{)}}{Y}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%





%%%%%%%%%%%





\subsection{The extended membership relation}
\label{sub-sec-the-rel-mem}
Finally, we have to give rules to define the extended membership
relation. Fig.~\ref{fig-syn-mod-spe} shows which expressions can
occur inside an assignable clause. Again, we give syntactic rules for
all possible formats of an assignment targets. First we consider the
assignable expressions \nothing\ and
\everything. In the first case the assignable
clause is the emptyset, in the second case it is the global
universe. The rules for these constructs are obvious.
\[
\begin{tabular}{p{5cm}p{5cm}}
\begin{tabular}{ll}
\textsf{(In-Nothing)} &
\begin{prooftree}
\textsf{false}
\justifies
\extmember{e}{\emptyset}
\end{prooftree}
\end{tabular}
&
\begin{tabular}{ll}
\textsf{(In-Everything)} &
\begin{prooftree}
\textsf{true}
\justifies
\extmember{e}{\mathcal{U}}
\end{prooftree}
\end{tabular}
\end{tabular}
\]

%Another important aspect that must be analyzed is
%the different constructs that can appear in assignable
%specifications. According to the syntax of the assignable clause as
%presented by Figure~\ref{fig-syn-mod-spe},
%\texttt{$\backslash$fields\_of} and \texttt{$\backslash$reach}
%constructs can occur inside of such assignable specifications, the
%latter only occurring inside the former. Hence, when establishing
%membership conditions $e\underline\in Y$, we need to define suitable
%rules taking into account the fact that these constructs can occur
%inside $Y$.

For non-trivial assignable clauses, the most simple case is where a
variable is mentioned literally in the assignable clause. In this
case, we fall back directly on the standard definition of set
membership.
%%%%%%%
\[
\begin{tabular}{p{5cm}p{5cm}}
\begin{tabular}{ll}
\textsf{(In-Var)} &
\begin{prooftree}
\member{\texttt{x}}{Y}
\justifies
\extmember{\texttt{x}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Arr)} &
\begin{prooftree}
\member{\texttt{a[}e\texttt{]}}{Y}
\justifies
\extmember{\texttt{a[}e\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
&
\begin{tabular}{ll}
\textsf{(In-Exp)} &
\begin{prooftree}
\member{e\texttt{.x}}{Y}
\justifies
\extmember{e\texttt{.x}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Exp-Arr)}\,\, &
\begin{prooftree}
\member{e\texttt{.a[}e_1\texttt{]}}{Y}
\justifies
\extmember{e\texttt{.a[}e_1\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
\end{tabular}
\]
%%%%%%%%%%

When checking array index expressions as
\texttt{a[}$e$\texttt{]$\underline{\in} Y$}, it is also sufficient
to find an expression \texttt{a[*]} or \texttt{a[i..j]} in the
assignable clause\footnote{Assuming that \(i \leq e \leq j\) can be
checked syntactically, which will not always be the case.}.

% \jml\ construct in $Y$ specifying that the
%corresponding method may modify any element of \texttt{a}
%(\textsf{Times-Arr}) or a certain interval where the value of $e$ is
%found (rule \textsf{Interv-Arr}).
%%%%%%%%%%
\[
\begin{tabular}{p{5cm}p{5cm}}
\begin{tabular}{ll}
\textsf{(Global-Arr)}\,\, &
\begin{prooftree}
\member{{a[}*\texttt{]}}{Y}
\justifies
\extmember{{a[}e_1\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
&%\\[3.0ex]
\begin{tabular}{ll}
\textsf{(Interv-Arr)}\,\, & 
\begin{prooftree}
\member{\texttt{a[}i..j\texttt{]}}{Y}
\quad\ i\leq e\leq j
\justifies
\extmember{\texttt{a[}e\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
\end{tabular}
\]
%%%%%%%%%%%
Further, an expression \fieldsofarg{\(e\)} can
occur in an assignable clause. Here we distinguish two cases: \(e\) is 
a single object or array\footnote{For arrays,
\fieldsofarg{\(e\)} is
equivalent to \(e\)\texttt{[*]}.}, or it is a
\reach\ expression. In the first case, the rules
check for each qualified expression whether
\fieldsof\ occurs for the receiving object. For 
unqualified expressions, this is checked for \texttt{this}.


%If these rules do not apply, we
%have to consider some cases according to the shape of $e$. If
%$e$ has shape $e_1\texttt{.}e_2$ and $e_2$ is not an array expression,
%it will be enough to have \texttt{$\backslash$fields\_of($e_1$)}
%occurring in $Y$ to establish the original condition of membership
%(rule \textsf{In-Fld-Exp-Var}). Otherwise, if $e_2$ is an array
%expression \texttt{a[$e_3$]}, it will be enough to have
%\texttt{$\backslash$fields\_of($e_1$.a)} occurring in $Y$ (see rule
%\textsf{In-Fld-Exp-Arr}). We have similar rules when $e$ is an
%expression not linked by ``.'' (see rules \textsf{In-Fld-Var} and
%\textsf{In-Fld-Arr}).
%%%%%%%%%%%
\[
\begin{tabular}{p{6.5cm}p{5cm}}
\begin{tabular}{ll}
\textsf{(In-Fld-Exp-Var)}\,\, &
\begin{prooftree}
\member{\fieldsofarg{\(e\)}}{Y}
\justifies
\extmember{e\texttt{.x}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Fld-Exp-Arr)}\,\, &
\begin{prooftree}
\member{\fieldsofarg{\(e\)\texttt{.a)}}}{Y}
\justifies
\extmember{e\texttt{.a[}e'\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
&
\begin{tabular}{ll}
\textsf{(In-Fld-Var)} &
\begin{prooftree}
\member{\fieldsofarg{this}}{Y}
\justifies
\extmember{\texttt{x}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Fld-Arr)}\,\, &
\begin{prooftree}
\member{\fieldsofarg{a}}{Y}
\justifies
\extmember{\texttt{a[}e'\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
\end{tabular}
\]
%%%%%%%%%%%
For reach expressions, we check whether an expression
\fieldsofarg{\reacharg{\(e'\)}} occurs in the assignable clause, and if \(e
\in \reacharg{\(e'\)}\), \emph{i.e.}~\(e\) is in the reach of \(e'\).

%Furthermore, \texttt{$\backslash$reach} expressions can occur in
%assignable clauses. So, if an expression such as
%\texttt{$\backslash$fields\_of($\backslash$reach($e_1$))} occurs in
%$Y$ it is sufficient having $e$ belonging to set expressions reachable
%from $e_1$ for establish the condition \texttt{$e$.x$\underline\in
%Y$}. This situation is presented by the rule
%\textsf{In-Reach-Exp}. Something similar happens when \texttt{x} is an
%array expression. This is presented by rules
%\textsf{In-Reach-Exp-Arr}. The rules \textsf{In-Reach-Var} and
%\textsf{In-Reach-Arr} present the cases when we intend to establish
%membership conditions for expressions not linked by ``.''.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(In-Reach-Var)} &
\begin{prooftree}
\member{\fieldsofarg{\reacharg{\(e\)}}}{Y}
\quad
\member{\texttt{this}}{\reacharg{\(e\)}}
\justifies
\extmember{\texttt{x}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Reach-Arr)} &
\begin{prooftree}
\member{\fieldsofarg{\reacharg{\(e'\)}}}{Y}
\quad
\member{\texttt{a}}{\reacharg{\(e'\)}}
\justifies
\extmember{\texttt{a[}e\texttt{]}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Reach-Exp)} &
\begin{prooftree}
\member{\fieldsofarg{\reacharg{\(e'\)}}}{Y}
\quad
\member{e}{\reacharg{\(e'\)}}
\justifies
\extmember{e\texttt{.x}}{Y}
\end{prooftree}
\\[3.0ex]
\textsf{(In-Reach-Exp-Arr)}\,\, &
\begin{prooftree}
\member{\fieldsofarg{\reacharg{\(e'\)}}}{Y}
\quad
\member{e\texttt{.a}}{\reacharg{\(e'\)}}
\justifies
\extmember{e\texttt{.a[}e''\texttt{]}}{Y}
\end{prooftree}
\end{tabular}
\]
The reach of an object is defined recursively: an element \(e\) is in
the reach of an object, if it is the object itself, or if it is in the 
reach of one of the fields of this object.
\[
\begin{tabular}{ll}
\textsf{(Reach-Base)} &
\begin{prooftree}
e = e'
\justifies
\member{e}{\reacharg{\(e'\)}}
\end{prooftree}
\\[3.0ex]
\textsf{(Reach-Rec)} &
\begin{prooftree}
\member{e''}{\fieldsofarg{\(e'\)}}
\quad
\member{e}{\reacharg{\(e''\)}}
\justifies
\member{e}{\reacharg{\(e'\)}}
\end{prooftree}
\end{tabular}
\]

%%%%%%%%%%%
\subsection{A deriviation example}
%%%%%%%%%%%
Do we have the space to put this????


\subsection{Limitations of our approach}
As our method works on a purely syntactical basis, it has some
limitations. In particular, our method does not work in the context of 
\emph{aliasing}. For example, suppose we have the following class
\texttt{C}.

%Our specification just does not concern with the modification but the
%assignment, hence in a context with \emph{Aliasing} we miss the
%variable modified. Thereby, suppose we have a class \texttt{C} as
%presented below. 
%%%%%%%%
\begin{alltt}
public class C\verb!{!
  O y = new O(), x = new O();    

  //@ modifies x, y.i;
  public void p()\verb!{!
     x = y;
     y.i = 7;
  \verb!}!    
\verb!}!
public class O\verb!{!
  public int i;
\verb!}!
\end{alltt}
%%%%%%%%%%
According to the specification method \texttt{p} may modify
\texttt{x} and the field \texttt{i} of the object \texttt{y}. Because
of the assignment \texttt{x = y;} the variables \texttt{x} and
\texttt{y} are aliases, so the assignment \texttt{y.i = 7;} implicitly 
also modifies \texttt{x.i}, which is an unwanted side-effect. However, 
our method will not reject this method.

%Although the expression
%\texttt{y.i = 7;}, in addition to modify the field \texttt{i} of the
%object \texttt{y}, modifies the field \texttt{i} of the object
%\texttt{x} (since the aliasing between \texttt{x} and \texttt{y} as
%consequence of the \emph{assignment} \texttt{x = y}), our rules
%accept as valid this specification.

Our method also does not take earlier assignments to variables into
account, \emph{e.g.}~a specification \texttt{//@ modifies a[i];} will 
be accepted for a body \texttt{i++; a[i] = 3;}.

However, we think that these limitations do not severely restrict the
usability of our method. Our method should be considered as a quick
check to get a reasonable trust in the correctness of the specified
assignable clauses. In our experience, when specifying the assignable
clause of a method, it is more likely to forget to mention a simple
variable then to overlook complicated modification structures. Finding 
these small specification mistakes before doing formal verification
significantly can help to improve the verification speed.



\section{A checker for assignable clauses}
\label{sec-che-for-ass-cla}
%%%---Finally, we briefly discuss the implementation of the \modtool, which
%%%---implements the method presented above.
%%%---%We present some implementation issues concerning \modtool: a
%%%---%modifiable checker implementing the approach and rules presented in
%%%---%Section~\ref{sec-syn-met-che-ass-cla}.
%%%---
%%%---For the implementation we reuse the parser of \jml.
%%%---%\jml\ comes with several classes for handling abstract
%%%---%syntax trees. 
%%%---The \jml\ parser returns an
%%%---\emph{abstract syntax tree}, in instance of class \texttt{AST}.
%%%---This class \texttt{AST} allow one to represent pieces of code as the
%%%---sequence of a node and a \emph{sibling}, where a node is a tuple of an
%%%---\texttt{int} and a \texttt{String}, and the sibling is another
%%%---\texttt{AST}.
%%%---Further, there is an utility class \texttt{ASTFactory} which
%%%---provides operations to create and duplicate trees, and a class
%%%---\texttt{ASTArray}, which maintains an array of abstract syntax trees.
%%%---
%%%---
%%%---% for recovering the
%%%---%structure of programs we are checking. 
%%%---We use these classes to first $(i)$\ determine the \emph{assignable
%%%---clause} of all method declarations and then $(ii)$\ to apply the rules
%%%---presented above. In order to do this we have defined a class
%%%---\texttt{ASTContext}, and a class \texttt{Assignable}. 
%%%---%recovering the structure of the program for
%%%---%applying our checking rules.
%%%---The last one implements our deriviation rules as static methods
%%%---parameterized by the assignable clause of an instruction.
%%%---%context under which the respective instruction is
%%%---%found.
%%%---
%%%---%Section~\ref{abo-jml-cla-use} gives a general overview of the class
%%%---%for handling Abstract syntax trees coming with
%%%---%\jml. Section~\ref{sub-sec-cla-ast-con} summarizes the implementation
%%%---%of the class \texttt{ASTContext} which is in charge of figuring out
%%%---%context of method declarations. Section~\ref{sub-sec-the-cla-ass}
%%%---%presents the class \texttt{Assignable}, which implement our
%%%---%syntactical rules. Finally, Section ~\ref{sub-sec-usi-the-too}
%%%---%summarizes our experience using the tool \modtool.
%%%---
%%%---
%%%---
%%%---
%%%---%\subsection{Representing Abstract syntax trees with \jml}
%%%---%\label{abo-jml-cla-use}
%%%---
%%%---
%%%---
%%%---
%%%---
%%%---
%%%---\subsection{The class \texttt{ASTContext}}
%%%---\label{sub-sec-cla-ast-con}
%%%---The class \texttt{ASTContext} represents the context of a method
%%%---declaration. A method context consists of the representation of its
%%%---assignable locations, its parameters and its local variables. This
%%%---representation is based on the definition~\ref{def-mod}. Additionally
%%%---we store the package, and the class in which the method
%%%---occurs and for each class we store which class it extends.
%%%---
%%%---These contexts are passed as parameter to the methods of the class
%%%---\texttt{Assignable}, which implements the rules presented in
%%%---Section~\ref{sec-che-for-ass-cla}.
%%%---
%%%---
%%%---
%%%---
%%%---\subsection{The class \texttt{Assignable}}
%%%---\label{sub-sec-the-cla-ass}
%%%---
%%%---The class \texttt{Assignable} implements the assignable rules as
%%%---static methods. To each static method one passes the expression
%%%---\texttt{e} currently analyzed, the context \texttt{cxt} of the method
%%%---where the expression \texttt{e} occurs and the contexts \texttt{cxts}
%%%---of all known classes.
%%%---
%%%---For example, when the expression \texttt{e} is an assignment
%%%---$e_1\:\texttt{=}\:e_2$, it has to be checked that $e_1$ belongs to set
%%%---of assignable expressions of the method
%%%---(\texttt{\_in\_PRIME($\cdots$)}) and that it obeys the
%%%---\textsf{modFE} rules on $e_1$ (\texttt{\_modFE($\cdots$)}) and the
%%%---\textsf{mod} rules on $e_2$ (\texttt{\_mod($\cdots$)}).
%%%---\begin{alltt}
%%%---public static boolean _mod(AST e, ASTContext cxt, Vector cxts)\verb!{!	
%%%---  boolean tempRes;	
%%%---  switch(e.getType())\verb!{!	
%%%---    case JavaTokenTypes.ASSIGN:{\it // =}
%%%---      tempRes = _in_PRIME(e.getFirstChild(),cxt,cxts) &&
%%%---       _mod(e.getFirstChild(),currentCxt,cxts) &&
%%%---       _mod(e.getFirstChild().getNextSibling(),cxt,cxts);
%%%---      return tempRes;
%%%---    \vdots 
%%%---  \verb!}!
%%%---\verb!}!
%%%---\end{alltt}
%%%---
%%%---
%%%---
%%%---
%%%---\subsection{Experiences using \modtool}
%%%---\label{sub-sec-usi-the-too}
%%%---To test the usability of our approach, we have applied \modtool\ to
%%%---the specifications that we wrote earlier for an electronic purse case
%%%---study~\cite{CatanoH02a}. This case study consists of .. classes,
%%%---containing .. methods all together. The specifications are written in
%%%---\escj, thus the assignable clauses are relatively simple and do not
%%%---contain constructs as \fieldsof\ and \reach. When writing and
%%%---improving the specificaitions, we found several times that we had
%%%---forgotten to mention a variable in an assignable clause, but even
%%%---after correcting this ....
Finally we discuss about our experiences in the process of using \modtool
for checking the specification of the case study Gemplus' electronic
purse~\cite{CatanoH02a} and briefly present a general overview on its
structure.




\subsection{On the structure of the tool}
\label{sub-on-the-str-too}
The tool has been constructed in two parts as presented below by the
figure. The first part has been made by reusing the
syntactical analyzer used by \jml. This part takes as input the
classes the user want to check and returns an Abstract syntax tree for 
each class passed as parameter. The information gather in these
\textsc{ASTs} is then used by the second part to check the
specification of the assignable clause.

The class \texttt{Assignable} implements as static methods the rules
presented in Section~\ref{sec-syn-met-che-ass-cla}. This class uses the 
\textsc{AST} passed by the Syntactical Analyzer of \jml~and figures
out the context --class \texttt{ASTContext}-- for all methods in the
source program. Basically, a context represents the \textit{elements} 
under which the different \java constructs are analyzed. These
elements typically consist of local variables, assignable declarations
and parameters of methods.

\begin{figure}[hbt]
\centering
\epsfig{file=figures/schema.eps, width=9cm, clip=}
\end{figure}

The class \texttt{ContextException} represents the kind of exception
raised up when some element required for figuring out a context has
not been passed as part of the source program. 

Finally, The class \texttt{Util} 
meets a sort of methods to handle the \textsc{AST} provided by the
\jml~syntactical analyzer.






\subsection{Experiences using \modtool}
\label{sub-sec-usi-the-too}
We have used \modtool~to check the assignable specifications provided
for the industrial case study ``Gemplus' electronic purse'' presented
in~\cite{CatanoH02a} and we have established specification
errors we made at that time, and which we could not detect before
because
\escj~does not do any checking of assignable
specifications. Basically, the errors detected consist of not
specifying as
assignable certain variable locations that the body that the
\java~structures actually modify. The tool efficiently detect
that and issues a message showing the structure that
violates the specification. 

Another important aspect of checking this application consist of
having established the set of its \emph{side-effects freeness}
methods. 

As an example, we present the specification of the
method \texttt{setValue} of the class \texttt{Decimal}. The class
\texttt{Decimal} models a floating point number, represented by an
integer and decimal parts. Our initial specification is presented
below and they only have stated as assignable the class variables
\texttt{intPart} and \texttt{decPart} since they are directly assigned 
in the body of the method. 

At that time, we did not consider any other
modification caused by the invocation to the method \texttt{throwIt}
of \texttt{decimal\_exception} as, in at first glance, when an exception
is raised you do not expect that that modifies any field, but that
because of memory management issues in \textsc{Javacard} applications
it actually happens.
%%%%%%%
\begin{alltt}
/*@ 
  modifies intPart, decPart;
*/ 
public Decimal setValue(short i, short d) throws DecimalException\verb!{!
  if(i < 0 || d < 0 || d >= PRECISION || 
     (i == MAX_DECIMAL_NUMBER && d != 0))
    decimal_exception.throwIt(decimal_exception.DECIMAL_OVERFLOW);

  intPart = i;
  decPart = d;
  return this;
\verb!}!
\end{alltt}
%%%%%%%

When this method is analyzed by \modtool, it obtains the specification 
of \texttt{throwIt} --\texttt{modifies instance, instance.type;}-- and 
realizes that it had not been considered by the method
\texttt{setValue}. Then, it issues a message pointing out the instruction
having the problem. After adding the specifications
\texttt{decimal\_exception.instance} and
\texttt{decimal\_exception.instance.type;} to the specification of
\texttt{setValue}, the tool stops of complaining.  


    

%   modifies decimal_exception.instance, decimal_exception.instance.type;

\section{Conclusion and future work}
\label{sec-con-and-fut-wor}
This paper presents a method to do an efficient check on assignable
clauses. In particular, this method can be used to do a quick check on 
side-effect freeness.
This method works on a syntactic basis: 
for each \java\ construct a rule is defined which checks that every
assignment only assigns to variables that are declared as 
\emph{assignable}. 
Currently, the tool
does not work with model variables (specification only variables), but
these could be handled in a similar way.

There are some limitations to our approach, in
particular it does not work in a context with aliasing. In such a
case, formal verification is necessary, but applying our method first
helps to find the very common simple mistakes, thus allowing to
concentrate on the essentials when doing formal verification.
%, our
%method can miss the variable modified. Several solutions have been
%proposed for solving this problem. In~\cite{Leino98} a solution with
%\emph{Data groups} is proposed, which enables modular checking.

%Our rules, and the implementation we are done, allow one to check for
%side-efects efficiently, as no too much is spend in it. 

\subsubsection{Future work}
Our method does not keep track of newly allocated memory. Therefore,
it will reject for example the following method specification:
\begin{verbatim}
class C {int x;}
class D {
  //@ modifies \nothing;
  m() {
   C c = new C();
   c.x = 3;
  }
}
\end{verbatim}
To overcome this limitation, future work is to extend our method to extend the
assignable clause with the (primitively typed) fields of newly
allocated method.

\jml\ provides so-called model variables, which allows to define
specification-only variables and relate them to concrete variables by
using \texttt{represents} or \texttt{depends} clauses,
following~\cite{Leino98}. These model variables also can be mentioned
in assignable clauses. It is future work to extend the tool to
appropriately handle this.

%On the other hand, in the process of specifying abstract classes, some
%times is useful to define fields
%which \emph{represents} or \emph{depends} of certain properties of those
%classes. Due to the nature of the abstract classes it becomes not
%convenient to define these fields in an implementation
%level. \jml\ provides the construct \texttt{model} to overcome this
%difficulty. This construct allow one to define fields in a
%specification level, hence they do not have to be implemented. Besides 
%this construct, \jml\ provide the constructs
%\texttt{depends} and \texttt{represents}. Our specification does not do any 
%analyses of this type as ``it is reasonable to wait until we clarify
%the precise semantics of dependencies''\footnote{Text taken from an
%email from Gary Leavens.}.

Finally, in the end we hope to be able to give better results in the
context of aliasing, for example by returning a warning if a possibly
aliased variable is changed.

\bibliographystyle{plain}
\bibliography{../specification}

\end{document}
