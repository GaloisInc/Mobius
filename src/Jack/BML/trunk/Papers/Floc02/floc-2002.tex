\documentclass[a4paper]{llncs}

\title{Specification of the \emph{assignable} clause of \jml}

\author{
  N\'estor Cata\~no and Marieke Huisman  \\
  \institute{
       \inria~Sophia-Antipolis, France \\
       \lemme~Project
  } 
  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
}

\newcommand{\lemme}{\textsc{Lemme}}
\newcommand{\inria}{\textsc{Inria}}
\newcommand{\jml}{\textsc{Jml}}
\newcommand{\escj}{\textsc{Esc/Java}}
\newcommand{\jass}{\textsc{Jass}}
\newcommand{\jcontract}{\textsc{JContract}}
\newcommand{\loopp}{\textsc{Loop}}
\newcommand{\java}{\textsc{Java}}
\newcommand{\cPP}{\texttt{C/C}\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf
+}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\newcommand{\gplus}{\textsc{GemPlus}}
\newcommand{\eiff}{\textsc{Eiffel}}
\newcommand{\ctl}{\textsc{Ctl}}
\newcommand{\pltl}{\textsc{Pltl}}
\newcommand{\csrc}{\textsc{Compaq Src}}
\newcommand{\insPP}{\textsc{Insure\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf
+}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}}

\newcommand{\modtool}{\texttt{assignable$:$tool}}

\newcommand{\sem}[1]{\ensuremath{\mbox{[\![} {#1} \mbox{]\!]}\/}}

\newtheorem {df}{Definition}

\usepackage{lscape} % it's needed to turn a page
\usepackage{amsmath} % it is needed by the \sem command
\usepackage{alltt}
\input{prooftree} %showing demonstration

\begin{document}
\fussy
\maketitle
\pagestyle{plain}

\begin{abstract}
This paper presents a method for checking the specification of
\emph{assignable} clauses in \java~programs with assertions \jml. We
propose syntactical rules for each type of \java~instruction. These
rules check for each \java~instruction occurring in a method
declaration that locations assigned by the instruction belong to set
of variable locations the method has specified as
\emph{assignable}. Hence, our specification does not concern with
modification but the assignment. We show the feasibility of our
approach presenting several specifications gaps found in the case
study \emph{Formal Specification and Static Checking of \gplus's
Electronic Purse Using \textsc{Esc/Java}}~\cite{CatanoH02a}.
\end{abstract}






\section{Introduction}
\label{sec-intro}

\paragraph{\bf Background.}
Several decades ago, the \emph{formal methods} were considered as a merely
theoretical issue in computer science, not suitable for real
problems$:$ \emph{complicated} notations taken from the logic and
the lack of tools supporting formal methods could not compete with the
tools and methods used in industry for software development. Recently, 
this has been changing. There are several reasons for this
change. Firstly, the specification languages are now closer to
programming languages than ever before and the techniques used are
more suitable to the actual programming paradigms (object oriented
and distributed programming). Secondly, industry has started to feel
the need for certified software. An
example~\cite{Borger99programmer}$:$ during $1995$,
\textsc{Intel} found a problem with its microprocessors
\textsc{Pentium}. This company was forced to replace around two
million processors. Thus, it realized that the costs of formal
verification would have been much lower than the costs required to
fix this bug.

Currently, with the interest of the industry and the academic world,
the developments in formal methods have become
increased. These developments are specially concerned with techniques
such as
\textit{model-checking} and \textit{theorem proving}.
Model-checking is technique based on constructing a finite model of a
problem and exhaustively checking the satisfaction of certain
properties. Model-checking is
a strong technique, as it is \emph{decidable}, but it presents some
limitations$:$ $(i)$~it can validate a
model of a certain system but not the system itself, and
$(ii)$~verification even for simple systems might need huge amounts
of space and time. 

Theoretically, interactive theorem proving techniques are able to
solve any problem proposed in practice, but it presents some
disadvantages$:$ $(i)$~it is \emph{undecidable}, $(ii)$~the tools are
only capable of assisting an engineer in the process of constructing a
proof, and $(iii)$~it requires expressing and understanding the
semantics underlying the
programming language in the logic of the theorem prover, in order to
do program verification. 
%Testing checks whether a program produces
%correct output on certain input. This technique is important for
%checking some properties before applying a formal technique. A
%disadvantage of this approach is that one spends too much of time in the
%process of constructing all possible testing cases. Moreover,
%sometimes it is not possible to check all possible
%inputs. 

Recently, several approaches have been
proposed to overcome these kind of problems and although they can not
actually replace formal verification techniques, they constitute
important alternatives for checking the behavior of software
systems. \emph{Run-time
checking} is a kind of extended checking where, in addition to checking
the input-output behavior, it is checked whether certain specific
conditions are
satisfied at particular points in the program. For checking these
conditions, the original program is expressed into another
one
which can be then executed. If the execution throws an exception,
this indicates that the original program does not fulfill the
expected conditions.

\emph{Static checking} techniques check the behavior of programs
from its source code. This technique can be complemented with
an automatic theorem prover which automatically can detect
some specific problems. It is expected not to expend too much time in
this process.

When using static and run-time checking techniques on software systems,
it is possible to state
some specifications which we are interested to check. These
specifications can be provided to the checking tools as part of the
source code and written by using a suitable
specific-specification language. 

Currently, several specification languages have been proposed
for \java~and \cPP. \jml~\ (\java~Model
Language)~\cite{LeavensBR00} is a tool developed at the Iowa State
University
doing run-time checking. Its specification language follows the
\eiff's approach of \emph{Design by
Contract}~\cite{Meyer97}, hence
it is possible to state the functional behavior of methods as
pre- and postconditions as well as class
invariants. For
constructing predicates, in addition to the \java~boolean operators, 
\jml~relies on several logical operators such as the equivalence,
\texttt{<==>}, and the implication \texttt{==>}, and several
quantifiers as the existential,
\texttt{$\backslash$exists}, and the universal, \texttt{$\backslash$forall}.
Additionally, in \jml~ it is possible to use method
invocations inside the predicates provide that
those do not have \emph{side effects}.

\insPP~is a automatic run-time error detector for
\cPP~\cite{InsurePP}. This checker keeps track of a \cPP~program and
complains whether a block of memory is liberated too many times, a memory
block is used without being initialized or there exist memory leaks.

\jass\~ (\java~With Assertions)~\cite{bartetzko01assertions} is a Design
by Contract extension for \java~which allows to annotate
\java~programs. The \jass~tool~\cite{JassUrl} is developed at the
University of Oldenburg by the group Semantics. \jass~supports the
concept of \emph{trace assertions} which are used to monitor the
dynamic behavior of objects in run-time. This language provides a
construct called \texttt{changeonly} to specify the list of
attributes than \emph{may} be modified for a method invocation. This
list of attributes just consist of identifiers separated by ``.''.

\escj~\cite{ESCJavaUrl} is a specification language developed at
\csrc, conceived as a subset of the \jml~specification
language~\cite{EscJmlDiff}. The \escj~tool advocates for doing static
checking of annotated \java~programs. Additionally it relies on an
automatic theorem prover for checking some specific problems. These
problems cover \texttt{ArrayIndexOutOfBoundExceptions},
\texttt{NullPointerExceptions} and \emph{Deadlock} and \emph{Race}
problems in multi-thread \java~programs. \escj~neither is sound nor
complete, hence whether it issues a warning it does not necessary
means that some problem occurs. \escj~ships with a specific construct,
\texttt{modifies}, for specifying the \emph{assignable} behavior of a
method, but unlike the \jass~tool the variable locations one can
annotate as assignable can become intricate. Thus, it is possible,
for instance, to state as assignable all elements of some array
(\texttt{a[$*$]}) or the fields of some object
expression $e$ (\texttt{fields\_of($e$)}). \escj~tool does not check
the correct specification of the assignable behavior of a method,
hence some verifications problems arise.
%The annotation language for \eiff~is the first
%example of such a specification language, following the \emph{design
%by contract} approach~\cite{Meyer97}. 



\paragraph{\bf The side-effects freeness problem.}
The functional behavior as can be expressed by pre- and postconditions
is not enough to reason about arbitrary method invocations. Suppose we 
have the example presented below. 
\begin{alltt}
public class C\verb!{!
  int[] arr;
  /*@
    ensures arr.length >= 4;
   */
  public void m()\verb!{!
    arr = new int[5]; n();
  \verb!}!
  public void n()\verb!{}!
\verb!}!
\end{alltt}
The functional behavior of \texttt{n} is not enough to \emph{ensure}
the post-condition of \texttt{m}, \emph{i.e.}, to ensure that the
length of \texttt{arr} still will be greater or equal than $4$ after
the invocation of \texttt{n}. Hence, it arises the need of specifying
the \emph{changeable} behavior of methods,\emph{i.e}, of specifying what
is set of variables locations a certain method modifies.




\paragraph{\bf This paper.}We propose a static checker for the correct
specification of the
\emph{assignable} (as a subset of \emph{modifiable}) behavior of
\jml~annotated programs. For this purpose, we define a set
of rules for each \java~construct which state the variable locations
these instructions \emph{may} modify. This checker carries out an
syntactical analysis of the source program and checks whether its
methods declarations fulfill their assignable specifications. By using
these rules one can detect errors such as
declaring a method without \emph{side-effects} when it actually modifies 
some variable location. Our rules are neither sound nor complete
(following the \escj~approach), as we can not detect the most subtle
errors since they require a detailed analysis, but using them the
most simple errors can be detected quickly. We have developed the tool
\modtool~which implements these rules, by using the Abstract syntax
tree generated by the parser of \jml. The feasibility of our approach is
shown by presenting some gaps found in the process of checking the
specification of the
assignable behavior of a realistic case study~\cite{CatanoH02a}.


The rest of this paper is organized as follows$:$
Section~\ref{sec-esc-prg} presents briefly the specification language
\escj~together with its most important assertion
constructs. Section~\ref{sec-syn-met-che-ass-cla}
presents our approach for checking assignable clauses and the
definition of our rules. Section~\ref{sec-che-for-ass-cla}
presents our assignable checker (\modtool) implementing these
rules. Additionally, we discuss some problems we have found using our
tool on a realistic case study \emph{Formal Specification and Static
Checking of \gplus's Electronic Purse Using
\textsc{Esc/Java}}~\cite{CatanoH02a}. Finally,
Section~\ref{sec-con-and-fut-wor} gives conclusions and presents
future work.






\section{Static checking of \java~programs with \escj}
\label{sec-esc-prg}
\escj~is a static checker for \java~programs developed
at \csrc~\cite{ESCJavaUrl} which allows a user to find common
programming errors. It relies on a dedicated theorem prover to
find specific problems such as\texttt{NullPointerExceptions},
\texttt{ArrayIndexOutOfBoundExceptions},
 and \emph{Deadlock} and \emph{Race}
problems in multi-thread \java~programs.

The basic idea is that
a user specifies the behavior of a class and its methods, by
using the specification language of \escj. This
behavior can be expressed as \textit{preconditions},
\textit{postconditions} and \textit{class invariants}. The \escj~tool
checks whether the implementation satisfies the given
specification and it issues a warning 
message if it can not establish this. Such a
warning does not necessarily mean that the program is
wrong, since the \escj~approach is neither sound nor
complete. \escj~is enriched with several
specific-specification constructs. Among them on can find the
\texttt{modifies} one. This construct allow one to model the
assignable behavior of a method, although this kind of specification
are not checked by the tool.

Below, we present
the main \escj~constructs together with an example of their
use. Their full description can be found in~\cite{LeinoNS00}. 


\paragraph{\bf Constructs for specifying methods} 
\begin{itemize}
\item{\texttt{requires P}.} 
This construct specifies a precondition {\tt P}. 
When \escj~checks the body of a
method, it assumes that \texttt{P} holds initially and when checking
a method call, \escj~will issue a warning if 
it can not establish that \texttt{P} holds at the call point. 
 
\item{\texttt{ensures Q}.} 
This construct specifies a postcondition \texttt{Q}. This postcondition
is checked against the body of method and assumed for any method
invocation if the method terminates normally (without throwing an
exception).
 
\item{\texttt{exsures (E) R}.}
This construct specifies an exceptional condition \texttt{R}. This
condition is
supposed to hold if the method finishes abruptly and if
the exception \texttt{e} that is thrown is a subclass of \texttt{E}. 
 
\item{\texttt{modifies L}.} 
This construct specifies \texttt{L} as the set of variable locations that
a method \emph{may} modify.
\end{itemize}
 
 
 
\paragraph{\bf Specification expressions} 
\begin{itemize} 
\item{\texttt{==>}} is the logical implication. So, \texttt{P 
==> Q} is true if and only if \texttt{P} is false or \texttt{Q} is 
true, where \texttt{P} and \texttt{Q} are specification expressions of  
\texttt{boolean} type. Furthermore, \texttt{<==>} represents the logical
equivalence and \texttt{<=!=>} specifies non-equivalence. 
 
\item {($\backslash$\texttt{forall T V; E)} and 
($\backslash$\texttt{exists T V; E})} are quantifier expressions (of 
type \texttt{boolean}).  The first expression denotes that \texttt{E}
is true
for all substitutions of values of type \texttt{T} for the bound 
variable \texttt{V}. The second one denotes that \texttt{E} is true 
for a substitution of a value of type \texttt{T} for the bound 
variable \texttt{V}. 
 
\item{\texttt{$\backslash$old(E)}} is used within a postcondition,
where it denotes the value of the expression \texttt{E} in the
pre-state of the method.
 
\item {\tt$\backslash$result} represents the value returned by 
a non-void method. It can only be used within an
\texttt{ensures} clause.
\end{itemize}
Below we present a typical annotation example using 
\escj. This example was taken from the formal specification of an
\emph{electronic purse} as presented in~\cite{CatanoH02a}\footnote{The whole
specification can be taken
from~\cite{CatanoH01URL}.}. 
%%%%%%%
\begin{alltt}
/*@
  modifies nbData, data[nbData];
  ensures (\verb!\!old(nbData) < MAX_DATA) ?
      (nbData == \verb!\!old(nbData) + 1 && data[\verb!\!old(nbData)] == cur) :
      (nbData == \verb!\!old(nbData));
*/
void addCurrency(byte cur)\verb!{!
   if(nbData < MAX_DATA)\verb!{!data[nbData] = cur; nbData++;\verb!}!
\verb!}!
\end{alltt}
%%%%%%%%
The \texttt{addCurrency} method belongs
to a class \texttt{Currencies}. This class stores all currencies 
supported by the purse application. The method 
\texttt{addCurrency} adds a new currency to the list of valid 
currencies. This list is represented by the 
array \texttt{data}. The \texttt{modifies} clause declared in the 
method's header specifies that 
this method \emph{may} modify \texttt{nbData} and 
\texttt{data} in the position \texttt{nbData}\footnote{More precisely,
it specifies that the method only may modify these instance variables
and the local variables and formal parameters of the method.}. The
postcondition of the method \texttt{addCurrency} (written as 
\texttt{ensures} clauses) expresses that if \texttt{nbData} has not 
yet reached the threshold value \texttt{MAX$\_$DATA}, \texttt{nbData} 
will increase its value by one and the value of the formal parameter 
\texttt{cur} will be assigned to \texttt{data[\(\backslash\)old(nbData)]}.  
Inside the postcondition, the expression 
\texttt{$\backslash$old(nbData)} refers to the value of 
\texttt{nbData} before the method invocation. 






\section{A syntactical method to check assignable clauses}
\label{sec-syn-met-che-ass-cla}
We present a set of syntactical rules which define the conditions that
must be fulfilled for any instruction occurring in a
\java~annotated program. We have profited the syntax of \java~for
defining our rules. Thus, for instance, we rely on rules for
expressions, statements, and so on. The basic idea is that for each
sort of instruction occurring in a method
declaration, these rules check that the variable locations they assign
belongs to the set of variable locations that the
method \emph{may} modify.

Our specification just does not concern with the modification but the
assignment, hence in a context with \emph{Aliasing} we miss the
variable modified. Thereby, suppose we have a class \texttt{C} as
presented below. 
%%%%%%%%
\begin{alltt}
public class C\verb!{!
  O y = new O(), x = new O();    
  //@modifies x, y.i
  public void p()\verb!{!
     x = y ;
     y.i = 7;
  \verb!}!    
\verb!}!
public class O\verb!{!
  public int i;
\verb!}!
\end{alltt}
%%%%%%%%%%
The specification of the method \texttt{p} states it may modify
\texttt{x} and
the field \texttt{i} of the object \texttt{y}. Although the expression 
\texttt{y.i = 7;}, in addition to modify the field \texttt{i} of the
object \texttt{y}, modifies the field \texttt{i} of the object
\texttt{x} (since the aliasing between \texttt{x} and \texttt{y} as
consequence of the \emph{assignment} \texttt{x = y}), our rules
accept as valid this specification.

On the other hand, in the process of specifying abstract classes, some
times is useful to define fields
which \emph{represents} or \emph{depends} of certain properties of those
classes. Due to the nature of the abstract classes it becomes not
convenient to define these fields in an implementation
level. \jml~provides the construct \texttt{model} to overcome this
difficulty. This construct allow one to define fields in a
specification level, hence they do not have to be implemented. Besides 
this construct, \jml~provide the constructs
\texttt{depends} and \texttt{represents}. Our specification does not do any 
analyses of this type as ``it is reasonable to wait until we clarify
the precise semantics of dependencies''\footnote{Text taken from an
email from Gary Leavens.}.

The rest of this section is organized as it follows. Section
\ref{sub-sec-ass-beh} present the syntax of specification of
assignable clause and certain other definitions used in the
specification of our rules. Sections \ref{sub-sec-rul-con-met},
\ref{sub-sec-rul-con-pri-suf-and-pri-exp}, \ref{sub-sec-rul-con-ass},
\ref{sub-sec-rul-con-ope}, \ref{sub-sec-rul-con-sta}, and
\ref{sub-sec-tra-rul} present the rules for the different
\java~constructs. Section \ref{sub-sec-the-rel-mem} the definition of
membership operator used in the specification of our rules.






\subsection{Assignable Behavior}
\label{sub-sec-ass-beh}
\jml~as well as \escj~provides a construct for specifying the
assignable behavior of a method. For historical reasons this construct
can be named \texttt{assignable}, \texttt{modifiable} or
\texttt{modifies} like in \escj. In the following we use indistinctly
any among them. 

The syntax of specification of a assignable clause in a
\java~annotated program
is presented by the figure~\ref{fig-syn-mod-spe}. From this scheme, it
is possible to specify as assignable expressions like
\texttt{a$[$i$\dots$j$]$}. A such expression declares as assignable
the variable locations
\texttt{a$[$i$],$a$[$i$+1],\dots$a$[$j$]$}. Something similar happens
with an expression like
\texttt{a$[*]$}, which denotes the variable locations
\texttt{a$[$i$]$}, for all \texttt{i} lying between $0$ and
\texttt{sizeOf(a)}. An expression like
\texttt{$\backslash$fields\_of(x)} denotes \texttt{x[*]} if \texttt{x}
is an array, otherwise the set of fields of \texttt{x}. The construct
\texttt{$\backslash$reach} only can occur inside a \texttt{fields\_of}
construct. An specification like \texttt{$\backslash$reach(x)} denotes
the minimal set containing \texttt{x}, the fields of \texttt{x} and
all objects
reachable from the fields of \texttt{x}. A specification like
\texttt{modifies \!\!$\backslash$nothing} expresses the method as not
having
side-effects. Additionally, a specification like \texttt{modifies
\!\!$\backslash$everything} expresses that the method may modify any
variable location.
%%%%%%%%%%%%%%%%%%
\begin{figure}[hbt]
\begin{tabular}{lll}
$<$\textsf{Assignable-spec}$>$ &::= &$<$\textsf{Assignable-clause}$>$ $<$\textsf{Assignable-exps}$>$ \\
$<$\textsf{Assignable-exps}$>$ &::= &$<$\textsf{Assignable-exp}$>$\texttt{,}$<$\textsf{Assignable-exps}$>$ $|| $\\
                           &    &$<$\textsf{Assignable-exp}$>$ \\
$<$\textsf{Assignable-exp}$>$  &::= &$<$\textsf{Identifier}$>$ $||$ \\
                           &    &$<$\textsf{Array-exp}$>$  $||$ \\
                           &  &$\backslash$\texttt{fields\_of(}$<$\textsf{Field-exp}$>$\texttt{)} $||$ \\
                           &  &$\backslash$\texttt{nothing} $||$\\
                           &  &$\backslash$\texttt{everything} \\
$<$\textsf{Array-exp}$>$      &::=  &$<$\textsf{Identifier}$>$\texttt{[}\textsf{Exp}\ldots \textsf{Exp}\texttt{]} $||$ \\
                           &  &$<$\textsf{Identifier}$>$\texttt{[}\textsf{Exp}\texttt{]} $||$ \\
                           &  &$<$\textsf{Identifier}$>$\texttt{[}*\texttt{]} \\
$<$\textsf{Field-exp}$>$      &::=  &$\backslash$\texttt{reach(}$<$\textsf{Point-identif}$>$\texttt{)} $||$ \\
                           &     &\texttt{reach(}\texttt{this}\texttt{)} $||$ \\
                           &     &$<$\textsf{Point-identif}$>$ $||$ \\
                           &     &\texttt{this} \\
$<$\textsf{Point-identif}$>$   &::=  &$<$\textsf{Identifier}$>$\texttt{.}$<$\textsf{Point-identif}$> $$||$ \\
                           &     &$<$\textsf{Identifier}$>$ \\
$<$\textsf{Assignable-clause}$>$ &::= &\texttt{assignable} $||$  \\
                             &    &\texttt{modifiable} $||$  \\
                             &    &\texttt{modifies} \\
\end{tabular}
\label{fig-syn-mod-spe}
\caption{Syntax of a assignable specification}
\end{figure}
%%%%%%%%%%%%%%%%%%%%
%We present a set of syntactical rules which check the correct
%specification of assignable clauses in \java~asserted programs. These
%rules have been defined taking into account both of the \jml~grammar
%%specification and the definition of assignable clauses presented
%in~\cite{LeavensBR00}.

We present the definition concerning the conditions about the assigment
of expressions in \jml. This definition was taken directly
from~\cite{LeavensBR00}.
\begin{df}
\label{def-mod}
In \jml, a method may modify a location \emph{loc} provided that$:$
\begin{itemize}
\item \emph{loc} is mentioned in the \emph{assignable} clause, or
\item \emph{loc} is a local variable to the method, or 
\item \emph{loc} is a parameter
\end{itemize}
\end{df}

We have adapted this definition in the presentation of our \textsf{mod}
rules. Thereby the definition~\ref{df-mod}.
%%%%%%%%%%%%%%
\begin{df}[\textsf{mod}]
\label{df-mod}
$S$\ \textsf{mod}\ $Y$ $\Leftrightarrow$ $\forall x \in LC.
x\not\in$ \textsc{Y}$\ \Rightarrow Pre(x) = Post(x)$ \\
where $LC$ is a global set of variable locations, $Pre(x)$
refers to the state of $x$ before executing $S$,
$Post(x)$ refers to the state of $x$ after executing
$S$ and $Y$ is the set of variables that can be mentioned
inside a assignable clause as well as parameters and local variable to the 
method.
\end{df}
%%%%%%%%%%%%%%
These \textsf{mod} rules have beeing reformulated in other more
specific ones, considering the syntactical structure of
\java. Consequently, we rely on \textsf{modEXP} for
expressions, \textsf{modSTM} for statements and so on. Each rule
checks that the set of locations modified by the corresponding
instruction \emph{belongs} to a set of locations specifined as modified for
the method. This concept $\underline\in$ of membership must be
formulated considering
the syntaxis of the assignable declarations (see
Figure~\ref{fig-syn-mod-spe}), but intituivaly subsumes the standard
concept $\in$. Section~\ref{sub-sec-the-rel-mem} shows the definition
of this concept. 

Once we count on the definition of membership for assignable
locations, we should give the definition for the
inclusion. Figure~\ref{def-subseq} presents the definition of inclusion of
assignable locations.
%%%%%%%%%%
\begin{df}[$\sqsubseteq$]
\label{def-subseq}
$X \sqsubseteq Y$ iff $\forall x.\ x\underline{\in}X\Rightarrow
x\underline\in Y$
\end{df} 
%%%%%%%%%%
Definition~\ref{def-mod-lis} generalize the concept introduce by
Definition~\ref{df-mod}, by extending it for set of instructions.
%%%%%%%%%
\begin{df}[$\overrightarrow{\textsf{mod}}$]
\label{def-mod-lis}
$X\ \overrightarrow{\textsf{mod}}\ Y$ iff $\forall x.\ x\in
X\Rightarrow x\ \textsf{mod}\ Y$
\end{df}
%%%%%%%%%%

%We have also introduced some other \emph{mod}
%constructs by exploiting the \java~syntax. These \emph{mod}
%constructs cover concepts such as \textit{modSTM}, \textit{modEXP},
%\textit{modPE}, \textit{modPRM} and \textit{modPS}, which redefine the
%original concept \textit{mod} in terms of concepts for
%\emph{statements}, \emph{expressions}, \emph{post-expressions},
%\emph{primary} and \emph{suffixes} expressions respectively. A primary
%\java~expression can be seen as the first expression in a
%sequence of \java~expressions joined by the symbol \texttt{``.''}. All 
%of the other expressions make up the suffix of the original
%expression.
%
%expresses that if the set of assignable variable locations of certain
%method is represented by locations $Y$, then this method may modify the set
%of expressions \textsc{Y}, and in its method body occur expressions or
%declarations such as \textup{f}$_1$\textup{(e}$_1$\textup{,
%f}$_2$\textup{(e}$_2$\textup{,}$\cdots$
%\textup{(f}$_n$\textup{(e}$_n$\textup{))))}, then their correctness
%will be established in terms of the correctness of each subexpression
%\textup{e}$_i$ \emph{w.r.t} \textsc{Y}. 






\subsection{Rules concerning methods}
\label{sub-sec-rul-con-met}
%We have defined certain syntactical rules for every \java~construct,
%stating which variables may be modified. Our rules check for
%all \java~constructs that the expressions modified by instructions
%inside all method bodies are according to
%their assignable specification. We present the derivation rules for
%the most important \java~constructs. The whole set of rules can be found
%in~\cite{CatanoMasterThesis01}.

\textsf{Meth-Dec} is the rule corresponding to a method declaration
\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{)} that has
specified may modify the set of variable locations $Y$. This rule
states that for this method declaration, it is enough to
check every instruction in its method body
(\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{).body}) with respect
to \textsc{Y}, the set of parameters and the local variables to the
method. As can be seen, this rule essentially formalizes
Definition~\ref{def-mod}. 
%%%%%
\[
\begin{tabular}{ll}
\textsf{(Meth-Dec)}\,\,\,&
\begin{prooftree} 
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{).body}\
\overrightarrow{\textsf{mod}}\ 
Y\cup \{\overrightarrow{\texttt{o}}\}\cup \{
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{).locvars}\} 
\justifies
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{)}\ \textsf{mod}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%

A method invocation
$e\texttt{.m(}\overrightarrow{\texttt{q}}\texttt{)}$,
must fulfill the assignable specification corresponding to its
method declaration $\texttt{m(}\overrightarrow{\texttt{o}}\texttt{)}$
previous replacing$:$ $(i)$~\texttt{this} by $e$ and
$(ii)$~$\overrightarrow{\texttt{o}}$ by
$\overrightarrow{\texttt{q}}$. Additionally, the actual parameters
$\overrightarrow{\texttt{q}}$ must be checked for
side-effects. It similar to the expression $e$ (see rule
\textsf{Meth-Inv}). As can be seen this rules use \textsf{modEXP}
and \textsf{modPE} rules. \textsf{modEXP} stands for expressions and
\textsf{modPE} for post-fix expressions. A \java~post-fix
expression represents a sort of \emph{primary} expressions linked by
``.''. A typical primary \java~expression is a \java~identifier.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Meth-Inv)}\,\, &
\begin{prooftree}
\sem{e\texttt{.m(}\overrightarrow{\texttt{o}})\texttt{.modifies}}
[\overrightarrow{\texttt{o}}\backslash \overrightarrow{\texttt{q}},
\texttt{this}\backslash e]\sqsubseteq Y,\
e\ \textsf{modPE}\ Y,\
\overrightarrow{\texttt{q}}\ \overrightarrow{\textsf{modEXP}}\ Y
\justifies
e\texttt{.m(}\overrightarrow{\texttt{q}}\texttt{)}\ \textsf{modPE}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%





\subsection{Rules concerning primary suffix and primary expressions}
\label{sub-sec-rul-con-pri-suf-and-pri-exp}
\java~\emph{post-fix} expressions can be seen as set of \emph{suffix}
expressions linked by ``.''. The first expression of which must be a
\emph{primary} expression. Typical primary expressions correspond to
identifiers, constants, the special \java~keywords \texttt{this},
\texttt{static} and \texttt{super}, method invocations (as presented
before) and \emph{new} expressions. 

In the case of \emph{new} expressions (see rule \textsf{New-Exp}), the
expressions passed as parameters must be checked for side-effects by
using \textsf{modEXP} rules. The other cases of primary expression do
not require an additional analyze.
%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(New-Exp)}\,\, & 
\begin{prooftree}
\overrightarrow{e}\ \overrightarrow{\textsf{modEXP}}\ Y
\justifies
\texttt{new T(}\overrightarrow{e}\texttt{)}\ \textsf{modPRM}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%










\subsection{Rules concerning assignments}
\label{sub-sec-rul-con-ass}
When an assignment $e_1\oplus e_2$ occurs inside a method body, we
must check that
$e_1$ belongs to set of locations the method may modify
(\textup{e}$_1\underline{\in}$\ \textsc{Y}), since $e_1$ is
target of an assignment. Additionally, and according to the
\java~syntax, we must check $e_1$ and $e_2$ by
using the \textsf{modPE} and \textsf{modEXP} rules respectively. This
is showed by the rule \textsf{(Assg)}.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Assg)}\,\,\, & 
\begin{prooftree}
e_1\underline{\in}Y,\ \ e_1\ \textsf{modPE}\ Y,\ \ e_2\ \textsf{modEXP}\ Y
\justifies
e_1\oplus \textup{e}_2\ \textsf{modEXP}\ Y
\using
\oplus \in \{\texttt{=,+=,-=,*=,/=}\}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%
An assignment can also be occurred in the declaration of a local
variable. Suppose we have the declaration of certain variable
\texttt{x} which is initialized with the value corresponding to
certain expression $e$. The location
corresponding a this variable must belong to the set $Y$ of possible
assignable locations. Rule \textsf{Var-Decl-Assg} states this
fact. Additionally, one must check the expression $e$ by using
expressions rules.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Var-Decl-Assg)}\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{x}\underline{\in}Y,\ \ e\ \textsf{modEXP}\ Y
\justifies
\texttt{T x =}\ e\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%

\java~instructions can also be represented by pre- and
\emph{post-expressions}. A post-expression can be seen as \emph{in
place} assignment. Rule \textsf{(Post-Plus)} presents the case for
post-increment expressions. This rule states that the expression $e$,
which is the target
of an assignment, has to belong to set of expressions $Y$ which may
modified by the method. Additionally, $e$ must be checked for
side-effects.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Post-Plus)}\,\, &
\begin{prooftree}
e\underline{\in}Y,\ \ e\ \textsf{modPE}\ Y
\justifies
e\texttt{++}\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%






\subsection{Rules concerning \java~operators}
\label{sub-sec-rul-con-ope}
The rule \textsf{Binary} is applicable
to arithmetic, relational and logic operators. This rule
does not take into account any consideration about membership of
expressions $e_i$ to $Y$, since no expression
is directly modified by these
operators. This analysis also works for \java~operators as
\textsf{unary}, \texttt{instanceof}, \texttt{()} (\emph{casting}) and
$?$, as presented by rules \textsf{Unary}, \textsf{Instance},
\textsf{Cast} and \textsf{Conditional}.

%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Binary)} & 
\begin{prooftree} 
e_1\ \textsf{modEXP}\ Y,\ \ e_2\ \textsf{modEXP}\ Y
\justifies
e_1\oplus e_2\ \textsf{modEXP}\ Y
\using
\oplus \in \{
	\begin{array}{l}
		\texttt{<,<=,>,>=,==,!=,||}	\\
		\texttt{\&\&,+,-,*,/,\,\&,\^\ ,|}
	\end{array}
	\}
\end{prooftree}
\\[3.0ex] 
\textsf{(Unary)} & 
\begin{prooftree} 
e\ \textsf{modEXP}\ Y
\justifies
\oplus \ e\ \textsf{modEXP}\ Y
\using
\oplus \in \{\texttt{+,-,$\sim$,!}\}
\end{prooftree}
\\[3.0ex] 
\textsf{(Instance)} & 
\begin{prooftree} 
e\ \textsf{modEXP}\ Y
\justifies
e\ \texttt{instanceof C}\ \textsf{modEXP}\ Y
\end{prooftree}
\\[3.0ex] 
\textsf{(Cast)} & 
\begin{prooftree}
e\ \textsf{modEXP}\ Y
\justifies
\texttt{(T)}e\ \textsf{modEXP}\ Y
\end{prooftree}
\\[3.0ex] 
\textsf{(Conditional)}\,\, & 
\begin{prooftree} 
e_1\ \textsf{modEXP}\ Y,\ \ e_2\ \textsf{modEXP}\ Y,\ \ e_3\
\textsf{modEXP}\ Y
\justifies
e_1\texttt{?}e_2\texttt{:}e_3\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%






\subsection{Rules concerning statements}
\label{sub-sec-rul-con-sta}
Typical \java~statements are
\texttt{if(}c\texttt{)\{$\overrightarrow{s}$\texttt{\}}},
\texttt{if(}c\texttt{)\{$\overrightarrow{s}$\texttt{\}}else\{$\overrightarrow{t}$\}},
\texttt{while(c)\{$\overrightarrow{s}$\}}. For the first case, for
instance, the guard $c$ must be checked using
\textsf{modEXP} rules since a guard
corresponds to an expression. The set of instructions occurring in its
body $\overrightarrow{s}$ must be checked using the most general rules
\textsf{mod}. This is showed by the rule \textsf{(If-Then)}. For the
others \java~statements a similar analysis can be done.
%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(If-Then)}\,\, & 
\begin{prooftree}
c\ \textsf{modEXP}\ Y,\ \ \overrightarrow{s}\ \overrightarrow{\textsf{mod}}\ Y
\justifies
\texttt{if(}c\texttt{)\{}\overrightarrow{s}\ \texttt{\}}\ 
\textsf{modSTM}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%






\subsection{Transition rules}
\label{sub-sec-tra-rul}
In addition to define rules for each \java~construct, we need also
certain \emph{transition} rules which allow us to pass from more
general rules to more particular ones, depending on the kind of the
instruction. So, for example, we need transition rules from the most
general case to expressions statements (\textsf{Mod-To-Exp} and
\textsf{Mod-To-Stm}), from expressions to post-fix expressions
(\textsf{Exp-To-Pe}), and from post-fix expressions to primary suffix
and primary expressions.
%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Mod-To-Exp)}\,\, & 
\begin{prooftree}
e\ \textsf{modEXP}\ Y
\justifies
e\ \textsf{mod}\ Y
\using
e\in Expression
\end{prooftree}
\\[3.0ex]
\textsf{(Mod-To-Stm)} & 
\begin{prooftree}
e\ \textsf{modSTM}\ Y
\justifies
e\ \textsf{mod}\ Y
\using
e\in Statement
\end{prooftree}
\\[3.0ex]
\textsf{(Exp-To-Pe)}\,\, & 
\begin{prooftree}
e\ \textsf{modPE}\ Y
\justifies
e\ \textsf{modEXP}\ Y
\using
e\in Post\!\!-\! expression
\end{prooftree}
\\[3.0ex]
\textsf{(Pe-To-Ps)} &
\begin{prooftree}
e_1\ \textsf{modPE}\ Y,\ e_2\ \textsf{modPS}\ Y
\justifies
e_1\ \texttt{.}\ e_2\ \textsf{modPE}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(Pe-to-Prm)} &
\begin{prooftree}
e\ \textsf{modPRM}\ Y
\justifies
e\ \textsf{modPE}\ Y
\using
e\in \ \textsf{Primary}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%




\subsection{The relation of membership $\underline{\in}$}
\label{sub-sec-the-rel-mem}
Another important aspect that must be analyzed is
the different constructs that can appear in assignable
specifications. According to the syntax of the assignable clause as
presented by Figure~\ref{fig-syn-mod-spe},
\texttt{$\backslash$fields\_of} and \texttt{$\backslash$reach}
constructs can occur inside of such assignable specifications, the
latter only occurring inside the former. Hence, when establishing
membership conditions $e\underline\in Y$, we need to define suitable
rules taking into account the fact that these constructs can occur
inside $Y$.

Typically, if none of these constructs occur in the assignable clause
we fall on the standard definition of membership (see rules rules
\textsf{In-Var},\textsf{In-Arr}, \textsf{In-Exp} and
\textsf{In-Exp-Arr}).
%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(In-Var)} &
\begin{prooftree}
\texttt{x}\in \textsc{Y}
\justifies
\texttt{x}\underline{\in}Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Arr)} &
\begin{prooftree}
\texttt{a[}e\texttt{]}\in Y
\justifies
\texttt{a[}e\texttt{]}\underline{\in}Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Exp)} &
\begin{prooftree}
e\texttt{.x}\in Y
\justifies
e\texttt{.x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Exp-Arr)}\,\, &
\begin{prooftree}
e\texttt{.a[}e_1\texttt{]}\in Y
\justifies
e\texttt{.a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%

Moreover, when we are checking simple array membership conditions as
\texttt{a[}$e$\texttt{]$\underline{\in} Y$}, it is
enough to find a \jml~construct in $Y$ specifying that the
corresponding method may modify any element of \texttt{a}
(\textsf{Times-Arr}) or a certain interval where the value of $e$ is
found (rule \textsf{Interv-Arr}).
%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(Times-Arr)}\,\, &
\begin{prooftree}
\texttt{a[}*\texttt{]}\in Y
\justifies
\texttt{a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(Interv-Arr)}\,\, & 
\begin{prooftree}
\texttt{a[}i..j\texttt{]}\in Y,\ i\leq e\leq j
\justifies
\texttt{a[}e\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%
If these rules do not apply, we
have to consider some cases according to the shape of $e$. If
$e$ has shape $e_1\texttt{.}e_2$ and $e_2$ is not an array expression,
it will be enough to have \texttt{$\backslash$fields\_of($e_1$)}
occurring in $Y$ to establish the original condition of membership
(rule \textsf{In-Fld-Exp-Var}). Otherwise, if $e_2$ is an array
expression \texttt{a[$e_3$]}, it will be enough to have
\texttt{$\backslash$fields\_of($e_1$.a)} occurring in $Y$ (see rule
\textsf{In-Fld-Exp-Arr}). We have similar rules when $e$ is an
expression not linked by ``.'' (see rules \textsf{In-Fld-Var} and
\textsf{In-Fld-Arr}).
%%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(In-Fld-Exp-Var)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(}e\texttt{)}\in Y
\justifies
e\texttt{.x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Fld-Exp-Arr)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(}e\texttt{.a)}\in Y
\justifies
e\texttt{.a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Fld-Var)} &
\begin{prooftree}
\backslash \texttt{fields\_of(this)}\in Y
\justifies
\texttt{x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Fld-Arr)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(a)}\in Y
\justifies
\texttt{a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%

Furthermore, \texttt{$\backslash$reach} expressions can occur in
assignable clauses. So, if an expression such as
\texttt{$\backslash$fields\_of($\backslash$reach($e_1$))} occurs in
$Y$ it is sufficient having $e$ belonging to set expressions reachable
from $e_1$ for establish the condition \texttt{$e$.x$\underline\in
Y$}. This situation is presented by the rule
\textsf{In-Reach-Exp}. Something similar happens when \texttt{x} is an
array expression. This is presented by rules
\textsf{In-Reach-Exp-Arr}. The rules \textsf{In-Reach-Var} and
\textsf{In-Reach-Arr} present the cases when we intend to establish
membership conditions for expressions not linked by ``.''.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(In-Reach-Var)} &
\begin{prooftree}
\backslash
\texttt{fields\_of(}\backslash\texttt{reach(}e\texttt{))}\in Y,\ \
\texttt{this}\in \backslash \texttt{reach(}e\texttt{)} 
\justifies
\texttt{x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Reach-Arr)} &
\begin{prooftree}
\backslash \texttt{fields}\_\texttt{of(}\backslash
\texttt{reach(}e_1\texttt{))}\in Y,\ \ \texttt{a}\in \backslash
\texttt{reach(}e\texttt{)} 
\justifies
\texttt{a[}e\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Reach-Exp)} &
\begin{prooftree}
\backslash \texttt{fields\_of(}\backslash
\texttt{reach(}e_1\texttt{))}\in Y,\ \ e\in \backslash
\texttt{reach(}e_1\texttt{)}
\justifies
e\texttt{.x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(In-Reach-Exp-Arr)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(}\backslash
\texttt{reach(}e\texttt{))}\in Y,\ \ e_2\texttt{.a}\in \backslash
\texttt{reach(}e\texttt{)}
\justifies
e_2\texttt{.a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%
HERE I HAVE TO PRESENT AN DERIVATION EXAMPLE.
%%%%%%%%%%%






\section{A checker for assignable clauses}
\label{sec-che-for-ass-cla}
We present some implementation issues concerning \modtool$:$ a
modifiable checker implementing the approach and rules presented in
Section~\ref{sec-syn-met-che-ass-cla}.

We have reused the syntactical analyzer of \jml~for recovering the
structure of programs we are checking. This parser returns an
\emph{Abstract syntax tree} as an \texttt{AST} (see
Section~\ref{abo-jml-cla-use}). We use this Abstract syntax tree
for$:$ $(i)$~figuring out the \emph{context} of all method
declarations in the program and $(ii)$~recovering the structure of the
program for applying our checking rules.

We have implemented our specification rules as static methods
parameterized by the context under which the respective instruction is
found.

Section~\ref{abo-jml-cla-use} gives a general overview of the class
for handling Abstract syntax trees coming with
\jml. Section~\ref{sub-sec-cla-ast-con} summarizes the implementation
of the class \texttt{ASTContext} which is in charge of figuring out
context of method declarations. Section~\ref{sub-sec-the-cla-ass}
presents the class \texttt{Assignable}, which implement our
syntactical rules. Finally, Section ~\ref{sub-sec-usi-the-too}
summarizes our experience using the tool \modtool.




\subsection{Representing Abstract syntax trees with \jml}
\label{abo-jml-cla-use}

\jml~ships with several classes for representing and handling abstract
syntax trees. The class \texttt{AST} allow one to represent piece of
code as the sequence of a node a \emph{sibling}. The former
represented as a tuple of an \texttt{int} and a \texttt{String}, and
the latter of type \texttt{AST}.

\jml~also ships the utility \texttt{ASTFactory} with operation
covering create and duplicate trees. Finally, the distribution of
\jml~comes with the class \texttt{ASTArray} for representing an array
of trees having type \texttt{AST}.





\subsection{The class \texttt{ASTContext}}
\label{sub-sec-cla-ast-con}
The class \texttt{ASTContext} represent the context of any method
declaration. A method context consists of the representation of its
assignable locations, its parameters and its local variables. This
representation is based on the definition~\ref{def-mod}. Additionally
we provide representation for the package and class where the method
occurs and the class that it extends (if any).

These contexts, are passed as parameter to the methods of the class
\texttt{Assignable}, which implements the rules presented in
Section~\ref{sec-che-for-ass-cla}.




\subsection{The class \texttt{Assignable}}
\label{sub-sec-the-cla-ass}

The class \texttt{Assignable} implements the assignable rules like
static method. As an example, in the case of \textsf{modEXP} rules
(see below), one must pass to it the expression \texttt{e} currently
analyzed, the context \texttt{cxt} of the method where the expression
\texttt{e} occurs and the contexts \texttt{cxts} of all known classes.

When the expression \texttt{e} is, for instance, an assignment
$e_1=e_2$ check that $e_1$ belongs to set of assignable expressions of
the method (\texttt{\_in\_PRIME($\cdots$)}) and then it applies the
\textsf{modPE} rules on $e_1$ (\texttt{\_modPE($\cdots$)}) and the
\textsf{modEXP} rules on $e_2$ (\texttt{\_modEXP($\cdots$)}).
\begin{alltt}
public static boolean _modEXP(AST e, ASTContext cxt, Vector cxts)\verb!{!	
  boolean tempRes;	
  switch(e.getType())\verb!{!	
    case JavaTokenTypes.ASSIGN:{\it // =}
      tempRes = _in_PRIME(e.getFirstChild(),cxt,cxts) &&
       _modPE(e.getFirstChild(),currentCxt,cxts) &&
       _modEXP(e.getFirstChild().getNextSibling(),cxt,cxts);
      return tempRes;
    \vdots 
  \verb!}!
\verb!}!
\end{alltt}




\subsection{Experiences using \modtool}
\label{sub-sec-usi-the-too}






\section{Conclusion and future work}
\label{sec-con-and-fut-wor}
We have presented a method for checking \emph{side-effects}
freeness. We are defined syntactical rules for each \java~construct
checking that they only assign local declared as
\emph{assignable}. Hence, our method does not concern with
modification but assignment. Therefore in a context with aliasing, our
method can miss the variable modified. Several solutions have been
proposed for solving this problem. In~\cite{Leino97} a solution with
\emph{Data groups} is proposed, which enables modular checking.

Our rules, and the implementation we are done, allow one to check for
side-efects efficiently, as no too much is spend in it. 

BLA-BLA-BLA

\bibliographystyle{alpha}
\bibliography{../specification}

\end{document}
