\documentclass[a4paper]{llncs}

\title{The \modif~clause: semantics, verification and application}

\author{
  N\'estor Cata\~no and Marieke Huisman  \\
  \institute{
       \inria~Sophia-Antipolis, France \\
       \lemme~Project
  } 
  \email{\{Nestor.Catano, Marieke.Huisman\}@sophia.inria.fr}
}

\newcommand{\lemme}{\textsc{Lemme}}
\newcommand{\inria}{\textsc{Inria}}
\newcommand{\jml}{\textsc{Jml}}
\newcommand{\escj}{\textsc{Esc/Java}}
\newcommand{\jass}{\textsc{Jass}}
\newcommand{\jcontract}{\textsc{JContract}}
\newcommand{\loopp}{\textsc{Loop}}
\newcommand{\java}{\textsc{Java}}
\newcommand{\gplus}{\textsc{GemPlus}}
\newcommand{\eiff}{\textsc{Eiffel}}
\newcommand{\ctl}{\textsc{Ctl}}
\newcommand{\pltl}{\textsc{Pltl}}
\newcommand{\csrc}{\textsc{Compaq Src}}

\newcommand{\modtool}{\texttt{mod$:$tool}}


\newcommand{\modif}{\textit{modifiable}}
\newcommand{\modifies}{\textit{modifies}}
\newcommand{\sem}[1]{\ensuremath{\mbox{[\![} {#1} \mbox{]\!]}\/}}

\newtheorem {df}{Definition}

\usepackage{lscape} % it's needed to turn a page
\usepackage{amsmath} % it is needed by the \sem command
\usepackage{alltt}
\input{prooftree} %showing demonstration

\begin{document}
\fussy
\maketitle
\pagestyle{plain}

\begin{abstract}
not yet
%We have worked in \jml, which is a specification language
%tailored to Java. \jml~allows us to specify the functional behavior
%of methods$:$ preconditions and postconditions, and apart from that,
%class invariants. Unfortunately, using only the functional
%specification of a
%method is not enough to reason about arbitrary method
%invocations. Therefore, the so-called \modif~clauses are
%introduced. By asserting a
%method with a \modif~clause, it is stated this method may only modify
%the set of expressions represented by its \modif~clause. There are
%several projects studying \modif~clauses such as \jml~and \escj~(a
%subset of \jml). The \jml~specification language gives a definition
%for the \modif~clause, but when the \jml~tool is run on an asserted
%\java~program, it does not do any checking on its \modif~clause
%specification. In the \loopp~project the
%implementation of some \jml~assertions pragmas are defined, including
%the \modif~ one. This implementation is based on a underlying memory
%model
%and the logic representation of \java~and the \jml~pragmas. This
%implementation is not yet an easy and fast method for its verification
%. This paper presents a first solution to achieve this in a context
%without \textit{aliasing}. For this specification we have made
%an implementation, which extends the functionality of the
%\jml~parser. Our approach presents some advantages over the
%\loopp~project approach, namely$:$ $(i)$~it is faster, and $(ii)$~the
%verification carried out is closer to the specification
%language. Additionally, an electronic banking case study has been used
%to demonstrate the usability of our approach~\cite{CH02}.
\end{abstract}

\section{Introduction}
\label{sec-intro}

\paragraph{\bf Background.}
Some decades ago, the \emph{formal methods} were considered as a merely
theoretical issue in computer science, not suitable for real
problems$:$ \emph{complicated} notations taken from the logic and
the lack of tools supporting formal methods could not compete with the
tools and methods used in industry for software development. Recently, 
this has been changing. There are several reasons for this
change. Firstly, the specification languages are now closer to
programming languages than ever before and the techniques used are
more suitable to the actual programming paradigms (object oriented
and distributed programming). Secondly, industry has started to feel
the need for certified software. An example$:$ during
$1995$\cite{Borger99programmer},
\textsc{Intel} found a problem with its microprocessors
\textsc{Pentium}. This company was forced to replace around two
million processors. Thus, it realized that the costs of formal
verification would have been much lower than the costs required to
fix this bug.

There are two approaches for verification of software systems$:$
\textit{model-checking} and\textit{theorem proving}.
Model-checking is based on constructing a finite model of a
problem and exhaustively checking the satisfaction of certain
properties. Model-checking is
a strong technique, as it is \emph{decidable}, but it presents some
limitations$:$ $(i)$~it can validate a
model of a certain system but not the system itself, and
$(ii)$~verification even for simple systems might need huge amounts
of space and time. 

Theoretically, interactive theorem proving techniques are able to
solve any problem proposed in practice, but it presents some
disadvantages$:$ $(i)$~it is \emph{undecidable}, $(ii)$~the tools are
only capable of assisting an engineer in the process of constructing a
proof, and $(iii)$~it requires expressing and understanding the
semantics underlying the
programming language in the logic of the theorem prover, in order to
do program verification. 
 %Testing checks whether a program produces
%correct output on certain input. This technique is important for
%checking some properties before applying a formal technique. A
%disadvantage of this approach is that one spends too much of time in the
%process of constructing all possible testing cases. Moreover,
%sometimes it is not possible to check all possible
%inputs. 
Recently, several approaches have been
proposed to overcome these kind of problems and although they can not
actually replace formal verification techniques, they constitute
important alternatives for checking the behavior of software
systems. \emph{Run-time
checking} is a kind of extended checking where, in addition to checking
the input-output behavior, it is checked whether certain specific
conditions are
satisfied at particular points in the program. For checking these
conditions, the original program is converted into another
one,
which can be then executed. If this execution raises an exception,
this indicates that the original program does not fulfill the
expected conditions.

The \emph{static checking} techniques check the behavior of programs
from its source code. This technique can be complemented with
complemented with a automatic theorem prover which automatically can
some specific problems. It is expected this checking is efficient in
time.

When using static and run-time checking techniques is expected to
state some specifications in which we are interested to check. These
specifications allow to state the functional behavior of methods as
pre- and postcondtions, besides class invariants. These specifications
can be provided to the checking tools as part of the source and
written and some specific language. 

Currently, several specific specification languages have been proposed
for \java. \jml is a language developed at the Iowa University and
doing run-time checking. For constructing predicates, in addition to
the java boolean operators, 
\jml~ counts on several logical operators. Additionally in \jml is
possible to use methods invocation as part of the predicates as long
as those do not have \emph{side effects}.

It relies on several specific constructs whifor
expressing the \emph{normal behavior} of methods (when no exception is 
thrown) an 

~such as
\jml~\cite{LeavensBR00}, \jcontract~\cite{JContractUrl},
\jass~\cite{JassUrl} and \escj~\cite{LeinoNS00} (a subset of
\jml~\cite{EscJmlDiff})



%For expressing these conditions, some specification languages are
%commonly used and they are typically \emph{asserted} as comments in
%the
program source code. 

%The annotation language for \eiff~is the first
%example of such a specification language, following the \emph{design
%by contract} approach~\cite{Meyer97}. 


. Usually, these specifications serve to state
the functional behavior of the methods (typically as preconditions and
postconditions) and also class invariants. However, the
functional behavior of the methods is often not enough to reason about
arbitrary method invocations. It is thus necessary to specify the
\emph{changeable} behavior of methods. By way of example, ...

The \jass~tool comes with the construct \textit{changeonly}, which
provides only a basic way to specify what expressions a method intends
to change, typically as variables joined by ``.''. The
\escj~specification
language provides an assertion construct,
\modifies, which specifies the set of expressions which a method
\emph{may} modify, but its tool does not check these kind of
specifications. Therefore, some verification problems occur.






\paragraph{\bf This paper.}We propose a static checker for
\modif~clauses in \java~programs with \jml~assertions\footnote{For
reasons of compatibility between \jml~and \escj~, we will 
use indistinctly the words \emph{modifiable} and \emph{modifies}},
based on a syntactical analysis of the source program. This
checker is neither sound nor complete (following the \escj~approach),
but is useful
for detecting some typical specification errors such as
forgetting to mention some variable
as \modif~when a method implementation actually may modify it, or
declaring a method without side-effects when it modifies some
expression. We can not always detect the most subtle errors because they 
require a detailed analysis, but by using our approach the most
simple errors can be detected quickly. We have defined certain
syntactical rules for every \java~construct, stating which
variables may be modified. Moreover, we have implemented
this approach by extending the \jml~parser and embedding these
conditions as \java~code. The viability of our approach is
shown by presenting some gaps found in the process of expressing the
\emph{changeable} behavior of a realistic case study~\cite{CatanoH02a} and
checking these specifications with our tool.


The rest of this paper is organized as follows$:$
Section~\ref{sec-esc-prg} presents briefly the specification language
\escj~together with its more important assertion
constructs. Section~\ref{sec-sem-mod-cla} shows the problems which
arise when the specifications of \modif~clauses are not
checked. Section~\ref{sec-giv-sin-def}
presents our approach for checking \modif~clauses and the definition
of the respective syntactical rules. Section~\ref{sec-imp-iss}
presents a modifiable checker (~\modtool) implementing these
rules. Additionally, we discuss some problems found using our tool on a
realistic case study~\cite{CatanoH02a}.
Finally, Section~\ref{sec-con}
gives conclusions and presents future work. 






\section{Static checking of \java~programs with \escj}
\label{sec-esc-prg}
\escj~is a static checker for \java~programs developed
at \csrc~\cite{ESCJavaUrl}, enabling a user to find common programming
errors of \java~programs. It counts on a dedicated theorem prover for
finding problems such as \emph{array index bounds},
\emph{nil deference} and \emph{synchronization} in multi-thread
programs. The basic idea is that
a user specifies the behavior of a class and its methods, by
using the specification language of \escj. This
behavior can be expressed as \textit{preconditions},
\textit{postconditions} and \textit{class invariants}. The \escj~tool
checks whether the implementation satisfies the given
specification and it issues a warning 
message if it can not establish this. Such a
warning does not necessarily mean that the program is
wrong, since the \escj~approach is neither sound nor
complete. 

\escj~is enriched with several
specification-specific pragmas. Below, we present
the main \escj~pragmas together with an example of their
use. Their full description can be found in~\cite{LeinoNS00}. 




\paragraph{\bf Pragmas for specifying methods} 
\begin{itemize}
\item{\texttt{requires P}.} 
This pragma specifies a precondition {\tt P}. 
When \escj~checks the body of a
method, it assumes that \texttt{P} holds initially and when checking
a method call, \escj~will issue a warning if 
it can not establish that \texttt{P} holds at the call point. 
 
\item{\texttt{ensures Q}.} 
This pragma specifies a postcondition \texttt{Q}. This postcondition
is checked against the body of method and assumed for any method
invocation if the method terminates normally (without throwing an
exception).
 
\item{\texttt{exsures (E) R}.}
This pragma specifies an exceptional condition. This condition is 
supposed to hold if the method finishes abruptly and if
the exception \texttt{e} that is thrown is a subclass of \texttt{E}. 
 
\item{\texttt{modifies L}.} 
This pragma specifies that the method \emph{may} only modify any of 
the state components listed in \texttt{L}, the formal parameters of 
the method and the variables local to the method. 
\end{itemize}
 
 
 
\paragraph{\bf Specification expressions} 
\begin{itemize} 
\item{\texttt{==>}} is the logical implication. So, \texttt{P 
==> Q} is true if and only if \texttt{P} is false or \texttt{Q} is 
true, where \texttt{P} and \texttt{Q} are specification expressions of  
\texttt{boolean} type. Furthermore, \texttt{<==>} represents the 
equivalence relation and \texttt{<=!=>} specifies non-equivalence. 
 
\item {($\backslash$\texttt{forall T V; E)} and 
($\backslash$\texttt{exists T V; E})} are quantifier expressions (of 
type \texttt{boolean}).  The first expression denotes that \texttt{E}
is true
for all substitutions of values of type \texttt{T} for the bound 
variable \texttt{V}. The second one denotes that \texttt{E} is true 
for a substitution of a value of type \texttt{T} for the bound 
variable \texttt{V}. 
 
\item{\texttt{$\backslash$old(E)}} is used within a postcondition,
where it denotes the value of the expression \texttt{E} in the
pre-state of the method.
 
\item {\tt$\backslash$result} represents the value returned by 
a non-void method. It can only be used within an
\texttt{ensures} clause.
\end{itemize}
Figure~\ref{fig-add-cur} shows a typical annotation example using 
\escj. This example was taken from the formal specification of an
\emph{electronic purse} presented in~\cite{CatanoH02a}\footnote{The overall
specifications of this application can be taken
from~\cite{CatanoH01URL}}. The \texttt{addCurrency} method belongs
to a class \texttt{Currencies}. This class stores all currencies 
supported by the purse application. The method 
\texttt{addCurrency} adds a new currency to the list of valid 
currencies. This list is represented by the 
array \texttt{data}. The \texttt{modifies} clause declared in the 
method's header specifies that 
this method \emph{may} modify \texttt{nbData} and 
\texttt{data} in the position \texttt{nbData}\footnote{More precisely,
it specifies that the method only may modify these instance variables
and the local variables and formal parameters of the method.}. The
postcondition of the method \texttt{addCurrency} (written as 
\texttt{ensures} clauses) expresses that if \texttt{nbData} has not 
yet reached the threshold value \texttt{MAX$\_$DATA}, \texttt{nbData} 
will increase its value by one and the value of the formal parameter 
\texttt{cur} will be assigned to \texttt{data[\(\backslash\)old(nbData)]}.  
Inside the postcondition, the expression 
\texttt{$\backslash$old(nbData)} refers to the value of 
\texttt{nbData} before the method invocation. 
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{verbatim}
/*@
  modifies nbData, data[nbData];
  ensures (\old(nbData) < MAX_DATA) ?
      (nbData == \old(nbData) + 1 && data[\old(nbData)] == cur) :
      (nbData == \old(nbData));
*/
void addCurrency(byte cur){
   if(nbData < MAX_DATA){data[nbData] = cur; nbData++;}
}
\end{verbatim}
\caption{Example of \escj~specification} 
\label{fig-add-cur} 
\rule{\linewidth}{0.25mm} 
\end{figure} 


\section{On the use of \modif~clauses}
\label{sec-sem-mod-cla}
The checking of \modif~clauses is especially important for rejecting
incorrect specifications. Figure~\ref{fig-mod-spe} presents
a typical example, where \escj~accepts an incorrect specification. The
specification of the method
\texttt{m()} states that after a method invocation the length of the
instance variable \texttt{arr} will be greater or equal than $4$. This
property holds after the assignment in the
method body, but to establish this property holds after \texttt{m()},
it is necessary to check that the method \texttt{n()} will not modify the
instance variable \texttt{arr}. What \escj~does is to look at the
modifiable specification of the method \texttt{n()}, and from that
establish
if this method modifies this instance variable. When a method is
asserted without any \modif~clause, \escj~takes by default a
\texttt{modifies $\backslash$nothing} specification, but it {\bf does
not} check it. Therefore, in regards to this example, \escj~assumes
the method \texttt{n()} does not modify any variable, \emph{i.e.}, it
assumes \texttt{n()} is a method without side-effects. Consequently,
when using this specification in the method \texttt{m()},
\escj~establishes that after a call to \texttt{m()}, its
postcondition will hold. Hence, it does not reject the specification of
\texttt{m()}.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{verbatim}
public class C{
  int[] arr;
  /*@ modifies arr.length
      ensures arr.length >= 4; */
  public void m(){
    arr = new int[5]; n();
  }

  public void n(){arr = new int [3];}
}
\end{verbatim}
\caption{Modifiable specifications} 
\label{fig-mod-spe} 
\rule{\linewidth}{0.25mm} 
\end{figure} 
This problem is caused because \escj~does not check any \modif~clause,
even though the specification of the \escj~language claims to do so. We
have specified and implemented a static checker for \modif~clauses,
which can detect these kind of inconsistencies in \java~asserted
programs. 

Below we present our method to check \modif~clauses. In
Section~\ref{sec-imp-iss}, we discuss how we implemented this method
in our \modtool~and we show
some problems found in the formal specification of an
\emph{electronic purse}, by using it.






\section{A syntactical method to check \modif~clauses}
\label{sec-giv-sin-def}
We present a set of syntactical rules which check the correct
specification of \modif~clauses in \java~asserted programs. These
rules have been defined taking into account both of the \jml~grammar
specification and the definition of \modif~clauses presented
in~\cite{LeavensBR00}.




\subsection{Modifiable behavior}
Below we present the definition of the specification of the modifiable
behavior of a method.
\begin{df}[clause {\bf \it modifiable}]
\label{def-mod}
A method may modify an expression provided that$:$ 
\begin{itemize}
\item This expression is mentioned in the \modif~clause
\item The expression is a local variable to the method or in a
parameter
\end{itemize}
\end{df}
This definition makes no dependency analysis as introduced by
\emph{model} pragmas (see~\cite{LeavensBR00}). Apart from that, from this
definition it can be
gathered that a method can not modify fields of any parameter.

In \jml, the modifiable behavior of a method can be specified with
aid of clauses \modif, as presented for \escj~in
Section~\ref{sec-esc-prg}. The expressions that can appear in this
clause cover any
\java~identifiers and all expressions constructed using some
\jml~specific constructs. These constructs are presented below.

\paragraph{\bf \textsc{Jml} specific constructs.}
\begin{itemize} %%%%%%
\item{\texttt{a$[$i$\dots$j$]$}}. It denotes
\texttt{a$[$i$],$a$[$i$+1],\ \dots$ a$[$j$]$}.
\item{\texttt{x$[*]$}}. It denotes \texttt{x$[i]$} for all
\texttt{i}, such as $0\leq$\texttt{i}$\le$\texttt{sizeOf(x)}.
\item{\texttt{$\backslash$fields\_of(x)}}. It denotes
\texttt{x[*]} if \texttt{x} is an array, otherwise it denotes the set
of fields belonging to \texttt{x}.
\item{\texttt{$\backslash$reach(x)}}. It denotes the
minimal set containing \texttt{x}, the fields of \texttt{x} and all
objects reachable from the fields of \texttt{x}.
\end{itemize} %%%%%%
\begin{df}[mod] %%%%%
\label{df-mod}
\textup{S}\ \textit{mod}\ \textsc{Y} $=$ $\forall x \in LC.
x\not\in$ \textsc{Y}$\ \Rightarrow Pre(x) = Post(x)$ \\
where $LC$ is a global set of expressions, $Pre(x)$
refers to the state of $x$ before executing $S$,
$Post(x)$ refers to the state of $x$ after executing
$S$ and \textsc{Y} is the set of variables that can be mentioned
inside a \modif~clause).
\end{df} %%%%%%
Consequently, a derivation rule such as \\
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\textup{e}_1\ \textit{mod}\ \textsc{Y}, \cdots ,\textup{e}_n\ \textit{mod}\ \textsc{Y}
\justifies
\textup{f}_1\textup{(e}_1\textup{, f}_2\textup{(e}_2\textup{,}\cdots
\textup{(f}_n\textup{(e}_n\textup{))))}\ \textit{mod}\ \textsc{Y} 
\end{prooftree}\\ \\
states that if some method \texttt{m} specifies that, it may modify the set
of expressions \textsc{Y}, and in its method body occur expressions or
declarations such as \textup{f}$_1$\textup{(e}$_1$\textup{,
f}$_2$\textup{(e}$_2$\textup{,}$\cdots$
\textup{(f}$_n$\textup{(e}$_n$\textup{))))}, then their correctness
will be established in terms of the correctness of each subexpression
\textup{e}$_i$ \emph{w.r.t} \textsc{Y}. 

When trying method
calls we have to make some special
considerations (as we will see later). For this purpose, we
present the following definitions$:$
\begin{df}[$\sqsubseteq$] %%%%%%
\label{def-subseq}
$X \sqsubseteq Y$ iff $\forall x.\ x\underline{\in}X\Rightarrow
x\underline\in Y$.
\end{df} %%%%%
\begin{df}[$\overrightarrow{mod}$] %%%%%%
\label{def-mod-lis}
$X\ \overrightarrow{mod}\ Y$ iff $\forall x.\ x\in X\Rightarrow x\ mod\ Y$
\end{df} %%%%%%
Definition~\ref{def-subseq} presents the concept of inclusion of
modifiable expressions. This definition is made in terms of a no
standard concept $\underline\in$. This concept will be defined later,
but intuitively includes the standard membership concept $\in$.
Definition~\ref{def-mod-lis} gives a more general specification of the
concept introduced by Definition~\ref{df-mod}.






\subsection{Syntactical rules}
We have defined certain syntactical rules for every \java~construct,
stating which variables may be modified. Our rules check for
all \java~constructs that the expressions modified by instructions
inside all method bodies are according to
their modifiable specification. We present the derivation rules for
the most important \java~constructs. The whole set of rules can be found
in~\cite{CatanoMasterThesis01}.

\textup{METH-DEC} is the
general rule corresponding to a method declaration
\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{)}, which has
specified it may modify the set of expressions \textsc{Y}.
%%%%%
\[
\begin{tabular}{ll}
\textsf{(METH-DEC)}\,\,\,&
\begin{prooftree} 
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{).body}\
\overrightarrow{\textsf{mod}}\ 
Y\cup \{\overrightarrow{\texttt{o}}\}\cup \{
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{).locvars}\} 
\justifies
\texttt{m(}\overrightarrow{\texttt{o}}\texttt{)}\ \textsf{mod}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%
This rule states that for this
method declaration, it is enough to
check every instruction in its method body
\texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{).body} with respect
to \textsc{Y}, the set of parameters and the local variables to the
method. As can be seen, this rule essentially rephrases
Definition~\ref{def-mod}. 

We have introduced some other \emph{mod}
constructs by exploiting the \java~syntax. These \emph{mod}
constructs cover concepts such as \textit{modSTM}, \textit{modEXP},
\textit{modPE}, \textit{modPRM} and \textit{modPS}, which redefine the
original concept \textit{mod} in terms of concepts for
\emph{statements}, \emph{expressions}, \emph{post-expressions},
\emph{primary} and \emph{suffixes} expressions respectively. A primary
\java~expression can be seen as the first expression in a
sequence of \java~expressions joined by the symbol \texttt{``.''}. All 
of the other expressions make up the suffix of the original
expression.

When an instruction is represented by a method invocation
\textup{e}\texttt{.m(}$\overrightarrow{\texttt{q}}$\texttt{)}, it 
must fulfill the \modif~clause specification corresponding to its
method declaration \texttt{m(}$\overrightarrow{\texttt{o}}$\texttt{)}
after changing the formal parameters
$\overrightarrow{\texttt{o}}$ by the real parameters
$\overrightarrow{\texttt{q}}$. Additionally, if \emph{this} appears in 
the formal parameters $\overrightarrow{\texttt{o}}$, it must be
changed by the path \textup{e}.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(METH-INV)}\,\, &
\begin{prooftree}
\sem{e\texttt{.m(}\overrightarrow{\texttt{o}})\texttt{.modifies}}
[\overrightarrow{\texttt{o}}\backslash \overrightarrow{\texttt{q}},
\texttt{this}\backslash e]\sqsubseteq Y,\
e\ \textsf{modPE}\ Y,\
\overrightarrow{\texttt{q}}\ \overrightarrow{\textsf{modEXP}}\ Y
\justifies
e\texttt{.m(}\overrightarrow{\texttt{q}}\texttt{)}\ \textsf{modPE}\ Y
\end{prooftree}
\end{tabular}
\]
 %%%%%%
This fact is shown by the rule
\textup{METH-INV}.  One must also check the formal parameters
of the method by using \emph{modEXP} rules
($\overrightarrow{\texttt{q}}\ \overrightarrow{\textit{modEXP}}$) since,
according to the \java~syntax, they can represent expressions. A similar
situation occurs with the path \textup{e}.

When an assignment \textup{e}$_1$\ $\oplus$\
\textup{e}$_2$ occurs inside of a method body, we must check that
\textup{e}$_1$ belongs to set of expressions that the method may modify
(\textup{e}$_1\underline{\in}$\ \textsc{Y}), since \textup{e}$_1$ is
target of an assignment. Additionally, and according to the
\java~syntax, we must check \textup{e}$_1$ and \textup{e}$_2$ by
using the \textit{modPE} and \textit{modEXP} rules respectively. This
fact is showed by the rule \textup{ASSG}.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(ASSG)}\,\,\, & 
\begin{prooftree}
e_1\underline{\in}Y,\ \ e_1\
\textsf{modPE}\ Y,\ \ e_2\ \textsf{modEXP}\ Y
\justifies
e_1\oplus \textup{e}_2\ \textsf{modEXP}\ Y
\using
\oplus \in \{\texttt{=,+=,-=,*=,/=}\}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%
An instruction in a method body can be represented by a local
declaration. In this way, if some variable \texttt{x} is declared and is
provided an initial value, that variable must belong to the
set \textsc{Y} of expressions modifiable by the method. Rule
\textup{VAR-DECL-ASSG} states this fact. Additionally, one must
keep checking \textup{e} by using expressions rules.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(VAR-DECL-ASSG)}\,\, & 
\begin{prooftree}
\rule[1ex]{0em}{1.5ex}
\texttt{x}\underline{\in}Y,\ \ e\ \textsf{modEXP}\ Y
\justifies
\texttt{T x =}\ e\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%
Contrary to that, if the variable is not
assigned while is declared, we do not have to do any
membership checking. This fact is presented by the rule
\textup{VAR-DECL}.
%%%%%
\[
\begin{tabular}{ll}
\textsf{(VAR-DECL)}\,\,\, & 
\begin{prooftree}
\justifies
\texttt{T x}\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%
\java~instructions can also be represented by pre and post
expressions. These can be seen as \emph{in place} allocations. Rule
\textup{POST-PLUS} presents the case for post-increment expressions.
That rule states that the expression \textup{e}, which is the target
of an assignment, has to belong to set of expressions \textup{Y}
modifiable by the method. Additionally, \textup{e} must be checked using
expression rules.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(POST-PLUS)}\,\, &
\begin{prooftree}
e\underline{\in}Y,\ \ e\ \textsf{modPE}\ Y
\justifies
e\texttt{++}\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%
The \textup{BINARY} rule is applicable
to arithmetic, relational and logic operators. This rule
does not take into account any consideration about membership of
expressions \textup{e}$_i$ to some set \textsc{Y}, since no expression
is directly modified by these
operators, although eventually some subexpression could modify some
variable. This analysis also works for \java~operators as \texttt{unary},
\texttt{instanceof}, \texttt{()} (\emph{casting}) and $?$, as
presented by rules \textup{UNARY}, \textup{INSTANCE}, \textup{CAST}
and \textup{CONDITIONAL}.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(BINARY)} & 
\begin{prooftree} 
e_1\ \textsf{modPE}\ Y,\ \ e_2\ \textsf{modEXP}\ Y
\justifies
e_1\oplus e_2\ \textsf{modEXP}\ Y
\using
\oplus \in \{
	\begin{array}{l}
		\texttt{<,<=,>,>=,==,!=,||}	\\
		\texttt{\&\&,+,-,*,/,\,\&,\^\ ,|}
	\end{array}
	\}
\end{prooftree}
\\[3.5ex]
\textsf{(UNARY)} & 
\begin{prooftree} 
e\ \textsf{modEXP}\ Y
\justifies
\oplus \ e\ \textsf{modEXP}\ Y
\using
\oplus \in \{\texttt{+,-,$\sim$,!}\}
\end{prooftree}
\\[3.5ex]
\textsf{(INSTANCE)} & 
\begin{prooftree} 
e\ \textsf{modEXP}\ Y
\justifies
e\ \texttt{instanceof C}\ \textsf{modEXP}\ Y
\end{prooftree}
\\[3.5ex]
\textsf{(CAST)} & 
\begin{prooftree}
e\ \textsf{modEXP}\ Y
\justifies
\texttt{(T)}e\ \textsf{modEXP}\ Y
\end{prooftree}
\\[3.5ex]
\textsf{(CONDITIONAL)}\,\, & 
\begin{prooftree} 
e_1\ \textsf{modEXP}\ Y,\ \ e_2\ \textsf{modEXP}\ Y,\ \ e_3\
\textsf{modEXP}\ Y
\justifies
e_1\texttt{?}e_2\texttt{:}e_3\ \textsf{modEXP}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%

So far, the rules defined here enable us to detect the kind of problems
presented in Section~\ref{sec-sem-mod-cla} (see
figure~\ref{fig-mod-spe}). Thus, by applying the rule
\textup{METH-DEC}, the checking condition for the method \texttt{n()}
will become $\mathtt{\{myArr\ =\ new\ int[3]\}}$ \textit{mod}
$\phi$. Then,
by applying the rule \textup{ASSG}, we would should be able to
deduce $myArr\underline\in\ \phi$. That is not possible. Hence, the
checking of the method \texttt{n()} will
fail. Figure~\ref{fig-der-cor-fig-esc} presents the whole derivation
corresponding to this problem.
%%%%%%%
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\\[0.5ex]
\begin{prooftree}
   \[
     \[
       \[
	 \texttt{false}
         \justifies 
         \texttt{myArr}\ \in\ \phi
	 \using
         \textsf{(AX)}
       \]
       \justifies 
       \texttt{myArr}\ \underline\in\ \phi
       \using
       \textsf{(IN-SIMP)}
     \]
     \[
       \[
         \proofdotseparation=1.2ex 
         \proofdotnumber=3
         \leadsto 
       \]
       \justifies 
       \texttt{myArr}\ \textsf{modPE}\ \phi
     \]
     \[
       \[
         \proofdotseparation=1.2ex 
         \proofdotnumber=3
         \leadsto 
       \]
       \justifies 
       \texttt{new int[3]}\ \textsf{modEXP}\ \phi
     \]
     \justifies
     \texttt{myArr = new int[3]}\ \textsf{mod}\ \phi
     \using
     \textsf{(ASSG)}
   \]
   \justifies
   \texttt{m}\ \textsf{mod}\ \phi
   \using
   \textsf{(METH-DEC)}
\end{prooftree}
\caption{Detecting not modifiable definitions}
\label{fig-der-cor-fig-esc}
\rule{\linewidth}{0.25mm}
\end{figure} %%%%%%%%

Following our initial presentation, \java~expressions can be
represented by primary and suffix expressions. Primary rules
\textup{ID-FLD}, \textup{SUPER}, \textup{THIS}, \textup{STATIC},
\textup{CONST} do not take into account any consideration of
membership of expressions \textup{e}$_i$ to some set, since they do
not change any expression.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(ID-FLD)}\,\, &
\begin{prooftree}
\justifies
\texttt{x}\ \textsf{modPRM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(SUPER)}\,\, & 
\begin{prooftree}
\justifies
\texttt{super}\ \textsf{modPRM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(THIS)}\,\, & 
\begin{prooftree}
\justifies
\texttt{this}\ \textsf{modPRM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(STATIC)}\,\, &
\begin{prooftree}
\justifies
\texttt{A}\ \textsf{modPRM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(CONST)}\,\, &
\begin{prooftree}
\justifies
\texttt{b}\ \textsf{modPRM}\ Y
\using
\texttt{b}\in Constant
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%%%

Rule \textup{ARR-FLD} shows that for array primary expressions one
must check the corresponding parameter expression \textup{e} using
\textit{modEXP} rules.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(ARR-FLD)}\,\, &
\begin{prooftree}
e\ \textsf{modEXP}\ Y
\justifies
\texttt{a[}e\texttt{]}\ \textsf{modPRM}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%%%
The rule \textup{METH} expresses the fact that a primary expression
can be represented by a method invocation. This rule is similar to
\textup{METH-INV} presented above. 
%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(METH)}\,\, &
\begin{prooftree}
\sem{\texttt{this.m(}\overrightarrow{\texttt{o}}\texttt{).modifies}}[\overrightarrow{\texttt{o}} 
\backslash \overrightarrow{\texttt{q}}]\sqsubseteq Y,\ \
\overrightarrow{\texttt{q}}\ \overrightarrow{\textsf{modEXP}}\
\textsc{Y}
\justifies
\texttt{m(}\overrightarrow{\texttt{q}}\texttt{)}\ \textsf{modPRM}\ \textsc{Y}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%
Rules \textup{NEW-EXP} and \textup{NEW-ARR} show the cases when
primary expressions are represented by \java~\emph{new}
expressions. Both rules express that the expressions passed as
parameters must be checked by using \textit{modEXP} rules. To suffix
expressions, we have rules \textup{ID-FLD}, \textup{ARR-FLD},
\textup{THIS} and \textup{SUPER} similar to those presented for primary
expressions.
%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(NEW-EXP)}\,\, & 
\begin{prooftree}
\overrightarrow{e}\ \overrightarrow{\textsf{modEXP}}\ Y
\justifies
\texttt{new T(}\overrightarrow{e}\texttt{)}\ \textsf{modPRM}\ Y
\end{prooftree}
\\[3.5ex]
\textsf{(NEW-ARR)}\,\, & 
\begin{prooftree}
e\ \textsf{modEXP}\ Y
\justifies
\texttt{new T[}{e}\texttt{]}\ \textsf{modPRM}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%
\java~instructions can be also represented by statements. In case
of \texttt{if...then...} statements, rule
\textup{IF-THEN} states that its guard must be checked using
\textit{modEXP} rules since, according to the \java~syntax, a guard
corresponds to an expression. Its body \textsc{S} can be represented by
a set of
statements (an expression can be seen as a statement), thus it must be
checked by using rules for statements. A similar analysis can be
formulated for \texttt{if...then...else...} and \texttt{while} constructs.
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(IF-THEN)}\,\, & 
\begin{prooftree}
c\ \textsf{modEXP}\ Y,\ \ s\ \textsf{modSTM}\ Y
\justifies
\texttt{if(}c\texttt{)\{}s\ \texttt{\}}\ 
\textsf{modSTM}\ Y
\end{prooftree}
\\[3.5ex]
\textsf{(IF-THEN-ELSE)}\,\, & 
\begin{prooftree}
c\ \textsf{modEXP}\ Y,\ \ s\ \textsf{modSTM}\ Y,\ \ \textsf{t}\
\textsf{modSTM}\ Y
\justifies
\texttt{if(}c\texttt{)\{}s\texttt{\}else\{}t\texttt{\}}\
\textsf{modSTM}\ Y
\end{prooftree}
\\[3.5ex]
\textsf{(WHILE)}\,\,\, & 
\begin{prooftree}
c\ \textsf{modEXP}\ Y,\ \ b\ \textsf{modSTM}\ Y
\justifies
\texttt{while(}c\texttt{)\{}b\texttt{\}}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%

Rules \textup{SKIP}, \textup{BREAK}, \textup{BREAK-LBL},
\textup{CONTINUE} and \textup{CONTINUE-LBL}
present the analysis for the \texttt{skip},
\texttt{break}, \texttt{break} \emph{lbl}, \texttt{continue} and
\texttt{continue} \emph{lbl} \java~statements. 
%%%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(SKIP)} &  
\begin{prooftree}
\justifies
\texttt{skip}\ \textsf{modSTM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(BREAK)} & 
\begin{prooftree}
\justifies
\texttt{break}\ \textsf{modSTM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(BREAK-LBL)} &
\begin{prooftree}
\justifies
\texttt{break\! lbl}\ \textsf{modSTM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(CONTINUE)} & 
\begin{prooftree} 
\justifies
\texttt{continue}\ \textsf{modSTM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(CONTINUE-LBL)}\,\, & 
\begin{prooftree} 
\justifies
\texttt{continue\! lbl}\ \textsf{modSTM}\ Y
\end{prooftree}
\\[3.0ex]
\textsf{(RETURN)} & 
\begin{prooftree} \justifies
\texttt{return}\ \textsf{modSTM}\ Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%%%

Rule \textup{SEQ} presents the analysis for the composition of
\java~instructions. This rule
states that the composition of instructions \textup{S} and \textup{T}
may modify \textsc{Y} if \textup{S} may modify \textsc{Y} and
\textup{T} may modify \textsc{Y}. This rule enables us to express
modifiable conditions for different \java~instructions as the
sequentialization of their respective conditions.
%%%%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(SEQ)}\,\, & 
\begin{prooftree}
s\ \textsf{modSTM}\ Y,\ \ t\
\textsf{modSTM}\ Y
\justifies
s\texttt{;}t\ \textsf{modSTM}\ Y
\end{prooftree} 
\end{tabular}
\]
%%%%%%%%%%%%%
%%%%%%%%%%%%%
%\[
%\begin{tabular}{ll}
%\textsf{RETURN-EXP}\,\, & 
%\begin{prooftree} 
%e\ \textsf{modEXP}\ Y
%\justifies
%\texttt{return}\ e\ \textsf{modSTM}\ Y
%\end{prooftree}
%\end{tabular}
%\]
%%%%%%%%%%%%%
Finally, another aspect that must be analyzed is
the different constructs that can appear in modifiable
specifications. According to \jml~specifications, 
\texttt{$\backslash$fields}$\_$\texttt{of} and
\texttt{$\backslash$reach} pragmas can occur inside of such modifiable
specifications. Hence, when establishing membership conditions
\textup{e}$_1$\texttt{.}\textup{e}$_2$$\underline\in$ \textsc{Y}, we
also need to define rules taking into account the fact that these constructs can
occur inside of \textsc{Y}. 

Typically, if none of these pragmas occur in the modifiable
clause we fall on the standard definition of membership (see rules
rules \textup{IN-SIMP}, \textup{IN-ARR}, \textup{IN-EXP},
\textup{IN-EXP-ARR}).
%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(IN-SIMP)} &
\begin{prooftree}
\texttt{x}\in \textsc{Y}
\justifies
\texttt{x}\underline{\in}Y
\end{prooftree}
\\[3.5ex]
\textsf{(IN-ARR)} &
\begin{prooftree}
\texttt{a[}e\texttt{]}\in Y
\justifies
\texttt{a[}e\texttt{]}\underline{\in}Y
\end{prooftree}
\\[3.5ex]
\textsf{(IN-EXP)} &
\begin{prooftree}
e\texttt{.x}\in Y
\justifies
e\texttt{.x}\underline{\in} Y
\end{prooftree}
\\[3.5ex]
\textsf{(IN-EXP-ARR)}\,\, &
\begin{prooftree}
e_2\texttt{.a[}e_1\texttt{]}\in Y
\justifies
e_2\texttt{.a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%

Moreover, if we are checking simple array membership conditions as
\texttt{a[}\textup{e}\texttt{]}$\underline{\in}$ \textsc{Y}, it will
be enough to find a \jml~construct in \textsc{Y} specifying that the
corresponding method may modify any element of \texttt{a} (rule
\textup{TIMES-ARR}) or certain intervale where the value
of \textup{e} is found (rule INTERV-ARR).
%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(INTERV-ARR)}\,\, & 
\begin{prooftree}
\texttt{a[}i..j\texttt{]}\in Y,\ i\leq e\leq j
\justifies
\texttt{a[}e\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(TIMES-ARR)}\,\, &
\begin{prooftree}
\texttt{a[}*\texttt{]}\in Y
\justifies
\texttt{a[}e\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%
When establishing membership conditions
\textup{e}$_1$\texttt{.}\textup{e}$_2$$\underline\in$ \textsc{Y}, we
have to consider some cases according to the shape of \textup{e}$_2$. If
\textup{e}$_2$ is not an array expression, it will be enough to have
\texttt{$\backslash$fields$\_$of(}\textup{e}$_1$\texttt{)} occurring 
in \textsc{Y} to establish the original condition of membership
(see rules \textup{IN-THIS} and \textup{IN-EXP-FLD}). Otherwise, if
\textup{e}$_2$ is an array expression
\texttt{a[}\textup{e}$_3$\texttt{]}, it will be enough to have
\texttt{$\backslash$fields$\_$of(}\textup{e}$_1$\texttt{.a}\texttt{)}
occurring in \textsc{Y} (see rules \textup{IN-ARR-FLD} and
\textup{IN-EXP-ARR-FLD}).
%%%%%%
\[
\begin{tabular}{ll}
\textsf{(IN-THIS)} &
\begin{prooftree}
\backslash \texttt{fields\_of(this)}\in Y
\justifies
\texttt{this.x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(IN-EXP-FLD)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(}e\texttt{)}\in Y
\justifies
e\texttt{.x}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%

%%%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(IN-ARR-FLD)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(a)}\in Y
\justifies
\texttt{this.a[}e_3\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(IN-EXP-ARR-FLD)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(}e_1\texttt{.a)}\in Y
\justifies
e_1\texttt{.a[}e_3\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%

Similarly, \texttt{$\backslash$reach}
expressions can occur in \modif~clauses\footnote{According to the
\jml~syntax $\backslash$\texttt{reach} expressions can only occur
inside of a $\backslash$\texttt{fields}$\_$\texttt{of}
expression.}. So, if expressions such as
$\backslash$\texttt{fields}$\_$\texttt{of($\backslash$reach(}\textup{e}$_1$\texttt{))}
occur in \textsc{Y} (and we would like to establish
\textup{e}\texttt{.x}$\underline\in$\textsc{Y}) it will be enough to
have \textup{e}\texttt{.x} belonging to set expressions reachable from
\textup{e}$_1$. This situation is presented by the rule
\textup{IN-EXP-REACH}. Something similar happens when \texttt{x} is an
array expression. This
is presented by rules \textup{IN-REACH}, \textup{IN-ARR-REACH} and
\textup{IN-EXP-ARR-REACH}.
%%%%%%%%%
\[
\begin{tabular}{ll}
\textsf{(IN-EXP-REACH)} &
\begin{prooftree}
\backslash \texttt{fields\_of(}\backslash
\texttt{reach(}e_1\texttt{))}\in Y,\ \ e\texttt{.x}\in \backslash
\texttt{reach(}e_1\texttt{)}
\justifies
e\texttt{.x}\underline{\in} Y
\end{prooftree}
\\[3.5ex]
\textsf{(IN-REACH)} &
\begin{prooftree}
\backslash
\texttt{fields\_of(}\backslash\texttt{reach(}e\texttt{))}\in Y,\ \
\texttt{this}\in \backslash \texttt{reach(}e\texttt{)} 
\justifies
\texttt{this.x}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(IN-ARR-REACH)} &
\begin{prooftree}
\backslash \texttt{fields}\_\texttt{of(}\backslash
\texttt{reach(}e_1\texttt{))}\in Y,\ \ \texttt{this.a}\in \backslash
\texttt{reach(}e\texttt{)} 
\justifies
\texttt{this.a[}e\texttt{]}\underline{\in} Y
\end{prooftree}
\\[3.0ex]
\textsf{(IN-EXP-ARR-REACH)}\,\, &
\begin{prooftree}
\backslash \texttt{fields\_of(}\backslash
\texttt{reach(}e\texttt{))}\in Y,\ \ e_2\texttt{.a}\in \backslash
\texttt{reach(}e\texttt{)}
\justifies
e_2\texttt{.a[}e_1\texttt{]}\underline{\in} Y
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%%%

%Appendix ~\ref{ane-der-exa} shows some derivation examples of checking
%\java~asserted programs using the rules we present below. These examples
%allow us to see how incorrect modifiable specifications can be
%detected using our rules.






\section{A checker for \modif~clauses}
\label{sec-imp-iss}
We present the implementation of a modifiable checker (\modtool)
implementing the syntactical rules presented during
Section~\ref{sec-giv-sin-def}. For doing such an implementation we
have taken certain \jml~classes for representing the \java~syntactical 
constructs. Additionally, we have used the \jml~parser for parsing
\java~asserted programs, storing the underlying context on which
modifiable specifications are made and embedding the calls of
respective classes which implement our syntactical rules.

Section~\ref{abo-jml-cla-use} gives a general overview about the
\jml~classes we used for representing \java~constructs and doing
parsing. Section~\ref{fig-out-met-cal-con} shows how the
context underlying method specifications is determined and how
the calls to methods which implement our syntactical
rules are made. Section~\ref{mod-and-con-clab} presents classes
\texttt{Context} and \texttt{Modifiable}, which implement the
underlying method contexts and modifiable syntactical rules.




\subsection{About \jml~classes}
\label{abo-jml-cla-use}
We have taken two \jml~classes for modeling \java~constructs$:$
\texttt{AST} and \texttt{ASTFactory}. Abstract class \texttt{AST}
represents \java~constructs as tree structures and class
\texttt{ASTFactory} defines a set of operations for handling
\texttt{AST} trees. These operations cover \texttt{create{AST}},
\texttt{dupTree{AST}} and \texttt{ASTChild(AST)} which create,
duplicate and add a child to a tree.

Class \texttt{JmlParser} implements the \jml~syntactical analyzer and
can be extended by embedding \java~source code implementing any
specific functionality.

\subsection{Determining contexts of calling}
\label{fig-out-met-cal-con}
We have extended the \jml~parser by adding semantics actions for
determining contexts under which instructions have occurred. These
semantics actions have been embedded as \java~code in the parser. A
context for a method consists of its parameters, its local variables
and the set of variables declared as modifiable for it. Determining
the context for a method allows us to apply the general rule for method
declarations \textup{METH-DEC}, defined during
Section~\ref{sec-giv-sin-def}. Additionally, the contexts enable us to
apply the rest of the rules
for any instruction occurring inside of this method, since the context
for any instruction coincides with the context of the method in which
they occur.

Figure~\ref{fig-out-par} shows the source code embedded in the
\jml~parser for adding any parameter to a method
context. Specifically, this code is added in the
\texttt{param$\_$declaration()} method. To do this, the variable
\texttt{currentContext} (having \texttt{Context} type and which serves
to store the current method context0 makes a call to
\texttt{addParameter(AST)} and passes it the parameter just
parsed. The Implementation of the class \texttt{Context} will be
presented in
Section~\ref{mod-and-con-clab}. Similar actions are
considered for the declaration of modifiable and local variables.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{alltt}
   public final void param_declaration() throws \dots \verb!{! 
      \vdots
      AST tmp87_AST = null;
      if(inputState.guessing == 0) \verb!{!
         tmp87_AST = (AST)astFactory.create(LT(1));
         astFactory.addASTChild(currentAST, tmp87_AST);
         {\it//code added for modifiable checker: parameter of the method}
         currentContext.addParameter(astFactory.dupTree(tmp87_AST));
      \verb!}!
      \vdots
   \verb!}!
\end{alltt}
\caption{Determining out parameters}
\label{fig-out-par}
\rule{\linewidth}{0.25mm}
\end{figure}




\subsection{Making calls to static rules}
\label{mak-cal-sta-rul}
After determining the context of each method and its instructions, we
are ready to statically call methods of the \texttt{Modifiable} class
and thus check its modifiable declarations. Figure~\ref{fig-cal-whi-rul}
shows the case for the rule corresponding a \texttt{while}
construct. Its
respective rule \textup{WHILE} is presented below.
%%%%%%%%%%
\[
\begin{tabular}{ll}
WHILE\,\, & 
\begin{prooftree}
c\ \textsf{modEXP}\ Y,\ \ b\ \textsf{modSTM}\ Y
\justifies
\texttt{while(}c\texttt{)\{}b\texttt{\}}
\end{prooftree}
\end{tabular}
\]
%%%%%%%%%

As can be seen, as far as the method \texttt{statement} parses the
different parts of a \texttt{while} statement, we store the guard
and block constructs as variables of type \texttt{AST}
\texttt{temp4$\_$MOD} and \texttt{temp5$\_$MOD}\footnote{In the rule
above, these correspond to \textsc{C} and \textsc{B}
respectively}. Finally, we use the static Al method \texttt{$\_$WHILE}
of \texttt{Modifiable} class for doing the corresponding checking. In
addition to variables \texttt{temp4$\_$MOD} and \texttt{temp5$\_$MOD},
we have to pass to method \texttt{$\_$WHILE} the context of the method
where this statement is declared and a list of all other known
contexts. Class \texttt{Modifiable} will be presented in
Section~\ref{mod-and-con-clab}.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{alltt}
   public final void statement(boolean in_model_prog) \dots \verb!{!
      \vdots
      case LITERAL_while:
         match(LITERAL_while);\dots match(LPAREN); \dots expression(side_effects_allowed);
         {\it //code added for modifiable checker}
         AST temp4_MOD = (AST)astfactoryMOD.dupTree(returnAST);
         match(RPAREN); \dots statement(in_model_prog);
         {\it //code added for modifiable checker}
         AST temp5_MOD = (AST)astfactoryMOD.dupTree(returnAST);
         Modifiable._WHILE(temp4_MOD,temp5_MOD, currentContext.getY(), contextStack);
    \verb!}!
\end{alltt}
\caption{Calling of {\tt while} rule}
\label{fig-cal-whi-rul}
\rule{\linewidth}{0.25mm}
\end{figure}




\subsection{\texttt{Modifiable} and \texttt{Context} classes}
\label{mod-and-con-clab}
The \texttt{Modifiable} class implements rules presented in
Section~\ref{sec-giv-sin-def} as static methods. As an example
Figure~\ref{fig-met-sta-whi} shows method \textup{$\_$WHILE}, which
implements the rule \textup{WHILE} presented above. This method makes
calls to \texttt{$\_$modEXP($\dots$)} and
\texttt{$\_$modSTM($\dots$)} static methods, which implements rules
\texttt{modEXP} and \texttt{modSTM} respectively.




\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\begin{alltt}
public static boolean _WHILE(AST C, AST B, Vector Y, Stack contexts)\verb!{!
  return(_modEXP(C,Y,contexts) && {\it //C modEXP Y}
         _modSTM(B, Y, contexts); {\it //B modSTM Y}
        );
\verb!}!


public static boolean _modEXP(AST e, Vector Y, Stack contexts)\verb!{!
  boolean tempRes;
  switch(e.getType())\verb!{!
    case JavaTokenTypes.ASSIGN: case JavaTokenTypes.PLUS_ASSIGN:
    case JavaTokenTypes.MINUS_ASSIGN: case JavaTokenTypes.STAR_ASSIGN:
    case JavaTokenTypes.DIV_ASSIGN: case JavaTokenTypes.BITWISE_ASSIGNMENT_OP:
    tempRes = _in_PRIME(astfactoryMOD.dupTree(e.getFirstChild()),Y,contexts) &&
     _modPE(astfactoryMOD.dupTree(e.getFirstChild()),Y,contexts) &&
     _modEXP(astfactoryMOD.dupTree(e.getFirstChild().getNextSibling()),Y,contexts);
    break;
    \vdots
  \verb!}!
  return tempRes;
\verb!}!
\end{alltt}
\caption{Static method \texttt{$\_$WHILE}}
\label{fig-met-sta-whi}
\rule{\linewidth}{0.25mm}
\end{figure}


\section{Conclusion}
\label{sec-con}



\bibliographystyle{alpha}
\bibliography{../specification}

\end{document}




\appendix
\section{Checking specifications}
\label{ane-der-exa}


This appendix presents some derivation examples of checking
\java~asserted programs using the rules we presented in
Section~\ref{sec-giv-sin-def}.



We present some derivation examples in
figures~\ref{fig-der-tre-c-cal-n},~\ref{fig-der-tre-this-m},~\ref{fig-der-tre-val-n}
and~\ref{fig-der-tre-c-cal-n} corresponding to
figure~\ref{fig-der-exa}.
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\rule{0em}{0.1ex}
\begin{alltt}
  public class C\verb!{!
    public int k = 0;

    {\it //@modifies arr[pos];}
    public void m(int[] arr, int pos)\verb!{! arr[pos] = this.k; \verb!}!
    public C getC()\verb!{! return this; \verb!}!
  \verb!}!
  public class D\verb!{!
    int[] myArr = new int[5];
    int myPos = 3;
    C c = new C();

    {\it //@modifies \verb!\!fields_of(\verb!\!reach(this));}
    public void n(int val)\verb!{! c.getC().k = val++; c.m(myArr, myPos); \verb!}!
  \verb!}!
\end{alltt}
\caption{Derivation example}
\label{fig-der-exa}
\rule{\linewidth}{0.25mm}
\end{figure} %%%%%%%
\begin{landscape} %%%%%%%%
\begin{center} 
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\\[2.0ex]
\begin{prooftree}
   \[
      \[
        \[
	  \justifies
	  \mathtt{arr[pos]}\in\ \textsc{Y}
	\]
	\justifies
	\mathtt{arr[pos]}\underline\in\ \textsc{Y}
	\using
	\textsc{\tiny IN-SIMP}
      \]
      \[
	\[
	  \[
            \[
	      \[
		\justifies
	 	\texttt{pos}\  \textit{modPRM}\ \textsc{Y}
		\using
		\textsc{\tiny CONST}
	      \]
	      \justifies
	      \texttt{pos}\  \textit{modPE}\ \textsc{Y}
	      \using
	      \textsc{\tiny EXP-PRM}	      
	    \]
	    \justifies
    \texttt{pos}\  \textit{modEXP}\ \textsc{Y}
	    \using
	    \textsc{\tiny EXP-TO-PE}
          \]
 	  \justifies
	  \mathtt{arr[pos]}\  \textit{modPRM}\ \textsc{Y}
	  \using
	  \textsc{\tiny ARR-FLD}
	\]
 	\justifies
	\mathtt{arr[pos]}\  \textit{modPE}\ \textsc{Y}
	\using
	\textsc{\tiny EXP-PRM}
      \]
      \[ %1
        \[ %2
          \[ %2
	     \[ %3
	       \justifies
	       \texttt{this}\ \textit{modPRM}\ \textsc{Y}
	       \using
	       \textsc{\tiny THIS}
	     \] %3
	     \justifies
	     \texttt{this}\ \textit{modPE}\ \textsc{Y}
	     \using
	     \textsc{\tiny EXP-PRM}
          \] %2
	  \[ %3
	    \justifies
	    \texttt{k}\ \textit{modPS}\ \textsc{Y}
	    \using
	    \textsc{\tiny ID-FLD}
	  \] %3
 	  \justifies
	  \texttt{this.k}\ \textit{modPE}\ \textsc{Y}
	  \using
	  \textsc{\tiny PE-TO-PE}
 	\] %2
 	 \justifies
	 \texttt{this.k}\ \textit{modEXP}\ \textsc{Y}
	 \using
         \textsc{\tiny EXP-TO-PE}
     \] %1
     \justifies
     \mathtt{arr[pos] = this.k}\  \textit{mod}\ \mathtt{\{arr[pos],arr,pos\}}
     \using
     \textsc{\tiny ASSG}
   \]
   \justifies
   \texttt{m(arr,pos)}\ \textit{mod}\ \mathtt{\{arr[pos]\}}
   \using
   \textsc{\tiny METH-DEC}
\end{prooftree}
\caption{Derivation tree for the method \texttt{m(int$[]$, int)}}
\label{fig-der-tre-this-m}
\rule{\linewidth}{0.25mm}
\end{figure}
\end{center} %%%%%%%%%%%
\begin{center} %%%%%%%%%%%
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\\[2.0ex]
\begin{prooftree}
\footnotesize
   \[
     \[
       \mathtt{fields\_of(\backslash reach(this))}\in \textsc{Y},\ \
\mathtt{c.getC()}\in \backslash\texttt{reach(this)}
       \justifies
       \mathtt{c.getC().k}\underline\in\ \textsc{Y} %
       \using
       \textsc{\tiny IN-EXP-REACH}
     \]
     \[
       \[
	 \[
	   \justifies
	   \phi \sqsubseteq \textsc{Y}
	   \using
	   \textsc{\tiny AX}
	 \]
	 \[
           \[
             \proofdotseparation=1.2ex 
             \proofdotnumber=3
             \leadsto 
           \]
	   \justifies
	   \texttt{c}\ \textit{modPE}\ \textsc{Y} 
	   \using 
	 \]
         \justifies
	 \mathtt{c.getC()}\ \textit{modPE}\ \textsc{Y} 
       \]
       \[
         \justifies
	 \mathtt{k}\ \textit{modPS}\ \textsc{Y} 
	 \using
	 \textsc{\tiny ID-FLD}
       \]
       \justifies
       \mathtt{c.getC().k}\ \textit{modPE}\ \textsc{Y} %
       \using
       \textsc{\tiny PE-TO-PE}
     \]
      \[ %1
         \[ %2
           \[ %3
            \justifies 
	     \texttt{val}\in \textsc{Y}\
	     \using
	     \textsc{\tiny AX}
	   \] %3
           \justifies 
           \texttt{val}\underline\in \textsc{Y}\ 
	   \using
	   \textsc{\tiny IN-SIMP}
	 \] %2
         \[ %2
   \[ %3
             \justifies
             \texttt{val}\ \textit{modPRM}\ \textsc{Y}
	     \using
	     \textsc{\tiny ID-FLD}	
	   \] %3  
           \justifies
           \texttt{val}\ \textit{modPE}\ \textsc{Y}
	   \using
	   \textsc{\tiny EXP-PRM}
	 \] %2
       \justifies
       \mathtt{val ++}\ \textit{modEXP}\ \textsc{Y} %
       \using
       \textsc{\tiny POST-PLUS}
     \] %1
    \justifies
     \mathtt{c.getC().k = val ++}\ \textit{modEXP}\
\mathtt{\{\backslash fields\_of(\backslash reach(this)), val\}}
     \using
     \textsc{\tiny ASSG}
   \] %0
   \justifies
   \texttt{n(val)}\ \textit{mod}\ \mathtt{\{\backslash fields\_of(\backslash reach(this))\}}
   \using
   \textsc{\tiny METH-DEC}
\end{prooftree}
\caption{Derivation tree for $\mathtt{c.getC().k = val ++}$ in {\tt n(int)}}
\label{fig-der-tre-val-n}
\rule{\linewidth}{0.25mm}
\end{figure}
\end{center}




\begin{center}
\begin{figure}[tbh]
\rule{\linewidth}{0.25mm}
\\[2.0ex]
\begin{prooftree}
   \[
       \[ %1
         \[ %---
         \[ %2
	   \[ %3
             \mathtt{\backslash fields\_of(\backslash reach(this))}\in 
\texttt{Y},\ \ \texttt{myArr}\in \mathtt{\backslash reach(this)}
	     \justifies
             \mathtt{myArr[myPos]}\underline\in\textsc{Y}
             \using
             \textsc{\tiny IN-ARR-REACH}
	   \] %3
           \justifies
	   \mathtt{\{myArr[myPos]\}}\sqsubseteq\textsc{Y}
	   \using
	   \sqsubseteq
         \] %2
         \[ %2
	   \[ %3
             \proofdotseparation=1.2ex 
             \proofdotnumber=3
            \leadsto 
           \] %3
	   \justifies
	   \texttt{c}\ \textit{modPE}\ \textsc{Y}
         \] %2
         \[ %2 
           \[ %3
             \proofdotseparation=1.2ex 
             \proofdotnumber=3
             \leadsto 
           \] %3
	   \justifies
   \texttt{myArr}\ \textit{modEXP}\ \textsc{Y}
	 \]  %2
	 \[  %2
           \[ %3
             \proofdotseparation=1.2ex 
             \proofdotnumber=3
             \leadsto 
           \] %3	
	   \justifies	
	   \texttt{myPos}\ \textit{modEXP}\ \textsc{Y}
	 \]  %2
         \justifies
         \texttt{c.m(myArr, myPos)}\ \textit{modPE}\ \textsc{Y}
         \using
         \textsc{\tiny EXP-METH}
        \] %-----
        \justifies
         \texttt{c.m(myArr, myPos)}\ \textit{modEXP}\ \textsc{Y}
         \using
         \textsc{\tiny EXP-TO-PE}
     \] %1
     \justifies
     \texttt{c.m(myArr, myPos)}\ \textit{mod}\ \mathtt{\{\backslash
fields\_of(\backslash reach(this)), val, myArr\}}
     \using
     \textsc{\tiny MOD-TO-EXP}
   \] %0
   \justifies
   \texttt{n(val)}\ \textit{mod}\ \mathtt{\{\backslash fields\_of(\backslash reach(this))\}}
   \using
   \textsc{\tiny METH-DEC}
\end{prooftree}
\caption{Derivation tree for {\tt c.m(myArr, myPos)} in {\tt n(int)}}
\label{fig-der-tre-c-cal-n}
\rule{\linewidth}{0.25mm}
\end{figure}
\end{center}

\end{landscape}

