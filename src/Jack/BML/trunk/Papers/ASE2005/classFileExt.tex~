% CHANGED - the example o compilation of loop specification

\section{Extension of the Class File With JML Annotation}\label{extClassJML}
This section explains how high level program specifications are compiled into bytecode level specifications and how they are inserted into the bytecode. 
When using JML, preconditions and postconditions are written by the programmer at a source level, i.e. the specification is written in special comments in the source. 
After compilation, the executable code is detached from its source code; but the verification process cannot be performed only with the compilation of the code - a specification of the bytecode is needed. 
We propose a specification compiler and implementation of an important subset of the JML language into a low level specification language. The JML compiler does not depend on any specific Java compiler. Once the compilation of JML is done it is added into the class file as new method or class attributes. 
%Specification available at bytecode level is necessary in situations where bytecode is verified, thus one need a way to express specification information in suitable form. 

The rest of the section will consist in two remainders concerning the Java Modeling Language, then part of the compiler will be presented and finally an example of JML use on source level and its translation in the bytecode specification language.
\subsection{Java Modeling Language (JML)} 
JML~\cite{JMLRefMan} is a behavioral interface specification language tailored to Java applications. It uses a predicate logic in order to describe class invariants, pre and postconditions, loop invariants, etc. Its syntax is close to Java's - most part of JML expressions are subset of Java expressions except for some keywords. For example \texttt{$\backslash$result} stands for the value that method returns if it is not void or \texttt{$\backslash$old(expression)} designates the value of \texttt{expression} in the prestate of a method and is usually used in the postcondition of a method. Statements in JML contain also special JML keywords - like \texttt{requires} for introducing method precondition, \texttt{ensures} for stating method postcondition, \texttt{loop\_invariant} for loop invariants, etc. JML specifications are written in comments so they are not visible for Java compilers. Instead they are used by tools tailored basically to either static checking of Java programs such as JACK, the Loop tool, ESC/Java or dynamic checking as the assertion checker jmlc. An overview of tools dealing with JML can be found in~\cite{BurdyCCEKLLP03}.

Figure ~\ref{halfSrc} gives an example of a JML specification.     
It describes the class \texttt{Half}. %one method \texttt{half}. 
The specification tells that if the method starts execution in a state that satisfies the precondition then on termination it will return the half of the argument as specified in the postcondition. The loop invariant is specified by using the key word \texttt{loop\_invariant} and a condition for loop termination is also specified by declaring after the keyword \texttt{decreases} the expression that decreases after every loop execution. 
\begin{figure}
\begin{verbatim}
public class Half {	
   //@ requires n >= 0;
   //@ ensures \result == \old(n) / 2; 	 
   public int half(int n) {
      int a = 0;
      int c = n;
      //@ loop_modifies n,a;
      //@ loop_invariant c==n+2*a;
      //@ decreases n;
      while (n > 1) {
         a = a + 1;
         n = n - 2;
      }
      return a;
   }
}
\end{verbatim}
\caption{class \texttt{Half} with JML annotations} 
\label{halfSrc}
\end{figure}

%\subsection{The Java class File Format}\label{classFileFormat}
%We now describe briefly the class file format in a manner to understand how information can be inserted. A complete definition of the class file format can be found in~\cite{VMSpec}. Fig.~\ref{classFileFormatF} gives the structure of a class file. A class file contains the definition of a single class or interface. It contains information about the class name, interfaces implemented by the class, super class, methods and fields declared in the class and references. The array with name \textbf{method} contains for every method declared in the class or interface a \textbf{method\_info} data structure. The array named \textbf{fields} contains a data structure for every field declared in the class or interface. The \textbf{constant\_pool} is a table of structures representing various string constants, class and interface names, field names, and other constants that are referred to within the class file structure and its substructures. The \textbf{constant\_pool} table in the binary representation of a class or interface is used to construct the runtime constant pool upon class or interface creation. The runtime constant pool serves for loading, linking and resolution of references used in the class. 
%\input classFileFormatTexPic.tex 
%The annotations that we add to the class file will appear as attributes associated to the class or to a method. Those attributes are defined by the Java Virtual Machine specification for user specific tools (see ~\cite{VMSpec}, ch.4.7.1 ). We change the class file format in a way not disturbing any other tool that does not use the compiled JML annotations.

\subsection{Compilation of JML Expressions}
% added for CAV - before there was the paragraph The Java Class File Format
Before talking about the specification compilation a brief presentation of the class file format will be useful. As defined in \cite{VMSpec}, a class file contains a definition of a single class class or interface.  It contains information about the class name, interfaces implemented by the class, super class, methods and fields declared in the class and references. There is a table data structure called \textbf{constant\_pool} that is used to construct the runtime constant pool upon class or interface creation. The runtime constant pool serves for loading, linking and resolution of references used in the class. The java virtual machine  specification (JVMS) allows to add to the class file a user specific information(~\cite{VMSpec}, ch.4.7.1). This is done by defining user specific attributes  (their structure is predefined by JVMS ).

Thus what we call a ``JML compiler'' will compile the jml source specification into a user defined attributes. The compilation process is as follows : 1. compile the java source file , 2. from the source file and the resulting class file compile the JML specification , 3. add the JML compilation in the class file. In the phase 2. Java and JML source identifiers should be linked with the names on bytecode level, namely with the corresponding indexes either from the constant pool or the array of local variables. 

We define a compilation function $\ulcorner \urcorner$ for a subset of JML statements and expressions. As JML is a rich specification language, we focus on the following statements: method precondition, normal and exceptional postconditions, loop invariants, class invariants, historical constraints. This JML fragment is expressive enough for most purposes.
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|l|p{5cm}|}
\hline
\texttt{Identifier} & \textrm{code} $($ \tt{Identifier} $)$ & Comments  \\
\hline
reference & \texttt{RefTag i}  & \texttt{i} is an index in the class \texttt{Constant Pool} \\
\hline
local variable & \texttt{LocVarTag i}  & \texttt{i} is a valid entry in the array of local variables \\
\hline
\end{tabular}
\end{center}
\caption{Coding function for identifiers}
\label{codingFunction}
\end{table}

Table \ref{codingFunction} describes the linking of identifiers: a unique code is assigned to each identifier depending on if it is a field or a local variable. This code is effectively the result of the compilation of an identifier. For identifiers that are method parameters or local variables, their index (denoted by \texttt{i}) in the local variable array is used preceded by a tag for local variables. Field references are translated using the index of the corresponding constant field reference data structure in the constant pool preceded by a tag for references.
\subsection{Compilation of JML Statements}
 JML statements are compiled in new class file attributes. Method specifications, class invariants, loop invariants are defined as new attributes in the class file with respect to the Java Sun Virtual Machine specification. 
 For example, the specification information for all the loops in a method specification is compiled to a unique attribute: the \textbf{Loop\_specification\_attribute}. This attribute contains an array of loop specifications - for every loop there should be a corresponding element in the array. More precisely it contains information at which instruction the loop starts, the invariant, the decreasing expression in case of total correctness, the expressions that can be modified. 
The syntax of the loop attribute is given Figure~\ref{loopAttribute}. For the full specification of the compiler you can see~\cite{JML2BCSpec}.
\begin{figure}
%\begin{frameit}
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
%\> u2 attribute\_name\_index;\\
%\> u4 attribute\_length;\\
%\> u2 loop\_count;\\
\> ...\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}
\begin{itemize}
%\item \textbf{	attribute\_name\_index}: The value of the attribute\_name\_index item must be a valid index into the second \texttt{ constant\_pool table}. The \texttt{constant\_pool} entry at that index must be a\texttt{ CONSTANT\_Utf8\_info} structure representing the string "Loop\_Specification''
%\textbf{   attribute\_length }\\
%    The length of the attribute in bytes\\

%\item \textbf{   loop\_count}: The length of the array of loop specifications

\item \textbf{   index}: The index in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described

\item \textbf{   modifies[]}: The array of modified expressions.

\item \textbf{  invariant }: The predicate that is the loop invariant. It is a compilation of the JML formula in the low level specification language

\item \textbf{  decreases }: The expression whose decreasing after every loop execution will guarantee loop termination 
\end{itemize}
\caption{Structure of the Loop Attribute}
\label{loopAttribute}
%\end{frameit}
\end{figure}

%A ``JML bytecode'' viewer is under development at project Everest, INRIA Sophia-Antipolis. The latter is a tool that visualizes all aspects of compiled Java class files and the contained bytecode.
