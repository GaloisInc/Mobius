% CHANGED - the example o compilation of loop specification

\section{Bytecode Specification Language (BCL)}\label{bcSpecLg}
Traditionally a lot of research has been done in the field of program verification for structured program languages~\cite{WPCDS},
~\cite{DisDij}. This explains the fact that the existing specification languages are designed for dealing with high level program languages. In order to verify 
a program w.r.t. to some property, usually the property is expressed in a suitable specification language.
After compilation, the executable code is detached from the source code; still we may need to verify that the resulting bytecode 
preserves the property in question. A typical example is when an untrusted bytecode implementing a public interface arrives at a 
receiver side and the latter wants to check that the unknown  bytecode respects the interface specification (which may not be trivial). Here comes the need for writing specification on  bytecode level. 
We propose a bytecode level specification language which corresponds to an important subset of JML.
We scatch the bytecode specification language grammar at \fig~\ref{bclGrammar}. We ommit some of the definitions for reason of space constraints,
 e.g. the grammar for arithmetic expressions, as it is defined in a standard way. For the full specification you can look at ~\cite{JML2BCSpec}.  
\begin{figure}[!htbp]
$$ \begin{array}{l}
\MethodSpec  ::= \\
   \Myspace \SpecCase \\
   \Myspace  \mid  \SpecCase \  \jmlStmt{also} \  \MethodSpec	;\\
   \\
\SpecCase ::= \\ 
    \Myspace \jmlStmt{requires} \ \predicate;\\ 
	\Myspace \jmlStmt{modifies} \ list(\expression);\\
	\Myspace \jmlStmt{decreases} \ \expression;\\
    \Myspace \jmlStmt{ensures} \ \predicate;\\
    \Myspace \jmlStmt{exsures} \ \texttt{ExceptionClass EXC} \ \predicate;\\
                     \\
\interMethodSpec ::= \\
     \Myspace \loopSpec \\
	 \Myspace  \assert \\
	  \\
\loopSpec ::= \\
		\Myspace \jmlStmt{pc\_ index} \ int;\\
	    \Myspace \jmlStmt{loop\_modifies} \ list(\expression);\\
       \Myspace \jmlStmt{loop\_invariant}  \ \predicate; \\
	   \Myspace \jmlStmt{loop\_decreases} \ \expression; \\
	 \\								
\assert   ::= \\
		\Myspace \jmlStmt{pc\_ index} \ int;\\
		\Myspace \jmlStmt{assert} \ \predicate; \\
	\\
\ClassSpec ::= \\ 
     \Myspace \jmlStmt{class \ invariant} \ \predicate \\
     \Myspace  \mid  \jmlStmt{history \ constraint} \ \predicate \\
     \Myspace  \mid  \jmlStmt{model} \ \texttt{ClassName}  \ id \\
      \\
      \predicate ::= \\
      \Myspace    \true \ \mid \ \false \\
      \Myspace  \mid   \expression \ predSymbol \ \expression \\
       \Myspace \mid   \predicate \wedge \predicate \\
       \Myspace \mid   \predicate \vee \predicate \\
       \Myspace \mid   \predicate \Rightarrow \predicate \\
       \Myspace \mid   \forall (\texttt{boundVar } : JavaType )  \predicate \\
       \Myspace \mid   \exists(\texttt{boundVar } : JavaType )  \predicate \\
       \\ 
  \expression ::= \\  
      \Myspace  \ArithExpr  \mid  \ \register{i}  \  \mid  \ \reference \\
  	  \Myspace  \mid  \ \fieldAccess{\expression}  \\
  	  \Myspace  \mid \ \arrayAccess{\expression} {\expression}  \\
  	  \Myspace  \mid \result \ \mid \old{\expression}  \\
  	  \Myspace \mid \typeof{\expression}  \ \mid \ \Mynull \ \mid \  \this
\end{array}$$
\caption{BCL grammar}
 \label{bclGrammar}
 \end{figure}
 The language defined here is expressive enough for most purposes including the description of non trivial functional and 
 security properties. Let's just discuss some of the specification clauses 
 (their semantics is the same as in JML~\cite{RT03djml} , ~\cite{JMLRefMan}).
  
 We can specify using the specification clause \jmlKey{exsures} what is the postcondition of  a method in case it terminates with 
 an exception  \texttt{ExceptionClass}.The special keyword \texttt{EXC} stands for the thrown exception object.
 
As shown by the grammar BCL allows us to specify different method specification cases separated by the keyword \jmlKey{also} - this means that 
 method caller has to satisfy the disjunction of the preconditions in the specification cases  and the method's implementation 
 has to guarantee the postcondition of every specification case given that the corresponding precondition held in the prestate.
The rules for loop specifications and assertions  say at what point in the bytecode they must hold. Loop  specification 
contains a frame conditions i.e. the expressions that may be modified in a loop iteration. This feature is not standard in JML; this is an extension introduced in 
 ~\cite{BRL-JACK}. 
 
\subsection{Compiling JML into bytecode specification language}

This section explains how high level program specifications are compiled into bytecode level specifications and how they are inserted into the bytecode. 
 A compiler from JML to the bytecode specification language is also defined and its features are discussed.


Before going farther we give a brief desrciption of the class file format. As defined by the java virtual machine  specification (JVMS) \cite{VMSpec}, a class file contains a definition of a single class class or interface. It contains information about the class name, interfaces implemented by the class, super class, methods and fields declared in the class and references. The JVMS mandate that the class file contains data structure usually refered as the \textbf{constant\_pool} table which is used to construct the runtime constant pool upon class or interface creation. The runtime constant pool serves for loading, linking and resolution of references used in the class. The JVMS allows to add to the class file a user specific information(~\cite{VMSpec}, ch.4.7.1). This is done by defining user specific attributes  (their structure is predefined by JVMS).

Thus the ``JML compiler'' compiles the jml source specification into a user defined attributes. The compilation process has three stages:
\begin{enumerate}
\item compile the java source file. This can be done by any java compiler that supplies for every method in the generated class file the \textbf{Line\_Number\_Table} and \textbf{Local\_Variable\_Table}  attributes.
 The presence in the java class file format of these attribute is optional \cite{VMSpec}. The \textbf{Line\_Number\_Table} describes the link between the source line and the bytecode of a method.  The \textbf{Local\_Variable\_Table} describes the local variables that appear in a method. This attribute is important for the next phase of the JML cpmpilation.
\item from the source file and the resulting class file compile the JML specification. In this phase Java and JML source identifiers are linked with their identifiers on bytecode level, namely with the corresponding indexes either from the constant pool or the array of local variables described in the \textbf{Local\_Variable\_Table} attribute. It is also in this phase that the specification parts like the loop invariants and the assertions which must hold at a certain source program point must be associated to the respective program point on bytecode level. The specification
is compiled standartly in binary form using tags. Basically the compilation of an expression is a tag followed by the compilation of its subexpressions. 

\todo{example for the compilation rule for a specific expression. Explain that the expressions are compiled in binary using tags }

\item add the JML compilation in the class file as user defined attributes. Method specifications, class invariants, loop invariants are 
newly defined attributes in the class file.
 For example, the specification of all the loops in a method are compiled to a unique method attribute: the \textbf{Loop\_specification\_attribute}. The syntax of the loop attribute is given at fig.~\ref{loopAttribute}. This attribute is an array of data structures each describing a single loop from the method source code. Also for each loop in the source code there must be a corresponding element in the array. 
More precisely every element contains information about the instruction where the loop starts as specified in the \textbf{Line\_Number\_Table}, the invariant associated to this loop, the decreasing expression in case of total correctness, the expressions that can be modified. 
For the full specification of the compiler you can see~\cite{JML2BCSpec}.
\end{enumerate}

\begin{figure}[ht!]
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{index}: The index in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described

\item \textbf{modifies[]}: The array of modified expressions.

\item \textbf{invariant }: The predicate that is the loop invariant. It is a compilation of the JML formula in the low level specification language

\item \textbf{decreases}: The expression whose decreasing at every loop iteration will guarantee loop termination 
\end{itemize}
\caption{Structure of the Loop Attribute}
\label{loopAttribute}
%\end{frameit}
\end{figure}

%A ``JML bytecode'' viewer is under development at project Everest, INRIA Sophia-Antipolis. The latter is a tool that visualizes all aspects of compiled Java class files and the contained bytecode.

\subsubsection{Discussion}
The JML compiler does not depend on any specific Java compiler. Anyways it requires the presence of a debug information, namely the presence of the \textbf{Line\_Number\_Table} attribute for the proper compilation of intermethod specification, i.e. loops and assertions. We hope that this is an acceptable restriction for the compiler.
The most problematic part of the compilation is to find the instructions to which the loop invariants must be associated. The difficulty consists in identifying the right cycle in the bytecode control flow graph corresponding to a particular loop in the source code. 
