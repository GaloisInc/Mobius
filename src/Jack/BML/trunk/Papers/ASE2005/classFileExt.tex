% CHANGED - the example o compilation of loop specification

\section{Bytecode Specification \\Language (BCSL)}\label{bcSpecLg}
%Traditionally a lot of research has been done in the field of program verification for structured program languages~\cite{WPCDS},
%~\cite{DisDij}. This explains the fact that the existing specification languages are designed for dealing with high level program languages. 
In this section, we propose a bytecode specification language which we call BCSL. We define a compiler from the high level specification language JML to BCSL. The specification compilation results in a class file extension. In the following we give the grammar of BCSL and sketch the specification compiler.

%In order to verify 
%a program w.r.t. to some property, usually the property is expressed in a suitable specification language.
%After compilation, the executable code is detached from the source code; still there are situations where the bytecode is subject to verification procedures (e.g. for example establishing trust in it). A typical example is when an untrusted bytecode implementing a public interface arrives at a 
%receiver side and the latter wants to check that the unknown  bytecode respects the interface specification (which may not be trivial).
% Here comes the need for writing specification on  bytecode level.


\subsection{Grammar} \label{grammar}
We propose a bytecode level specification language which corresponds to a representative subset of JML.
We sketch the bytecode specification language grammar in figure~\ref{bclGrammar}. We omit some of the definitions 
because of space constraints, e.g. the grammar for arithmetic expressions (which is defined in a standard way). The full specification can be found in~\cite{JML2BCSpec}.  
\begin{figure}[!htb]
$$ \begin{array}{ll}
\ClassSpec & ::=  \jmlStmt{class \ invariant} \ \predicate \\
               &  \mid  \jmlStmt{history \ constraint} \ \predicate \\
               &  \mid  \jmlStmt{model} \ \texttt{ClassName}  \ id \\

& \\
      
\MethodSpec  ::= & \SpecCase \\
           &  \mid  \SpecCase \  \jmlStmt{also} \  \MethodSpec	;\\
&  \\
\SpecCase & ::=  \jmlStmt{requires} \ \predicate;\\ 
	      & \jmlStmt{modifies} \ list(\expression);\\
	%\Myspace \jmlStmt{decreases} \ \expression;\\
              & \jmlStmt{ensures} \ \predicate;\\
              & \jmlStmt{exsures} \ (\texttt{ExceptionClass}) \ \predicate;\\
          
&  \\

\interMethodSpec & ::= \loopSpec \\
	             & \mid \assert \\
	&  \\
\loopSpec & ::= \jmlStmt{pc\_ index} \ int;\\
	      & \jmlStmt{loop\_modifies} \ list(\expression);\\
              & \jmlStmt{loop\_invariant}  \ \predicate; \\
	      & \jmlStmt{loop\_decreases} \ \expression; \\
	& \\								
\assert   & ::= \jmlStmt{pc\_ index} \ int;\\
	      & \jmlStmt{assert} \ \predicate; \\
&	\\

      \predicate & ::= \true \ \mid \ \false \\
                     & \mid   \expression \ predSymbol \ \expression \\
                     & \mid   \predicate \wedge \predicate \mid   \predicate \vee \predicate \mid   \predicate \Rightarrow \predicate \\
                     & \mid   \forall (\texttt{boundVar } : JavaType )  \predicate \\
                     & \mid   \exists(\texttt{boundVar } : JavaType )  \predicate \\
     &  \\ 
  \expression & ::= \ArithExpr  \mid  \ \register{i} \\
	  & \mid  \reference \mid \ \intLiteral \\	
  	  &  \mid  \ \fieldAccess{\expression} \  \mid \ \arrayAccess{\expression} {\expression}  \\
  	  &  \mid \result \ \mid \old{\expression} \mid \ \EXC \\
  	  & \mid \typeof{\expression}  \ \mid \ \Mynull \ \mid \ \this \\
  	  &  \mid  \counter \mid \stack{\ArithExpr} \ldots
\end{array}$$
\caption{BCSL grammar}
 \label{bclGrammar}
 \end{figure}
\clearpage 
 The language defined here is expressive enough for most purposes including the description of non trivial functional and 
 security properties. We now discuss some of the specification clauses that have some differences with JML, for the rest their semantics is the same as in JML and can be found in~\cite{RT03djml,JMLRefMan}.
 
 We can specify using the specification clause \jmlKey{exsures} what is the postcondition of  a method in case it terminates with 
 an exception  \texttt{E}. If the postcondition states something about the exception object thrown then the special expression \texttt{EXC} is used 
(this expression can appear only in exceptional postconditions). If \jmlKey{exsures} is not specified for certain exception, then by default it is considered as \Myfalse.
 
As shown by the grammar, BCSL allows to specify different method specification cases separated by the keyword \jmlKey{also} --- this means that 
 method caller has to satisfy the disjunction of the preconditions in the specification cases  and the method's implementation 
 has to guarantee the postcondition of every specification case of which the precondition held in the prestate.

Loop specifications and assertions are tagged with the program point in the bytecode where they must hold. Among the expressions 
that are handled (almost all are also handled
by JML) we have the expressions : \register{i} standing for the \texttt{i}-th local variable in a method; 
$\fieldAccess{\expression}$ meaning a field access expression, where \texttt{field\_cp\_index} is the constant pool index
describing the field; $\counter$ stands for the stack counter and \stack{\ArithExpr} a stack element at position \ArithExpr. These expressions do not appear in the precondition and postcondition specification of a method. Later we shall see how they are used.
 
 
\subsection{Compiling JML into bytecode specification language}\label{comJML}

This section explains how JML specifications are compiled into bytecode level specifications and how they are inserted into the bytecode. 
 
Before going farther we give a brief description of the class file format. As defined by the Java Virtual Machine Specification (JVMS) \cite{VMSpec}, a class file contains a definition of a single class class or interface. It contains information about the class name, interfaces implemented by the class, super class, methods and fields declared in the class and references. The JVMS mandates that the class file contains data structure usually referred as the \textbf{constant\_pool} table which is used to construct the runtime constant pool upon class or interface creation. The runtime constant pool serves for loading, linking and resolution of references used in the class. The JVMS allows to add to the class file user specific information(\cite{VMSpec}, ch.4.7.1). This is done by defining user specific attributes  (their structure is predefined by JVMS).

Thus the ``JML compiler'' \footnote{Gary Leavens also calls his tool jmlc JML compiler, which transforms jml into runtime checks and thus generates input for the jmlrac tool  } compiles the JML source specification into user defined attributes. The compilation process has three stages:
\begin{enumerate}
\item compile the Java source file. This can be done by any Java compiler that supplies for every method in the generated class file 
the \textbf{Line\_Number\_Table} and \textbf{Local\_Variable\_Table}  attributes. The presence in the Java class file format of 
these attribute is optional \cite{VMSpec}, yet almost all standard non optimizing compilers can generate these data. 
The \textbf{Line\_Number\_Table} describes the link between the source line and the bytecode of a method.  
The \textbf{Local\_Variable\_Table} describes the local variables that appear in a method. 
Those attributes are important for the next phase of the JML compilation.
\item from the source file and the resulting class file compile the JML specification. In this phase, Java and JML source identifiers are 
linked with their identifiers on bytecode level, namely with the corresponding indexes either from the constant pool or the array of 
local variables described in the \textbf{Local\_Variable\_Table} attribute. If in the JML specification a field
identifier appears, for which no constant pool (cp) index exists, such is added in the constant pool and the identifier in question
is compiled to the new cp index. It is also in this phase that the specification parts like the loop invariants and the assertions which should hold at a certain source program point must be associated to the respective program point on bytecode level. The specification
is compiled in binary form using tags in the standard way. Basically the compilation of an expression is a tag followed by the compilation of its subexpressions. 


Another important issue in this stage of the JML compilation is how the type differences on source and bytecode level are treated. 
By type differences we refer to the fact that the JVM (Java Virtual Machine) does not provide direct support for intergral types like byte, short, char, neither for boolean. Those types are rather encoded as integers in the bytecode. Concretely, this means that a variable in a Java source can have boolean type but it will be compiled to a variable with
an integer type.% In case that the JML specification contains boolean expressions we transform the specification in an equivalent one. 
For instance, in the example for the method 
\texttt{isElem} and its specification in Fig. \ref{replaceSrc}  the postcondition contains an equiavlence between the JML expression  
\result \ and a predicate. As the method \texttt{isElem} is declared with return type boolean the expression \result \ has type boolean on source level. 
Still, the bytecode resulting from the compilation of the method  \texttt{isElem} has type integer. This means that the compiler method has to make
 more effort than simply compiling the left and right side of the equivalence in the postcondition, otherwise the postcondition will not make sense
 (it will not be well typed). Actually, 
if the JML specification contains program boolean expressions that the java compiler will compile to bytecode expression with an integer type, the JML compiler 
will also compile them in integer expressions and will transform the specification condition in equivalent one 
\footnote{when generating proof obligations we add for every source boolean expression an assumption that it must be equal to 0 or 1. This, actually, must be always
equal to true as we assume that the programs are well typed}.  

Finally, the compilation of the postcondition of method \texttt{isElem} in  is given in Fig. \ref{postCompile}.
\begin{figure}[tb]
 $$\begin{array}{l}
         \result = 1 \\
         \iff \\ 
         \exists  var(0) . \ 0 \leq var(0) \wedge \\
         \Myspace var(0) < len(\#19(\register{0})) \wedge\\
         \Myspace  \#19(\register{0})[var(0)] = \register{1}  
   \end{array}
$$
\caption{The compilation of the postcondition in Fig. \ref{replaceSrc}}
\label{postCompile}
\end{figure}

From the postcondition compilation, one can see that \result \ is compiled to integer and the equivalence between the boolean expressions in the postcondition in Fig. \ref{replaceSrc}  is compiled into logical equivalence.

The example also shows that local variables and  fields are respectively linked to the index of the register table for the method and to the corresponding index of the constant pool table (\#19 is the compilation of the field name \texttt{list}, \register{1} stands for the method parameter \texttt{obj}). 


\item add the result of the JML compilation in the class file as user defined attributes. Method specifications, class invariants, loop invariants are 
newly defined attributes in the class file.
 For example, the specification of all the loops in a method are compiled to a unique method attribute: whose syntax is given in figure~\ref{loopAttribute}. This attribute is an array of data structures each describing a single loop from the method source code. Also for each loop in the source code there must be a corresponding element in the array. 
More precisely, every element contains information about the instruction where the loop starts as specified in the
\textbf{Line\_Number\_Table}, the invariant associated to this loop, the decreasing expression in case of total correctness, the expressions that can be modified. 
For the full specification of the compiler see~\cite{JML2BCSpec}.
\end{enumerate}

\begin{figure}[ht!]
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{index}: The index in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described

\item \textbf{modifies[]}: The array of modified expressions.

\item \textbf{invariant }: The predicate that is the loop invariant. It is a compilation of the JML formula in the low level specification language

\item \textbf{decreases}: The expression whose decreasing at every loop iteration
\end{itemize}
\caption{Structure of the Loop Attribute}
\label{loopAttribute}
%\end{frameit}
\end{figure}

The JML compiler does not depend on any specific Java compiler, but it requires the presence of a debug information, namely the presence of the \\ \textbf{Line\_Number\_Table} attribute for the proper compilation of inter method specification, i.e. loops and assertions. We think that this is an acceptable restriction for the compiler. The most problematic part of the compilation is to find the program points where the loop invariants must hold. This basically means that one has to identify which source loop corresponds to which bytecode loop in the control flow graph. To do this, we assume that the control flow graph is reducible (see~\cite{ARUCom1986}); intuitively this means no jumps from outside a loop inside it; graph reducibility allows to establish the same order between loops in the bytecode and source code level and to compile correctly the invariants to the proper places in the bytecode.


\todo{limitations : registers that are used with two different types in the method bytecode}
