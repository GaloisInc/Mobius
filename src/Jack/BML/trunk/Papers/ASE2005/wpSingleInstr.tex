\subsection{Weakest Precondition for bytecode instructions}\label{wpInstr}
First the weakest precondition (\wpi) calculus is a predicate transformer function which takes two arguments : an instruction and a predicate that is the instruction's postcondition $\psi$ and it returns the weakest predicate such that if it holds in the state when the instruction starts its execution then $\psi$ must hold in the state in which the instruction terminates its execution. The signature of \wpi is:
$$\wpi : \texttt{instruction} \rightarrow \texttt{predicate} \rightarrow \texttt{predicate}  $$

For every instruction \wpi \ symbolically evaluates the values in the prestate of the instruction for the variables that are changed by the instruction w.r.t. to their values in the poststate of the instruction and substitues in the postcondition the postcondition values with the precondition values. As the bytecode language is stack based, i.e. the instructions take their arguments from the method execution stack and put the result onto the stack. Thus we have to represent the elements of the stack that correspond to the arguments and the result of the instruction. In the examples at fig.~\ref{instrWP} \stack{\counter} stands for the element on the top of the stack. The instruction \instr{Type\_load i} loads on the top of the stack the value of the method local variable with at index \textit{i} in the \textbf{Local\_Variable\_Table} (see section ~\ref{bcSpecLg}). The \wpi \ rule for  \instr{Type\_load i} increments the stack counter \counter \ and puts on \stack{\counter} the contents of the local variable $l(i)$.


As we said in the beginning of the section \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their corresponding semantics. For example the keyword \jmlKey{$\backslash$result} is evaluated only by \instr{Type\_return} instructions and if appearing in the postcondition  \jmlKey{$\backslash$ result} is substituted by the element on the top of the stack \stack{\counter}. 

 More details can be found in~\cite{WPBC}.
\begin{figure}[ht]
%\begin{frameit}
$
wp(\instr{Type\_return} , \psi) = \psi[\backslash \jmlKey{result} \leftarrow \stack{\counter}]
$
%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } \\
%                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\

$
wp(\instr{Type\_load} \ i, \psi) = \psi[\counter \ \leftarrow \ \counter+1] [\stack{\counter+1} \ \leftarrow \ l(i)]
$ where $i$ is a valid entry in the list of local variables $l$

%\texttt{wp(Type\_load index,$\psi$)} = $\psi$\texttt{[Stack(t)$\leftarrow$local(index)][t$\leftarrow$t+1]}  \\
%, where the local variable must contain value of type Type
\caption{rules for some bytecode instructions}
\label{instrWP}
%\end{frameit}
\end{figure}

\subsubsection{References: creating objects, updating field values}


\subsubsection{Method calls}
