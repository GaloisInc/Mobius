%\subsection{Weakest Precondition Function for bytecode \\instructions}\label{wpInstr}
%We define a weakest precondition (\wpi) predicate transformer function which takes into account normal and exceptional termination. 
%\wpi \ takes three arguments: an instruction, a predicate that is the instruction's normal postcondition $\psi$, and a function
%from exception types to predicates $\excPost$ (it returns the specified postcondition in the \jmlKey{exsures} clause for a given exception; see section~\ref{grammar}).
%The \wpi \ function returns the weakest predicate such that if it holds in the state when the instruction starts its execution the following conditions are met: 
%\begin{enumerate}
	% \item if the instruction terminates its execution normally the predicate $\psi$ holds in the poststate 
	% \item if it terminates with an exception \texttt{E} then the predicate $\excPost(\tt{E})$ holds in the poststate.
%\end{enumerate}


 
 %The instruction $\instr{Type\_load} \ i$ loads on the top of the stack the value of the method local variable at index \textit{i}
 %in the \textbf{Local\_Variable\_Table} (see section~\ref{bcSpecLg}).

%As we said in the beginning of the section, \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their 
%corresponding semantics. For example, the keyword \result \ is evaluated only by \instr{Type\_return} 
%instructions and if appearing in the postcondition, \result \ is substituted by the element on the top of 
%the stack \stack{\counter}. 

%The rules also take into account the possible abnormal execution of the instruction. For example, in Fig. \ref{instrWP}, the rule for the instruction \instr{putField}
%has two conjuncts - one in the case when the dereferenced object is not null and the instruction execution terminates normally; the other one stands for the case when this is not true. Note, in case the exception thrown is not handled, we substitute the special specification variable \jmlKey{EXC} with the thrown exception object.


%\begin{figure}[!htp]
%$$
% (\texttt{Cl.f})\oplus[e2 \rightarrow e1](o) = \left\{ \begin{array} {ll}
%						       e1 & if \ e2 = o \\
%					               \texttt{Cl.f}(o)	& else 
%	\end{array}\right. 
%$$ 
%\caption{Overriding Function}
%\label{override}
%\end{figure}

\subsection{Manipulating object fields}
Instance fields are treated as functions, where the domain of a field \texttt{f} 
declared in the class \texttt{Cl} is the set of objects of class \texttt{Cl} and its subclasses.
We are using function update when assigning a value to a field reference as, for instance in~\cite{B00ppp}. 
%In Fig.~\ref{instrWP} the rule for \instr{putField} substitutes the corresponding field function \texttt{Cl.f} with \texttt{Cl.f} updated for object $o$, in case the dereferenced object is not null. The definition of update function is given in figure~\ref{override}.


%To illustrate how references are treated we give an example at fig.\ref{aliasing} - a method that assigns to the parameter's instance integer field (we give the example in source code to keep simplicity). 
%The \wpi \ for the method is given at      

%\begin{figure}
%\begin{verbatim}
%public class FieldAssign {
%  public int i = 0;

 % //@requires a != null;
 % //@modifies a.i; 
  %//@ensures i == 5;
 % public void set( FieldAssign a) {
 %   a.i = 3;
 % } 
%}
%\end{verbatim}
%%\caption{Example for recursive Java class}
 %\label{aliasing}
%\end{figure}

\subsection{Method calls}
Method calls are handled by using their specification. A method specification is a contract between callers and callees --- the precondition of the called method
must be established by the caller at the program point where the method is invoked and its postcondition is assumed to hold after the invocation. The rule for
invocation on a non-void instance method is given in figure~\ref{wpInv}. In the precondition of the called method, the formal parameters and the object on which the method is called are substituted with the first \textit{n+1} elements from the top of stack. 
Because the method returns a value, if it terminates normally, any occurrence of the JML keyword \result \ in $\psi^{post}(m)$ is substituted with the fresh variable $fresh\_var$.  
Because the return value in the normal case execution is put on the stack top, the $fresh\_var$ is substituted for the stack top in $\psi$. The resulting predicate is quantified over the expressions that may be modified by the called method. We also assume that if the invoked method terminates abnormally, by throwing an exception of type $\texttt{Exc}$, on returning the control to the invoker its exceptional postcondition $\excPost_{\tt{m} }( \tt{Exc} )$ holds. 
The rule for static methods is rather the same except for the number of stack elements taken from the stack.  

\begin{figure}[!ht]
$$
\begin{array}{l}
\wpi(\instr{invoke \  m}, \ \psi ,\ \excPost) =\\ 
\begin{array}{l}
\Myspace \psi^{pre}(m) \ \wedge \\
\Myspace  \forall_{j = 1..s} e_{j}.( \\
\Myspace \psi^{post}( \texttt{m})[\register{i}  \leftarrow \stack{\counter \ + i - numArgs( \texttt{m}) }]_{i=0}^{\tt{numArgs(\texttt{m} )}}  \\
\Myspace \Myspace\Myspace \Myspace[\tt{\backslash result} \leftarrow fresh\_var] \\
\Myspace \Rightarrow  \psi[\counter \leftarrow \counter - \tt{numArgs}( \texttt{m} )][\stack{\counter }  \leftarrow \tt{fresh\_var}]) \ \wedge_{i = 1}^k \\
\Myspace \forall_{j = 1..s} e_i ( \\
\Myspace \excPost_{\tt{m} }( \tt{Exc_i} ) \Rightarrow  \phi_{\tt{Exc_i} }[ \counter \leftarrow  0][\stack{0} \leftarrow \stack{\counter}]   ) ) \\		
\end{array} \\[15 mm]
\\
\psi^{pre}(\texttt{m}) - \it{ the \ specified \ precondition \ of \ method \ }\texttt{m} \\
\\
\psi^{post}(\texttt{m}) - \it{the \ specified \ postcondition \ of \ method \ }\texttt{m}  \\
\\
\excPost_{\texttt{m}} - \it{ the \ exceptional \ function \ for \ method \ }\texttt{m}  \\
\\
\tt{numArgs}( \texttt{m} ) - \it{ the \  number \ of \ arguments \ of \ }\texttt{m} \\  
\\
e_{j} , j = 1 .. s - \it{ the \ locations \ modified \ by \ method \ }\texttt{m} \\
\\
\tt{Exc_i}, i = 1.. k - \it{ the \ exceptions \ that \ } \texttt{m} \ \it{may \ throw} \\
\\
\phi_{\tt{Exc_i}}, i = 1..k -   \it{is \ the \ precondition } \\
\Myspace   \it{of \ the \  exception \ handler \ protecting \ the \ instruction \  against} \\
\Myspace   \tt{Exc_i} \ \it{\ if \ it \  exists, \ otherwise} \it{if \ the } \ \tt{Exc_i} \ \it{\ is \ not \ handled}    \\
\Myspace      \phi = \excPost( \tt{Exc_i})[ \jmlKey{EXC} \leftarrow \stack{\counter}]
\end{array}
$$
\caption{\wpi \ rule for a call to an instance non void method}
\label{wpInv}
\end{figure}
