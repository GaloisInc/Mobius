\subsection{Weakest Precondition for bytecode instructions}\label{wpInstr}
We define a weakest precondition (\wpi) predicate transformer function which takes into account normal and exceptional termination. 
\wpi \ takes three arguments : an instruction, a predicate that is the instruction's normal postcondition $\psi$, and a function
from exception types to predicates $\excPost$ (it returns the specified postcondition in the \jmlKey{exsures} clause for a given exception; see section~\ref{bclGrammar}).
The \wpi \ function returns the weakest predicate such that if it holds in the state when the instruction starts its execution the following conditions are met: 
\begin{enumerate}
	\item if the instruction terminates its execution normally the predicate $\psi$ holds in the poststate 
	\item if it terminates with an exception \texttt{E} then the predicate $\excPost(\tt{E})$ holds in the poststate.
\end{enumerate}
 So the signature of \wpi \ is:
$$\wpi : \texttt{instruction} \rightarrow \predicate \rightarrow (\tt{ ExceptionType} \rightarrow  \predicate) \rightarrow \predicate   $$

 The Java bytecode language is stack based, i.e. the instructions take their arguments from the method execution stack and 
 put the result on the stack. So we have to represent the elements of the stack that correspond to the arguments and the result for a given instruction. 
 In the examples in fig.~\ref{instrWP} \stack{\counter} stands for the element on the top of the stack. 
 The instruction $\instr{Type\_load} \ i$  loads on the top of the stack the value of the method local variable at index \textit{i}
 in the \textbf{Local\_Variable\_Table} (see section ~\ref{bcSpecLg}). The \wpi \ rule for  \instr{Type\_load i} increments the stack
counter \counter \ and puts on \stack{\counter} the contents of the local variable $\register{i}$.
As we said in the beginning of the section, \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their 
corresponding semantics. For example, the keyword \result \ is evaluated only by \instr{Type\_return} 
instructions and if appearing in the postcondition, \result \ is substituted by the element on the top of 
the stack \stack{\counter}. 

 More details can be found in~\cite{WPBC}.
\begin{figure}[ht]

$$
\begin{array}{l}
\wpi(\instr{iinc} \  i , \ \psi, \ \excPost) = \psi[\register{i} \leftarrow \register{i} + 1 ] \\
\\
\wpi(\instr{Type\_load} \ i, \ \psi, \ \excPost) =  \\
\Myspace \psi[\counter \ \leftarrow \ \counter+1] [\stack{\counter+1} \ \leftarrow \ \register{i}] \\
 \Myspace \texttt{where} \ i \ \texttt{is a valid local variable index}   \\
\\ 
\wpi(\instr{putField} \ \texttt{Cl.f}, \ \psi, \ \excPost) = \\
\begin{array}{l}
\begin{array}{l}
   (\stack{\counter -1} \not= \Mynull \Rightarrow  \\
   \begin{array}{l} \psi [\counter \leftarrow \counter-2 ] \\[0 mm] 
   \Myspace  [\texttt{Cl.f} \leftarrow \texttt{Cl.f}\oplus [\stack{\counter -1} \rightarrow \stack{\counter}] ] )\ \wedge 
\end{array}
\end{array}
   \\
   \stack{\counter-1} = \Mynull \Rightarrow \excPost(\tt{NullPointerException}) \end{array}
 \end{array} $$

%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } \\
%                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\


%\texttt{wp(Type\_load index,$\psi$)} = $\psi$\texttt{[Stack(t)$\leftarrow$local(index)][t$\leftarrow$t+1]}  \\
%, where the local variable must contain value of type Type
\caption{rules for some bytecode instructions}
\label{instrWP}
%\end{frameit}
\end{figure}

\subsubsection{References: manipulating fields}
Fields are treated as functions, where the domain of a field \texttt{f} 
declared in the class \texttt{Cl} is the set of objects of class \texttt{Cl} and its subclasses.
We are using function update when assigning a value to a field reference as in ~\cite{B00ppp}. 
In fig.~\ref{instrWP} the rule for \instr{putField} substitutes the corresponding field function \texttt{Cl.f} with \texttt{Cl.f} updated for object $o$ 
The definition of update function is given in fig.~\ref{override}.

\begin{figure}
$$
 (\texttt{Cl.f})\oplus[e2 \rightarrow e1](o) = \left\{ \begin{array} {ll}
						       e1 & if \ e2 = o \\
					               \texttt{Cl.f}(o)	& else 
	\end{array}\right. 
$$ 
\caption{Overriding Function}
\label{override}
\end{figure}
%To illustrate how references are treated we give an example at fig.\ref{aliasing} - a method that assigns to the parameter's instance integer field (we give the example in source code to keep simplicity). 
%The \wpi \ for the method is given at      

%\begin{figure}
%\begin{verbatim}
%public class FieldAssign {
%  public int i = 0;

 % //@requires a != null;
 % //@modifies a.i; 
  %//@ensures i == 5;
 % public void set( FieldAssign a) {
 %   a.i = 3;
 % } 
%}
%\end{verbatim}
%%\caption{Example for recursive Java class}
 %\label{aliasing}
%\end{figure}

\subsubsection{Method calls}
Method calls are handled by using their specification. A method specification is a contract - the precondition of the called method
must be established by the caller at the program point where the method is invoked and its postcondition is assumed to hold after the invocation. Thus the rule for
invocation on a non-void instance method is given in fig ~\ref{wpInv}. In the precondition of the called method the formal parameters and the object on which the method is called are substituted with the first \textit{n+1} elements from the top of stack. 
Because the method returns a value, any occurences of the JML keyword \result \ in $\psi^{post}(m)$  are substituted with the fresh variable $fresh\_var$.  
Because the return value is put on the stack top, the $fresh\_var$ is substituted for the stack top in $\psi$. The resulting predicate is quantified over the 
expressions that may be modified by the called method. Here we omit the case when the method calls results in an exception for reasons of limited space. 
The rule for static methods is rather the same except for the number of stack elements taken from the stack.  

\begin{figure}[!ht]
$$
\begin{array}{l}
\wpi(\instr{invoke} \ m, \ \psi ,\ \excPost) =\\ 
\begin{array}{l}
\psi^{pre}(m) \ \wedge \\
 \forall_{j = 1..s} m_{j}.( \\
\psi^{post}(m)[\register{i}  \leftarrow \stack{\counter \ - i + numArgs(m)}]_{i=0}^n  \\
%\phantom{\psi^{post}}
\Myspace \Myspace\Myspace \Myspace[\tt{\backslash result} \leftarrow fresh\_var] \\
\Rightarrow \\
 \psi[\counter \leftarrow \counter - \tt{numArgs}(m)][\stack{\counter }  \leftarrow \tt{fresh\_var}]) \\
%[e_{i} \rightarrow m_{i}]_{i = 1}^s \\
\end{array} \\[15 mm]
\psi^{pre}(m) - the \ specified \ precondition \ of \ method \ m \\
\psi^{post}(m) - the \ specified \ postcondition \ of \ method \ m \\
m_{j} , j = 1 .. s - the \ locations \ modified \ by \ method \ m
\end{array}
$$
\caption{\wpi \ rule for a call to an instance method}
\label{wpInv}
\end{figure}
