\subsection{Weakest Precondition for bytecode \\instructions}\label{wpInstr}
We define a weakest precondition (\wpi) predicate transformer function which takes into account normal and exceptional termination. 
\wpi \ takes three arguments: an instruction, a predicate that is the instruction's normal postcondition $\psi$, and a function
from exception types to predicates $\excPost$ (it returns the specified postcondition in the \jmlKey{exsures} clause for a given exception; see section~\ref{bclGrammar}).
The \wpi \ function returns the weakest predicate such that if it holds in the state when the instruction starts its execution the following conditions are met: 
\begin{enumerate}
	\item if the instruction terminates its execution normally the predicate $\psi$ holds in the poststate 
	\item if it terminates with an exception \texttt{E} then the predicate $\excPost(\tt{E})$ holds in the poststate.
\end{enumerate}
 So the signature of \wpi \ is:
$$\wpi : \texttt{instruction} \rightarrow \predicate \rightarrow (\tt{ ExceptionType} \rightarrow  \predicate) \rightarrow \predicate   $$

 The Java bytecode language is stack based, i.e. the instructions take their arguments from the method execution stack and 
 put the result on the stack. So, we have to represent the elements of the stack that correspond to the arguments and the result for a given instruction. 
 In the examples in figure~\ref{instrWP} \stack{\counter} stands for the element on the top of the stack. 
 The instruction $\instr{Type\_load} \ i$  loads on the top of the stack the value of the method local variable at index \textit{i}
 in the \textbf{Local\_Variable\_Table} (see section~\ref{bcSpecLg}). The \wpi \ rule for  \instr{Type\_load i} increments the stack
counter \counter \ and puts on \stack{\counter} the contents of the local variable $\register{i}$.
As we said in the beginning of the section, \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their 
corresponding semantics. For example, the keyword \result \ is evaluated only by \instr{Type\_return} 
instructions and if appearing in the postcondition, \result \ is substituted by the element on the top of 
the stack \stack{\counter}. 

The rules also take into account the possible abnormal execution of the instruction. For example, in Fig. \ref{instrWP}, the rule for the instruction \instr{putField}
has two conjuncts - one in the case when the dereferenced object is not null and the instruction execution terminates normally; the other one stands for the case when this is not true. Note, that if the exception thrown is not handled,
 we substitute the special specification variable \jmlKey{EXC} (see Subsection \ref{grammar}) in the exceptional postcondition by the thrown exception object.     

A complete definition of \wpi can be found in~\cite{WPBC}.
\begin{figure}[ht]

$$
\begin{array}{l}
\wpi(\instr{iinc} \  i , \ \psi, \ \excPost) = \psi[\register{i} \leftarrow \register{i} + 1 ] \\
\\
\wpi(\instr{Type\_load} \ i, \ \psi, \ \excPost) =  \\
\Myspace \psi[\counter \ \leftarrow \ \counter+1] [\stack{\counter+1} \ \leftarrow \ \register{i}] \\
 \Myspace \texttt{where} \ i \ \texttt{is a valid local variable index}   \\
\\ 
\wpi(\instr{putField} \ \texttt{Cl.f}, \ \psi, \ \excPost) = \\
\begin{array}{l}
	%\begin{array}{l}
   	\Myspace	\stack{\counter -1} \not= \Mynull \\
	\Myspace	\Rightarrow  
	\Myspace		%\begin{array}{l}
	\Myspace	 \psi [\counter \leftarrow \counter-2 ] \\[0 mm] 
   		\Myspace\Myspace\Myspace[\texttt{Cl.f} \leftarrow \texttt{Cl.f}\oplus [\stack{\counter -1} \rightarrow \stack{\counter}] ] \\
	%	\end{array}
	%\end{array}
   \Myspace	\wedge \\
   \Myspace	\stack{\counter-1} = \Mynull \\
 \Myspace	\Rightarrow  \phi[ \counter \leftarrow  0][\stack{0} \leftarrow \stack{\counter}]  \\		  \\
   \it{where \ the \ predicate \ \phi \  is \ the \ precondition \ of \ the} \\
   \it{exception \ handler \ protecting \ the \ instruction \  against} \\ 
   \tt{NullPointerException } \ \it{\ if \ it \  exists, \ otherwise}  \\
   \it{if \ the } \ \tt{ NullPointerException} \ \it{\ is \ not \ handled}    \\
      \phi = \excPost(\tt{NullPointerException})[ \jmlKey{EXC} \leftarrow \stack{\counter}]
    \end{array}
 \end{array} $$

%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } \\
%                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\


%\texttt{wp(Type\_load index,$\psi$)} = $\psi$\texttt{[Stack(t)$\leftarrow$local(index)][t$\leftarrow$t+1]}  \\
%, where the local variable must contain value of type Type
\caption{rules for some bytecode instructions}
\label{instrWP}
%\end{frameit}
\end{figure}

\subsubsection{References: manipulating fields}
Instance fields are treated as functions, where the domain of a field \texttt{f} 
declared in the class \texttt{Cl} is the set of objects of class \texttt{Cl} and its subclasses.
We are using function update when assigning a value to a field reference as in~\cite{B00ppp}. 
In Fig.~\ref{instrWP} the rule for \instr{putField} substitutes the corresponding field function \texttt{Cl.f} with \texttt{Cl.f} updated for object $o$, in case the dereferenced object is not null. The definition of update function is given in figure~\ref{override}.

\begin{figure}
$$
 (\texttt{Cl.f})\oplus[e2 \rightarrow e1](o) = \left\{ \begin{array} {ll}
						       e1 & if \ e2 = o \\
					               \texttt{Cl.f}(o)	& else 
	\end{array}\right. 
$$ 
\caption{Overriding Function}
\label{override}
\end{figure}
%To illustrate how references are treated we give an example at fig.\ref{aliasing} - a method that assigns to the parameter's instance integer field (we give the example in source code to keep simplicity). 
%The \wpi \ for the method is given at      

%\begin{figure}
%\begin{verbatim}
%public class FieldAssign {
%  public int i = 0;

 % //@requires a != null;
 % //@modifies a.i; 
  %//@ensures i == 5;
 % public void set( FieldAssign a) {
 %   a.i = 3;
 % } 
%}
%\end{verbatim}
%%\caption{Example for recursive Java class}
 %\label{aliasing}
%\end{figure}

\subsubsection{Method calls}
Method calls are handled by using their specification. A method specification is a contract - the precondition of the called method
must be established by the caller at the program point where the method is invoked and its postcondition is assumed to hold after the invocation. The rule for
invocation on a non-void instance method is given in figure~\ref{wpInv}. In the precondition of the called method, the formal parameters and the object on which the method is called are substituted with the first \textit{n+1} elements from the top of stack. 
Because the method returns a value, if it terminates normally, any occurence of the JML keyword \result \ in $\psi^{post}(m)$ is substituted with the fresh variable $fresh\_var$.  
Because the return value in the normal case execution is put on the stack top, the $fresh\_var$ is substituted for the stack top in $\psi$. The resulting predicate is quantified over the expressions that may be modified by the called method. We also assume that if the invoked method terminates abnormally, by throwing an exception of type $\texttt{Exc}$, on returning the control to the invoker its exceptional postcondition $\excPost_{\tt{m} }( \tt{Exc} )$ holds. 
The rule for static methods is rather the same except for the number of stack elements taken from the stack.  

\begin{figure}[!ht]
$$
\begin{array}{l}
\wpi(\instr{invoke \  m}, \ \psi ,\ \excPost) =\\ 
\begin{array}{l}
\Myspace \psi^{pre}(m) \ \wedge \\
\Myspace  \forall_{j = 1..s} e_{j}.( \\
\Myspace \psi^{post}( \texttt{m})[\register{i}  \leftarrow \stack{\counter \ + i - numArgs( \texttt{m}) }]_{i=0}^{\tt{numArgs(\texttt{m} )}}  \\
\Myspace \Myspace\Myspace \Myspace[\tt{\backslash result} \leftarrow fresh\_var] \\
\Myspace \Rightarrow  \psi[\counter \leftarrow \counter - \tt{numArgs}( \texttt{m} )][\stack{\counter }  \leftarrow \tt{fresh\_var}]) \ \wedge_{i = 1}^k \\
\Myspace \forall_{j = 1..s} e_i ( \\
\Myspace \excPost_{\tt{m} }( \tt{Exc_i} ) \Rightarrow  \phi_{\tt{Exc_i} }[ \counter \leftarrow  0][\stack{0} \leftarrow \stack{\counter}]   ) ) \\		
\end{array} \\[15 mm]
\\
\psi^{pre}(\texttt{m}) - \it{ the \ specified \ precondition \ of \ method \ }\texttt{m} \\
\\
\psi^{post}(\texttt{m}) - \it{the \ specified \ postcondition \ of \ method \ }\texttt{m}  \\
\\
\excPost_{\texttt{m}} - \it{ the \ exceptional \ function \ for \ method \ }\texttt{m}  \\
\\
\tt{numArgs}( \texttt{m} ) - \it{ the \  number \ of \ arguments \ of \ }\texttt{m} \\  
\\
e_{j} , j = 1 .. s - \it{ the \ locations \ modified \ by \ method \ }\texttt{m} \\
\\
\tt{Exc_i}, i = 1.. k - \it{ the \ exceptions \ that \ } \texttt{m} \ \it{may \ throw} \\
\\
\phi_{\tt{Exc_i}}, i = 1..k -   \it{is \ the \ precondition } \\
\Myspace   \it{of \ the \  exception \ handler \ protecting \ the \ instruction \  against} \\
\Myspace   \tt{Exc_i} \ \it{\ if \ it \  exists, \ otherwise} \it{if \ the } \ \tt{Exc_i} \ \it{\ is \ not \ handled}    \\
\Myspace      \phi = \excPost( \tt{Exc_i})[ \jmlKey{EXC} \leftarrow \stack{\counter}]
\end{array}
$$
\caption{\wpi \ rule for a call to an instance non void method}
\label{wpInv}
\end{figure}
