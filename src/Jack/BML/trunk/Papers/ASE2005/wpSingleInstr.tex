\subsection{Weakest Precondition for bytecode instructions}\label{wpInstr}
We define a weakest precondition (\wpi) predicate transformer function which takes into account normal and exceptional termination. 
\wpi \ takes three arguments : an instruction, a predicate that is the instruction's normal postcondition $\psi$, a function
from exception types to predicates $\excPost$ ( it returns the specified postcondition in the \jmlKey{exsures} clause for a given exception ~\ref{bclGrammar})  and it returns the weakest predicate such that if it holds in the state when the instruction starts its execution if the instruction terminates its execution normally  $\psi$ must hold in the poststate and if it terminates with an exception \texttt{E} then the predicate $\excPost(\tt{E})$ must hold. The signature of \wpi \ is:
$$\wpi : \texttt{instruction} \rightarrow \predicate \rightarrow (\tt{ ExceptionType} \rightarrow  \predicate) \rightarrow \predicate   $$

 The Java bytecode language is stack based, i.e. the instructions take their arguments from the method execution stack and 
 put the result on the stack. Thus we have to represent the elements of the stack that correspond to the arguments and the result for a given instruction. 
 In the examples at fig.~\ref{instrWP} \stack{\counter} stands for the element on the top of the stack. 
 The instruction $\instr{Type\_load} \ i$  loads on the top of the stack the value of the method local variable with at index \textit{i}
 in the \textbf{Local\_Variable\_Table} (see section ~\ref{bcSpecLg}). The \wpi \ rule for  \instr{Type\_load i} increments the stack
counter \counter \ and puts on \stack{\counter} the contents of the local variable $\register{i}$.
As we said in the beginning of the section \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their 
corresponding semantics. For example the keyword \jmlKey{$\backslash$result} is evaluated only by \instr{Type\_return} 
instructions and if appearing in the postcondition  \jmlKey{$\backslash$ result} is substituted by the element on the top of 
the stack \stack{\counter}. 

 More details can be found in~\cite{WPBC}.
\begin{figure}[ht]

$$
\begin{array}{l}
\wpi(\instr{Type\_return} , \psi, \excPost) =  \\
 \Myspace \psi[\backslash \jmlKey{result} \leftarrow \stack{\counter}] \\
\\
\wpi(\instr{Type\_load} \ i, \psi, \excPost) =  \\
\Myspace \psi[\counter \ \leftarrow \ \counter+1] [\stack{\counter+1} \ \leftarrow \ \register{i}] \\
 \Myspace where \ i \  is \ a \ valid \ entry \ in \\
 \ the \ list \  of \  local \ variables   \\
\\ 
\wpi(\instr{putField}\texttt{Cl.f}, \psi, \excPost) = \\
   ( \Myspace \stack{counter -1} = \Mynull \\
   \Myspace  \Myspace \Rightarrow \psi[\counter \leftarrow \counter-2 ] \\
   \Myspace  \Myspace [\texttt{Cl.f} \leftarrow \texttt{Cl.f}(\oplus [\stack{\counter - 1} \rightarrow \stack{\counter})] ] )\\
   \Myspace  \wedge  \\
   \Myspace  \stack{counter-1} \not= \Mynull \Rightarrow \excPost(\tt{NullPointer}) \\ 
 \end{array} $$

%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } \\
%                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\


%\texttt{wp(Type\_load index,$\psi$)} = $\psi$\texttt{[Stack(t)$\leftarrow$local(index)][t$\leftarrow$t+1]}  \\
%, where the local variable must contain value of type Type
\caption{rules for some bytecode instructions}
\label{instrWP}
%\end{frameit}
\end{figure}

\subsubsection{References: manipulating fields}
Fields are treated as functions, where the domain of a field \texttt{f} 
declared in the class \texttt{Cl} is the set of objects of class \texttt{Cl} and its subclasses.
We are using an overriding function rather in the same fashion as in ~\cite{B00ppp}. 
At fig.~\ref{instrWP} the rule for \instr{putField} substitutes the corresponding field function \texttt{Cl.f} with the overriding function. 
The definition of overriding expression is given at fig.~\ref{override}.

\begin{figure}
$$
 \texttt{Cl.f}(\oplus[e2 \rightarrow e1)])(o) = \left\{ \begin{array} {ll}
						       e1 & if \ e2 = o \\
					               \texttt{Cl.f}(o)	& else 
	\end{array}\right. 
$$ 
\caption{Overriding Function}
\label{override}
\end{figure}
%To illustrate how references are treated we give an example at fig.\ref{aliasing} - a method that assigns to the parameter's instance integer field (we give the example in source code to keep simplicity). 
%The \wpi \ for the method is given at      

%\begin{figure}
%\begin{verbatim}
%public class FieldAssign {
%  public int i = 0;

 % //@requires a != null;
 % //@modifies a.i; 
  %//@ensures i == 5;
 % public void set( FieldAssign a) {
 %   a.i = 3;
 % } 
%}
%\end{verbatim}
%%\caption{Example for recursive Java class}
 %\label{aliasing}
%\end{figure}

\subsubsection{Method calls}
Method calls are substituted by their specification. Method specification is a contract - the precondition of the called method
must be established by the caller at the program point where the method is invoked and its postcondition is assumed to hold after the invocation. Thus the rule for
invocation on an instance non void method is given at the fig ~\ref{wpInv}. In the precondition of the called method the formal parameters and the object on which the method is called are substituted with the first \textit{n+1} elements from the top of stack. As the method returns a value the JML keyword 
\jmlKey{ $\backslash$ result} if present in the postcondition of the called method is substituted with a fresh variable $fresh\_var$ and as the result is put after the execution of the invocation at the top stack $fresh\_var$ is substituted in the postcondition $\psi$. The resulting predicate is quantified over the 
expressions that may be modified by the called method. Here we omit the case when the invocation result in an exception for reasons of limited space. 
The rule for static methods is rather the same except for the number of stack elements taken from the stack.  

\begin{figure}[!ht]
$$
\begin{array}{l}
\wpi(\rm{invoke} \ m, \psi ,\excPost) =\\ 
\begin{array}{l}
\psi^{pre}(m) \wedge \\
 \forall m_{i}. ( i = 1 .. s ) \\
 ( \\
\psi^{post}(m) \\
\phantom{\psi^{post}}[\register{i}  \leftarrow \stack{\counter - i + numArgs(method(ind) ) } ]_{i=0}^n  \\
\phantom{\psi^{post}} [\tt{\backslash result} \leftarrow fresh\_var] \\
\Rightarrow \psi[\counter \leftarrow \counter - numArgs(m)]\\
\phantom{\Rightarrow \psi} [\stack{\counter }  \leftarrow fresh\_var] \\
) \\
%[e_{i} \rightarrow m_{i}]_{i = 1}^s \\
\end{array} \\
\psi^{pre}(m) - the \ specified \ precondition \ of \ method \ m \\
\psi^{post}(m) - the \ specified \ postcondition \ of \ method \ m \\
m_{i} , i = 1 .. s - stands  \ for \ the \ locations \\
\phantom{m_{i} , i = 1 .. s   } modified \ by \ method \ m
\end{array}
$$
\caption{\wpi \ rule for a call to an instance method}
\label{wpInv}
\end{figure}
