\subsection{Weakest Precondition for bytecode instructions}\label{wpInstr}
The weakest precondition (\wpi) calculus is a predicate transformer function which takes two arguments : an instruction and a predicate that is the instruction's postcondition $\psi$ and it returns the weakest predicate such that if it holds in the state when the instruction starts its execution then $\psi$ must hold in the state in which the instruction terminates its execution. The signature of \wpi is:
$$\wpi : \texttt{instruction} \rightarrow \predicate \rightarrow (\tt{ ExceptionType} \rightarrow  \predicate) \rightarrow \predicate   $$

For every instruction \wpi \ symbolically evaluates the values in the prestate of the instruction for the variables that 
are changed by the instruction w.r.t. to their values in the poststate of the instruction and substitues in the postcondition the
 postcondition values with the precondition values. As the bytecode language is stack based, i.e. 
 the instructions take their arguments from the method execution stack and put the result onto the stack. 
 Thus we have to represent the elements of the stack that correspond to the arguments and the result of the instruction. 
 In the examples at fig.~\ref{instrWP} \stack{\counter} stands for the element on the top of the stack. 
 The instruction $\instr{Type\_load} \ i$  loads on the top of the stack the value of the method local variable with at index \textit{i} in the \textbf{Local\_Variable\_Table} (see section ~\ref{bcSpecLg}). The \wpi \ rule for  \instr{Type\_load i} increments the stack
counter \counter \ and puts on \stack{\counter} the contents of the local variable $\register{i}$.
As we said in the beginning of the section \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their corresponding semantics. For example the keyword \jmlKey{$\backslash$result} is evaluated only by \instr{Type\_return} instructions and if appearing in the postcondition  \jmlKey{$\backslash$ result} is substituted by the element on the top of the stack \stack{\counter}. 

 More details can be found in~\cite{WPBC}.
\begin{figure}[ht]

$$
\begin{array}{l}
\wpi(\instr{Type\_return} , \psi, \excPost) =  \\
 \Myspace \psi[\backslash \jmlKey{result} \leftarrow \stack{\counter}] \\
\\
\wpi(\instr{Type\_load} \ i, \psi, \excPost) =  \\
\Myspace \psi[\counter \ \leftarrow \ \counter+1] [\stack{\counter+1} \ \leftarrow \ \register{i}] \\
 \Myspace where \ i \  is \ a \ valid \ entry \ in \ the \ list \  of \  local \ variables   \\
\\ 
\wpi(\instr{putField} \ i, \psi, \excPost) = \\
   \Myspace \stack(counter -1) \not= \Mynull \Rightarrow \psi[\counter   \leftarrow \counter -2]
   \phantom{ aaa \stack(counter -1) \not= \Mynull \Rightarrow}   [  \texttt{ClName.fName}(\stack{\counter - 1} ) \leftarrow   \stack{\counter}] \\
   \Myspace  \wedge  \\
   \Myspace  \stack(counter -1) = \Mynull \Rightarrow \excPost(\texttt{NullPointer}) \\
 where \ i \  is \ a \ valid \ entry \ in \ the \ class \ constant \  pool \ which   \\
 is  \ a \  symbolic \reference \ to \ the \  field  \ with \ name \  \texttt{fName} \\
 from \  class \  \texttt{ClName}
 \end{array} $$

%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } \\
%                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\


%\texttt{wp(Type\_load index,$\psi$)} = $\psi$\texttt{[Stack(t)$\leftarrow$local(index)][t$\leftarrow$t+1]}  \\
%, where the local variable must contain value of type Type
\caption{rules for some bytecode instructions}
\label{instrWP}
%\end{frameit}
\end{figure}

\subsubsection{References: creating objects, updating field values}
As Java is entirely based on references let's see how references are dealt with. 
We are using an overriding function rather in the same fashion as in ~\cite{B00ppp}.If a reference is updated 
we have to keep this information because of possible aliasing
$$
fName(\tt{e_1} ) [fName(\tt{e_2} ) \leftarrow \tt{e_3} ] = \\
$$
$$
\left\{ \begin{array}{ll}
\tt{e_3} & if \ \tt{e_1} == \tt{e_2} \\
fName(\tt{e_1} [fName(\tt{e_2} ) \leftarrow \tt{e_3} ] )(\oplus [ \tt{e_3} \rightarrow  \tt{e_2} ] ) & else 
\end{array} \right.						
$$

We give an example at fig.% \ref{aliasing} for how aliasing is treated. 

%\begin{figure}
%\begin{verbatim}
%public class P {
	%public P a;
	%public int b;
	%//@requires p.b == 3;
	%//@ ensures p.a.a.b == 3;
	%public void m(P p) {
		%p.a = p;
	%}
%}
%\end{verbatim}
%\caption{Example for recursive Java class}
 %\label{aliasing}
%\end{figure}


\subsubsection{Method calls}
