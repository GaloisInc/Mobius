
\section{Introduction}\label{intro}
Safety, security, establishing trust in unknown component are important issues for the mobile code world, i.e. mobile phones, bank cards, id cards and whatever scenario where 
unknown code must be executed. Those questions have received different answers - cryptography to guarantee data integrity or confidentiality,
 digital signatures for establishing that the code originates from a trusted entity, bytecode verification that checks if the bytecode is well structured(e.g. no jumps outside the bytecode array) and well typed, proof carrying code for establishing once again type properties for assembly language.  

Still downloading and installing untrusted software components may require more than guaranteeing that the code issuer is trusted, or that the code is well typed and well structures, i.e. the code receiver may be willing to establish that the component respects some functional properties or does not break certain security policy. 
A typical example is when the receiver site gets an interface implementation and wants to check the latter against the interface specification. Another scenario may be when the receiver requires some safety condition for the unknown code, e.g. no nested transactions or no exceptions may be thrown.  
We reply to those problems by defining a bytecode logic in terms of weakest precondition calculus for the sequential Java bytecode language. The logic rules out almost all Java bytecode instructions except for 64 bit data and floating point arithmetic and supports all the Java specific features - exceptions, references, methods and subroutines. The verification is modular  -  every method from the application is checked separately against its specification. In order to make the process automatic we define a bytecode specification language here called BCL and supply a compiler from the high level Java specification language JML ~\cite{JMLRefMan} to BCL. BCL supports a JML subset which is expressive to specify complex functional properties. The specification then is inserted in the class file format in extension attributes, thus making not only the code mobile but also its specification.

We have implementations of a verification condition generator based on the weakest precondition calculus and the JML specification compiler. Both are integrated in the Java Applet Correctness Kit(JACK) ~\cite{BRL-JACK} - a plugin for the eclipse integrated development environment for Java.

In what follows, the sections and their corresponding topics are: 
section ~\ref{architecture_s} proposes scenarios in which the architecture is appropriate to use; section ~\ref{relWork} is an overview of related works; 
section  ~\ref{prelim} is a short description of the JML specification language; section ~\ref{bcSpecLg} presents the bytecode specification language BCL and the JML compiler; section ~\ref{verifCond} explains how the weakest precondition calculus works giving definitions and example; section ~\ref{conclusion} concludes with future work.  















