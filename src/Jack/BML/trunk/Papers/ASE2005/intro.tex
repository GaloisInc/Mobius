
\section{Introduction}\label{intro}
Safety, security and establishing trust in untrusted component are important issues for the mobile code world, 
i.e. mobile phones, bank cards, ID cards and whatever scenario where 
untrusted code must be executed. Those questions have received different answers - cryptography to guarantee data integrity or confidentiality,
 digital signatures for establishing that the code originates from a trusted entity, bytecode verification that checks if the bytecode 
 is well structured(e.g. no jumps outside the bytecode array) or well typed, 
 the proof carrying code framework  and the certifying compiler ( see  \cite{ComNec},\cite{DesNecLee98} ) for establishing once 
 again type properties for assembly programs.  

%Still downloading and installing untrusted software components (which is not accompanied by its source code) may require 
%more than guaranteeing that the code issuer is trusted, or that the code is well typed / structured, i.e. the code receiver may be willing to establish that the component respects 
%some functional properties or does not break certain security policy. 
%A typical example is when the receiver site gets an interface implementation and wants to check the latter against the interface 
%specification. Another scenario may be when the receiver requires some safety condition for the untrusted code.  These situations
%can be resolved by using program logic for low level programs.


The Java technology finds a large use in mobile and embedded applications because of its portability across platforms. In particular its dialect JavaCard is largely used in mobile phone and smartcard applications. 

In this article we propose a static verification technique using formal methods for sequential Java bytecode programs.
We define a bytecode logic in terms of weakest precondition calculus for the sequential Java bytecode language. The logic rules out 
almost all Java bytecode instructions and supports the Java specific features like 
exceptions, references, method calls and subroutines.  
 
 %The verification is modular  -  every method from the application is checked separately against its specification. 
 In order to make the process automatic we define a bytecode specification language here called BCSL and supply a compiler from 
 the high level Java specification language JML ~\cite{JMLRefMan} to BCSL. 
 BCSL supports a JML subset which is expressive enough to specify complex functional properties. The specification then is 
 inserted in the class file format in extension attributes, thus making not only the code mobile but also its specification. These class
 file extensions do not affect the JVM performance.

We have implementations of a verification condition generator based on the weakest precondition calculus and the JML 
specification compiler. Both are integrated in the Java Applet Correctness Kit(JACK) ~\cite{BRL-JACK}. The tool is a plugin 
for the eclipse \todo{referenced - the eclipse site} integrated development environment for Java which uses formal methods for
statically checking Java programs againts their JML specification. The tool can interface several theorem provers (AtelierB, 
Simplify, Coq, PVS ) \todo{references}. Jack has a user friendly interface which makes it easy for use by developers that do not have
a large background in formal methods.

In what follows, the sections and their corresponding topics are: 
section ~\ref{architecture_s} reviews scenarios in which the architecture is appropriate to use; section  ~\ref{prelim} is a short description of the JML specification language; section ~\ref{bcSpecLg} presents the bytecode 
specification language BCSL and the JML compiler; section ~\ref{wpbc} explains how the weakest precondition calculus 
works illustrating it with definitions and an example; in this section we also give the verification conditions that are generated for 
proving program correctness; section ~\ref{relWork} provides an overview of related works; section ~\ref{conclusion} concludes with future work.  















