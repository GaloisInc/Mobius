
\section{Comparison between source and bytecode proofs}  \label{results}

The purpose of this section is to give a comparison between bytecode and source proof obligations.
In particular, we illustrate this by the proof obligations of the example program in Fig.\ref{replaceSrc}.
%We have an implementation of the JML compiler ( subsection \ref{comJML}) and the bytecode verification condition generator based on the weakest precondition calculus (Section \ref{wpbc}) which are integrated in JACK. Both of the verification condition generators perform the same simplifications over the verification conditions 
%, e.g. eliminate verification conditions that contain contradictory hypothesis or trivial goals (equal to true). 

%The performed tests show that JML compilation augments around twice the file size. 
%For the example in Fig.~\ref{replaceSrc}, the class file without the specification extensions is 548 bytes, 
%and the class with the BCSL extension BCSL is 954 bytes. 
%The size of the bytecode specification is proportional to the source specification: 
%the bigger is the source specification, the greater will be the size of the class file. 
We studied the relationship between the source code proof obligations generated 
by the standard feature of JACK and the bytecode proof obligations generated by our implementation over the corresponding bytecode
 produced by a non optimizing compiler over the examples given in \cite{JPVC03JKM}. The proof obligations were the same modulo 
program variables names and basic types.

 We return now to our example from the previous sections and give in Fig. \ref{vcEnsures} one of the proof obligations on source 
and bytecode level respectively concerning the postcondition correctness. The verification conditions on bytecode and source level
 have the same shape modulo names (Section \ref{comJML}). Also in Section
 \ref{comJML}, we discussed the compilation of the JML postcondition from Fig. \ref{replaceSrc}. In particularly,
 we saw that the compiler has to transform the source postcondition in an equivalent formula and we
 gave the compilation in Fig. \ref{postCompile}. 

Despite those transformations, the source and bytecode goal respectively (which are actually the postcondition) on bytecode and source level are not only
semantically equivalent but syntactically the same (except for the variable names ). Still, in the bytecode proof obligation we have one more hypothesis than on source level. The extra hypothesis in the bytecode proof obligation is related to the fact that the result type is boolean but the JVM encodes boolean expressions as integers (which is trivially true). This means that the proof obligations have also the same shape.

 Another important issue is the impact of simple optimizations like dead code elimination on the relationship between source and bytecode proof obligations. 
In this case, the compiler does not generate the dead code and the bytecode verification condition generator will neither ``see'' it. 
Even though the source contains the never taken branch as the condition is equivalent to false, this will result in a trivially true
verification condition which the JACK source verification condition generator will discard.

The equivalence between source and bytecode proof obligations can be exploited in PCC scenarios, as we discussed in Section \ref{architecture}. 
We aim to formally give evidence that the proof obligations on non optimized bytecode and source programs are syntactically the same (modulo names and types). 

%Fig. \ref{vcLoopPreserv} shows the proof obligations for the loop preservation. As you can see the hypothesis and the goal have the same ``shape'' on bytecode and source code and the differences are due to the variable names.



% \begin{figure}{!h}

% $$\begin{array}{ll}
%Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
%% & \\

%
%\begin{array}{l}
% \register{1} \neq \\
%\#19 (\register{0})[\register{2}\_at\_ins\_22]
%\end{array}  
%
%&  
%\begin{array}{l}
% \srcVar{obj} \neq \\
%  ListArray.list(\this)[\srcVar{i}\_at\_ins\_26] 
%\end{array}   \\
%
%
%
% & \\
%
%\#19(\register{0}) \neq \Mynull &  ListArray.list( \this) \neq \Mynull\\
%
%
%& \\
%
%\begin{array}{l}
%  len(\#19 (\register{0})) > \\
% \register{2}\_at\_ins\_22 
%\end{array}
%%& 
%\begin{array}{l}
%  len(ListArray.list(\this)) > \\
%\srcVar{i}\_at\_ins\_26
%\end{array}         \\ 

%

% & \\
%
% \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26    \geq 0    \\
%
%
% & \\
%\begin{array}{l}
%  \register{2}\_at\_ins\_22 < \\
%  len(\#19(\register{0}))
%\end{array} &
%
%\begin{array}{l}
%  \srcVar{i}\_at\_ins\_26 <\\
%  len(ListArray.list(\this))
%\end{array}   \\
%
%
% & \\
%\begin{array}{l}
%  \register{2}\_at\_ins\_22 \leq \\
%  len( \#19(\register{0}))
%\end{array} 
%&  
%\begin{array}{l} 
%  \srcVar{i}\_at\_ins\_26 \leq \\
%  len(ListArray.list(\this))
%\end{array}   \\
%
%
% &\\
%% \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26 \geq 0 \\
%
%
%
%% &\\
% \begin{array}{l} 
%         \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\register{2}\_at\_ins\_22) \Rightarrow \\
%                \Myspace    \#19(\register{0})[var(0)] \neq \register{1}
%      \end{array} &        
%      \begin{array}{l} 
%             \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\srcVar{i}\_at\_ins\_26) \Rightarrow \\
%                 \Myspace       ListArray.list(\this)[var(0)] \neq \srcVar{obj}
%      \end{array}  \\
%%
% typeof(\register{0}) <: ListArray &    typeof(this) <: ListArray     \\
%
%& \\
%& \\
%Goal \ on \ bytecode: & Goal \ on \ source \ level: \\
%
%& \\
%
%  \begin{array}{l}
%               1 + \register{2}\_at\_ins\_22 \leq  len(ListArray.list(\register{0}))  \\
%
%               1 + \register{2}\_at\_ins\_22 \geq 0 \\
%
%               \forall  var(0). 0 \leq var(0) \wedge var(0) < 1 + \register{2}\_at\_ins\_22 \Rightarrow \\
%                   \Myspace  ListArray.list(\register{0})[var(0)] \neq \register{1} 
%
%       \end{array}
%& 
%
%       \begin{array}{l}
%             1 + \srcVar{i}\_at\_ins\_26 \leq  len(ListArray.list(this))  \\
%	     \\
%             1 + \srcVar{i}\_at\_ins\_26 \geq 0 \\
%	     \\
%             \forall  var(0). 0 \leq var(0) \wedge\\
%	     \Myspace  var(0) < 1 + \srcVar{i}\_at\_ins\_26 \Rightarrow \\
%                  \Myspace  ListArray.list(this)[var(0)] \neq \srcVar{obj} 
%       \end{array}   
%
 
%\end{array}$$



%\caption{Source and Bytecode verification condition for loop preservation for method \texttt{ListArray.isElem} }
%\label{vcLoopPreserv}
%\end{figure}








\begin{figure}[!h]


\begin{tabular}{|l|l|}
\hline
Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
\hline 
$\register{2}\_at\_ins\_20 \geq $ 
& $ \srcVar{i}\_at\_ins\_26 \geq$ \\

$len(\#19(\register{0})) $ & $  len(ListArray.list(\this)) $ \\
\hline 

$\#19(\register{0}) \neq \Mynull$ 
& $ ListArray.list(\this) \neq \Mynull$ \\

\hline 
$ \register{2}\_at\_ins\_20) \leq$ 
&  $  \srcVar{i}\_at\_ins\_26  \leq   $ \\
$ len(\#19(\register{0}))  $ & $ len(ListArray.list(\this))  $ \\
\hline

$\register{2}\_at\_ins\_20 \geq 0  $ 
& $ \srcVar{i}\_at\_ins\_26  \geq 0 $ \\

\hline

$\forall  var(0). \  0 \leq var(0) \wedge  $ & $\forall  var(0). \  0 \leq var(0) \wedge $ \\
$ var(0) < \register{2}\_at\_ins\_20 \Rightarrow $ & $  var(0) < \srcVar{i}\_at\_ins\_26 \Rightarrow $\\
$ \#19(\register{0})[var(0)] = \register{1}   $ & $  ListArray.list(\this)[var(0)] = \srcVar{obj}  $ \\

\hline

 $typeof(\register{0}) <: ListArray$ & $typeof( \this) <:  ListArray$  \\
\hline

$0=0 \vee 0=1$ & \\

& \\

\hline
Goal on bytecode: & Goal on source level: \\
\hline
$\Myfalse  \iff $ & $\Myfalse \iff  $ \\
 $ \exists  var(0) . \ 0 \leq var(0) \wedge$ 
& $ \exists  var(0) . \ 0 \leq var(0) \wedge$ \\

$\Myspace \Myspace var(0) < len(\#19(\register{0})) \wedge$ 
& $\Myspace \Myspace  var(0) < len(ListArray.List(this)) \wedge $\\
       
$\Myspace \Myspace \#19(\register{0})[var(0)] = \register{1} $ 
&$\Myspace \Myspace  ListArray.List(this)[var(0)] = \srcVar{obj}  $ \\

\hline
\end{tabular}
\\
Note: $\expression\_at\_ins\_n$ denotes the value of  
expression $\expression$ at the bytecode instruction at index (source line)  $n$ \\

\caption{Source and Bytecode verification condition for one case of the postcondition correctness }
\label{vcEnsures}
\end{figure}
 















%\subsubsection{Example}
% We give a simple example of how the \wpi \ works. Block $\blockm{6}$ (starts at instr. \texttt{6}) in Fig.~\ref{blockBC} ends with a branching instruction and in the case when the condition is true (the current element of the array is not equal to the first parameter of the method \texttt{replace}) the execution will continue at $\blockm{19}$. Below we give the part of the weakest precondition for block $\blockm{6}$ in case the control flows to block $\blockm{19}$( the condition of its last instruction holds and in this case 
%the predicate $pre(b^{6}, b^{19})$ is $\wpi(\blockm{19})$).  The implications with conclusion \Myfalse \ stand for the possible exceptions \texttt{NullPointer} and \texttt{ArrayIndexOutOfBound} exceptions that may be thrown (as no postcondition is specified explicitly for these cases of abnormal termination, the one by default is taken). 

%\input wpExample.tex
