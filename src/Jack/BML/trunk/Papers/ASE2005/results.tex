
\subsection{Results}  \label{results}


We have an implementation of the JML compiler \ref{comJML} and the bytecode verification condition generator based on the weakest precondition calculus (Section \ref{wp}) 
which are integrated in JACK. 

The performed tests show that JML compilation augments around twice the file size. 
For the example given at fig.~\ref{replaceSrc}, the class file without the specification extensions is 548 bytes, 
and the class with the BCSL extension BCSL is 954 bytes. 
Another important point about the size of the bytecode specification is that it is proportional to the source specification: 
the more specific is the specification, the greater will be the size of the class file. 


We studied the relationship between the source code proof obligations generated 
by the standard feature of JACK and the bytecode proof obligations generated by our implementation over the corresponding bytecode produced by a nonoptimizing compiler.  
Basically, they are the same modulo the names of the program variables.

 We illustrate these differences by giving the proof obligations on source and bytecode level respectively of the example program from the previous sections. In particular, Fig. \ref{vcLoopPreserv} gives a comparison between the proof obligation for invariant preservation and  Fig. \ref{vcEnsures} compares the source and bytecode proof obligation
 for one of the cases of the postcondition correctness (as there are several return instructions).

The verification conditions on bytecode and source level for the postcondition  correctness given in Fig. \ref{vcEnsures}
 have the same shape modulo names (see Section \ref{comJML} for how method local variables and field names are compiled).
In Section \ref{comJML} we showed that the postcondition for our example was compiled by performing structural transformations 
in an equivalent expression. Despite those changes, the goals (which is actually the postcondition) on bytecode and source level are not only equivalent
but structurally the same. Still, in the bytecode proof obligation we have one more hypothesis than on source level. The extra hypothesis in the bytecode
version of the proof obligation is related to the fact that the result type is boolean but the JVM encodes boolean expressions as integers.

Fig. \ref{vcLoopPreserv} shows the proof obligations for the loop preservation. As you can see the hypothesis and the goal have the same ``shape'' on bytecode and source code and the differences are due to the variable names.



\begin{figure}{!h}

$$\begin{array}{ll}
Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
 & \\


\begin{array}{l}
 \register{1} \neq \\
\#19 (\register{0})[\register{2}\_at\_ins\_22]
\end{array}  

&  
\begin{array}{l}
 \srcVar{obj} \neq \\
  ListArray.list(\this)[\srcVar{i}\_at\_ins\_26] 
\end{array}   \\



 & \\

\#19(\register{0}) \neq \Mynull &  ListArray.list( \this) \neq \Mynull\\


& \\

\begin{array}{l}
  len(\#19 (\register{0})) > \\
 \register{2}\_at\_ins\_22 
\end{array}
& 
\begin{array}{l}
  len(ListArray.list(\this)) > \\
\srcVar{i}\_at\_ins\_26
\end{array}         \\ 



 & \\

 \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26    \geq 0    \\


 & \\
\begin{array}{l}
  \register{2}\_at\_ins\_22 < \\
  len(\#19(\register{0}))
\end{array} &

\begin{array}{l}
  \srcVar{i}\_at\_ins\_26 <\\
  len(ListArray.list(\this))
\end{array}   \\


 & \\
\begin{array}{l}
  \register{2}\_at\_ins\_22 \leq \\
  len( \#19(\register{0}))
\end{array} 
&  
\begin{array}{l} 
  \srcVar{i}\_at\_ins\_26 \leq \\
  len(ListArray.list(\this))
\end{array}   \\


 &\\
 \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26 \geq 0 \\



 &\\
 \begin{array}{l} 
         \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\register{2}\_at\_ins\_22) \Rightarrow \\
                \Myspace    \#19(\register{0})[var(0)] \neq \register{1}
      \end{array} &        
      \begin{array}{l} 
             \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\srcVar{i}\_at\_ins\_26) \Rightarrow \\
                 \Myspace       ListArray.list(\this)[var(0)] \neq \srcVar{obj}
      \end{array}  \\

 typeof(\register{0}) <: ListArray &    typeof(this) <: ListArray     \\

& \\
& \\
Goal \ on \ bytecode: & Goal \ on \ source \ level: \\

& \\

  \begin{array}{l}
               1 + \register{2}\_at\_ins\_22 \leq  len(ListArray.list(\register{0}))  \\

               1 + \register{2}\_at\_ins\_22 \geq 0 \\

               \forall  var(0). 0 \leq var(0) \wedge var(0) < 1 + \register{2}\_at\_ins\_22 \Rightarrow \\
                   \Myspace  ListArray.list(\register{0})[var(0)] \neq \register{1} 

       \end{array}
& 

       \begin{array}{l}
             1 + \srcVar{i}\_at\_ins\_26 \leq  len(ListArray.list(this))  \\
	     \\
             1 + \srcVar{i}\_at\_ins\_26 \geq 0 \\
	     \\
             \forall  var(0). 0 \leq var(0) \wedge\\
	     \Myspace  var(0) < 1 + \srcVar{i}\_at\_ins\_26 \Rightarrow \\
                  \Myspace  ListArray.list(this)[var(0)] \neq \srcVar{obj} 
       \end{array}   

 
\end{array}$$



\caption{Source and Bytecode verification condition for loop preservation for method \texttt{ListArray.isElem} }
\label{vcLoopPreserv}
\end{figure}








\begin{figure}[!h]
$$\begin{array}{ll}
Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
 & \\

\begin{array}{l}
   \register{2}\_at\_ins\_22 \geq \\
   len(\#19(\register{0}))
\end{array} &

\begin{array}{l}
   \srcVar{i}\_at\_ins\_26 \geq \\
   len(ListArray.list(\this))
\end{array} \\
& \\


\#19(\register{0}) \neq \Mynull & ListArray.list(\this) \neq \Mynull \\

 & \\
\register{2}\_at\_ins\_22) \leq len(\#19(\register{0})) &    \srcVar{i}\_at\_ins\_26  \leq  len(ListArray.list(\this)) \\
& \\

\register{2}\_at\_ins\_22 \geq 0 &    \srcVar{i}\_at\_ins\_26  \geq 0  \\
& \\

\begin{array}{l}
   \forall  var(0). \  0 \leq var(0) \wedge  \\
   \Myspace var(0) < \register{2}\_at\_ins\_22 \Rightarrow \\
   \#19(\register{0})[var(0)] = \register{1} 
\end{array} 
& 
\begin{array}{l}
   \forall  var(0). \  0 \leq var(0) \wedge \\
        \Myspace var(0) < \srcVar{i}\_at\_ins\_26 \Rightarrow \\
   ListArray.list(\this)[var(0)] = \srcVar{obj} 
\end{array} 

\\

& \\
 typeof(\register{0}) <: ListArray & typeof( \this) <:  ListArray  \\

& \\

0=0 \vee 0=1 & \\
& \\
& \\
Goal \ on \ bytecode: & Goal \ on \ source \ level: \\

& \\
   \begin{array}{l}
       \Myfalse  \iff \exists  var(0) . \ 0 \leq var(0) \wedge \\
       var(0) < len(Binc.\#19(\register{0})) \wedge\\
       \#19(\register{0})[var(0)] = \register{1}  
   \end{array}

&
  \begin{array}{l}
       \Myfalse \iff \exists  var(0) . \ 0 \leq var(0) \wedge \\
       var(0) < len(Binc.ListArray.List(this)) \wedge\\
       \#19(this)[var(0)] = \srcVar{obj}  

  \end{array}
\end{array}
$$

\caption{Source and Bytecode verification condition for one case of the postcondition correctness }
\label{vcEnsures}
\end{figure}
 















%\subsubsection{Example}
% We give a simple example of how the \wpi \ works. Block $\blockm{6}$ (starts at instr. \texttt{6}) in Fig.~\ref{blockBC} ends with a branching instruction and in the case when the condition is true (the current element of the array is not equal to the first parameter of the method \texttt{replace}) the execution will continue at $\blockm{19}$. Below we give the part of the weakest precondition for block $\blockm{6}$ in case the control flows to block $\blockm{19}$( the condition of its last instruction holds and in this case 
%the predicate $pre(b^{6}, b^{19})$ is $\wpi(\blockm{19})$).  The implications with conclusion \Myfalse \ stand for the possible exceptions \texttt{NullPointer} and \texttt{ArrayIndexOutOfBound} exceptions that may be thrown (as no postcondition is specified explicitely for these cases of abnormal termination, the one by default is taken). 

%\input wpExample.tex
