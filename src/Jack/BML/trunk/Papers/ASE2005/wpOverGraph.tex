

\subsection{Bytecode Weakest Precondition}\label{wpGraph}

In the following we overload the function symbol \wpi \ applying it to a method, i.e. the verification condition generation for a method is defined over its acyclic execution graph.
The \wpi \ function runs in a backwards direction starting from the blocks that do not have successors up to reaching the entry point
 instruction. We distinguish the \wpi \ calculus over  a method's body bytecode, a bytecode block and a sequence of bytecode instructions.

\paragraph{The weakest precondition $\wpi(\tt{m})$ for method \texttt{m}} is the weakest precondition of its entry block $\blockm{entry}$. 
 $$\wpi(\tt{m}) = \wpi(\blockm{entry})$$%, \blockPost{entry}, \excPost(m) ) $$
%

%


\paragraph{The weakest precondition for a bytecode block} is calculated splitting the block in two parts: its last instruction and its sequential part (the instruction sequence without the last one).
Let call $\blockSeq{i}$ the sequential part of block $\blockm{i}$ and $\blockPost{i}$ the precondition of its last instruction, the weakest precondition of $\blockm{i}$ is then defined as follows:

$$ \wpi(\blockm{i}) = \wpi( \blockSeq{i}, \blockPost{i}, \excPost ) $$

Concerning the sequential part, the \wpi \ is calculated applying the standard $\wpi$ rule for compositional statements :
\begin{center}
$ \begin{array}{l} \wpi( instrList;i_{j}, \psi,\excPost ) = \\ \wpi(instrList, \wpi(i_{j}, \psi,\excPost ),\excPost ) \end{array} $
\end{center}
%Calculating the precondition of the sequential part of the block $\blockm{i}$ which we denote with  $\blockSeq{i}$  is standard - the precondition of an instruction  is inferred from the precondition of the previous one.=
Let define now the precondition of the last instruction of a block. This precondition depends on the blocks that can be executed after it. The definition will be notably different if a successor is an entry point of a loop or not. Thus, definition \ref{post} defines the precondition in function of the last instruction and the precondition of the successor block. This precondition depends on the relation between the two blocks (the current and the successor), it is defined in definition \ref{post2}, we call it $pre(b^{i}, b^{n})$ standing for the precondition of block n when it is executed after block i..
%The postcondition $\blockPost{i}$ is calculated recursively starting from the blocks that do not have successors upon the specified method's postcondition  $\psi^{post}(m)$ and exceptional postcondition $\excPost (m)$.
 
%It is actually the conjunction of the preconditions of the block successors and it depends on the last instruction of the block.

\begin{defn}[Last instruction block precondition]\label{post}
 Let $\tt{ins}_s$ be the last instruction of $\ \blockm{i} $ then:
 \begin{itemize} 
 
 \item if  $\tt{ins}_s$ =  \instr{if\_cond n} \\
$$
\blockPost{i} =  \\
\left\{
\begin{array}{l}
cond( \stack{\counter}, \stack{\counter - 1} )   \Rightarrow \\
\phantom{ \counter }   pre(b^{i}, b^{n})[ \counter \leftarrow \counter -2 ]  \\
\wedge \\
 not ( cond( \stack{\counter}, \stack{\counter - 1} )  )   \Rightarrow \\
\phantom{ \counter}    pre(b^{i}, b^{s+1})[ \counter \leftarrow \counter -2 ]      \\                             
\end{array}
\right.
$$
\item if  $\tt{ins}_s$ =  \instr{goto n} \\ 
$\blockPost{i} =  pre(b^{i}, b^{n})$ \\

\item  if  $\tt{ins}_s$ =  \instr{athrow} \\ 
	\begin{enumerate}
\item if there exists a block $\blockm{e}$ such that 
$\blockm{i} \execRel^A \blockm{e}$ (i.e. an exception handler protects the type of the exception thrown)
then :\\
$\blockPost{i }=$\\
$ pre(b^{i}, b^{e})[\counter \leftarrow 0][\EXC \leftarrow \stack{\counter}] $. \\
\item Otherwise the thrown exception is not handled and then $\blockm{i}$ must respect the postcondition determined by
the exceptional postcondition function $\excPost$ for this exceptional type:\\ %(or if not specified for the closest supertype) : \\ 
 $\blockPost{i }=$\\ $\excPost(\stack{\counter}) [\counter \leftarrow 0][\EXC \leftarrow \stack{\counter}] $. \\
see in section \ref{grammar} for the meaning of \EXC.
    \end{enumerate}
%The only thing that is known about the exception thrown is that it is 
 % on the top of the stack $\stack{\counter}$. We keep track of all the possible postconditions (as the exception
%may be caught by an exception handler starting at $\blockm{e}$ or it is thrown and thus the exceptional postcondition for 
%the exception must hold) up to
%discovering the type of the thrown exception and then identifying the adequate predicate 
%that must hold after the execution of the \instr{athrow} instruction. 
\item  if  $\tt{ins}_s$ = \instr{return} \\
$$
   \blockPost{i } = \psi[\result \leftarrow \stack{\counter} ]    
$$
where $\psi $ is the specified method postcondition.
\item  else  \\[3 mm]
 $ \blockPost{i} =$  \\ $\wpi(  \tt{ins}_s , pre(b^{i}, b^{s+1}) , \excPost)  $
 \end{itemize}

\end{defn}

\begin{defn}[precondition of a block]\label{post2}
$pre(b^{i}, b^{n})$ is the precondition of the block n when it is executed after the block i.
\begin{itemize}

\item if \ $\blockm{i} \execRel^l \blockm{n}$ 
%if  $\tt{ins}_s$ is a loop end instruction \footnote{loop entry and loop end instructions are identified when building the acyclic control flow graph} of a loop with invariant $\invariant$ 
then the loop invariant has to be proven:
$$
pre(b^{i}, b^{n}) =  \invariant
$$

\item else if $\ \blockm{n}$ is a loop entry then the corresponding loop invariant $\invariant$ must hold before $\blockm{n}$ is executed, i.e. after the execution of $\blockm{i}$. We also require as postcondition that \invariant \ implies the weakest precondition of the loop entry instruction. The implication is quantified over the locations $m_i , i= 1..s$ that may be modified in the loop.
% These locations are specified by the \jmlKey{loop\_modifies} loop specification entry (see section \ref{bclGrammar}). The quantification thus allows to initialize the free expressions applying the \textit{wp} and this prevents us from writing large loop invariants.

$$
pre(b^{i}, b^{n}) = \invariant \ \wedge \ \forall_{i = 1..s} m_i.(
\invariant \Rightarrow \wpi(\blockSeq{l},\blockPost{l},\excPost))
$$
\item else the precondition is the classical precondition of the block n. 
$$
pre(b^{i}, b^{n}) = \wpi( \blockSeq{n} ,  \blockPost{n}, \excPost)
$$
\end{itemize}
\end{defn}
Subroutines are treated by in-lining. As we stated in the beginning we assume that the bytecode has been certified by a Java
bytecode verifier thus our analysis for identifying  subroutines is not a problem.  


\subsection{Verifying Java Bytecode Programs} Bytecode programs represent a set of Java classes. Establishing the correctness of Java bytecode program w.r.t. to their specification thus, consists in generating verification conditions for every method appearing in every class of the bytecode program.
The verification procedure for a method \texttt{m} consists in  calculating the weakest precondition $\wpi(\tt{m})$ upon its specification: precondition $\psi^{pre}(m)$, 
postcondition $\psi^{post}(\tt{m})$ and the mapping between exceptional types and predicates $\excPost(\tt{m})$ and then prove the condition: 
$$
\psi^{pre}(m)  \Rightarrow \wpi(m)
$$    

\paragraph{Example} We give a simple example of how the \wpi \ works. Block $\blockm{6}$ (starts at instr. \texttt{6}) in fig.\ref{blockBC} ends with a branching instruction and in the case when the condition is true (the current element of the array is not equal to the first parameter of the method \texttt{replace}) the execution will continue at $\blockm{19}$. Below we give the part of the weakest precondition predicate of $\blockm{6}$ when the condition of its last instruction holds - in this case the postcondition of the block is the precondition of $\blockm{19}$ which is an end of a loop and thus its postcondition is the loop invariant. The implications with conclusion \Myfalse \ stand for the possible exceptions \texttt{NullPointer} and \texttt{ArrayIndexOutOfBound}  exceptions that may be thrown. 



\input wpExample.tex


%\paragraph{Example} We give a simple example of how the \wpi \ works. Looking at fig. \ref{blockBC} we calculate the weakest precondition of the basic block starting at instruction \texttt{19} (it ends with the same instruction). In particular this block is a loop end block, thus its postcondition is
%the invariant as specified for this loop in the loop attribute.

% $$
%\wpi(\blockm{19}) = \\
%\left\{ \begin{array}{l}    
%1 + \register{3} <= length(\#19(\register{0}) \wedge \\
     %                 1 + \register{3} >= 0)  \wedge \\ 
 %                       \forall  var_0:int  (  0 <= var_0 \wedge \\
   %                 \Myspace    var_0 < 1 + \register{3}  \Rightarrow \\
  %              \Myspace \Myspace \#19(\register{0})[var_0] \neq \register{1})
%\end{array}
%\right.
%$$
%In the example the rule for the instruction \texttt{iinc 3} is applied which increments the \texttt{3$^{th}$} register of the method bytecode. 

%\begin{center} \texttt{wp(instruction\_list;instruction, $\psi$)} = \texttt{wp(instruction\_list, wp(instruction, $\psi$))} \end{center}
%For example for the sequence of instructions of the block starting with $\tt{instr_{18}}$ from Figure~\ref{blockBC} we calculate
%\begin{center}
%\texttt{wp( iload\_2; ireturn,  $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ )}
%\\
%=
%\\
%\texttt{wp(iload\_2, wp( ireturn, $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ ))} \end{center}
%Thus the weakest precondition for the block starting at $\tt{instr_{18}}$ at figure~\ref{blockBC} is
%\texttt{local(2) $\ulcorner$==$\urcorner$ $\ulcorner$ $\backslash$ old(n)div 2 $\urcorner$}

