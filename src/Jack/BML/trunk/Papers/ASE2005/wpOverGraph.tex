

\subsection{Bytecode Weakest Precondition}\label{wpGraph}

In the following we overload the function symbol \wpi \ applying it to a sequence of bytecode instructions.
 The verification condition generation is defined over the acyclic execution graph of a method. 
The \wpi \ function runs in a backwards direction starting from the blocks that do not have predecessors up to reaching the entry point
 instruction. We distinguish the \wpi \ calculus over  a method's body bytecode, a bytecode block and a sequence of bytecode instructions.

\paragraph{The weakest precondition $\wpi(\tt{m})$ for method \texttt{m}}  is the weakest precondition of its entry block $\blockm{entry}$ and its postcondition $\blockPost{entry}$ which is calculated recursively starting from the blocks that do not have successors upon the specified method's postcondition  $\psi^{post}(m)$ and exceptional postcondition $\excPost (m)$ :
 $$\wpi(\tt{m}) = \wpi(\blockSeq{entry}, \blockPost{entry}, \excPost ) $$


\paragraph{Weakest precondition for a bytecode block} If $\blockSeq{i}$ is the sequential part of block $\blockm{i}$ (without its last instruction ) and  $\blockPost{i}$ is its postcondition, the weakest precondition of $\blockm{i}$ is defined as follows:

$$ \wpi(\blockm{i}) = \wpi( \blockSeq{i}, \blockPost{i}, \excPost ) $$
 
Thus to get the \wpi \ for a block its postcondition should be known. A block postcondition is actually the conjunction of the preconditions
of its successors and it depends on the last instruction of the block.

\begin{defn}[Block postcondition  $\blockPost{i}$]\label{post}
 If $\blockm{i}$ ends with instruction $ins_s$ then:
 \begin{itemize} 

\item if  $ins_s$ is a loop end instruction \footnote{loop entry and loop end instructions are identified when building the acyclic control flow graph} of a loop with invariant \invariant \ then 
$$
\blockPost{i} =  \wpi( ins_s, \invariant, \excPost ) 
$$

\item if \ $\blockm{i} \execRel^A \blockm{l}$ where $\blockm{i}$ is not a loop end and  $\blockm{l}$ is a loop entry  then the corresponding loop invariant \invariant \ must hold before $\blockm{l}$ is executed, i.e. after the execution of $\blockm{i}$. We also require as postcondition that \invariant \ implies the weakest precondition of the loop entry instruction. The implication is quantified over the locations $m_i , i= 1..s$ that may be modified in the loop. These locations are specified by the \jmlKey{loop\_modifies} loop specification entry  see \ref{bclGrammar}. The quantification thus allows to initialize the free expressions applying the \textit{wp} and this prevents us from writing large loop invariants.

$$
\blockPost{i} = \wpi(ins_s, \phi, \excPost) \\
$$
where \\
$$
\phi = \\
\left\{
\begin{array}{l}
\invariant \ \wedge \ \forall m_i (i = 1..s ) (\\
\invariant \Rightarrow \wpi(\blockSeq{l},\blockPost{l},\excPost))
\end{array}
\right.
$$
  
 \item if  $ins_s$ =  \instr{if\_cond n} \\
$$
\blockPost{i} =  \\
\left\{
\begin{array}{l}
cond( \stack{\counter}, \stack{\counter - 1} )   \Rightarrow \\
\phantom{ \counter }   \wpi(\blockSeq{n}, \blockPost{n} ,\excPost )[ \counter \leftarrow \counter -2 ]  \\
\wedge \\
 not ( cond( \stack{\counter}, \stack{\counter - 1} )  )   \Rightarrow \\
\phantom{ \counter}    \wpi(\blockSeq{i+1}, \blockPost{i+1},\excPost ) [ \counter \leftarrow \counter -2 ]      \\                             
\end{array}
\right.
$$
\item if  $ins_s$ =  \instr{goto n} \\ 
$\blockPost{i} =  \wpi(\blockSeq{n}, \blockPost{n} , \excPost )$ \\

\item  if  $ins_s$ =  \instr{athrow} \\ 
	\begin{enumerate}
\item if there exists a block $\blockm{e}$ such that 
$\blockm{i} \execRel^A \blockm{e}$ (i.e. an exception handler protects the type of the exception thrown)
then :\\
$\blockPost{i }= \\ \wpi(\blockSeq{e}, \blockPost{e} ,\excPost)[\counter \leftarrow 0]$\\
\Myspace \Myspace \Myspace  \Myspace  \Myspace  \Myspace  \Myspace  $[EXC \leftarrow \stack{\counter}] $. \\
\item Otherwise if the thrown exception is not handled then $\blockm{i}$ must respect the postcondition determined by
the exceptional postcondition function $\excPost$ for this exceptional type ( or if not specified for the closest supertype) : \\ 
 $\blockPost{i }= \excPost(\stack{\counter}) [\counter \leftarrow 0] $
\Myspace \Myspace \Myspace \Myspace \Myspace  \Myspace  \Myspace  \Myspace  \Myspace  \Myspace $[EXC \leftarrow \stack{\counter}] $. \\
see in section \ref{grammar} for the meaning of \jmlKey{EXC}.
    \end{enumerate}
%The only thing that is known about the exception thrown is that it is 
 % on the top of the stack $\stack{\counter}$. We keep track of all the possible postconditions (as the exception
%may be caught by an exception handler starting at $\blockm{e}$ or it is thrown and thus the exceptional postcondition for 
%the exception must hold) up to
%discovering the type of the thrown exception and then identifying the adequate predicate 
%that must hold after the execution of the \instr{athrow} instruction. 
\item  if  $ins_s$ = \instr{return} \\
$$
   \blockPost{i } = \psi[\result \leftarrow \stack{\counter} ]    
$$
where $\psi $ is the specified method postcondition.
\item  else  
 $$ \blockPost{i} =  \wpi(  ins_s , \wpi( \blockSeq{s+1} ,  \blockPost{ s  +1}, \excPost) , \excPost)  $$ 
 \end{itemize}

\end{defn}

\paragraph{\wpi \ for a sequence of bytecode instructions} is calculated applying the standard $\wpi$ rule for compositional statements : 
$$ \wpi( instrList;i_{j}, \psi,\excPost ) =\wpi(instrList, \wpi(i_{j}, \psi,\excPost ),\excPost ) $$

 %Calculating the precondition of the sequential part of the block $\blockm{i}$ which we denote with  $\blockSeq{i}$  is standard - the precondition of an instruction  is inferred from the precondition of the previous one.


Subroutines are treated by in-lining. As we stated in the beginning we assume that the bytecode has been certified by a Java
bytecode verifier thus our analysis for identifying  subroutines is not a problem.  


\paragraph{Verifying Java Bytecode Programs} Bytecode programs represent a set of Java classes. Establishing the correctness of Java bytecode program w.r.t. to their specification thus, consists in generating verification conditions for every method appearing in any class of the bytecode program.
The verification procedure for a method \texttt{m} consists in  calculating the weakest precondition $\wpi(\tt{m})$ upon its specification: precondition $\psi^{pre}(m)$, 
postcondition $\psi^{post}(\tt{m})$ and the mapping between exceptional types and predicates $\excPost(\tt{m})$ and then prove the condition: 
$$
\psi^{pre}(m)  \Rightarrow \wpi(m)
$$    

\paragraph{Example} We give a simple example for how the \wpi \ works. Looking at fig. \ref{blockBC} we calculate the weakest precondition of the basic block starting at instruction \texttt{19} (it ends with the same instruction). In particular this block is a loop end block, thus its postcondition is
the invariant as specified for this loop in the loop attribute.
$$
\wpi(\blockm{19}) = \\
\left\{ \begin{array}{l}    
1 + \register{3} <= length(\#19(\register{0}) \wedge \\
                      1 + \register{3} >= 0)  \wedge \\ 
                        \forall  var_0:int  (  0 <= var_0 \wedge \\
                    \Myspace    var_0 < 1 + \register{3}  \Rightarrow \\
                \Myspace \Myspace \#19(\register{0})[var_0] \neq \register{1})
\end{array}
\right.
$$
In the example the rule for the instruction \texttt{iinc 3} is applied which increments the \texttt{3$^{th}$} register of the method bytecode. 

%\begin{center} \texttt{wp(instruction\_list;instruction, $\psi$)} = \texttt{wp(instruction\_list, wp(instruction, $\psi$))} \end{center}
%For example for the sequence of instructions of the block starting with $\tt{instr_{18}}$ from Figure~\ref{blockBC} we calculate
%\begin{center}
%\texttt{wp( iload\_2; ireturn,  $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ )}
%\\
%=
%\\
%\texttt{wp(iload\_2, wp( ireturn, $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ ))} \end{center}
%Thus the weakest precondition for the block starting at $\tt{instr_{18}}$ at figure~\ref{blockBC} is
%\texttt{local(2) $\ulcorner$==$\urcorner$ $\ulcorner$ $\backslash$ old(n)div 2 $\urcorner$}

