

\subsection{Bytecode Weakest Precondition}\label{wpGraph}

The verification being modular, proof obligations are generated for every method separately. The verification condition generation 
is trivially defined over the acyclic execution graph of a method. 
The \wpi \ function runs in a backwards  direction starting from the blocks that do not have predecessors up to reaching the entry point
 instruction.  Calculating the precondition of the sequential part of the block $\blockm{i}$ 
 which we denote with  $\blockSeq{i}$  is standard - the precondition of an instruction  is inferred from the precondition of the previous.
The  interesting part is how the postcondition  for $\blockSeq{i}$ , i.e. the precondition of the last block instructions is inferred 
(i.e. jumps, return, loop end ) see for the definition of basic block section ~\ref{abstrCntrFlow}.  In the following we overload the function 
symbol \wpi applying to sequence of bytecode instructions.
The postcondition for the sequential part of a block  $\blockSeq{i}$ (without its last instruction )   is defined inductively 
 as follows :
 \begin{defn}[Block postcondition  $\blockPost{i}$]\label{post}
 If $\blockm{i}$ ends with instruction $i_s$ then :
 \begin{itemize} 
 \item  if  $i_s$ is a loop end instruction \wpi \footnote{those \ instructions \ are detected when building the acyclic  graph and the 
 back edge is "replaced"  by the corresponding \ invariant \ \invariant  } and whose invariant is \invariant: 
 $$ \blockPost{i} =  \wpi(  i_s, \invariant)  $$ 
 \item if  $i_s$ =  \instr{if\_cond n} \\
$$
\blockPost{i} =  \\
\left\{
\begin{array}{l}
cond( \stack{\counter}, \stack{\counter - 1} )   \Rightarrow \\
\phantom{ \counter }   \wpi(\blockSeq{n}, \blockPost{n} ,\excPost )[ \counter \leftarrow \counter -2 ]  \\
\wedge \\
 not ( cond( \stack{\counter}, \stack{\counter - 1} )  )   \Rightarrow \\
\phantom{ \counter}    \wpi(\blockSeq{i+1}, \blockPost{i+1},\excPost ) [ \counter \leftarrow \counter -2 ]      \\                             
\end{array}
\right.
$$
\item if  $i_s$ =  \instr{goto n} \\ 
$\blockPost{i} =  \wpi(\blockSeq{n}, \blockPost{n} , \excPost )$ \\

\item  if  $i_s$ =  \instr{athrow ExceptionType} \\ 
$$
\blockPost{i }  \\ 
 =   \left\{ \begin{array}{l} 
		\jmlKey{subtype}( \jmlKey{ typeof}(\stack{\counter} )) \\
		(\oplus (Exc_{i}^{thrown} \rightarrow \excPost(Exc_{i}^{thrown}) ) \\
		\phantom{\oplus Exc^{thrown} } [\counter \leftarrow  0] \\ 
		\phantom{ \oplus Exc^{thrown} } [EXC \leftarrow  \stack{\counter} ] )_{i=0}^{n}   \\
		(\oplus Exc_{i}^{handled} \rightarrow \wpi(\blockm{e}, \blockPost{e}, \excPost )\\
		\phantom{\oplus Exc^{handled} } [\counter \leftarrow  0] \\ 
		\phantom{ \oplus Exc^{handled}} [EXC \leftarrow  \stack{\counter} ] )_{i=0}^{m} \\
		\end{array} \right.
$$
The only thing that is known about the exception thrown is that it is 
on the top of the stack $\stack{\counter}$. We keep track of all the possible postconditions (as the exception
may be caught by an exception handler starting at $\blockm{e}$ or it is thrown and thus the exceptional postcondition for 
the exception must hold) up to
discovering the type of the thrown exception and then identifying the adequate predicate 
that must hold after the execution of the \instr{athrow} instruction. 
\item  if  $i_s$ = \instr{return} \\
$$
   \blockPost{i } = \psi[\result \leftarrow \stack{\counter} ]    
$$
where $\psi $ is the specified method postcondition.
\item  else  
 $$ \blockPost{i} =  \wpi(  i_s , \wpi( \blockSeq{s+1} ,  \blockPost{ s  +1} ) )  $$ 
 \end{itemize}
\end{defn}

%\Paragraph{Subroutines}
Subroutines are treated by inlining them. As we stated in the beginning we assume that the bytecode has been certified by a Java
bytecode verifier thus our analysis for identifying  subroutine is not a problem.  
\todo{example}

%\begin{center} \texttt{wp(instruction\_list;instruction, $\psi$)} = \texttt{wp(instruction\_list, wp(instruction, $\psi$))} \end{center}
%For example for the sequence of instructions of the block starting with $\tt{instr_{18}}$ from Figure~\ref{blockBC} we calculate
%\begin{center}
%\texttt{wp( iload\_2; ireturn,  $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ )}
%\\
%=
%\\
%\texttt{wp(iload\_2, wp( ireturn, $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ ))} \end{center}
%Thus the weakest precondition for the block starting at $\tt{instr_{18}}$ at figure~\ref{blockBC} is
%\texttt{local(2) $\ulcorner$==$\urcorner$ $\ulcorner$ $\backslash$ old(n)div 2 $\urcorner$}

