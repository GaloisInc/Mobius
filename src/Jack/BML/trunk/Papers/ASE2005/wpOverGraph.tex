

\subsection{Bytecode Weakest Precondition}\label{wpGraph}

In the following we overload the function symbol \wpi \ applying it to sequence of bytecode instructions.
 The verification condition generation is defined over the acyclic execution graph of a method. 
The \wpi \ function runs in a backwards direction starting from the blocks that do not have predecessors up to reaching the entry point
 instruction. We distinguish the \wpi \ calculus over  a method's body bytecode, a bytecode block and a sequence of bytecode intructions.

\paragraph{The weakest precondition $\wpi(\tt{m})$ for method \texttt{m}}  is the weakest precondition of its entry block $\blockm{entry}$ and its postcondition $\blockPost{entry}$ which is calculated recursively starting from the blocks that do not have successors upon the specified method's postcondition  $\psi^{post}(m)$ and exceptional postcondition $\excPost (m)$ :
 $$\wpi(\tt{m}) = \wpi(\blockSeq{entry}, \blockPost{entry}, \excPost ) $$

\paragraph{Weakest precondition for a bytecode block} If $\blockSeq{i}$ is the sequential part of block $\blockm{i}$ (without its last instruction ) and  $\blockPost{i}$ is its postcondition the precondition of $\blockm{i}$ is defined as follows:

$$ \wpi(\blockm{i}) = \wpi( \blockSeq{i}, \blockPost{i}, \excPost ) $$
 
Thus to get the \wpi \ for a block its postcondition should be known. A block postcondition is actually the conjunction of the preconditions
of its successors and it depends on the last instruction of the block.

\begin{defn}[Block postcondition  $\blockPost{i}$]\label{post}
 If $\blockm{i}$ ends with instruction $i_s$ then:
 \begin{itemize} 
 \item  if  $i_s$ is a loop end instruction \wpi \ \footnote{those \ instructions \ are detected when building the acyclic graph and the 
 back edge is "replaced"  by the corresponding \ invariant \ \invariant  } and whose invariant is \invariant: 
 $$ \blockPost{i} =  \wpi(  i_s, \invariant, \excPost )  $$ 
 \item if  $i_s$ =  \instr{if\_cond n} \\
$$
\blockPost{i} =  \\
\left\{
\begin{array}{l}
cond( \stack{\counter}, \stack{\counter - 1} )   \Rightarrow \\
\phantom{ \counter }   \wpi(\blockSeq{n}, \blockPost{n} ,\excPost )[ \counter \leftarrow \counter -2 ]  \\
\wedge \\
 not ( cond( \stack{\counter}, \stack{\counter - 1} )  )   \Rightarrow \\
\phantom{ \counter}    \wpi(\blockSeq{i+1}, \blockPost{i+1},\excPost ) [ \counter \leftarrow \counter -2 ]      \\                             
\end{array}
\right.
$$
\item if  $i_s$ =  \instr{goto n} \\ 
$\blockPost{i} =  \wpi(\blockSeq{n}, \blockPost{n} , \excPost )$ \\

\item  if  $i_s$ =  \instr{athrow ExceptionType} \\ 
if there exists a block $\blockm{e}$ such that 
$\blockm{i} \execRel \blockm{e}$ (an exception handler protects the type of the exception thrown)
then :\\
$\blockPost{i }= \\ \wpi(\blockSeq{e}, \blockPost{e} ,\excPost)[\counter \leftarrow 0][EXC \leftarrow \stack{\counter}] $. \\
Otherwise if the thrown exception is not handled then $\blockm{i}$ must respect the postcondition determined by
the exceptional postcondition function $\excPost$ for this exceptional type ( or if not specified for the closest supertype) : \\ 
 $\blockPost{i }= \excPost(\stack{\counter}) [\counter \leftarrow 0][EXC \leftarrow \stack{\counter}] $. \\
    
%The only thing that is known about the exception thrown is that it is 
 % on the top of the stack $\stack{\counter}$. We keep track of all the possible postconditions (as the exception
%may be caught by an exception handler starting at $\blockm{e}$ or it is thrown and thus the exceptional postcondition for 
%the exception must hold) up to
%discovering the type of the thrown exception and then identifying the adequate predicate 
%that must hold after the execution of the \instr{athrow} instruction. 
\item  if  $i_s$ = \instr{return} \\
$$
   \blockPost{i } = \psi[\result \leftarrow \stack{\counter} ]    
$$
where $\psi $ is the specified method postcondition.
\item  else  
 $$ \blockPost{i} =  \wpi(  i_s , \wpi( \blockSeq{s+1} ,  \blockPost{ s  +1} ) , \excPost)  $$ 
 \end{itemize}
\end{defn}

\paragraph{\wpi \ for a sequence of bytecode instructions} is calculated standardly applying the standard $\wpi$ rule for compositional statements $\wpi( instrList;i_{j}, \psi,\excPost ) =\wpi(instrList, \wpi(i_{j}, \psi,\excPost )) $. %Calculating the precondition of the sequential part of the block $\blockm{i}$ which we denote with  $\blockSeq{i}$  is standard - the precondition of an instruction  is inferred from the precondition of the previous one.



Subroutines are treated by inlining. As we stated in the beginning we assume that the bytecode has been certified by a Java
bytecode verifier thus our analysis for identifying  subroutines is not a problem.  
\todo{example}

%\begin{center} \texttt{wp(instruction\_list;instruction, $\psi$)} = \texttt{wp(instruction\_list, wp(instruction, $\psi$))} \end{center}
%For example for the sequence of instructions of the block starting with $\tt{instr_{18}}$ from Figure~\ref{blockBC} we calculate
%\begin{center}
%\texttt{wp( iload\_2; ireturn,  $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ )}
%\\
%=
%\\
%\texttt{wp(iload\_2, wp( ireturn, $\ulcorner \backslash$\texttt{result} == $\backslash$ old(n)div 2 $\urcorner$ ))} \end{center}
%Thus the weakest precondition for the block starting at $\tt{instr_{18}}$ at figure~\ref{blockBC} is
%\texttt{local(2) $\ulcorner$==$\urcorner$ $\ulcorner$ $\backslash$ old(n)div 2 $\urcorner$}

