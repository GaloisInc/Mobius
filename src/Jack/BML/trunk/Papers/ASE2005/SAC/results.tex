
 \section{Relation between verification conditions on source and bytecode level }  \label{pogEquiv}

 We studied the relationship between the source code proof obligations generated 
 by the standard feature of JACK and the bytecode proof obligations generated by our implementation over the corresponding bytecode
 produced by a non optimizing compiler over the examples given in \cite{JPVC03JKM}. The proof obligations were the same modulo names and
short, byte and boolean values as well as hypothesis names. The proof obligations on bytecode and source level
that we proved interactively in Coq produced proof scripts which were also equal modulo the names of hypothesis. This means that if an
 appropriate encoding of proof obligations on source and bytecode level is found, where the names of the source and bytecode hypothesis are the same,
 the produced proof script for a source proof obligation can be applied to the corresponding one on bytecode. 



% The purpose of this section is to give a comparison between bytecode and source proof obligations.
% In particular, we illustrate this by the proof obligations of the example program in Fig.\ref{replaceSrc}.
 
% We studied the relationship between the source code proof obligations generated 
% by the standard feature of JACK and the bytecode proof obligations generated by our implementation over the corresponding bytecode
%  produced by a non optimizing compiler over the examples given in \cite{JPVC03JKM}. The proof obligations were the same modulo 
% program variables names and basic types.

%  We return now to our example from the previous sections and give in Fig.\ref{vcEnsures} one of the proof obligations on source 
% and bytecode level respectively concerning the postcondition correctness. The verification conditions on bytecode and source level
%  have the same shape modulo names (see Section \ref{comJML} for how names are compiled). Also in Section
%  \ref{comJML}, we discussed the compilation of the JML postcondition from Fig. \ref{replaceSrc}. Particularly,
%  we saw that the compiler has to transform the source postcondition in an equivalent formula and we
%  gave the compilation in Fig.\ref{postCompile}. 

% Despite those transformations, the source and bytecode goal respectively are not only
% semantically equivalent but syntactically the same (except for the variable names). Still, in the bytecode proof obligation we have one more hypothesis than on source level. The extra hypothesis in the bytecode proof obligation is related to the fact that the result type is boolean but the JVM encodes boolean expressions as integers (which is trivially true). This means that the proof obligations have also the same shape.

%  Another important issue is the impact of simple optimizations like dead code elimination on the relationship between source and bytecode proof obligations. 
% In this case, the compiler does not generate the dead code and the bytecode verification condition generator will neither ``see'' it. 
% Even though the source contains the never taken branch as the condition is equivalent to false, this will result in a trivially true
% verification condition which the JACK source verification condition generator will discard.

 The equivalence between source and bytecode proof obligations can be applied to PCC scenarios, as discussed in Section \ref{architecture} in cases where the
 client policy is complex and a complete automatic certification will not work and the producer has to generate the program certificate interactively. 
% where  the producer generates the program certificate over the source code

%Fig. \ref{vcLoopPreserv} shows the proof obligations for the loop preservation. As you can see the hypothesis and the goal have the same ``shape'' on bytecode and source code and the differences are due to the variable names.



% \begin{figure}{!h}

% $$\begin{array}{ll}
%Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
%% & \\

%
%\begin{array}{l}
% \register{1} \neq \\
%\#19 (\register{0})[\register{2}\_at\_ins\_22]
%\end{array}  
%
%&  
%\begin{array}{l}
% \srcVar{obj} \neq \\
%  ListArray.list(\this)[\srcVar{i}\_at\_ins\_26] 
%\end{array}   \\
%
%
%
% & \\
%
%\#19(\register{0}) \neq \Mynull &  ListArray.list( \this) \neq \Mynull\\
%
%
%& \\
%
%\begin{array}{l}
%  len(\#19 (\register{0})) > \\
% \register{2}\_at\_ins\_22 
%\end{array}
%%& 
%\begin{array}{l}
%  len(ListArray.list(\this)) > \\
%\srcVar{i}\_at\_ins\_26
%\end{array}         \\ 

%

% & \\
%
% \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26    \geq 0    \\
%
%
% & \\
%\begin{array}{l}
%  \register{2}\_at\_ins\_22 < \\
%  len(\#19(\register{0}))
%\end{array} &
%
%\begin{array}{l}
%  \srcVar{i}\_at\_ins\_26 <\\
%  len(ListArray.list(\this))
%\end{array}   \\
%
%
% & \\
%\begin{array}{l}
%  \register{2}\_at\_ins\_22 \leq \\
%  len( \#19(\register{0}))
%\end{array} 
%&  
%\begin{array}{l} 
%  \srcVar{i}\_at\_ins\_26 \leq \\
%  len(ListArray.list(\this))
%\end{array}   \\
%
%
% &\\
%% \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26 \geq 0 \\
%
%
%
%% &\\
% \begin{array}{l} 
%         \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\register{2}\_at\_ins\_22) \Rightarrow \\
%                \Myspace    \#19(\register{0})[var(0)] \neq \register{1}
%      \end{array} &        
%      \begin{array}{l} 
%             \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\srcVar{i}\_at\_ins\_26) \Rightarrow \\
%                 \Myspace       ListArray.list(\this)[var(0)] \neq \srcVar{obj}
%      \end{array}  \\
%%
% typeof(\register{0}) <: ListArray &    typeof(this) <: ListArray     \\
%
%& \\
%& \\
%Goal \ on \ bytecode: & Goal \ on \ source \ level: \\
%
%& \\
%
%  \begin{array}{l}
%               1 + \register{2}\_at\_ins\_22 \leq  len(ListArray.list(\register{0}))  \\
%
%               1 + \register{2}\_at\_ins\_22 \geq 0 \\
%
%               \forall  var(0). 0 \leq var(0) \wedge var(0) < 1 + \register{2}\_at\_ins\_22 \Rightarrow \\
%                   \Myspace  ListArray.list(\register{0})[var(0)] \neq \register{1} 
%
%       \end{array}
%& 
%
%       \begin{array}{l}
%             1 + \srcVar{i}\_at\_ins\_26 \leq  len(ListArray.list(this))  \\
%	     \\
%             1 + \srcVar{i}\_at\_ins\_26 \geq 0 \\
%	     \\
%             \forall  var(0). 0 \leq var(0) \wedge\\
%	     \Myspace  var(0) < 1 + \srcVar{i}\_at\_ins\_26 \Rightarrow \\
%                  \Myspace  ListArray.list(this)[var(0)] \neq \srcVar{obj} 
%       \end{array}   
%
 
%\end{array}$$



%\caption{Source and Bytecode verification condition for loop preservation for method \texttt{ListArray.isElem} }
%\label{vcLoopPreserv}
%\end{figure}









 % \begin{figure*}[!thb]

%\begin{center}
%\begin{tabular}{|l|l|}
%\hline
%\bf{Hypothesis \ on \ bytecode:}  & \bf{Hypothesis \ on \ source \ level:}  \\
%\hline 
%$\register{2}\_at\_ins\_20 \geq $ 
%& $ \srcVar{i}\_at\_ins\_26 \geq$ \\
%
%$len(\#19(\register{0})) $ & $  len(ListArray.list(\this)) $ \\
%\hline 
%
%$\#19(\register{0}) \neq \Mynull$ 
%& $ ListArray.list(\this) \neq \Mynull$ \\

%\hline 
%$ \register{2}\_at\_ins\_20) \leq$ 
%&  $  \srcVar{i}\_at\_ins\_26  \leq   $ \\
%$ len(\#19(\register{0}))  $ & $ len(ListArray.list(\this))  $ \\
%\hline

%$\register{2}\_at\_ins\_20 \geq 0  $ 
%& $ \srcVar{i}\_at\_ins\_26  \geq 0 $ \\

%\hline

%$\forall  var(0). \  0 \leq var(0) \wedge  $ & $\forall  var(0). \  0 \leq var(0) \wedge $ \\
%$ var(0) < \register{2}\_at\_ins\_20 \Rightarrow $ & $  var(0) < \srcVar{i}\_at\_ins\_26 \Rightarrow $\\
%$ \#19(\register{0})[var(0)] = \register{1}   $ & $  ListArray.list(\this)[var(0)] = \srcVar{obj}  $ \\

%\hline
%
% $typeof(\register{0}) <: ListArray$ & $typeof( \this) <:  ListArray$  \\
%\hline

%$0=0 \vee 0=1$ & \\
%
%& \\

%\hline
%\bf{Goal on bytecode:} & \bf{Goal on source level:} \\
%\hline
%$\Myfalse  \iff $ & $\Myfalse \iff  $ \\
% $ \exists  var(0) . \ 0 \leq var(0) \wedge$ 
%& $ \exists  var(0) . \ 0 \leq var(0) \wedge$ \\
%
%$\Myspace \Myspace var(0) < len(\#19(\register{0})) \wedge$ 
%& $\Myspace \Myspace  var(0) < len(ListArray.List(this)) \wedge $\\
       
%$\Myspace \Myspace \#19(\register{0})[var(0)] = \register{1} $ 
%&$\Myspace \Myspace  ListArray.List(this)[var(0)] = \srcVar{obj}  $ \\

%\hline
%\end{tabular}
%\end{center}

%Note: $\expression\_at\_ins\_n$ denotes the value of  
%expression $\expression$ at the bytecode instruction at index (source line)  $n$ 

%\caption{\sc Comparison of source and bytecode verification conditions}
%\label{vcEnsures}
%\end{figure*}

%We aim to formally give evidence that the proof obligations on non optimized bytecode and source programs are syntactically the same (modulo names and types). 

 



%\subsubsection{Example}
% We give a simple example of how the \wpi \ works. Block $\blockm{6}$ (starts at instr. \texttt{6}) in Fig.~\ref{blockBC} ends with a branching instruction and in the case when the condition is true (the current element of the array is not equal to the first parameter of the method \texttt{replace}) the execution will continue at $\blockm{19}$. Below we give the part of the wp for block $\blockm{6}$ in case the control flows to block $\blockm{19}$( the condition of its last instruction holds and in this case 
%the predicate $pre(b^{6}, b^{19})$ is $\wpi(\blockm{19})$).  The implications with conclusion \Myfalse \ stand for the possible exceptions \texttt{NullPointer} and \texttt{ArrayIndexOutOfBound} exceptions that may be thrown (as no postcondition is specified explicitly for these cases of abnormal termination, the one by default is taken). 

%\input wpExample.tex
