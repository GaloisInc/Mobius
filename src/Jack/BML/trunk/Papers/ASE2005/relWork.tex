\section{Related Work} \label{relWork}
The present work is similar to the Proof Carrying Code architecture (PCC) proposed by Necula (see \cite{Necula97}). The technique is used in a scenario where a code issuer sends a code to a code receiver and where the code receiver does not trust the received code. PCC has several stages. Code issuer compiles its source using a certifying compiler (see \cite{ComNec}, \cite{DesNecLee98}). Certifying compiler infers automatically a type specification (e.g. loop invariants). Then the code issuer generates a proof over the code and the annotation and sends both to the code receiver. Code receiver then validates the proof upon its security policy. Thus he can capture (if code and proof are not both changed in a suitable way) tampering in both proof or code. In particular Necula instantiates the PCC architecture for Java (see \cite{ProColLeeNec}).  

 Having the same expressive power as JML we can encode a larger set of properties than in the case of the certifying compiler (see~\cite{DesNecLee98}) which infers type specification.

In ~\cite{WildmoserN-ESOP05} a  framework is described for verifying code against arithmetic overflow. Anyways the annotation is written manually which is not comfortable especially on bytecode. Here we propose a way to compile a specification written in a high level language thus leaving the specification to be written on high level which is convenient.% which has the necessary expressive power to verify the same property.    
A similar work is presented in \cite{Quigley} where a definition of Hoare logics for bytecode programs is established. This work is limited to a subset of the Java virtual machine instructions and does not treat for example method calls, neither exceptional termination. Also our definition for WPC is rather naturally done over the execution graph of the bytecode rather than on searching some structure in it as is done in \cite{Quigley}.
