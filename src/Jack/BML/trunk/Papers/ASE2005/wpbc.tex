
\section{Weakest Precondition \\Calculus For Java Bytecode}\label{wpbc}
In this section, we define a bytecode logic in terms of a weakest precondition calculus.
We assume that the bytecode program has passed the bytecode verification procedure,
 thus the calculus is concerned only with program functional properties. We also assume that code is generated by a non optimizing compiler. 

The proposed weakest precondition ($wp$) supports all Java sequential instructions except for floating point arithmetic instructions and 64 bit data (\java{long} and \java{double} types), including exceptions, object creation, references and subroutines. The calculus is defined over the method control flow graph. It supports BCSL annotations (section \ref{bcSpecLg}), i.e. bytecode method's specification like preconditions, normal and exceptional postconditions, class invariants, assertions at particular program point among which loop invariants (if there is no explicite specification  the default one is taken into account: preconditions, postconditions and invariants are taken to be true, exceptional postcondition is by default false) is taken into account. In the rest of the section, we consider these specific features - treating instance fields, method invocations and loops. 

The Java bytecode language is stack based, i.e. the instructions take their arguments from the method execution stack and 
 put the result on the stack. In Fig.~\ref{instrWP} we show the \wpi \ rules for some bytecode instructions 
where the expression \counter~ and  \stack{\counter}~ stand respectively for the the stack counter and the element on the top of the stack. 
 The \wpi \ rule for  \instr{Type\_load i} increments the stack counter \counter \ and loads on the stack top the contents of the local variable $\register{i}$. 

% The calculus is defined over the control flow graph of the program and has two levels of definitions --- the first one is the set of rules for sequential Java bytecode instructions (discussed in subsection~\ref{wpInstr} ) and the second one takes into account how control flows in the bytecode (subsection~\ref{wpGraph}).
%Loops are treated by transforming the control flow graph into an abstract acyclic graph (by eliminating the backedges). As we mentioned earlier we assume that every method is specified enough, i.e. for each loop, the corresponding invariant is present. Thus, the eliminated edges are replaced by the corresponding loop invariant. 
% The verification conditions are generated over the abstract control flow graph. Subsection~\ref{abstrCntrFlow} discusses 
%how the abstract control flow graph is generated.

%We have the proof of soundness of the \wpi \ predicate transformer. The proof is done w.r.t. to the operational semantics of the sequential Java bytecode
%subset and establishes that if the verification conditions are provable this means that the method implementation respects the method specification.
\begin{figure}[ht]

$$
\begin{array}{l}
%\wpi(\instr{iinc} \  i , \ \psi, \ \excPost) = \psi[\register{i} \leftarrow \register{i} + 1 ] \\
%\\
\wpi(\instr{Type\_load} \ i, \ \psi, \ \excPost) =  \\
\Myspace \psi[\counter \ \leftarrow \ \counter+1] [\stack{\counter+1} \ \leftarrow \ \register{i}] \\
 \Myspace \textit{where} \ i \ \textit{is a valid local variable index}   \\
\\ 
\wpi(\instr{putField} \ \texttt{Cl.f}, \ \psi, \ \excPost) = \\
\begin{array}{l}
	%\begin{array}{l}
   	\Myspace	\stack{\counter -1} \not= \Mynull \\
	\Myspace	\Rightarrow  
	\Myspace		%\begin{array}{l}
	\Myspace	 \psi [\counter \leftarrow \counter-2 ] \\[0 mm] 
   		\Myspace\Myspace\Myspace[\texttt{Cl.f} \leftarrow \texttt{Cl.f}\oplus [\stack{\counter -1} \rightarrow \stack{\counter}] ] \\
	%	\end{array}
	%\end{array}
   \Myspace	\wedge \\
   \Myspace	\stack{\counter-1} = \Mynull \\
 \Myspace	\Rightarrow  \phi[ \counter \leftarrow  0][\stack{0} \leftarrow \stack{\counter}]  \\		  \\
   \it{where \ the \ predicate \ \phi \  is \ the \ precondition \ of \ the} \\
   \it{exception \ handler \ protecting \ the \ instruction \  against} \\ 
   \tt{NullPointerException } \ \it{\ if \ it \  exists, \ otherwise}  \\
   \it{if \ the } \ \tt{ NullPointerException} \ \it{\ is \ not \ handled}    \\
      \phi = \excPost(\tt{NullPointerException})[ \jmlKey{EXC} \leftarrow \stack{\counter}]
    \end{array}
 \end{array} $$

%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } \\
%                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\


%\texttt{wp(Type\_load index,$\psi$)} = $\psi$\texttt{[Stack(t)$\leftarrow$local(index)][t$\leftarrow$t+1]}  \\
%, where the local variable must contain value of type Type
\caption{rules for some bytecode instructions}
\label{instrWP}
%\end{frameit}
\end{figure}

\input wpSingleInstr.tex
\input loops.tex

%\input abstractCntrFlow.tex
%\input wpOverGraph.tex

%\begin{center} \texttt{wp} : \texttt{STMT} $\longrightarrow$ \texttt{Predicate} $\longrightarrow$ \texttt{Predicate}\end{center}





