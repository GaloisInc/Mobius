

In this chapter, we will look at the relationship between
the verification conditions generated for a Java like source programming 
language and the verification conditions generated for the bytecode language 
as defined in Chapter \ref{wpGeneral}. More particularly, we 
argue that they are syntactically equivalent if the compiler is nonoptmizing and satisfies certain 
conditions.
  

% motivation
% 1. security involves more and more complex policies
% 2. evolution of the techniques 
First, we would like to give the 
context and motivations for studying the relationship 
between source and bytecode verification.


 Security becomes an important issue for the overall software quality.
This is especially the case for mobile code or what so ever untrusted code. 
A solution  proposed by G.Necula (see his thesis \cite{ComNec}) 
is the PCC framework which brings the possibility to a  code receiver to 
verify if an unknown code  or untrusted code respects certain safety conditions before being executed by the code receiver.
In this framework the code client annotates the code automatically, generates verification conditons automatically
 and proves them automatically.
The  program accompanied by the proof  is sent to the code receiver  who will typecheck the proof against 
the verification conditions that he will generate.
Because of its full automation this architecture fails to deal with complex functional or security properties.


The relation of the verification conditions over bytecode and source code can be used for building an
 alternative PCC architecture which can deal with complex security policies. Note that in case of a non-trivial 
security policy neither an automatic inference of the specification, nor an automatic generation 
of the proof will be possible.
In those cases, such an equivalence can be exploited by the code producer to generate
 the certificate interactively over the source code. Because of the
equivalence between the proof obligations over source and bytecode programs (modulo names and types), 
their  proof certificates are also the same and thus the certificate generated interactively over the
 source code can be sent along with the code.   




In the following, Section \ref{pog:relWork} presents an overview of existing work in the field.

 In Section \ref{source},  we introduce the source programming language. As we shall see,
this programming language has the basic features of Java as it supports object creation and manipulation, like instance 
field access and  update, 
 exception throwing and handling, method calls as well as subroutines. Section \ref{compile} presents a simple non optimizing compiler from the source language to the bytecode
 language presented already in Chapter \ref{prelim}. In this section, we will discuss certain properties of the 
compiler which are necessary conditions for establishing this equivalence. Next, Section \ref{pog:wpSrcGeneral} presents the weakest precondition predicate 
transformer which we define over the source language. Section  \ref{pog:wpBcGeneral} introduces a new formulation of the weakest precondition for bytecode, which 
is defined over the  compilation of source expressions and statements. This formulation of the weakest precondition
 is helpful for establishing the desired 
relation between bytecode and source proof obligations.
 In this section, we also discuss upon what conditions
the weakest precondition given before in Chapter \ref{wpGeneral} and 
this new version are equivalent.
In Section \ref{pogEq:aux}, we proceed with the proof of equivalence between the proof obligations generated 
by the weakest precondition defined in  Chapter \ref{wpGeneral}.
To do this, we first establish  the equivalence between the source weakest precondition and the bytecode weakest precondition
 defined over the compilation of statements and expressions. We exploit this equivalence 
to conclude that the source verification conditions and the bytecode verification conditions 
presented in Chapter \ref{wpGeneral} are syntactically the same.
 


% existing work , Gilles , Peter Mueller



% This result may have an impact on the application on PCC techniques for 
%complex functional and security properties where full automatisation is not possible.

%The traditional PCC architecture comes along with a certifying compiler. The basic idea is that the certifying compiler  infers automatically annotations,
%automatically generates verification conditions, proves them automatically and then sends both the code and the proof certificate to the 
%counterpart that will run the code. The receiver then, generates the verification conditions and  type checks the generated formulas against the proof certificate.
%This architecture works for properties like well typedness and safe memory read/write but it is not applicable for complex policies where the specification and the proof 
%cannot be done automatically. 


