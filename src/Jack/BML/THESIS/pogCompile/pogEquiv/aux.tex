

%\newtheorem{interProp}{Lemma} % states that the postcondition doesnot change by adding a goto
\newtheorem{wpExprSrc}{Lemma}[section]
\newtheorem{exprValueOnStack1}[wpExprSrc]{Lemma}
\newtheorem{exprSrcBcWp1}[wpExprSrc]{Lemma}
\newtheorem{exprSrcBcWp2}[wpExprSrc]{Lemma}
\newtheorem{wpStmtBcSrc1}[wpExprSrc]{Lemma}
\newtheorem{wpStmtBcSrc3}[wpExprSrc]{Lemma} % wp(s), where [s, stmt, e] does not contain stack expressions if inter(s, e) does not contain
\newtheorem{wpStmtBcSrc2}[wpExprSrc]{Lemma}
\newtheorem{theorem}{Theorem}[section]
%\newtheorem{stackCounter}[interProp]{Lemma}
%\newtheorem{dupProp}[interProp]{Lemma}
%\newtheorem{newProp}[interProp]{Lemma}


\section{Proof obligation equivalence on source and bytecode level}\label{pogEq:aux}

In the following, we will argue that the proof obligations generated by the weakest precondition
over programs of our source language are equivalent to the  proof obligations generated over bytecode.

First, we remark that a $\wpNameSrcExpr$ defined over source  expressions generates formulas which may
 have two possible normal forms. From the definition of the \wpName{}  for expressions, we may notice that the predicate 
$\wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v}$ asserts that  (in case for normal termination) the  normal postcondition
 predicate $\psi $ must hold under certain  conditions in the prestate of the evaluation of an expression and that
 (in the exceptional termination case) some other condition must hold. Some expressions always terminate evaluation normally
 (e.g. constants, \instanceof{} expressions) and in that case for normalizing the form of the \wpName{} result we may consider
that the exceptional postcondition case is equal to \Mytrue. Another particularity is that the instance creation
expression has a \wpName{} predicate which is quantified over the evaluation of the new instance. The same happens in the case
for method invokation expressions where the \wpName{} predicate is quantified over the result of the method invokation 
as well on the values of the modified expressions by the method invokation. 
Thus, we obtain the following formal statement.
 

\begin{wpExprSrc}[Normal form of $\wpNameSrcExpr$] \label{pogEq:aux:wpExprSrc}
for any source expression $\expressionSrc$ 
normal form of  $\wpNameSrcExpr$ is such that 

$$ \begin{array}{l}
         \mbox{\rm\textit{either  there exists formulas $ Q,R$  }} \\
         \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  = \\ 
         \left( \begin{array}{l} Q \Rightarrow \psi   \end{array} \right)
          \wedge 
	  R \\\\
	  \mbox{\rm\textit{or exists formulas $ Q,R $   }} \\
\\
 \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  = \\
      \forall \freshVar, %, \freshVar_1, \ldots  \freshVar_k   , 
                 \left( \begin{array}{l} Q \Rightarrow \left( \begin{array}{l} \psi \subst{v}{ \freshVar}\end{array} \right)  \end{array} \right)    \wedge   R  
                                                                               %    \begin{array}{l}
									            
									       %    \subst{v_1 }{ \freshVar_1 }  \\
									       %    \ldots \\
									       %    \subst{v_k}{ \freshVar_k } 
									       %  \end{array}  
                                                                        
   \end{array}  $$ \\
\end{wpExprSrc}

The proof is done over the  definition of $\wpNameSrcExpr$ function given in Section \ref{pog:wpSrc:wpExpr}.
% The second form  in which the part of the calculated weakest precondition predicate is quantified   appears in the cases for instance creation and method invokation expressions.

%Before stating the main theorem we need some auxiliary properties.
% First, we establish that adding a \instr{goto} \ instruction  to a bytecode of instructions does not change the weakest predicate of the
% augmented bytecode sequence.  


%\begin{interProp} \label{interProp}
%Assume that we have the block of bytecode instructions $i_1;...;i_k$ 
%     $$ \wpBcSeq{ i_1;...;i_k}{ \psi  }  { \excPost } = 
%\wpBcSeq{i_1;...;i_k; \goto \  l }{\psi }{\excPost} $$
%
%The proof is based on the fact that the instruction \goto \ does not have side effects and thus,
%the following holds: $ \wpBcSeq{ \instr{goto l}}{\psi}{\excPost} = \psi $
%\end{interProp}


We now turn to see what is the relation between  the weakest precondition formulas for  an expression $\expressionSrc$ 
and its compilation $\compileLabel{s}{\expressionSrc}{e}$. 
The following lemma establishes a relation between the \wpName{} functions on source and bytecode level which 
are independent from the postcondition.
 First, we have to take into account that the evaluation 
of an expression on bytecode level, which in terms of the virtual machine means the execution of the instructions
resulting from the expression compilation will terminate normally in a state where the value of the expression will be on the top
of the operand stack. In particular, we will show that if  the expression  $\expressionSrc$ evaluates to $v$ then the stack top element will be on the stack top when 
the compilation of an expression executes.
 Apart from this difference that on bytecode stack comes into the scene, the \wpName{} function on source and bytecode 
calculates very similar verification conditions. In particular, 

\begin{itemize}
  \item the hypothesis of the part of the weakest preconditions on  source and bytecode level
concerning the normal termination of the expression  are the same  
   \item   the part of the weakest preconditions on  source and bytecode level concerning the exceptional termination 
           of the expression are the same  
\end{itemize}



\begin{exprSrcBcWp1}[Wp of a compiled expression ] \label{exprValueOnStack}
 For any expression $\expressionSrc$ from our source language, for any formula $\psi$  
of the source assertion language and any formula $\phi$ such that $\phi$ may only 
contain stack expressions of the form     $\stack{\counter - k}, k \ge 0$ and if the modifies clauses of every
 method does not contain stack expression  the following holds:



  Forall formulas $ Q, R$  such that 
$$ \begin{array}{l}
      \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  = \\ 
        \left( \begin{array}{l} Q \Rightarrow \psi   \end{array} \right) 
          \wedge  
	  R  \\
  \\
\Longrightarrow \\
 \\

  
	    \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e} }{ \phi }{\excPost} \  = \\ 
             \left( \begin{array}{l} Q \Rightarrow \left( \begin{array}{l} \phi \begin{array}{l}
                                       \subst{\counter}{\counter + 1}\\
			               \subst{\stack{\counter +1}}{ v }
                         \end{array} \end{array} \right) \end{array} \right)
          \wedge 
	  R 
  \end{array}$$
and 
forall formulas $ Q, R$  such that 
$$ \begin{array}{l} \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  = \\
      \forall \freshVar, %\freshVar_1, \ldots  \freshVar_k   , 
             \left( \begin{array}{l} Q \Rightarrow \left( \begin{array}{l} \psi \subst{v}{ \freshVar}\end{array} \right)  \end{array} \right) 
                                                                             %    \begin{array}{l}
									     %       \\
									     %  \subst{v_1 }{ \freshVar_1 }  \\
									     %	\ldots \\
									     %	\subst{v_k}{ \freshVar_k } 
									     %   \end{array}  
                                                                  \wedge   R     

 \\
\Longrightarrow \\
 \\

\wpBcSeq{ \compileLabel{s}{\expressionSrc}{e} }{ \phi }{\excPost} \  = \\ 
            \forall \freshVar, % \freshVar_1, \ldots  \freshVar_k ,  
                              \left( \begin{array}{l} Q \Rightarrow  \left( \begin{array}{l} \phi  \begin{array}{l}\subst{\counter}{\counter + 1} \\
                                                                                                  \subst{\stack{\counter +1}}{\freshVar  } \end{array} \end{array} \right)
			       \end{array} \right)      
			               
                                    %  \begin{array}{l}
				    %   \subst{v_1 }{ \freshVar_1 }  \\
				    %   \ldots \\
				    %   \subst{v_k}{ \freshVar_k } 
				    % \end{array}  
				    \wedge R
	
\end{array}$$
\end{exprSrcBcWp1} 
The scatch of the proof is given in Appendix \ref{appendix:pogComp:pogEq:aux}.



The next lemma establishes  a relation between the source and bytecode functions \wpName \ w.r.t. to the same weakest precondition. 
This follows from the previous lemma which establishes the relation between the \wpName \ over source expressions and
 the \wpName \ over bytecode expressions that takes into account the compilation structure.

\begin{wpStmtBcSrc1}[Proof obligation equivalence on statements ] \label{wpStmtBcSrc1}
 
$$ 
    \begin{array}{l}
    \forall \stmt, \psi, \excPostSrc , \\
       \Myspace  \wpStmt{\compileLabel{s}{\stmt}{e}}{ \psi }{ \excPostSrc }  = \\
       \Myspace   \wpSrcStmt{\stmt  }{\psi }{ \excPostSrc }  
	 
    \end{array}
 $$
\end{wpStmtBcSrc1}
Proof:

The proof is done by structural induction. Here, we scatch the case for assignment to a local variable.

 $$\begin{array}{l}
	  \wpSrcStmt{  \var = \expressionSrc }{\psi}{\excPostExpl} =  \\
	  \comment{Def. of $\wpNameSrcExpr$ for  statements in the previous Section }	\\
	  \numConclusion{1} \   \wpSrcExpr{  \expressionSrc }{\psi \subst{\var}{v}}{\excPostExpl}{v} \\\\
	
          \wpStmt{  \compileLabel{s}{\var = \expressionSrc}{e} }{\psi}{\excPostExpl} =  \\
	 \comment{Def. of the compiler from Section \ref{pogEq:compile:compExpr} } \\
	 \wpStmt{\begin{array}{l}
                        \compileLabel{s}{\expressionSrc}{e  - 1 }\\
			e : \store \ \var; 
             \end{array}  }{\psi}{\excPostExpl} = \\ 

	  \comment{Def. of $\wpNameStmt$ function for compiled statements in the previous Section }	\\
	 
	  \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e  - 1 }
		  }{\wpExpl{\store  \ \var}{ \psi  }{ \excPostExpl} }{\excPostExpl} = \\ 
             
          \comment{Def. of $\wpNameExpl$ function for single instruction in the previous Section }	\\
	  \numConclusion{2} \   \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e  - 1 }
		  }{ \psi \begin{array}{l}
                                \subst{\counter}{\counter - 1}\\  
				\subst{\var}{\stack{\counter }}
                          \end{array}}{\excPostExpl} = \\ 
        


\end{array}$$

\Qed \\


 

%\todo{say what is this?}
 
%\begin{wpStmtBcSrc3}  \label{wpStmtBcSrc3}
%For every $\stmt$, compilation $\compileLabel{s}{\stmt}{e}$ 
%$ \wpi{}{\methodd}{\ins{s} } $ does not contain stack expressions
%\end{wpStmtBcSrc3}

The next statement establishes under what conditions
 the \wpName \  over source and the \wpName \ defined in the previous Chapter are equivalent.

\begin{wpStmtBcSrc2}[Proof obligation equivalence on statements] \label{wpStmtBcSrc2}
For every $\stmt$, compilation $\compileLabel{s}{\stmt}{e}$,  formula $\psi$ and 
   exceptional postcondition  function $\excPostExpl $ such that :
 
  \begin{itemize}
         \item if $e + 1$ exists then  $\psi = \inter{e}{e+1}$
	 \item if $e+1$ does not exist and $\ins{e} = \return$  then $\psi = \methodd.\normalPost$
	 \item$\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e) $ 
  \end{itemize}
      then it holds 
$$ \wpSrcStmt{\stmt}{\psi }{\excPostSrc }  = \wpi{}{\methodd}{\ins{s} }$$
\end{wpStmtBcSrc2}
\textit{Proof}: \\
This follows from Lemmas \ref{wpStmtBcSrc1}, which establishes the equivalence between the verification conditions of
 source programs  and their compilation which is generated over the compilation and  Lemma \ref{relWpStmt}  which establishes 
the equivalence between the latter and verification conditions generated over the bytecode without taking into account the compiler.\\
\Qed


From the last lemma follows that if the body of the  method \methodd \ is $\stmt$, and its compilation is $\compileLabel{s}{\stmt}{e}$, then 
the proof obligations generated over $\stmt$ upon postcondition $\method.\normalPost$ and exceptional
postcondition function  $\method.\excPostSpec$     and its compilation $\compileLabel{s}{\stmt}{e}$ are the same. The last theorem 
formalizes this fact.

\begin{theorem}[Proof obligation preservation]
For all method \methodd \ if its body is $\stmt$ such that its compilation is 
 $\compileLabel{s}{\stmt}{e}$  we have the following:
$$ \wpSrcStmt{\stmt}{\methodd.\normalPost }{\methodd.\excPostSrc }  = \wpi{}{\methodd}{\ins{s} }$$
\end{theorem}
The proof follows from the previous proposition \ref{wpStmtBcSrc2}




Note that such an equivalence between proof obligations on source and bytecode and the fact that
we have proof for the soundness of the bytecode verification condition generator
 gives us the soundness of the source  weakest precondition calculus.  

Another remark is that here we ignore the difference between names and types on  source and bytecode level. 
Let us first focus on the naming on source and bytecode. 
In this chapter, we have considered that the compiler  does not change  variable, class and method  names.
 This is not true for Java compilers, as these names are basically compiled into 
indexes in the constant pool table. However, this difference is a minor detail and of course, this means that 
the equivalence between source and bytecode verification conditions in Java can be established modulo names.
The second detail in the formalization presented here is that the compilers compiles boolean types into boolean types.
This neither holds for real Java compiler. This is because JVM does not have a direct support  for booleans and thus,
Java compilers compile booleans into integers. This implies that the other difference between source and proof
obligations in Java is modulo types. Once again, we consider that this is a detail that would only make heavier
the presentation without being an important issue in establishing the equivalence of the verification conditions on source and bytecode. 
