

%\newtheorem{interProp}{Lemma} % states that the postcondition doesnot change by adding a goto
\newtheorem{wpExprSrc}{Lemma}[section]
\newtheorem{exprValueOnStack1}[wpExprSrc]{Lemma}
\newtheorem{exprSrcBcWp1}[wpExprSrc]{Lemma}
\newtheorem{exprSrcBcWp2}[wpExprSrc]{Lemma}
\newtheorem{wpStmtBcSrc1}[wpExprSrc]{Lemma}
\newtheorem{wpStmtBcSrc2}[wpExprSrc]{Lemma}
%\newtheorem{stackCounter}[interProp]{Lemma}
%\newtheorem{dupProp}[interProp]{Lemma}
%\newtheorem{newProp}[interProp]{Lemma}


\section{Proof obligation equivalence on source and bytecode level}\label{pogEq:aux}

In the following, we will argue that the proof obligations generated by the weakest precondition
over programs of our source language are equivalent to the  proof obligations generated over bytecode.

First, we remark that a $\wpNameSrcExpr$ defined over source  expressions generates formulas which may
 have two possible normal forms.


\begin{wpExprSrc}[Normal form of $\wpNameSrcExpr$] \label{pogEq:aux:wpExprSrc}
for any source expression $\expressionSrc$ 
normal form of  $\wpNameSrcExpr$ is such that 

$$ \begin{array}{l}
         \mbox{\rm\textit{either  there exists $ Q,R:\formulaSrc $  }} \\
         \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  \equiv \\ 
          Q \Rightarrow \psi \\
          \wedge \\ 
	  R \\\\
	  \mbox{\rm\textit{or exists $ Q,R:\formulaSrc, v_1 \ldots v_k :\expressionSrc $   }} \\
\\
 \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  \equiv \\
      \forall \freshVar_1, \ldots  \freshVar_k   ,  Q \Rightarrow \psi 
                                                                             \begin{array}{l}
									        \subst{v_1 }{ \freshVar_1 }  \\
										\ldots \\
										\subst{v_k}{ \freshVar_k } 
									     \end{array}
          \wedge \\ 
	  R  
   \end{array}  $$ \\
\end{wpExprSrc}

This follows from the definition of $\wpNameSrcExpr$ \ in Section \ref{pog:wpSrc:wpExpr}. The second form  
in which the part of the calculated weakest precondition predicate is quantified  
appears in the cases for instance creation and method invokation expressions.

%Before stating the main theorem we need some auxiliary properties.
% First, we establish that adding a \instr{goto} \ instruction  to a bytecode of instructions does not change the weakest predicate of the
% augmented bytecode sequence.  


%\begin{interProp} \label{interProp}
%Assume that we have the block of bytecode instructions $i_1;...;i_k$ 
%     $$ \wpBcSeq{ i_1;...;i_k}{ \psi  }  { \excPost } = 
%\wpBcSeq{i_1;...;i_k; \goto \  l }{\psi }{\excPost} $$
%
%The proof is based on the fact that the instruction \goto \ does not have side effects and thus,
%the following holds: $ \wpBcSeq{ \instr{goto l}}{\psi}{\excPost} = \psi $
%\end{interProp}


We now turn to see what is the relation between  the weakest precondition formulas \ for  an expression $\expressionSrc$ 
and its compilation $\compileLabel{s}{\expressionSrc}{e}$. 
Depending on the form of the weakest precondition  (as we saw with the previous lemma there are two possible forms of the weakest precondition for source expressions) 
of a soure expression $\expressionSrc $ obtained from  $\wpNameSrcExpr$ 
 we will state the relation between $\wpNameSrcExpr$  \ and $\wpNameBcSeq$  in the following two lemmas.  
Informally, both lemmas express the fact that 
\begin{itemize}
  \item the hypothesis of the part of the weakest preconditions on  source and bytecode level
concerning the normal termination of the expression  are the same  
   \item   the part of the weakest preconditions on  source and bytecode level concerning the exceptional termination 
           of the expression are the same  
\end{itemize}



\begin{exprSrcBcWp1}[Wp of a compiled expression ] \label{exprValueOnStack}
 For any expression $\expressionSrc$ from our source language, for any formula $\psi: \formulaSrc$  
of the source assertion language and any formula $\phi: \formulaBc$ such that $\phi$ may only 
contain stack expressions of the form     $\stack{\counter - k}, k \ge 0$, the following holds



  There  exist $ Q, R : \formulaSrc$  such that 
$$ \begin{array}{l}
      \wpSrcExpr{\expressionSrc }{ \psi }{ \excPost}{v} \  \equiv \\ 
          Q \Rightarrow \psi \\
          \wedge \\ 
	  R  \\
  \\
\Rightarrow \\
 \\

  
	    \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e} }{ \phi }{\excPost} \  \equiv \\ 
              Q \Rightarrow \phi \begin{array}{l}
                                       \subst{\counter}{\counter + 1}\\
			               \subst{\stack{\counter +1}}{ v }
                         \end{array} \\ \\
          \wedge \\ 
	  R 
  \end{array}$$




\end{exprSrcBcWp1}

We proceed with several cases of the proof, which is done by induction over the structure of the formula

Proof : 
 


\begin{enumerate} 
		\item    $\expressionSrc = const , const \in \ \constantInt, \Mytrue, \Myfalse $
                     
		     $$ \begin{array}{l}  
		               \mbox{\rm\comment{source case }} \\
		              \numConclusion{1} \wpSrcExpr{ const}{\psi}{ \excPost}{const}  \\
		    	       \mbox{\rm\comment{following the definition of the wp function for source expressions in subsection  \ref{pog:wpSrc:wpExpr} }} \\
			       \equiv \psi \\
			       \\
			       \mbox{\rm\comment{bytecode case }} \\
		               \numConclusion{2} \wpBcSeq{\compileLabel{s}{const}{s} }{\phi}{ \excPost}  \\
			\end{array}$$ 
                       $$ \begin{array}{l}  
		               
		    	       \mbox{\rm\comment{following the definition   of the compiler function in subsection \ref{pogEq:compile:compExpr} }} \\
			       \equiv \wpExpl{s \ \push const }{\phi}{ \compile{\excPost}}  \\
			       \mbox{\rm\comment{following the definition of the wp function for bytecode in subsection \ref{pog:wpSrc:wpExpr}  }} \\
			       \equiv \phi \begin{array}{l}
                                                \subst{ \counter }{ \counter + 1}\\
						\subst{\stack{ \counter +1} }{const  }
					    \end{array} \\
			        \\
				\\
				 \mbox{\rm\comment{from \numConclusion{1} and   \numConclusion{2} and $Q,R = \true $ this case holds   }} \\
					 
				    
			\end{array}$$
                        
			
			
                \item  $\expressionSrc = \expressionSrc.f $
                         $$ \begin{array}{l}  
		               \mbox{\rm\comment{source case }} \\
		               \numConclusion{1} \ \wpSrcExpr{ \expressionSrc.f  }{\psi}{ \excPost}{v.f}  \\
		    	       \mbox{\rm\textit{\{following the definition of the wp function  }} \\
			        \mbox{\rm\textit{ for source expressions in subsection  \ref{pog:wpSrc:wpExpr}  \} }} \\
			       \equiv \wpSrcExpr{\expressionSrc }{ \begin{array}{l}
                                                                 v \neq \Mynull \Rightarrow \psi\\
								 \wedge \\
								 v = \Mynull \Rightarrow \excPost(\NullPointerExc)
								 \end{array} }{ \excPost  }{v}  \\
			       \\
			       \\ 
			        \mbox{\rm\comment{bytecode case }} \\
		               \numConclusion{2} \  \wpBcSeq{ \compileLabel{s}{\expressionSrc.f}{e}}{\phi}{\compile{ \excPost}}   \\
			       \mbox{\rm\comment{following the definition of the compiler function in subsection \ref{pogEq:compile:compExpr} }} \\
			       \equiv \wpBcSeq{ \begin{array}{l}
			                          \compileLabel{s}{\expressionSrc}{e-1} \\
						   e \ \getfield  \ f
						 \end{array} }{\phi}{ \excPost}  \\
			       \mbox{\rm\textit{\{following the definition of the wp function for bytecode    }} \\
			        \mbox{\rm\textit{ in subsection \ref{pog:wpBc}   \} }} \\
			        \equiv \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e-1}}{\\
                                                                          \phantom{wp^{bc}} \begin{array}{l} 
				                                                 \stack{\counter} \neq \Mynull \Rightarrow  \\
										    \phi \subst{\stack{ \counter} }{ \fieldAccess {\stack{\counter}}{\fieldd} } \\
										    \wedge \\
										    \stack{\counter} = \Mynull   \Rightarrow   \excPost (\NullPointerExc)  
										 
				                                            \end{array} }{\\ \phantom{wp^{bc}} \compile{ \excPost}} \\

			

	\mbox{\rm\comment{From \numConclusion{1} and \numConclusion{2} we apply the induction hypothesis  }} \\		
				\exists Q', R' : \formulaSrc , \\ 
			       \numConclusion{3} \
						\wpSrcExpr{\expressionSrc }{ \begin{array}{l}
                                                                 v \neq \Mynull \Rightarrow \psi\\
								 \wedge \\
								  v = \Mynull \Rightarrow \excPost(\NullPointerExc)
								 \end{array} }{ \excPost  }{v}  \\
				\equiv  \\
				Q'  \Rightarrow \begin{array}{l}
				                     v \neq \Mynull \Rightarrow \psi\\
						     \wedge \\
						     v \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
				               \end{array} \\
					      \wedge \\
					       R' \\\\
			  \Rightarrow \\	   
			        \wpBcSeq{ \compile{\expressionSrc}}{\\
                                                                          \phantom{wp^{bc}} \begin{array}{l} 
				                                                 \stack{\counter} \neq \Mynull \Rightarrow  \\
										    \phi \subst{\stack{ \counter} }{ \fieldAccess {\stack{\counter}}{\fieldd} }\\
										    \wedge \\
										    \stack{\counter} = \Mynull   \Rightarrow   \excPost (\NullPointerExc)  
										 
				                                            \end{array} }{\\ \phantom{wp^{bc}} \compile{ \excPost}} \\
				\equiv  \\

\end{array}$$
$$\begin{array}{l}

				Q'  \Rightarrow \begin{array}{ll}
				                                \begin{array}{l} \stack{\counter} \neq \Mynull \Rightarrow \phi\subst{\stack{ \counter}}{\fieldAccess {\stack{\counter}}{\fieldd}}\\
								\wedge \\
								\stack{\counter} = \Mynull \Rightarrow \excPost(\NullPointerExc) 
							  \end{array} &
							  \begin{array}{l}   
						                \subst{\counter}{\counter + 1} \\
								 \subst{\stack{\counter + 1}}{v }
						          \end{array}
				               \end{array} \\	
			        \wedge \\
			       R'
			       \\
			       	\equiv  \\
			
				 \mbox{\rm\comment{$\phi$ contains only stack expressions $\stack{\counter - k } , k \ge 0$ and properties of substitution }} \\
 				 Q'  \Rightarrow \begin{array}{l}
				                                 v \neq \Mynull \Rightarrow \phi
                                                                 \begin{array}{l}
								   \subst{\counter}{\counter + 1} \\
								   \subst{\stack{\counter + 1}}{\fieldAccess{v}{\fieldd} }
								   \end{array}  \\
								\wedge \\
								v = \Mynull \Rightarrow \excPost(\NullPointerExc) 
							  
							  
				               \end{array} \\	
			        \wedge \\
			       R'		\\
			       \\
			       \mbox{\rm\comment{from \numConclusion{3}  this case holds  }}\\
			       		 
		      	\end{array}$$

\end{enumerate}



\begin{exprSrcBcWp2}[Wp of a compiled expression ] \label{pogEq:aux:exprSrcBcWp}
 For any expression $\expressionSrc$ from our source language, for any formula $\psi: \formulaSrc$  
of the source assertion language and any formula $\phi: \formulaBc$ such that $\phi$ may only 
contain stack expressions of the form     $\stack{\counter - k}, k \ge 0$, the following holds
there exist $ Q,R:\formulaSrc, v_1 \ldots v_k :\expressionSrc $
$$ \begin{array}{l}
 \forall \freshVar_1, \ldots  \freshVar_k   ,  Q \Rightarrow \\
 \Myspace \psi 
                                                                             \begin{array}{l}
									        \subst{v_1 }{ \freshVar_1 }  \\
										\ldots \\
										\subst{v_k}{ \freshVar_k } 
									     \end{array}
          \wedge \\ 
	  R  

      
  \\
\Rightarrow \\
 \\

  
	    \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e} }{ \psi }{\excPost} \  \equiv \\ 
            \forall \freshVar_1, \ldots  \freshVar_k ,   Q \Rightarrow \\
	                      \Myspace \phi \begin{array}{l}
                                       \subst{\counter}{\counter + 1}\\
			               \subst{\stack{\counter +1}}{ v }\\
				       \subst{v_1 }{ \freshVar_1 }  \\
				       \ldots \\
				       \subst{v_k}{ \freshVar_k } 
                         \end{array} \\ \\
          \wedge \\ 
	  R 
  \end{array}$$
\end{exprSrcBcWp2}



The next lemma establishes  a relation between the source and bytecode\wpName w.r.t. to the same weakest precondition. 

$\excPost $ 
\begin{wpStmtBcSrc1}[Proof obligation equivalence on statements ] \label{wpStmtBcSrc1}
 
$$ 
    \begin{array}{l}
    \forall \stmt, \psi, \excPostSrc , \\
       \Myspace  \wpStmt{\compileLabel{s}{\stmt}{e}}{ \psi }{ \excPostSrc }  = \\
       \Myspace   \wpSrcStmt{\stmt  }{\psi }{ \excPostSrc }  
	 
    \end{array}
 $$
\end{wpStmtBcSrc1}

This follows from the previous lemma (which establishes the relation between the \wpName over source and the \wpName \ over bytecode that takes into account the compilation structure  )
and lemma \ref{relWpStmt} (which establishes the relation between the \wpName \ over bytecode that takes into account the compilation structure  and the original \wpName which does 
not consider the properties of the compiler )


The next statement establishes under what conditions
 the \wpName \  over source and the \wpName defined in the previous Chapter are equivalent.
 

\todo{for the next lemma we have to say also : if 
      $\compileLabel{s}{\stmt}{e}$ and $ \inter{e}{e+1} $ does not  contain stack expr. then $\wpi{s }{\methodd}{} $  does not  contain stack expr }
\begin{wpStmtBcSrc2}[Proof obligation equivalence on statements] \label{wpStmtBcSrc2}
For every $\stmt$, compilation $\compileLabel{s}{\stmt}{e}$,  formula $\psi$ and 
   exceptional postcondition  function $\excPostExpl $ such that :
 
  \begin{itemize}
         \item $\psi = \inter{e}{e+1}$
	 \item$\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\excPost(\mbox{\rm\texttt{Exc}}, e) $ 
  \end{itemize}
      then it holds 
$$ \wpSrcStmt{\stmt}{\psi }{\excPostSrc }  = \wpi{}{\methodd}{\ins{s} }$$
\end{wpStmtBcSrc2}


From the last lemma follows that if the body of the  method \methodd is $\stmt$, and its compilation is $\compileLabel{s}{\stmt}{e}$, then 
the proof obligations generated over $\stmt$ upon postcondition $\method.\normalPost$ and exceptional
postcondition function  $\method.\excPostSpec$     and its compilation $\compileLabel{s}{\stmt}{e}$ are the same 
$$ \wpSrcStmt{\stmt}{\normalPost }{\excPostSrc }  = \wpi{}{\methodd}{\ins{s} }$$
