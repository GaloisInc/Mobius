

\newtheorem{interProp}{Lemma} % states that the postcondition doesnot change by adding a goto

\newtheorem{exprValueOnStack}[interProp]{Lemma}
\newtheorem{wpStmtBcSrc1}[interProp]{Lemma}
\newtheorem{wpStmtBcSrc2}[interProp]{Lemma}
%\newtheorem{stackCounter}[interProp]{Lemma}
%\newtheorem{dupProp}[interProp]{Lemma}
%\newtheorem{newProp}[interProp]{Lemma}


\section{Auxiliary Properties}

Before stating the main theorem we need some auxiliary properties.
 First, we establish that adding a \instr{goto} \ instruction  to a bytecode of instructions does not change the weakest predicate of the
 augmented bytecode sequence.  


\begin{interProp} \label{interProp}
Assume that we have the block of bytecode instructions $i_1;...;i_k$ 
     $$ \wpBcSeq{ i_1;...;i_k}{ \psi  }  { \excPost } = 
\wpBcSeq{i_1;...;i_k; \goto \  l }{\psi }{\excPost} $$

The proof is based on the fact that the instruction \goto \ does not have side effects and thus,
the following holds: $ \wpBcSeq{ \instr{goto l}}{\psi}{\excPost} = \psi $
\end{interProp}


We now turn to see how the execution of the compilation  $\compile{\expressionSrc}$ of an expression 
$\expressionSrc$ affects the operand stack. In particular, we claim that if the execution of the compiled expression 
 $\compile{\expressionSrc}$ terminates normally then the stack top contains the value of the expression $\compileSynt{\expressionSrc}$.
This actually reflects how we expect that the virtual machine execute bytecode programs.

 This fact in terms of weakest 
preconditons can be expressed as follows: 

\begin{exprValueOnStack}[Wp of a compiled expression ] \label{exprValueOnStack}
For any expression $\expressionSrc$ from our source language, for any formula $\psi: \formulaSrc$  
of the source assertion language and any formula $\phi: \formulaBc$ such that $\phi$ may only 
contain stack expressions of the form     $\stack{\counter - k}, k \ge 0$, there 
exist $ Q, R : \formulaSrc$ such that the following holds


\begin{itemize}
\item 
$$ \begin{array}{l}
      \wpiSrc{  \expressionSrc }{ \psi }{ \excPost} \  \equiv \\ 
          Q \Rightarrow \psi \\
          \wedge \\ 
	  R  \\
  \\
\leftrightarrow \\
 \\

  
	    \wpBcSeq{ \compile{\expressionSrc} }{ \phi }{\compile{\excPost}} \  \equiv \\ 
              \compileSynt{Q} \Rightarrow \phi \begin{array}{l}
                                       \substitution{\counter}{\counter + 1}\\
			               \substitution{\stack{\counter +1}}{ \compileSynt{ \expressionSrc}}
                         \end{array} \\ \\
          \wedge \\ 
	  \compileSynt{R}
  \end{array}$$



\item 
$$ \begin{array}{l}
      \wpiSrc{  \expressionSrc[\expressionSrc_1]  }{ \psi }{ \excPost} \  \equiv \\ 
         \forall \freshVar ,  Q \Rightarrow \psi \substitution{ \compileSrcSpec{\expressionSrc_1} }{ \freshVar }  \\
          \wedge \\ 
	  R  \\
  \\
\leftrightarrow \\
 \\

  
	    \wpBcSeq{ \compile{\expressionSrc} }{ \psi }{\compile{\excPost}} \  \equiv \\ 
            \forall \freshVar ,   \compileSynt{Q} \Rightarrow \phi \begin{array}{l}
                                       \substitution{\counter}{\counter + 1}\\
			               \substitution{\stack{\counter +1}}{ \compileSynt{ \expressionSrc[\freshVar]}}
                         \end{array} \\ \\
          \wedge \\ 
	  \compileSynt{R}
  \end{array}$$



\end{itemize}
\end{exprValueOnStack}

We proceed with several cases of the proof, which is done by induction over the structure of the formula

Proof : 
 


\begin{enumerate} 
		\item    $\expressionSrc = const , const \in \ \constantInt, \Mytrue, \Myfalse $
                     
		     $$ \begin{array}{l}  
		               \mbox{\rm\comment{source case }} \\
		              \numConclusion{1} \wpiSrc{ const}{\psi}{ \excPost}  \\
		    	       \mbox{\rm\comment{following the definition of the wp function for source expressions in subsection  \ref{pog:wpSrc} }} \\
			       \equiv \psi \\
			       \\
			       \\ 
			
		               \mbox{\rm\comment{bytecode case }} \\
		               \numConclusion{2} \wpBcSeq{ \compile{const}}{\phi}{ \compile{\excPost}}  \\
		    	       \mbox{\rm\comment{following the definition   of the compiler function in subsection \ref{compExpr} }} \\
			       \equiv \wpBcSeq{\push \compileSynt{const} }{\phi}{ \compile{\excPost}}  \\
			       \mbox{\rm\comment{following the definition of the wp function for bytecode in subsection \ref{pog:wpBc}   }} \\
			       \equiv \phi \begin{array}{l}
                                                \substitution{ \counter }{ \counter + 1}\\
						\substitution{\stack{ \counter +1} }{  \compileSynt{const}}	
					    \end{array} \\
			        \\
				\\
				 \mbox{\rm\comment{from \numConclusion{1} and   \numConclusion{2} and $Q,R = \true $ this case holds   }} \\
					 
				    
			\end{array}$$
                        
			
			
                \item  $\expressionSrc = \expressionSrc.f $
                         $$ \begin{array}{l}  
		               \mbox{\rm\comment{source case }} \\
		               \numConclusion{1} \ \wpiSrc{ \expressionSrc.f  }{\psi}{ \excPost}  \\
		    	       \mbox{\rm\textit{\{following the definition of the wp function  }} \\
			        \mbox{\rm\textit{ for source expressions in subsection  \ref{pog:wpSrc}  \} }} \\
			       \equiv \wpiSrc{\expressionSrc }{ \begin{array}{l}
                                                                 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \psi\\
								 \wedge \\
								 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
								 \end{array} }{ \excPost  }  \\
			       \\
			       \\ 
			        \mbox{\rm\comment{bytecode case }} \\
		               \numConclusion{2} \  \wpBcSeq{ \compile{\expressionSrc.f}}{\phi}{\compile{ \excPost}}   \\
			       \mbox{\rm\comment{following the definition of the compiler function in subsection \ref{compExpr} }} \\
			       \equiv \wpBcSeq{ \begin{array}{l}
			                          \compile{\expressionSrc}; \\
						   \getfield  \ f
						 \end{array} }{\phi}{ \excPost}  \\
			       \mbox{\rm\textit{\{following the definition of the wp function for bytecode    }} \\
			        \mbox{\rm\textit{ in subsection \ref{pog:wpBc}   \} }} \\
			        \equiv \wpBcSeq{ \compile{\expressionSrc}}{\\
                                                                          \phantom{wp^{bc}} \begin{array}{l} 
				                                                 \stack{\counter} \neq \Mynull \Rightarrow  \\
										    \phi \substitution{\stack{ \counter} }{  f (\stack{\counter}) } \\
										    \wedge \\
										    \stack{\counter} = \Mynull   \Rightarrow  \compile{ \excPost} (\NullPointerExc)  
										 
				                                            \end{array} }{\\ \phantom{wp^{bc}} \compile{ \excPost}} \\

				\mbox{\rm\comment{from \numConclusion{1} and \numConclusion{2} we apply the induction hypothesis  }} \\		
				\exists Q', R' : \formulaSrc , \\ 
			       \numConclusion{3} \
						\wpiSrc{\expressionSrc }{ \begin{array}{l}
                                                                 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \psi\\
								 \wedge \\
								 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
								 \end{array} }{ \excPost  }  \\
				\equiv  \\
				Q'  \Rightarrow \begin{array}{l}
				                     \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \psi\\
						     \wedge \\
						     \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
				               \end{array} \\
					      \wedge \\
					       R' 
				\\	   \\ 
			      \numConclusion{4}   \  \wpBcSeq{ \compile{\expressionSrc}}{\\
                                                                          \phantom{wp^{bc}} \begin{array}{l} 
				                                                 \stack{\counter} \neq \Mynull \Rightarrow  \\
										    \phi \substitution{\stack{ \counter} }{ f (\stack{\counter}) } \\
										    \wedge \\
										    \stack{\counter} = \Mynull   \Rightarrow  \compile{ \excPost} (\NullPointerExc)  
										 
				                                            \end{array} }{\\ \phantom{wp^{bc}} \compile{ \excPost}} \\
				\equiv  \\
				 \compile{Q'}  \Rightarrow \begin{array}{ll}
				                                \begin{array}{l} \stack{\counter} \neq \Mynull \Rightarrow \phi\substitution{\stack{ \counter} }{ f (\stack{\counter}) }  \\
								\wedge \\
								\stack{\counter} \neq \Mynull \Rightarrow \compile{\excPost}(\NullPointerExc) 
							  \end{array} &
							  \begin{array}{l}   
						                \substitution{\counter}{\counter + 1} \\
								 \substitution{\stack{\counter + 1}}{\compileSynt{\expressionSrc }}
						          \end{array}
				               \end{array} \\	
			        \wedge \\
			       \compile{R'}	
			       \\
			       	\equiv  \\
				\end{array}
				$$
				$$
				\begin{array}{l}
				 \mbox{\rm\comment{$\phi$ contains only stack expressions $\stack{\counter - k } , k \ge 0$ and properties of substitution }} \\
 				 \compile{Q'}  \Rightarrow \begin{array}{l}
				                                 \compileSynt{\expressionSrc } \neq \Mynull \Rightarrow \phi
                                                                 \begin{array}{l}
								   \substitution{\counter}{\counter + 1} \\
								   \substitution{\stack{\counter + 1}}{\compileSynt{f(\expressionSrc)}}
								   \end{array}  \\
								\wedge \\
								\compileSynt{\expressionSrc } \neq \Mynull \Rightarrow \compile{\excPost}(\NullPointerExc) 
							  
							  
				               \end{array} \\	
			        \wedge \\
			       \compile{R'}		\\
			       \\
			       \mbox{\rm\comment{from \numConclusion{3} and \numConclusion{4} this case holds  }}\\
			       		 
		      	\end{array}$$

\end{enumerate}







The next lemma establishes  a relation between the source and bytecode\wpName w.r.t. to the same weakest precondition. 

$\excPost $ 
\begin{wpStmtBcSrc1}[Proof obligation equivalence on statements ] \label{wpStmtBcSrc1}
 
$$ 
    \begin{array}{l}
    \forall \stmt, \psi, \excPostSrc , \\
       \Myspace  \wpStmt{\compileLabel{s}{\stmt}{e}}{ \psi }{ \compile{\excPostSrc} }  = \\
       \Myspace   \wpiSrc{\stmt  }{\psi }{ \excPostSrc }  
	 
    \end{array}
 $$
\end{wpStmtBcSrc1}

This follows from the previous lemma (which establishes the relation between the \wpName over source and the \wpName \ over bytecode that takes into account the compilation structure  )
and lemma \ref{relWpStmt} (which establishes the relation between the \wpName \ over bytecode that takes into account the compilation structure  and the original \wpName which does 
not consider the properties of the compiler )


The next statement establishes under what conditions
 the \wpName \  over source and the \wpName defined in the previous Chapter are equivalent.
 
\begin{wpStmtBcSrc2}[Proof obligation equivalence on statements ] \label{wpStmtBcSrc2}
For every $\stmt$, compilation $\compileLabel{s}{\stmt}{e}$,  formula $\psi$ and 
   exceptional postcondition  function $\excPostExpl $ such that :
 
  \begin{itemize}
         \item $\psi = \inter{e}{e+1}$
	 \item$\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\excPost(\mbox{\rm\texttt{Exc}}, j ) $ 
  \end{itemize}
      then it holds 
$$ \wpiSrc{\stmt}{\psi }{\excPostSrc }  = \wpi{}{\methodd}{\ins{s} }$$
\end{wpStmtBcSrc2}


From the last lemma follows that if the body of the  method \methodd is $\stmt$, and its compilation is $\compileLabel{s}{\stmt}{e}$, then 
the proof obligations generated over $\stmt$ upon postcondition $\method.\normalPost$ and exceptional
postcondition function  $\method.\excPostSpec$     and its compilation $\compileLabel{s}{\stmt}{e}$ are the same 
$$ \wpiSrc{\stmt}{\normalPost }{\excPostSrc }  = \wpi{}{\methodd}{\ins{s} }$$
