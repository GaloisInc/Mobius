
\newtheorem{Expression}{Definition}[section]
\newtheorem{ExpressionRel}[Expression]{Definition}
\newtheorem{Statement}[Expression]{Definition}

\section{Source language} \label{source}


We present a source Java-like programming language which supports the following features:
object manipulation and creation, method invokation, throwing and handling exceptions, subroutines etc. Fig. \ref{source:grammar} gives the formal grammar of the source language.
\begin{figure}[ht!] 
\begin{frameit}
   $$ \begin{array} {ll}    
     \expressionSrc ::=         & \constantInt  \\
				& \mid \Mytrue \\ 
				& \mid \Myfalse \\
				& \mid \Mynull  \\
				& \mid \this \\
				& \mid \expressionSrc \ op \ \expressionSrc \\  
				& \mid \expressionSrc.f \\
				& \mid \var \\
  			        & \mid (Class) \ \expressionSrc \\
				& \mid \expressionSrc.m( ) \\
				& \mid  \newSrc \ Class  ( \expressionSrc  ) \\ 
				& \mid \expressionSrcRel \\
                                & \\
				& \\
     \expressionSrcRel ::=      & \expressionSrc \ \rel \ \expressionSrc \\
				& \mid \expressionSrc \ \instanceofSrc \ Class\\
				& \\   
				& \rel \in \{ \le, < ,  \ge, >, = , \neq \}      \\
				& \\
				& \\
      \stmt ::=		        & \Myskip \\
                                & \mid \stmt;\stmt \\
                                & \mid \Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} \  \Myelse \ \{ \stmt \}  \\
				& \mid \Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \}	\\
			        & \mid \try  \ \{ \stmt \}  \ \catch \ ( \mbox{\rm\texttt{Exc} } )\ \{ \stmt \} \\
		                & \mid \try  \ \{ \stmt \} \ \finally \ \{ \stmt \} \\
			%	& \mid \try  \ \{ \stmt \} \ \catch \ ( \mbox{\rm\texttt{Exc} }  )\ \{ \stmt \} \ \finally \ \{ \stmt \} \\
				& \mid \throw \ \expressionSrc  \\
                                & \mid \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \}\ \\
				& \mid \returnSrc \  \expressionSrc \\
			%	& \mid \returnSrc \\
                   		& \mid \expressionSrc = \expressionSrc \\        
    \end{array} $$
\caption{\sc Source language}
\label{source:grammar}
\end{frameit}
\end{figure}


    As we can see from the figure, the language supports 
    integer constants $\constantInt$, the boolean constants  $ \Mytrue$ and $\Myfalse$, the null constant \Mynull \ 
    denoting  the empty reference, a construct \this \ for referring to the current object,  
    arithmetic expressions  $\expressionSrc \ \arithOp \ \expressionSrc$ where $\arithOp \in  \{+ , - , div , rem, * \}$.
    The language  allows to talk about the value stored in a field \fieldd \ for the object reference $\expressionSrc $
    via the construct  $ \fieldAccess{\expressionSrc}{\fieldd} $, cast expressions  $(Class) \expressionSrc$
    and method local variables  and parameters \var.  
    The language also has constructs for expressing method invokations  $ \expressionSrc.m()  $  as well as instance creation
    $\newSrc \ Class(\expressionSrc )$. For the sake of clarity we consider only non void  methods which do not receive parameters and constructors
    that receive exactly one argument without losing
    any specific feature   of modular object oriented  languages. 
    The language allows to express a relation between  expressions via the construct
     $\expressionSrc \ \rel \ \expressionSrc $ where $\rel  \in \{ \le, < ,  \ge, >, = , \neq \}$ as well as to state that an expression 
   $\expressionSrc$ is an instance of class Class via  $\expressionSrc \ \instanceofSrc \ Class$.
    
    The expressions can be of object types or basic types. Formally the types are 

    $$
\JavaType ::= Class, \ Class \in \ClassTypes \mid \Myint \mid \Mybool
$$ 




% informal description 

  The source language supports also control flow constructs like  the statement which does nothing \Myskip, the  compositional statement
  $\stmt;\stmt$. The conditional statement
  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ $  \Myelse \ \{ \stmt \}  $ which stands for
  an if statement.%  We also have a construct  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ which has the semantics 
%  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ $  \Myelse \ \{ \Myskip\}  $.  However, we include it explicitely 
%  as it is useful and makes the language more realistic.  
   The semantics of the construct is the standard one, i.e. if the relation expression $\expressionSrcRel$ 
  evaluates to true then the statement in the $ \Mythen$ branch is executed, otherwise the statement in the
  $\Myelse$ branch is executed. Next, there is a construct for handling exceptions $ \try  \ \{ \stmt \}  \ \catch \ ( Class  )\ \{ \stmt \}  $.
  Its meaning is that if the statement following the $ \try $ keyword throws an exception of type \texttt{Exc} then
  the exception will be caught by the statement following the  $ \catch $ keyword. The source language supports also 
  subroutines via the statement $ \try  \ \{ \stmt \}  $ $ \finally \ \{ \stmt \}$.  The meaning of the construct is that  
  no matter how the statement following the keyword \try \ terminates,
  the statement introduced by the keyword \finally \ must execute after it. The language also provides a construct for expressing loops 
   $ \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} $ states for a loop statement where the body 
   statement $ \stmt$ will be executed until the relational expression  $\expressionSrcRel$ evaluates to false.
   Note that a loop statement is provided with a predicate \invariant \ which must hold whenever the loop entry is reached and with a list of expressions
   \modLoop \ which give all the locations that  may be modified per loop iteration. The construct $ \returnSrc \  \expressionSrc $ is
   the statement by which method execution may terminate and control will be transfered to the method caller.
   The last statement that we consider is the assignment statement $ \expressionSrc = \expressionSrc$.
    It states that the expression on the left of the assignment sign $=$ is assigned the value of the expression on the right.

In Fig. \ref{pogComp:source:example}, we give an example program written in our source language. The figure shows 
the method \lstinline!square! which calculates the 
the   square of the parameter \lstinline!i!. First, the absolute value of \lstinline!i! is stored in the variable \lstinline!v!.
Then  the while statement  calculates the sum of the impair positive numbers whose whole division by 2 is smaller than
\lstinline!v! which is the square of \lstinline!i!.  The example is also
provided with specification written in JML. The specification states
that the method returns the square of its parameter and that the loop
invariant is \lstinline!(0 <= s) && (s <= v) && sqr == s*s!.

\begin{figure}[ht!]
 \begin{lstlisting}[frame=trbl] 
//@ ensures \result == i*i; 
public int square( int i ) {
  int sqr  = 0;
  int v = 0;
  if ( i < 0)
    then {
      v = -i;} 
    else {
      v = i;}
  int s = 0;
  /*@ loop_modifies s, sqr;
    @ loop_invariant (0 <= s) && (s <= v) && sqr == s*s ;
    @*/
  while( s < v ) {
    sqr = sqr + 2*s + 1;
    s = s+1;}
  return sqr;}
\end{lstlisting}
\caption{\sc method  \lstinline!square! written in our source language}
\label{pogComp:source:example}

\end{figure}
