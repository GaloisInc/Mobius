
\newtheorem{Expression}{Definition}[section]
\newtheorem{ExpressionRel}[Expression]{Definition}
\newtheorem{Statement}[Expression]{Definition}

\section{Source language} \label{source}


We present a source Java-like programming language which supports the following features:
object manipulation and creation, method invokation, throwing and handling exceptions, subroutines etc. Fig. \ref{source:grammar} gives the formal grammar of the source language.
\begin{figure}[ht!] 
\begin{frameit}
   $$ \begin{array} {ll}    
     \expressionSrc ::=         & \constantInt  \\
				%& \mid \Mytrue \\ 
				%& \mid \Myfalse \\
				& \mid \Mynull  \\
				& \mid \this \\
				& \mid \expressionSrc \ \op \ \expressionSrc \\  
				& \mid \expressionSrc.f \\
				& \mid \var \\
  			        & \mid (Class) \ \expressionSrc \\
				& \mid \expressionSrc.m() \\
				& \mid  \newSrc \ \class  ( ) \\
				& \\
				&  \op \in \{ +, - , *, \}  \\
				%& \mid \expressionSrcRel \\
                                & \\
				& \\
     \expressionSrcRel ::=      & \expressionSrc \ \rel \ \expressionSrc \\
				%& \mid \expressionSrc \ \instanceofSrc \ Class\\
				& \\   
				& \rel \in \{ \le, < ,  \ge, >, = , \neq \}      \\
				& \\
				& \\
      \stmt ::=		        & \Myskip \\
                                & \mid \stmt;\stmt \\
                                & \mid \Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} \  \Myelse \ \{ \stmt \}  \\
			        & \mid \try  \ \{ \stmt \}  \ \catch \ ( \mbox{\rm\texttt{Exc} } )\ \{ \stmt \} \\
		                & \mid \try  \ \{ \stmt \} \ \finally \ \{ \stmt \} \\
			%	& \mid \try  \ \{ \stmt \} \ \catch \ ( \mbox{\rm\texttt{Exc} }  )\ \{ \stmt \} \ \finally \ \{ \stmt \} \\
				& \mid \throw \ \expressionSrc  \\
                                & \mid \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \}\ \\
				& \mid \returnSrc \  \expressionSrc \\
			%	& \mid \returnSrc \\
                   		& \mid \expressionSrc = \expressionSrc \\        
    \end{array} $$
\caption{\sc Source language}
\label{source:grammar}
\end{frameit}
\end{figure}


    As we can see from the figure, the language supports 
    integer constants $\constantInt$, the null constant \Mynull \ 
    denoting  the empty reference, a construct \this \ for referring to the current object,  
    arithmetic expressions  $\expressionSrc \ op \ \expressionSrc$ where $op \in  \{+ , - , div , rem, * \}$.
    The value stored in a field \fieldd \ for the object reference $\expressionSrc $ is denoted with
    the construct  $ \fieldAccess{\expressionSrc}{\fieldd} $, cast expressions with   $(Class) \expressionSrc$
    and method local variables  and parameters with identifiers taken from the set \var.  
    The language also has constructs for expressing method invokation.  For the sake of clarity we consider only non void  instance  methods which does not 
    receive parameters.
    Thus, the first expression in the syntax of the method invokation stands for the receiver object and 
    the expression which is in brackets after the  method name is the unique argument of the  method.
    The language supports also instance creation. Note that constructors take one argument.
    A relation between    expressions is denoted with
     $\expressionSrc \ \rel \ \expressionSrc $ where $\rel  \in \{ \le, < ,  \ge, >, = , \neq \}$. 
    % The language supports also the construct  $\expressionSrc \ \instanceofSrc \ \class$ which means that $\expressionSrc$ is an instance of class \class.
    Expressions can be of reference type or integers. %Formally the types are 

%$$ \JavaType ::= \ClassTypes \mid \Myint \mid \Mybool $$ 




 % informal description 

  The source language supports control flow constructs like 
  compositional statement, conditional statement, assignment statement, return statement etc.
% the statement which does nothing \Myskip, the  compositional statement
%  $\stmt;\stmt$. The conditional statement
%  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ $  \Myelse \ \{ \stmt \}  $ which stands for
%  an if statement.%  We also have a construct  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ which has the semantics 
%   The semantics of the construct is the standard one, i.e. if the relation expression $\expressionSrcRel$ 
%  evaluates to true then the statement in the $ \Mythen$ branch is executed, otherwise the statement in the
%  $\Myelse$ branch is executed. 
  There is also a construct for handling exceptions $ \try  \ \{ \stmt \}  \ \catch \ ( Class  )\ \{ \stmt \}  $.
  Its meaning is that if the statement following the $ \try $ keyword throws an exception of type \texttt{Exc} then
  the exception will be caught by the statement following the  $ \catch $ keyword. An interesting feature  is the finally statement
  introduced via the syntax $ \try  \ \{ \stmt \}  $ $ \finally \ \{ \stmt \}$.  The meaning of the construct is that  
  no matter how the statement following the keyword \try \ terminates (on an exception or normally),
  the statement introduced by the keyword \finally \ must execute after it. If the try block terminates normally then the
  whole try statement will terminate as the finally block. If the try block terminates on exception \Exc{} and if the finally block
  terminates normally, the whole try finally statement terminates for on the exception  \Exc{}.  If the try block terminates on exception \Exc{} and if the finally block
  terminates on exception \Exc' then the whole try finally  terminates on exception \Exc'.
  Loop statements are also supported.  They are provided with a predicate \invariant \ which must hold whenever 
  the loop entry is reached and with a list of expressions
   \modLoop \ which lists the locations that  may be modified per loop iteration.
%  The construct $ \returnSrc \  \expressionSrc $ is
%   the statement by which method execution may terminate and control will be transfered to the method caller.
%   The last statement that we consider is the assignment statement $ \expressionSrc = \expressionSrc$.
%    It states that the expression on the left of the assignment sign $=$ is assigned the value of the expression on the right.

In Fig. \ref{pogComp:source:example}, we give an example program written in our source language. The figure shows 
the method \lstinline!square! which calculates the 
the   square of the parameter \lstinline!i!. First, the absolute value of \lstinline!i! is stored in the variable \lstinline!v!.
Then  the while statement  calculates the sum of the impair positive numbers whose whole division by 2 is smaller than
\lstinline!v! which is the square of \lstinline!i!.  The example is also
provided with specification written in JML. The specification states
that the method returns the square of its parameter and that the loop
invariant is \lstinline!(0 <= s) && (s <= v) && sqr == s*s!.

\begin{figure}[ht!]
 \begin{lstlisting}[frame=trbl] 
//@ ensures \result == i*i; 
public int square( int i ) {
  int sqr  = 0;
  int v = 0;
  if ( i < 0)
    then {
      v = -i;} 
    else {
      v = i;}
  int s = 0;
  /*@ loop_modifies s, sqr;
    @ loop_invariant (0 <= s) && (s <= v) && sqr == s*s ;
    @*/
  while( s < v ) {
    sqr = sqr + 2*s + 1;
    s = s+1;}
  return sqr;}
\end{lstlisting}
\caption{\sc method  \lstinline!square! written in our source language}
\label{pogComp:source:example}

\end{figure}
