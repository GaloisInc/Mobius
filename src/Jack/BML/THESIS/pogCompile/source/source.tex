
\newtheorem{Expression}{Definition}[section]
\newtheorem{ExpressionRel}[Expression]{Definition}
\newtheorem{Statement}[Expression]{Definition}

\section{Java like source language} \label{source}


We present a source Java-like programming language which supports the following features:
object manipulation and creation, method invokation, throwing and handling exceptions, subroutines etc. 
The language has only side effect free expressions for the sake of simplicity.
 Fig. \ref{source:grammar} gives the formal grammar of the source language.
\begin{figure}[ht!] 
\begin{frameit}
   $$ \begin{array} {ll}    
     \expressionSrc ::=         & \constantInt  \\
				%& \mid \Mytrue \\ 
				%& \mid \Myfalse \\
				& \mid \Mynull  \\
				& \mid \this \\
				& \mid \expressionSrc \ \op \ \expressionSrc \\  
				& \mid \expressionSrc.f \\
				& \mid \var \\
  			        & \mid (Class) \ \expressionSrc \\
				& \mid \expressionSrc.m() \\
				& \mid  \newSrc \ \class  ( ) \\
				& \\
				&  \op \in \{ +, - , *, \}  \\
				%& \mid \expressionSrcRel \\
                                & \\
				& \\
     \expressionSrcRel ::=      & \expressionSrc \ \rel \ \expressionSrc \\
				%& \mid \expressionSrc \ \instanceofSrc \ Class\\
				& \\   
				& \rel \in \{ \le, < ,  \ge, >, = , \neq \}      \\
				& \\
				& \\
      \stmt ::=		        %& \Myskip \\
                                & \mid \stmt;\stmt \\
                                & \mid \Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} \  \Myelse \ \{ \stmt \}  \\
			        & \mid \try  \ \{ \stmt \}  \ \catch \ ( \mbox{\rm\texttt{Exc} } )\ \{ \stmt \} \\
		                & \mid \try  \ \{ \stmt \} \ \finally \ \{ \stmt \} \\
			%	& \mid \try  \ \{ \stmt \} \ \catch \ ( \mbox{\rm\texttt{Exc} }  )\ \{ \stmt \} \ \finally \ \{ \stmt \} \\
				& \mid \throw \ \expressionSrc  \\
                                & \mid \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \}\ \\
				& \mid \returnSrc \  \expressionSrc \\
			%	& \mid \returnSrc \\
                   		& \mid \expressionSrc = \expressionSrc \\        
    \end{array} $$
\caption{\sc Source language}
\label{source:grammar}
\end{frameit}
\end{figure}


    As we can see from the figure, the language supports 
    integer constants $\constantInt$, the null constant \Mynull \ 
    denoting  the empty reference, a construct \this \ for referring to the current object,  
    arithmetic expressions  $\expressionSrc \ op \ \expressionSrc$ where $op \in  \{+ , - , div , rem, * \}$.
    The value stored in a field \fieldd \ for the object reference $\expressionSrc $ is denoted with
    the construct  $ \fieldAccess{\expressionSrc}{\fieldd} $, cast expressions with   $(Class) \expressionSrc$
    and method local variables  and parameters with identifiers taken from the set \var.  
    The language also has constructs for expressing method invokation.  For the sake of clarity we consider only non void  instance  methods which does not 
    receive parameters.
    Thus, the first expression in the syntax of the method invokation stands for the receiver object.  
    The language supports also instance creation construct. Note that constructors like methods do not take arguments.
    The semantics of instance creation expression $\newSrc \ \class{}$  is that it 
    creates a new reference of type \class{} in the heap  which is initialised by the class constructor $\class$.
    A relation between    expressions is denoted with
    $\expressionSrc \ \rel \ \expressionSrc $ where $\rel  \in \{ \le, < ,  \ge, >, = , \neq \}$.
  
    The source language supports also standard control flow constructs like 
    compositional statement, conditional statement, assignment statement, return statement etc.
% the statement which does nothing \Myskip, the  compositional statement
%  $\stmt;\stmt$. The conditional statement
%  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ $  \Myelse \ \{ \stmt \}  $ which stands for
%  an if statement.%  We also have a construct  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ which has the semantics 
%   The semantics of the construct is the standard one, i.e. if the relation expression $\expressionSrcRel$ 
%  evaluates to true then the statement in the $ \Mythen$ branch is executed, otherwise the statement in the
%  $\Myelse$ branch is executed. 
  There is also a construct for handling exceptions $ \try  \ \{ \stmt \} $ $ \catch \ ( Class  )\ \{ \stmt \}  $.
  Its meaning is that if the statement following the $ \try $ keyword throws an exception of type \texttt{Exc} then
  the exception will be caught by the statement following the  $ \catch $ keyword. The language also supports 
  try finally statements, a construct which is particular to the Java language.
  The meaning of the construct is that  no matter how the statement following the keyword \try \ terminates (on an exception or normally),
  the statement introduced by the keyword \finally \ must execute after it. If the try block terminates normally then the
  whole try statement will terminate as the finally block. If the try block terminates on exception \Exc{} and if the finally block
  terminates normally, the whole try finally statement terminates  on the exception  \Exc{}.  If the try block terminates on exception \Exc{} and if the finally block
  terminates on exception \Exc' then the whole try finally  terminates on exception \Exc'.
  Loop statements are also supported.  Note that there syntax inlcudes  a formula \invariant \ which must hold whenever 
  the loop entry is reached as well as a  list of expressions
  \modLoop \ which lists the locations that  may not have the same value at the beginning
  and at the end of a loop iteration. Note that a  variable should not be in the list \modLoop{} even if during a loop iteration its value is changed
  as far as at the end of the iteration the value it had in the beginning of the iteration is restored.
%  The construct $ \returnSrc \  \expressionSrc $ is
%   the statement by which method execution may terminate and control will be transfered to the method caller.
%   The last statement that we consider is the assignment statement $ \expressionSrc = \expressionSrc$.
%    It states that the expression on the left of the assignment sign $=$ is assigned the value of the expression on the right.

% In Fig. \ref{pogComp:source:example}, we give an example program written in our source language. The figure shows 
%the method \lstinline!square! which calculates the 
%the   square of the parameter \lstinline!i!. First, the absolute value of \lstinline!i! is stored in the variable \lstinline!v!.
%Then  the while statement  calculates the sum of the impair positive numbers whose whole division by 2 is smaller than
%\lstinline!v! which is the square of \lstinline!i!.  The example is also
%provided with specification written in JML. The specification states
%that the method returns the square of its parameter and that the loop
%invariant is \lstinline!(0 <= s) && (s <= v) && sqr == s*s!.
%
%\begin{figure}[ht!]
% \begin{lstlisting}[frame=trbl] 
%//@ ensures \result == i*i; 
%public int square( int i ) {
%  int sqr  = 0;
%  int v = 0;
%  if ( i < 0)
%    then {
%      v = -i;} 
%    else {
%      v = i;}
%  int s = 0;
%  /*@ loop_modifies s, sqr;
%    @ loop_invariant (0 <= s) && (s <= v) && sqr == s*s ;
%    @*/
%  while( s < v ) {
%    sqr = sqr + 2*s + 1;
%    s = s+1;}
%  return sqr;}
%\end{lstlisting}
%\caption{\sc method  \lstinline!square! written in our source language}
%\label{pogComp:source:example}

%\end{figure}
