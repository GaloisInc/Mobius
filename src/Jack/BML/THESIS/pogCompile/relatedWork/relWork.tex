\section{Related work}\label{pog:relWork}


Several works dealing with the relation between the 
verification conditions over source and its compilation into a low  level  programming  language exist.

Barthe, Rezk and Saabas in \cite{gta05:fast} also argue that proof obligations produced
over source code and
bytecode produced by a nonoptimizing compiler   are equivalent.
The source language which they use supports method invokation, exception throwing and handling. 
They do not consider instructions that may throw runtime exceptions which simplifies the reasoning over expressions. 
 However, in their work they do not discuss  what are the  assumptions about the compiler 
or the  properties that it might verify  which will guarantee this equivalence.
 We claim that the proof presented in \cite{gta05:fast} for
 the verification condition preserving compilation is correct only if the non optimizing 
 compiler has the properties discussed here in Section \ref{compile}, subsection \ref{compile:prop}.


In \cite{SU05CNS}, Saabas and Uustalu present a goto language provided with a compositional structure called SGoto.
They give a Hoare logic rules for the SGoto language and compiler from the source language into SGoto.
They show that if a source program has a Hoare logic derivation
 against a pre and postcondition then its compilation in SGoto will also have a Hoare
 logic derivation in the aformentioned Hoare logic rules for the SGoto language. 
A limitation of such an approach is that the bytecode logic is defined over structured pieces of code. In particular,
it becomes not so suitable for  a  PCC framework. This is because the code producer must supply along with the 
bytecode and the certificate the structure of the unstructured code that the client has used to
 generate the certificate. In case of a non-optimizing compiler, this will allow the client to reveal the original source 
which can be an undesirable compromise for the producer. 
Here, we propose a direct relation between source and bytecode verification conditions. 
 For this, as Saabas and Uustalo we use a  weakest precondition defined over the compilation of a source program 
but which is only an intermediate stage in the proof. 
We then show that the verification condition generated by
a weakest precondition calculus over a source program is syntactically equivalent to the 
weakest precondition over the compilation of the program. We also show that the weakest precondition over compiled source statements
and the weakest precondition over a single bytecode instruction given in Chapter \ref{wpGeneral} are syntactically equivalent.
This allows us to conclude that verification conditions over source code and verification conditions produced over its bytecode version
are syntactically the same (modulo names and basic types).

%\todo{to be continued.  je ne sais pas comment dire mais il faut dire que c'est un peu tough de retrouve dans un program bytecode les structure qu'ils proposent }
 

% \todo{because they do not expose those conditions, 
%they cannot use the induction hypothesis because they have not proven that the condition to apply the induction hold}

% Peter Mueller
 In \cite{FB04LBT}, F.Bannwart and P.Muller show how to transform a Hoare style logic derivation on source Java like
 program into a Hoare style logic derivation of a Java bytecode like program. This solution however has the shortcoming
that the certificate (in this case it is the Hoare style logic derivation) can be potentially large. In particular, this means that
applying this technique in scenarios like PCC could be hardly applicable because of the large size of the certificate. 
    


% see what are the others 
