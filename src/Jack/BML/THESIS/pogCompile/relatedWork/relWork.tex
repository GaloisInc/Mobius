\section{Related Work}\label{pog:relWork}


Several works dealing with the relation between the 
verification conditions over source and its compilation into a low  level  programming  language exist.

Barthe, Rezk and Saabas in \cite{gta05:fast} also argue that proof obligations produced
over source code and
bytecode produced by a nonoptimizing compiler   are equivalent.
The source language which they use supports method invokation, exception throwing and handling. 
They do not consider instructions that may throw
runtime exceptions. 
 However, in their work they do not discuss  what are the  assumptions about the compiler 
or the  properties that it might verify  which will guarantee this equivalence.
 We claim that the proof presented in \cite{gta05:fast} for
 the verification condition preserving compilation holds only if the non optimizing 
 compiler has the properties discussed here in Section \ref{compile}.


In \cite{SU05CNS}, Saabas and Uustalu present a goto language provided with a compositional structure called SGoto.
They give a Hoare logic rules for the language where they mention explicitely the program counter in the assertions and define a nonoptimizing 
compiler from the source language into SGoto. Few  restrictions are imposed on the compiler. 
They show that if a source program has a Hoare logic derivation
 against a pre and postcondition then its compilation in SGoto will also have a Hoare
 logic derivation in the aformentioned Hoare logic rules. However, we consider that this is not sufficient for a practical use especially when 
talking about programs written in an unstructured language. 
For instance, using this approach in a PCC scenario would mean that the consumer should know the structure of 
of the  executable code in order that the proof can be checked. This may not be desirable for several reasons:
the producer does not want to  give the structure because he does not want that the producer may get the source version of its program; 
or even if he does it, this means that the verification process on the consumer side could become heavier as the unstructured program
 should be transformed somehow in a SGoto program.
 Thus, it is more relevant if possible to get directly  a relation between a structured program 
and its compilation in an  unstructured  language which is the aim of the current chapter.
 For this, as Saabas and Uustalo we use a  structured version of the compilation of a source program 
but which is an intermediate stage of our proof that source structured programs and bytecode unstructured 
programs have the same verifictaion conditions.

%\todo{to be continued.  je ne sais pas comment dire mais il faut dire que c'est un peu tough de retrouve dans un program bytecode les structure qu'ils proposent }
 

% \todo{because they do not expose those conditions, 
%they cannot use the induction hypothesis because they have not proven that the condition to apply the induction hold}

% Peter Mueller
 In \cite{FB04LBT}, F.Bannwart and P.Muller show how to transform a Hoare style logic derivation on source Java like
 program into a Hoare style logic derivation of a Java bytecode like program. This solution however has the shortcoming
that the certificate (in this case it is the Hoare style logic derivation) can be potentially large. In particular, this means that
applying this technique in scenarios like PCC could be hardly applicable because of the large size of the certificate. 
    


% see what are the others 
