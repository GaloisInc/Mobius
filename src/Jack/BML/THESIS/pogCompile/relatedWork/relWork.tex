\section{Related work}\label{pog:relWork}


Several works dealing with the relation between the 
verification conditions over source and its compilation into a low  level  programming  language exist.

Barthe, Rezk and Saabas in \cite{gta05:fast} also argue that verification conditions produced
over source code and bytecode produced by a nonoptimizing compiler   are equivalent.
 The verification condition generators over source and bytecode are such that verification conditions
are discharged immediately when they are generated. This is different from our approach where the
 verification condition generator are propagated by the verification condition generator
 up to the entry point of a method body. However, the first technique requires much stronger
 annotations than the latter. The source language which they use supports method invokation, exception throwing and handling.
The evaluation of expressions do not throw exceptions   which simplifies the reasoning over expressions.

 % We claim that the proof presented in \cite{gta05:fast} for
 % the verification condition preserving compilation is correct only if the non optimizing 
 % compiler has the properties discussed here in Section \ref{compile}, subsection \ref{compile:prop}.


In \cite{SU05CNS}, Saabas and Uustalu present a goto language provided with a compositional structure called SGoto.
They give a Hoare logic rules for the SGoto language and compiler from the source language into SGoto.
They show that if a source program has a Hoare logic derivation
 against a pre and postcondition then its compilation in SGoto will also have a Hoare
 logic derivation in the aformentioned Hoare logic rules for the SGoto language. 
A limitation of such an approach is that the bytecode logic is defined over structured pieces of code. 
In particular, in a  PCC framework this could be problematic. The first reason is that the code producer must supply along with the 
bytecode and the certificate the structure of the unstructured code that the client has used to
 generate the certificate. The second reason is that the certificate  can be potentially large  as it consists of a Hoare logic
 derivation and thus, contains annotation for every instruction in the bytecode. In a PCC scenario, this could slow down the downloading
time of the certificate if it comes via a network or could be problematic if it must be stored on a device  where it will be checked especially if the device
has limitted resources.
%In case of a non-optimizing compiler, this will allow the client to reveal the original source 
%which can be an undesirable compromise for the producer. 
%Here, we propose a direct relation between source and bytecode verification conditions which does not require that the producer
%supply information about the code structure. 

% For this, as Saabas and Uustalo we use a  weakest precondition defined over the compilation of a source program 
%but which is only an intermediate stage in the proof. 
%We then show that the verification condition generated by
%a weakest precondition calculus over a source program is syntactically equivalent to the 
%weakest precondition over the compilation of the program. We also show that the weakest precondition over compiled source statements
%and the weakest precondition over a single bytecode instruction given in Chapter \ref{wpGeneral} are syntactically equivalent.
%This allows us to conclude that verification conditions over source code and verification conditions produced over its bytecode version
%are syntactically the same (modulo names and basic types).

%\todo{to be continued.  je ne sais pas comment dire mais il faut dire que c'est un peu tough de retrouve dans un program bytecode les structure qu'ils proposent }
 % \todo{because they do not expose those conditions, 
%they cannot use the induction hypothesis because they have not proven that the condition to apply the induction hold}

% Peter Mueller
 In \cite{FB04LBT}, F.Bannwart and P.Muller show how to transform a Hoare style logic derivation on source Java like
 program into a Hoare style logic derivation of a Java bytecode like program. This solution however has similar  shortcoming
as the previously cited work.

We would like to make a final remark concerning the ability to use such a scheme.
In order that a verification framework be able to exploit the equivalence between source
 and bytecode verification conditions it must be provided with bothe verification on source and bytecode. 
For instance, the Spec\#~\cite{BLS04sp} programming system being not provided with a mechanism for source verification may not benefit from this fact.
  


% see what are the others 
