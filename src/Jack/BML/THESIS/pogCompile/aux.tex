

\newtheorem{interProp}{Lemma} % states that the postcondition doesnot change by adding a goto

\newtheorem{exprValueOnStack}[interProp]{Lemma}
\newtheorem{stackCounter}[interProp]{Lemma}
\newtheorem{dupProp}[interProp]{Lemma}
\newtheorem{newProp}[interProp]{Lemma}


\subsection{Auxiliary Properties}

Before stating the main theorem we need some auxiliary properties.
 First, we establish that adding a \instr{goto} instruction  to a sequence of instructions does not change the weakest predicate of the
 augmented bytecode sequence.  


\begin{interProp} \label{interProp}
Let's have the sequence of bytecode instructions $i_1;...;i_k$ where $ \next{i_k} = i_l$
     $$ \wpBcSeq{ i_1;...;i_k}{ \psi  }  { \excPost } = 
\wpBcSeq{i_1;...;i_k; \instr{goto} l }{\psi }{\excPost} $$

The proof is based on the fact that the instruction \instr{goto} does not have side effects and thus,
the following holds: $ \wpBcSeq{ \instr{goto l}}{\psi}{\excPost} = \psi $
\end{interProp}


We now turn to see how the execution of the compilation  $\compile{\expressionSrc}$ of an expression 
$\expressionSrc$ affects the operand stack. In particular, we claim that if the execution of the compiled expression 
 $\compile{\expressionSrc}$ terminates normally then the stack top contains the value of the expression $\compileSynt{\expressionSrc}$.
This actually reflects how we expect that the virtual machine execute bytecode programs.

 This fact in terms of weakest 
preconditons can be expressed as follows: 

\begin{exprValueOnStack}[Wp of a compiled expression ] \label{exprValueOnStack}
For any expression $\expressionSrc$ from our source language, for any formula $\psi: \formulaSrc$  
of the source assertion language and any formula $\phi: \formulaBc$ such that $\phi$ may only 
contain stack expressions of the form     $\stack{\counter - k}, k \ge 0$, there 
exist $ Q, R : \formulaSrc$ such that the following holds


\begin{itemize}
\item   
$$ \begin{array}{l}
      \wpiSrc{  \expressionSrc }{ \psi }{ \excPost} \  \equiv \\ 
          Q \Rightarrow \psi \\
          \wedge \\ 
	  R  
  \end{array}$$


\item  
      $$ \begin{array}{l}
	    \wpBcSeq{ \compile{\expressionSrc} }{ \psi }{\compile{\excPost}} \  \equiv \\ 
              \compileSynt{Q} \Rightarrow \phi \begin{array}{l}
                                       \substitution{\counter}{\counter + 1}\\
			               \substitution{\stack{\counter +1}}{ \compileSynt{ \expressionSrc}}
                         \end{array} \\ \\
          \wedge \\ 
	  \compileSynt{R}
  \end{array}$$
\end{itemize}
\end{exprValueOnStack}

We proceed with several cases of the proof, which is done by induction over the structure of the formula

Proof : 
 


\begin{enumerate} 
		\item    $\expressionSrc = const , const \in \ \constantInt, \Mytrue, \Myfalse $
                     
		     $$ \begin{array}{l}  
		               \mbox{\rm\comment{source case }} \\
		              \numConclusion{1} \wpiSrc{ const}{\psi}{ \excPost}  \\
		    	       \mbox{\rm\comment{following the definition of the wp function for source expressions in subsection  \ref{pog:wpSrc} }} \\
			       \equiv \psi \\
			       \\
			       \\ 
			
		               \mbox{\rm\comment{bytecode case }} \\
		               \numConclusion{2} \wpBcSeq{ \compile{const}}{\phi}{ \compile{\excPost}}  \\
		    	       \mbox{\rm\comment{following the definition   of the compiler function in subsection \ref{compExpr} }} \\
			       \equiv \wpBcSeq{\push \compileSynt{const} }{\phi}{ \compile{\excPost}}  \\
			       \mbox{\rm\comment{following the definition of the wp function for bytecode in subsection \ref{pog:wpBc}   }} \\
			       \equiv \phi \begin{array}{l}
                                                \substitution{ \counter }{ \counter + 1}\\
						\substitution{\stack{ \counter +1} }{  \compileSynt{const}}	
					    \end{array} \\
			        \\
				\\
				 \mbox{\rm\comment{from \numConclusion{1} and   \numConclusion{2} and $Q,R = \true $ this case holds   }} \\
					 
				    
			\end{array}$$
                        
			
			
                \item  $\expressionSrc = \expressionSrc.f $
                         $$ \begin{array}{l}  
		               \mbox{\rm\comment{source case }} \\
		               \numConclusion{1} \wpiSrc{ \expressionSrc.f  }{\psi}{ \excPost}  \\
		    	       \mbox{\rm\textit{\{following the definition of the wp function  }} \\
			        \mbox{\rm\textit{ for source expressions in subsection  \ref{pog:wpSrc}  \} }} \\
			       \equiv \wpiSrc{\expressionSrc }{ \begin{array}{l}
                                                                 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \psi\\
								 \wedge \\
								 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
								 \end{array} }{ \excPost  }  \\
			       \\
			       \\ 
			        \mbox{\rm\comment{bytecode case }} \\
		               \numConclusion{2} \wpBcSeq{ \compile{\expressionSrc.f}}{\phi}{\compile{ \excPost}}   \\
			       \mbox{\rm\comment{following the definition of the compiler function in subsection \ref{compExpr} }} \\
			       \equiv \wpBcSeq{ \begin{array}{l}
			                          \compile{\expressionSrc}; \\
						   \getfield  \ f
						 \end{array} }{\phi}{ \excPost}  \\
			       \mbox{\rm\textit{\{following the definition of the wp function for bytecode    }} \\
			        \mbox{\rm\textit{ in subsection \ref{pog:wpBc}   \} }} \\
			        \equiv \wpBcSeq{ \compile{\expressionSrc}}{\\
                                                                          \phantom{wp^{bc}} \begin{array}{l} 
				                                                 \stack{\counter} \neq \Mynull \Rightarrow  \\
										    \phi \substitution{\stack{ \counter} }{  f (\stack{\counter}) } \\
										    \wedge \\
										    \stack{\counter} = \Mynull   \Rightarrow  \compile{ \excPost} (\NullPointerExc)  
										 
				                                            \end{array} }{\\ \phantom{wp^{bc}} \compile{ \excPost}} \\

				\mbox{\rm\comment{from \numConclusion{1} and \numConclusion{2} we apply the induction hypothesis  }} \\		
				\exists Q', R' : \formulaSrc , \\ 
			       \numConclusion{3} \
						\wpiSrc{\expressionSrc }{ \begin{array}{l}
                                                                 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \psi\\
								 \wedge \\
								 \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
								 \end{array} }{ \excPost  }  \\
				\equiv  \\
				Q'  \Rightarrow \begin{array}{l}
				                     \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \psi\\
						     \wedge \\
						     \compileSrcSpec{ \expressionSrc} \neq \Mynull \Rightarrow \excPost(\NullPointerExc)
				               \end{array} \\
					      \wedge \\
					       R' 
				\\	   \\ 
			      \numConclusion{4}   \  \wpBcSeq{ \compile{\expressionSrc}}{\\
                                                                          \phantom{wp^{bc}} \begin{array}{l} 
				                                                 \stack{\counter} \neq \Mynull \Rightarrow  \\
										    \phi \substitution{\stack{ \counter} }{ f (\stack{\counter}) } \\
										    \wedge \\
										    \stack{\counter} = \Mynull   \Rightarrow  \compile{ \excPost} (\NullPointerExc)  
										 
				                                            \end{array} }{\\ \phantom{wp^{bc}} \compile{ \excPost}} \\
				\equiv  \\
				 \compile{Q'}  \Rightarrow \begin{array}{ll}
				                                \begin{array}{l} \stack{\counter} \neq \Mynull \Rightarrow \phi\\
								\wedge \\
								\stack{\counter} \neq \Mynull \Rightarrow \compile{\excPost}(\NullPointerExc) 
							  \end{array} &
							  \begin{array}{l}   
						                \substitution{\counter}{\counter + 1} \\
								 \substitution{\stack{\counter + 1}}{\compileSynt{\expressionSrc }}
						          \end{array}
				               \end{array} \\	
			        \wedge \\
			       \compile{R'}	
			       \\
			       	\equiv  \\
				\end{array}
				$$
				$$
				\begin{array}{l}
				 \compile{Q'}  \Rightarrow \begin{array}{l}
				                                 \compileSynt{\expressionSrc } \neq \Mynull \Rightarrow \phi
                                                                 \begin{array}{l}
								   \substitution{\counter}{\counter + 1} \\
								   \substitution{\stack{\counter + 1}}{\compileSynt{\expressionSrc}}
								   \end{array}  \\
								\wedge \\
								\compileSynt{\expressionSrc } \neq \Mynull \Rightarrow \compile{\excPost}(\NullPointerExc) 
							  
							  
				               \end{array} \\	
			        \wedge \\
			       \compile{R'}		\\
			       \\
			       \mbox{\rm\comment{from \numConclusion{3} and \numConclusion{4} this case holds  }}\\
			       		 
		      	\end{array}$$

\end{enumerate}







