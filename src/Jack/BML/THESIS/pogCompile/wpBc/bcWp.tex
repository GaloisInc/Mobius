
\newtheorem{wpSeq}{Definition}[subsection]
\newtheorem{wpExpr}[wpSeq]{Definition}


\subsection{Weakest predicate transformer over compiled statements and expressions} \label{pog:wpBc}
In the following, we introduce a new formulation of the \wpName \ function 
which will be based on the compiler from source to bytecode  language.
The motivation for this new definition is that it will allow to reason about the
 relation between source and bytecode proof
obligations. 
Of course, it is also important to see what is the relation between the new definition
of the \wpName \ introduced here and the definition  given earlier in Chapter \ref{wpGeneral}, section \ref{wpRules}. 
We will argue under what conditions both formulations of the \wpName \ function produce the same formulas.



 


% single instruction

We give now a definition of the \wpName \ function for a single sequential instruction (instructions different from \goto, \ifCond, \jsr, \ret  ) which takes
explicitely the postcondition and the exceptional postcondition function 
upon which the precondition will be calculated. Its signature is the following:

$$ \mbox{\rm\textrm{wp}}^{bc} : \bcIns \backslash \{ \goto , \ifCond \}  \rightarrow \formulaBc \rightarrow ( \mbox{ \rm \texttt{ExcType}} \rightarrow \formulaBc ) \rightarrow \formulaBc$$

For instance, the \wpName \ definition for \getfield \ is :
$$ \begin{array}{l} \wpExpl{\getfield \ f }{ \psi  }{ \excPostExpl} = \\
		         \stack{\counter } \neq \Mynull \Rightarrow 
			                \psi   \subst{ \stack{\counter} }{ \fieldd(\stack{\counter})} 		                    
			  \wedge \\
			  \stack{\counter }  = \Mynull  \Rightarrow   \excPostExpl( \NullPointerExc )
			  \end{array}$$ 

Note that this differs from the definition of the \wpName \  given in Chapter \ref{wpGeneral}, section \ref{wpRules} where the postcondition 
is a function of the successor of the current instruction. We do not give the rest of the rules because they the same as the rules presented in \ref{wpRules} except
for the fact that the local postconditions are given explicitely.

% sequence of instructions
We also define the weakest predicate transformer function  for a block of instruction that always execute sequentially as follows:

\begin{wpSeq}[\wpName \ for a block of instructions]\label{pog:wpBc:wpSeq}
     $$ \begin{array}{l} 
              \wpBcSeq{ \ins{1};...;\ins{k}}{ \psi  } { \excPostExpl } =\\
              \wpBcSeq{\ins{1};...;\ins{k -1} }{ \wpExpl{ \ins{k} }{ \psi }{ \excPostExpl} }{\excPostExpl} 
        \end{array}$$ 

\end{wpSeq}


% wp for compiled expressions 

We turn now to the rules for compiled expressions. Note that from Property \ref{compile:prop:compProp2} it follows that 
the compilation of any expression is a sequence of instructions of instructions that execute sequentially and there is no jump from outside inside 
the sequence. Thus, we use 
the predicate transformer  for a sequence of bytecode instructions defined above in order to define 
the predicate transformer for  expressions. 

\begin{wpExpr}[\wpName \ for compiled expressions] \label{wpExpr}
               For any expression $\expressionSrc$, postcondition $\psi$ and exceptional postcondition function
               $\excPostExpl$ the \wpName \ function for the compilation $\compileLabel{s}{\expressionSrc}{e}$  is
               $ \wpBcSeq{\compileLabel{s}{\expressionSrc}{e} }{ \psi  } { \excPostExpl }  $
 \end{wpExpr}

For instance, the  rule of the \wpName  \ for the compilation of access  field expression $\expressionSrc.\fieldd $ 
where its compilation is 
$$\begin{array}{l}
    \compileLabel{s}{ \expressionSrc_1;}{e - 1}\\
     e \ \getfield \ \fieldd \\
 \end{array}
$$
  produce the following formula 
 
$$  \wpBcSeq{\begin{array}{l}
	              \compileLabel{s}{\expressionSrc }{e - 1} ;\\
	              e \ \getfield \ \fieldd 
	           \end{array} }{ \psi  } { \excPostExpl } $$	

This is equivalent to :
  $$\wpBcSeq{\compileLabel{s}{\expressionSrc}{e - 1}}{\wpExpl{\getfield \ \fieldd }{\psi}{\excPostExpl} }{\excPostExpl} $$  


% wp for compiled statements


The function which calculates the \wpName \ predicate of a compiled statement is called $\wpNameStmt$ and has the following signature :
$$\wpNameStmt : Set(\bcIns) \rightarrow  \formulaBc \rightarrow  ( \mbox{ \rm \texttt{Exc}}  \rightarrow \formulaBc ) \rightarrow \formulaBc$$ 
The definition of $\wpNameStmt$ uses the compiler function defined in the previous Section \ref{pogEq:compile:compCtrlStmt}.

\begin{itemize}
    \item sequential statement compilation $\compileLabel{s}{\stmt_1;\stmt_2}{e} $ which by definition is 
         % $$ \begin{array}{l}
         %                           \compileLabel{s}{\stmt_1};\\
          %                          \goto \ l;\\
	  %                          l: \compileLabel{s}{\stmt_2}
	 %	             \end{array}    $$
         % By definition the $\wpNameStmt$ for compiled sequental statements is 
       $$ \begin{array}{l} \wpStmt{ \compileLabel{s}{\stmt_1;\stmt_2 }{e}}{ \psi}{\excPostExpl} =\bydef \\
                    
	 	   \wpStmt{\compileLabel{s}{\stmt_1}{e'};}
                          {\\
                           \phantom{wp^{stmt}} \wpStmt{ \compileLabel{e' + 1}{\stmt_2}{s}}{ \psi}{\excPostExpl}}
			  {\\ 
                           \phantom{wp^{stmt}} \excPostExpl} 
          \end{array}  $$ 
     \item if statement compilation $\compileLabel{s}{   \Myif \ (\expressionSrcRel) \  \Mythen \ \{ \stmt_1 \} \    \Myelse \ \{ \stmt_2 \} }{e}$   
           % which by definition is  equal to
           % $$ \begin{array}{l}
	     %                           \compileLabel{s}{\expressionSrcRel}; \\
	 % %			        \ifCond\_\rel \ l_{true} ;\\
	 %			       \compileLabel{s}{\stmt_2)}\\
	 %			       \goto \ l; \\
	 %			       l_{true}: \ \compileLabel{s}{\stmt_1} \\ 
	 %			       l:
	    %                       \end{array} $$

%By definition the $\wpNameStmt$ \  in this case is defined as follows:
    $$ \begin{array}{l} \wpStmt{   \compileLabel{s}{ \begin{array}{l} \Myif \ (\expressionSrcRel) \\
                                                               \Mythen \ \{ \stmt_1 \} \\  
							       \Myelse \ \{ \stmt_2 \}   
                                              \end{array}}{e}}{\psi}{\excPostExpl} =\bydef \\\\
                     
                        \wpBcSeq{%   \begin{array}{l}
                      	                    \compileLabel{s}{\expressionSrcRel}{e'}; \\
					    %\ifCond\_\rel \ l_{true} ;\\
				%     \end{array}
			    } {\\
                             \phantom{wp^{bc}_{seq}}	 \begin{array}{l}
			              \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow   \\
				           \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e'' +  2 }{\stmt_1}{e} }{\psi}{\excPostExpl} \subst{t}{t-2} \\
			               \wedge \\
				       \neg \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow  \\
				           \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} \subst{t}{t-2} 
			        \end{array}  }{ \\ \phantom{wp^{bc}_{seq}} \excPostExpl} 
     \end{array} $$ 
       \item assignment expression. We will look only at the case for  compiled   field assignment 
	 expressions $\compileLabel{s}{\expressionSrc_1.\fieldd= \expressionSrc_2 }{e}$.

	 	      
		       $$\begin{array}{l}
		              \wpStmt{ \compileLabel{s}{\expressionSrc_1.\fieldd= \expressionSrc_2}{e}}{\psi}{\excPostExpl} =\bydef \\\\
	
			%      \wpBcSeq{ \compileLabel{s}{\expressionSrc_1}{e'}}
				%      { \\\\
			     %         \phantom{wp^{bc}_{seq}}  \wpBcSeq{\begin{array}{l}
                             %                                                  \compileLabel{e'+1}{\expressionSrc_2}{e - 1}; \\
                              %                                                 e \ \putfield \ \fieldd 
			 %	                                        \end{array}}{\psi}{\excPostExpl}  }
                             %          { \\\\
			      %         \phantom{wp^{bc}_{seq}} \excPostExpl}                     
		        \end{array} $$ 
          

     \item try catch statement compilation 

	   % $$  \begin{array}{l}
             %           \compileLabel{s}{\stmt_1}; \\
           %             goto \ l; \\
	 %	  
             %           \compileLabel{s}{\stmt_2};\\
	 %	       goto \ l; \\
	 %	       ...\\
	 %	       l: \\ 
               %         \\  
                    
	 %		\addExceptionTable{ \stR{\compileLabel{s}{\stmt_1} }}{ \enR{  \compileLabel{s}{ \stmt_1 }  }}{ \stR{\compileLabel{s}{\stmt_2}} }{ \excType} ) 
             %    \end{array}$$
			
          
    $$ \begin{array}{l}
	     \wpStmt{ \compileLabel{s}{  \begin{array}{l}
		                      \try \ \{ \stmt_1 \} \\ 
				      \catch \ (\excType \  \var)\{ \stmt_2 \}
	                         \end{array}   }{e}}{\psi}{\excPostExpl} =\bydef \\\\
	          \wpStmt{ \begin{array}{l}
	                 \compileLabel{s}{\stmt_1}{e'};\\
			  e' + 1: \goto \ e + 1;
			 \end{array} 
                           }
                         { \\\\
	                 \phantom{wp^{bc}_{stmt}} \psi}
			 { \\\\
	                  \phantom{wp^{bc}_{stmt}}  \update{\excPostExpl}{\excType}{ 
                                                                                       \wpStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} }
	\end{array}$$	

	 \item try finally statement compilation
 $\compileLabel{s}{\try \ \{ \stmt_1 \} \ \finally \ \{ \stmt_2 \}}{e}   $

	      
	       $$ \begin{array}{l}
	     \wpStmt{ \compileLabel{s}{\begin{array}{l}  
					  \try \ \{ \stmt_1 \} \\
					  \finally \ \{ \stmt_2 \} 
	                                  \end{array}}{e}}{\psi }{\excPostExpl} =\bydef \\\\
	     \wpStmt{ \compileLabel{s}{\stmt_1}{e'} \\
		    }
                    {\\\\
                      \phantom{wp^{bc}_{stmt}}  \wpStmt{ 
                             
                                     \compileLabel{e'+1}{\stmt_2}{e''};
				     
			  }{\psi}{\excPostExpl} }
		   {\\\\
                      \phantom{wp^{bc}_{stmt}} \update{\excPostExpl}{\excType}{ \wpStmt{  \begin{array}{l} 
		                                                                                 e'' +  2: \store \ l; \\
												 \compileLabel{e'' + 3}{\stmt_2}{e - 2}; \\	                
												 e - 1 :\load \ l;\\
												 e: \athrow 	
                                                                                        \end{array} 
                                                                                       }{\psi}{\excPostExpl }} }
               	\end{array}$$


   \item throw exception compilation $\compileLabel{s}{\throw \ \expressionSrc }{e}$
        
	 $$ \begin{array}{l} 
	         \wpStmt{ \compileLabel{s}{\throw \ \expressionSrc }{e}   }{\psi}{\excPostExpl} =\bydef \\ 
		 \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e - 1} }{ \wpExpl{e / \athrow}{\psi}{\excPostExpl}}{\excPostExpl} 
	 \end{array}
	 $$
   \item  loop statement

  
	 $$ \begin{array}{l} 
	         \wpStmt{ \compileLabel{s}{\begin{array}{l}
		                                \while \ (\expressionSrcRel) \\
						\lbrack \invariant, \modLoop \rbrack \\
						 \do \ \{ \stmt \}  
		                           \end{array} }{e}   }{\psi}{\excPostExpl} =\bydef \\ 
		  			   
		 \invariant  \\ 
		    \wedge \\ 
                       \forall mod \in   \modLoop,\\
		        \invariant \Rightarrow \\ 			   
		 \wpBcSeq{ \compileLabel{e'+1}{\expressionSrcRel}{e - 1} }{\\
                 \phantom{wp^{bc}_{seq}} \begin{array}{l}   
		           \begin{array}{l} 
			                \rel ( \stack{\counter}, \stack{\counter - 1 } )  \Rightarrow  \\
                                               \Myspace \wpStmt{\compileLabel{s +  1}{\stmt}{e' } }{\invariant  }{\excPostExpl }\\
					       \wedge \\
					\neg   \rel ( \stack{\counter}, \stack{\counter - 1 } )  \Rightarrow   \psi 
					      
		                     \end{array}   
		 \end{array}  
                         }{\\
                 \phantom{wp^{bc}_{seq}}\excPostExpl} 
	 \end{array}
	 $$
 
\end{itemize}
