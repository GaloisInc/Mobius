
\newtheorem{wpSeq}{Definition}[section]
\newtheorem{wpExpr}[wpSeq]{Definition}


%\subsection{Weakest predicate transformer over compiled statements and expressions} 
%\label{pog:wpBc}
In this section, we introduce a new formulation of the \wpName \ function  for bytecode 
which will be based on the compiler from source to bytecode  language.
The motivation for this new definition is that it will allow to reason about the
 relation between source and bytecode proof
obligations. 
Of course, it is also important to see what is the relation between the new definition
of the \wpName \ introduced here and the definition  given earlier in Chapter \ref{wpGeneral}, section \ref{wpRules}. 
We will argue under what conditions the two formulations of the \wpName \ function produce the same formulas.



% single instruction

We give now a definition of the \wpName \ function for a single sequential instruction (instructions different from \goto, \ifCond) which takes
explicitely the postcondition and the exceptional postcondition function 
upon which the precondition will be calculated. Its signature is the following:

$$ \mbox{\rm\textrm{wp}}^{bc} : \bcIns \backslash \{ \goto , \ifCond \}  \rightarrow \formulaBc \rightarrow ( \mbox{ \rm \texttt{ExcType}} \rightarrow \formulaBc ) \rightarrow \formulaBc$$

For instance, the \wpName \ definition for \getfield \ is :
$$ \begin{array}{l} \wpExpl{\getfield \ f }{ \psi  }{ \excPostExpl} = \\
		         \stack{\counter } \neq \Mynull \Rightarrow 
			                \psi   \subst{ \stack{\counter} }{ \fieldd(\stack{\counter})} 		                    
			  \wedge \\
			  \stack{\counter }  = \Mynull  \Rightarrow   \excPostExpl( \NullPointerExc )
			  \end{array}$$ 

Note that this differs from the definition of the \wpName \  given in Chapter \ref{wpGeneral}, section \ref{wpRules} where the postcondition 
is a function of the successor of the current instruction. We do not give the rest of the rules because they are the same as 
the rules presented in \ref{wpRules} except for the fact that the local postconditions are given explicitely.

% sequence of instructions
We also define the weakest predicate transformer function  for a block of instructions as follows:

\begin{wpSeq}[\wpName \ for a block of instructions]\label{pog:wpBc:wpSeq}
     $$ \begin{array}{l} 
              \wpBcSeq{ \ins{1};\ldots;\ins{k}}{ \psi  } { \excPostExpl } =\\
              \wpBcSeq{\ins{1};\ldots;\ins{k -1} }{ \wpExpl{ \ins{k} }{ \psi }{ \excPostExpl} }{\excPostExpl} 
        \end{array}$$ 

\end{wpSeq}


% wp for compiled expressions 

We turn now to the rules for compiled expressions. Note that from Property \ref{compile:prop:compProp2} it follows that 
the compilation of any expression is a sequence of instructions that execute sequentially and there is no jump from outside inside 
the sequence. Thus, we use 
the predicate transformer  for a sequence of bytecode instructions defined above in order to define 
the predicate transformer for  expressions. 

\begin{wpExpr}[\wpName \ for compiled expressions] \label{wpExpr}
               For any expression $\expressionSrc$, postcondition $\psi$ and exceptional postcondition function
               $\excPostExpl$ the \wpName \ function for the compilation $\compileLabel{s}{\expressionSrc}{e}$  is
               $ \wpBcSeq{\compileLabel{s}{\expressionSrc}{e} }{ \psi  } { \excPostExpl }  $
 \end{wpExpr}

For instance, the  rule of the \wpName  \ for the compilation of access  field expression $\expressionSrc.\fieldd $ 
where its compilation is 
$$\begin{array}{l}
    \compileLabel{s}{ \expressionSrc_1;}{e - 1}\\
     e \ \getfield \ \fieldd \\
 \end{array}
$$
  produce the following formula 
 
$$  \wpBcSeq{\begin{array}{l}
	              \compileLabel{s}{\expressionSrc }{e - 1} ;\\
	              e \ \getfield \ \fieldd 
	           \end{array} }{ \psi  } { \excPostExpl } $$	

This is equivalent to 
  $$\wpBcSeq{\compileLabel{s}{\expressionSrc}{e - 1}}{\wpExpl{\getfield \ \fieldd }{\psi}{\excPostExpl} }{\excPostExpl} $$  


% wp for compiled statements


The function which calculates the \wpName \ predicate of a compiled statement is called $\wpNameStmt$ and has the following signature :

$$\wpNameStmt : Set(\bcIns) \rightarrow  \formulaBc \rightarrow  ( \mbox{ \rm \texttt{Exc}}  \rightarrow \formulaBc ) \rightarrow \formulaBc$$ 

The definition of $\wpNameStmt$ is shown in Fig. \ref{pog:wpBcGeneral:wpNameStmt}
\begin{figure}[ht!]
\begin{frameit}
$${\scriptsize 
        \begin{array}{l} 
        \wpStmt{ \compileLabel{s}{\stmt_1;\stmt_2 }{e}}{ \psi}{\excPostExpl} = \\
                  \begin{array}{l}  
	 	   \wpStmt{\compileLabel{s}{\stmt_1}{e'};}
                          {\\
                           \phantom{wp^{stmt}} \wpStmt{ \compileLabel{e' + 1}{\stmt_2}{s}}{ \psi}{\excPostExpl}}
			  {\\ 
                           \phantom{wp^{stmt}} \excPostExpl} 
          \end{array} \\
	  \\ \\
	  \wpStmt{   \compileLabel{s}{ \begin{array}{l} \Myif \ (\expressionSrcRel) \\
                                                               \Mythen \ \{ \stmt_1 \} \\  
							       \Myelse \ \{ \stmt_2 \}   
                                              \end{array}}{e}}{\psi}{\excPostExpl} = \\ 
                     \begin{array}{l} 
                        \wpBcSeq{%   \begin{array}{l}
                      	                    \compileLabel{s}{\expressionSrcRel}{e'}; 
					    %\ifCond\_\rel \ l_{true} ;\\
				%     \end{array}
			    } {\\
                             \phantom{wp^{bc}_{seq}}	 \begin{array}{l}
			              \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow   \\
				           \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e'' +  2 }{\stmt_1}{e} }{\psi}{\excPostExpl} \subst{t}{t-2} \\
			               \wedge \\
				       \neg \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow  \\
				           \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} \subst{t}{t-2} 
			        \end{array}  }{ \\ \phantom{wp^{bc}_{seq}} \excPostExpl} 
     \end{array}\\
	  \\ \\

\wpStmt{ \compileLabel{s}{\expressionSrc_1.f= \expressionSrc_2}{e} }{\psi}{\excPostExpl} = \\
 \begin{array}{l}
	\wpBcSeq{\compileLabel{s}{\expressionSrc_1}{e'} }{ \\   
	        \phantom{wp^{bc}_{seq}} \begin{array}{l}
		                              \wpBcSeq{ \compileLabel{e'+1}{\expressionSrc_2}{e - 1 };\\
						      }{ \\
						      \phantom{wp^{bc}_{seq}} \wpExpl{e \ putfield  \  f}{\psi}{\excPostExpl}
                                                      }{ \\
						    \phantom{wp^{bc}_{seq}}\excPostExpl}  
                                        \end{array}  } {\\   
                \phantom{wp^{bc}_{seq}}\excPostExpl }
\end{array} \\
\\ \\ 
\wpStmt{ \compileLabel{s}{  \begin{array}{l}
		                      \try \ \{ \stmt_1 \} \\ 
				      \catch \ (\excType \  \var)\{ \stmt_2 \}
	                         \end{array}   }{e}}{\psi}{\excPostExpl} =\\
	     \begin{array}{l}
                       \wpStmt{ 
	                 \compileLabel{s}{\stmt_1}{e'};
                         }
                         { \\
	                 \phantom{wp^{bc}_{stmt}} \psi}
			 { \\
	                  \phantom{wp^{bc}_{stmt}}  \update{\excPostExpl}{\excType}{ 
                                                                                       \wpStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} }
	\end{array} \\
         \\ \\
         \wpStmt{ \compileLabel{s}{\begin{array}{l}  
					  \try \ \{ \stmt_1 \} \\
				 	  \finally \ \{ \stmt_2 \} 
	                                  \end{array}}{e}}{\psi }{\excPostExpl} = \\ 
	  \begin{array}{l}
	     \wpStmt{ \compileLabel{s}{\stmt_1}{e'} \\
		    }
                    {\\
                      \phantom{wp^{bc}_{stmt}}  \wpStmt{ 
                             
                                     \compileLabel{e'+1}{\stmt_2}{e''};
				     
			  }{\psi}{\excPostExpl} }
		   {\\
                      \phantom{wp^{bc}_{stmt}} \update{\excPostExpl}{\excType}{ \wpStmt{  \begin{array}{l} 
		                                                                                 e'' +  2: \store \ l; \\
												 \compileLabel{e'' + 3}{\stmt_2}{e - 2}; \\	                
												 e - 1 :\load \ l;\\
												 e: \athrow 	
                                                                                        \end{array} 
                                                                                       }{\psi}{\excPostExpl }} }
               	\end{array} \\
		\\ \\
		  \wpStmt{ \compileLabel{s}{\throw \ \expressionSrc }{e}   }{\psi}{\excPostExpl} = \\
		  \begin{array}{l}
		  \wpBcSeq{ \compileLabel{s}{\expressionSrc}{e - 1} }{ \wpExpl{e / \athrow}{\psi}{\excPostExpl}}{\excPostExpl} 
		 \end{array} \\
		 \\ \\ 
               \wpStmt{ \compileLabel{s}{\begin{array}{l}
		                                \while \ (\expressionSrcRel) \\
						\lbrack \invariant, \modLoop \rbrack \\
						 \do \ \{ \stmt \}  
		                           \end{array} }{e}   }{\psi}{\excPostExpl} = \\ 
		  \begin{array}{l}			   
		 \invariant  \\ 
		    \wedge \\ 
                       \forall mod \in   \modLoop,\\
		        \invariant \Rightarrow \\ 			   
		 \wpBcSeq{ \compileLabel{e'+1}{\expressionSrcRel}{e - 1} }{\\
                 \phantom{wp^{bc}_{seq}} \begin{array}{l}   
		           \begin{array}{l} 
			                \rel ( \stack{\counter}, \stack{\counter - 1 } )  \Rightarrow  \\
                                               \Myspace \wpStmt{\compileLabel{s +  1}{\stmt}{e' } }{\invariant  }{\excPostExpl }\\
					       \wedge \\
					\neg   \rel ( \stack{\counter}, \stack{\counter - 1 } )  \Rightarrow   \psi 
					      
		                     \end{array}   
		 \end{array}  
                         }{\\
                 \phantom{wp^{bc}_{seq}}\excPostExpl} 
	 \end{array}
	\end{array} 
} $$

\caption{\sc Definition of $\wpNameStmt$ }
\label{pog:wpBcGeneral:wpNameStmt}
\end{frameit}
\end{figure}


As we can see in the figure the \wpName{} is defined over the result of the compiler for every statement. Thus, it 
is similar to the definition of weakest precondition function for the source language.  
