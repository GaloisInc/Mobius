\newtheorem{wpIns}{Lemma}[subsection]
\newtheorem{wpBlock}[wpIns]{Lemma}
\newtheorem{relWpExpr}[wpIns]{Lemma}
\newtheorem{relWpStmt}[wpIns]{Lemma}

\subsection{Properties of the \wpName \ functions}\label{pog:wpBcProp}
    The previous subsection introduced a new formulation of the 
    \wpName \ function for bytecode which is defined over
    the source statement from which it is compiled. 
    However, it is important to establish a relation between this new definition
    and  the \wpName \ formulation given in  Chapter \ref{wpGeneral}.
    The following statements establish the relation between 
    the two versions of the \wpName \  calculus.


The first lemma states that the $\wpNameExpl$ \ function defined in the previous subsection 
 for a single bytecode instruction
 will return the same result as the \fwpi \ function defined in Chapter \ref{wpGeneral}.  In particular, the explicite
 weakest precondition function for a single bytecode instruction 
  $\wpExpl{ j}{ \psi  }{ \excPostExpl} $ \ is equivalent to $\wpi{}{\methodd}{j}$ only if 
$\psi$  is the intermediate predicate $\inter{j}{k}$ between $\ins{j}$ and the next instruction
 $\ins{k}$ to be executed. We get a similar condition for the function $\excPostExpl$.

\begin{wpIns}[Equivalence of the formulations for single instructions ]\label{wpIns}
If an instruction at index $j$ such that it is not a jump instruction
 $j  \in \bcIns \backslash \{ \goto , \ifCond\}$ and  
 $\psi$,and  function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that
\begin{itemize} 
   \item if an  instruction at index $k$ exists such that it may execute after the instruction at index $j$, i.e. $j \execRel k$ then $\psi = \inter{j}{k}$  
   \item if the instruction at index $j$ is a \return{} instruction then  $\psi = \methodd.\normalPost$  
   \item  $\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, j ) $ 
\end{itemize}

the following holds 

   $\wpExpl{ j}{ \psi  }{ \excPostExpl} = \wpi{}{\methodd}{j} $
\end{wpIns}
The proof is done by case analysis on the instruction $j$\\

%\todo{note that the current formulation is not true because of the exceptions }
\textit{Proof:}
We scatch the case for a \getfield \  instruction.
$$
\begin{array}{l}
  \mbox{\rm\comment{by hypothesis }} \\
    j = \getfield \ \fieldd \\
   \mbox{\rm\comment{by definition of the \wpName \  function }} \\
    \numConclusion{1} \  \wpExpl{\getfield \ \fieldd }{\psi}{\excPostExpl} = \\
    
        \stack{\counter } \neq \Mynull \Rightarrow 
			                \psi   \subst{ \stack{\counter} }{ \fieldd(\stack{\counter})}\\          
			  \wedge \\
			  \stack{\counter }  = \Mynull  \Rightarrow   \excPostExpl( \NullPointerExc ) \\\\


  \mbox{\rm\comment{by definition of the \fwpi \  function }} \\
\numConclusion{2} \  \wpi{}{\methodd}{ \getfield \ \fieldd} = \\
                           \stack{\counter } \neq \Mynull \Rightarrow 
			         \inter{j}{k}   \  \subst{ \stack{\counter} }{ \fieldd(\stack{\counter})}\\          
			  \wedge \\
			  \stack{\counter }  = \Mynull  \Rightarrow   \excPost( \NullPointerExc,j ) \\\\

  \mbox{\rm\comment{ from the initial hypothesis, \numConclusion{1}  and \numConclusion{2} the lemma holds in that case   }}
    

\end{array}
$$
\Qed\\

The following lemma establishes that calculating the \wpName{} predicate of the first instruction of a block of 
bytecode (Def. \ref{seqInstr}  in the previous Section \ref{compile}, Subsection \ref{compile:prop}) 
instructions and calculating it by using a $\wpNameBcSeq$ function which  calculates the precondition of a sequence of instructions is
 the same under several conditions about the postcondition predicates. 



 \begin{wpBlock}[\wpName  \  for a block of instructions]\label{wpBlock}
  For every block of instructions $\ins{1}; \dots;\ins{j} $  where instruction $\ins{j + 1}$  exists, 
  formula $\psi$ and function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $  such that
 \begin{itemize} 
    %\item $\ins{j} \execRel \ins{k}$
    \item  $\psi = \inter{\ins{j}}{\ins{j+1}}$

     \item $\forall \mbox{\rm\texttt{Exc}} ,  \forall i, 1 \le i \le j,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) =$ 
                  $ \methodd.\getExcPost(i,\mbox{\rm\texttt{Exc}}) $ 


   
\end{itemize}
then the following holds
     $$   \wpBcSeq{\ins{1}; \dots;\ins{j} }{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{1} }$$        
\end{wpBlock} 

The proof is done by induction on the length of the sequence of instructions.
\textit{Proof:}

$$
\begin{array}{l}
  \numConclusion{1} \ \wpBcSeq{\ins{1}; \dots;\ins{j} }{\psi }{\excPostExpl} = \\
   \comment{by Def. \ref{pog:wpBc:wpSeq} for \wpName \ of block of instructions } \\
   \wpBcSeq{\ins{1}; \ldots;\ins{j -1 } }{\wpExpl{ \ins{j} }{ \psi }{ \excPostExpl}  }{\excPostExpl } \\
   \comment{by initial hypothesis we can apply lemma \ref{wpIns} from which it follows } \\
   \wpExpl{ \ins{j} }{ \psi }{ \excPostExpl}  = \wpi{\ins{j}}{\methodd}{} \\
   \mbox{\rm\textit{\{by definition \ref{seqInstr} ,  $\ins{j}$ is not a loop entry }} \\
   \mbox{\rm\textit{ and from Def. \ref{wp:interPred} \}}} \\
   \numConclusion{2} \ \inter{j-1}{j} =\wpi{\ins{j}}{\methodd}{} \\
   \mbox{\rm\textit{\{apply the induction hypothesis over $\ins{1}; \ldots;\ins{j -1 } $  , }}\\
   \mbox{\rm\textit{ \numConclusion{2} and the initial hypothesis for exception handlers \}}}\\
   \numConclusion{3} \ \wpBcSeq{\ins{1}; \dots;\ins{j -1 } }{\wpExpl{ \ins{j} }{ \psi }{ \excPostExpl}  }{\excPostExpl } = \\
   \wpi{\ins{1}}{\methodd}{} \\  
   \comment{from  \numConclusion{1} and \numConclusion{3} the proposition holds}
\end{array}
$$
\Qed \\


The same property is established for compilation of expressions. 
\begin{relWpExpr}[\wpName  \  for compiled expressions ]\label{relWpExpr}
     For every compiled expression $\compileLabel{s}{\expressionSrc}{e}$  in  method \methodd  \,  formula $\psi$ and function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that 

      \begin{itemize}
            \item $\psi = \inter{e}{e+1}$	    
	    \item $\forall \mbox{\rm\texttt{Exc}} ,  \forall i, s\le i \le e,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) =$ 
                  $ \methodd.\getExcPost(i, \mbox{\rm\texttt{Exc}}) $ 
            

      \end{itemize} then the following holds:

     $$   \wpBcSeq{\compileLabel{s}{\expressionSrc}{e}   }{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}}$$        

\end{relWpExpr}

\textit{Proof}: \\
From Property \ref{compile:prop:compProp3} of the compiler it follows that for every expression
 $\expressionSrc$, start label $s$  and  end label $e$,
  the resulting compilation   $\compileLabel{s}{\expressionSrc}{e}$ is a block of instructions. We can apply 
 the previous lemma  \ref{wpBlock} and we get the result.
\Qed \\

The next lemma states the same property but this time for the compilation of statements.
\begin{relWpStmt}\label{relWpStmt}
     For every compiled statement $\compileLabel{s}{\stmt}{e}$  in  method \methodd, formula $\psi$ and 
    function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that 

      \begin{itemize}
            \item if $e+1$ exists  then $\psi = \inter{e}{e+1}$
	    \item if $e+1$ does not exist and $\ins{e} = \return$ then $\psi = \methodd. \normalPost$
	    \item $\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) $ 
      \end{itemize} then the following holds: 
  %   if $\psi = \inter{e}{e+1}$ then the following holds
     $$   \wpStmt{\compileLabel{s}{\stmt}{e} }{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}}$$   
\end{relWpStmt}

Proof : the proof is  by induction on the compilation of a statement. We scatch here the proof of few cases 


\begin{itemize}
      \item if statement 
           
	    %\begin{longtable}{>{$}c<{$}}
	     $$\begin{array}{l}
	     \wpStmt{   \compileLabel{s}{ \begin{array}{l} \Myif \ (\expressionSrcRel) \\
                                                               \Mythen \ \{ \stmt_1 \} \\  
							       \Myelse \ \{ \stmt_2 \}   
                                              \end{array}}{e}}{\psi}{\excPostExpl} =\bydef \\\\
                     
                        \wpBcSeq{    \compileLabel{s}{\expressionSrcRel}{e'}; \\
				} {\\
                             \phantom{wp^{bc}_{seq}}	 \begin{array}{l}
			              \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow   \\
				           \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e'' +  2 }{\stmt_1}{e} }{\psi}{\excPostExpl} \subst{t}{t-2} \\
			               \wedge \\
				       \neg \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow  \\
				           \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} \subst{t}{t-2} 
			        \end{array}  }{ \\ \phantom{wp^{bc}_{seq}} \excPostExpl}   \\ \\
				
				\end{array}$$
				  $$ \begin{array}{l}
				\mbox{\comment{\rm by initial hypothesis, we have   } }\\
				\numConclusion{1.1} \ \psi = \inter{e}{e+1}  \\ 
			         \mbox{\comment{\rm by the compiler definition $ \ins{e'' + 1} = \goto \ e +  1; $  } }\\
				\numConclusion{1.2} \ \ins{e'' + 1} \execRel \ins{e + 1} \\
				
				
                               	
				\mbox{\rm\textit{\{ from Property \ref{compile:prop:compProp5} which states that every instruction inside }} \\
				\mbox{\rm\textit{the compilation of $\compileLabel{s}{\stmt}{e}$ , }} \\
                        	\mbox{\rm\textit{is in the same execution relation with $\ins{e+1}$, }} \\


			        \mbox{\rm\textit{    Def. \ref{inter} for \interOnly, \numConclusion{1.1} and \numConclusion{1.2}   we conclude that \} } }\\
				\numConclusion{1.3}  \ \inter{e'' + 1}{e+1} = \inter{e}{e+1} = \psi\\
				\mbox{\rm\textit{\{From property \ref{compile:prop:compProp4} the edge between  $e''$ and $e'' + 1$}}\\
				\mbox{\rm\textit{ is not a loop edge and from Def. \ref{inter} \}  }} \\
				\numConclusion{1.4} \ \inter{e''}{e'' +1} = \wpi{e'' + 1}{m}{} \\
				\mbox{\rm \comment{ From the definition of the \wpName  \ for \goto \ instructions and \numConclusion{1.4}  }}\\
				\numConclusion{1.5}  \ \wpi{e'' + 1}{m}{} = \inter{e'' + 1}{e+1} \\
				 
				\mbox{\rm \comment{ From \numConclusion{1.4}, \numConclusion{1.3}	and \numConclusion{1.5}}}	\\
				\numConclusion{1.6}	\  \inter{e''}{e'' +1} = \inter{e}{e+1}	= \psi	\\
								

				\mbox{\rm\comment{From Property  \ref{compile:prop:compProp8}  } } \\
                               
                                \numConclusion{1.7}  \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e'' )  \\
				\mbox{\rm\comment{apply the induction hypothesis over \numConclusion{1.6} and  \numConclusion{1.7}  } }\\ 
				\numConclusion{1.8} \	\wpStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} = \wpi{e'+2}{m}{} \\

				\comment{ apply the induction hypothesis over the initial hypothesis  }\\
				\numConclusion{1.9} \ \wpStmt{\compileLabel{e'' +  2 }{\stmt_1}{e}   }{\psi}{\excPostExpl} = \wpi{e''+2}{m}{} \\
			
				\comment{by definition of \ifCond \ function }\\
			        \numConclusion{1.10} \ 	\wpi{  e' + 1: \ifCond \ e'' + 2; }{m}{ } = \\
			         \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow \wpi{e''+2}{m}{} \\
				 \wedge \\
				 \neg \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow \wpi{e'+2}{m}{} \\
				 \comment{from \numConclusion{1.8},  \numConclusion{1.9}  and \numConclusion{1.10}}\\
				 \numConclusion{1.11} \ \wpi{  e' + 1: \ifCond \ e'' + 2; }{m}{ } = \\
			         \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow \\
				  \Myspace  \wpStmt{\compileLabel{e'' +  2 }{\stmt_1}{e}   }{\psi}{\excPostExpl} \\ 
				 \wedge \\
				 \neg \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow \\
				 \Myspace  \wpStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl}  \\
				 	\end{array}$$
				  $$ \begin{array}{l}
				 \comment{From Property \ref{compile:prop:compProp5}  }\\
				 \numConclusion{1.12} \ \inter{e'}{e'+1} =	\wpi{  e' + 1: \ifCond \ e'' + 2; }{m}{ }\\
				 
				 \comment{From the initial hypothesis   }  \\
                               
                                 \numConclusion{1.13}  \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  \excPostExpl( \mbox{\rm\texttt{Exc}} )\\
				 
                                  \comment{From Property \ref{compile:prop:compProp9} and then  \numConclusion{1.13}}\\
				 \numConclusion{1.14} \ \forall \mbox{\rm\texttt{Exc}} ,  \forall i,  s \le i \le e',  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \\
                                                          \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, i )  \\
                                 
				 \comment{apply Lemma \ref{relWpExpr}  over hypothesis  \numConclusion{1.11}, \numConclusion{1.12}, \numConclusion{1.14} } \\
				 
				 \wpBcSeq{    \compileLabel{s}{\expressionSrcRel}{e'}; \\
				         }    
					 {\\
					 \phantom{wp^{bc}_{seq}}	 
					           \begin{array}{l}
			                                \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow   \\
							\phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e'' +  2 }{\stmt_1}{e} }{\psi}{\excPostExpl} \subst{t}{t-2} \\
							\wedge \\
							\neg \rel ( \stack{\counter}, \stack{\counter - 1 } ) \Rightarrow  \\
							 \phantom{wp^{bc}_{seq}} \wpStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} \subst{t}{t-2} 
			                           \end{array}  }
                                          { \\ \phantom{wp^{bc}_{seq}} \excPostExpl} = \wpi{s}{m}{}   \\ \\
					  \comment{and this case holds}
	    \end{array}$$
	  
  \item try catch statement 
        $$
	  \begin{array}{l}
	    \numConclusion{1} \    \wpStmt{   \compileLabel{s}{ \begin{array}{l} \try \ \{ \stmt_1 \} \\
		                                              \catch \ (\excType \ \var )\{ \stmt_2 \} 
                                              \end{array}}{e}}{\psi}{\excPostExpl} =\bydef \\
			\comment{Def. of $\wpNameStmt$ for compiled statements in the previous Section }	\\	      
	        \wpStmt{
	                 \compileLabel{s}{\stmt_1}{e'};
	
                           }
                         { \\
	                 \phantom{wp^{bc}_{stmt}} \psi}
			 { \\
	                  \phantom{wp^{bc}_{stmt}}   \update{\excPostExpl}{\excType}{ \wpStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} } \\
			  
              \comment{apply the induction hypothesis over $\stmt_2$ and the initial hypothesis} \\
	      \numConclusion{2} \   \wpStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl} = \wpi{e'+2}{\methodd}{} \\ 
	      \comment{from the definition of \getExcPost \ and property \ref{compile:prop:compProp10}} \\
	      \numConclusion{3} \ \forall \mbox{\rm\texttt{Exc}} ,  \update{\excPostExpl}{\excType}{ \wpi{e'+2}{\methodd}{} } = \\ 
              \phantom{\forall \mbox{\rm\texttt{Exc}} ,}     \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' )\\
	      \comment{we can also conclude from Prop.  \ref{compile:prop:compProp5} and  \ref{compile:prop:compProp4}  } \\
	      \numConclusion{4} \ \inter{e'}{e' + 1} = \inter{e'+1 }{e + 1} = \inter{e}{e+1} \\
	      \comment{apply  induction hypothesis over  \numConclusion{1}, \numConclusion{3} and  \numConclusion{4}    } \\
	       \wpStmt{
	                 \compileLabel{s}{\stmt_1}{e'};
	
                           }
                         { \\
	                 \phantom{wp^{bc}_{stmt}} \psi}
			 { \\
	                  \phantom{wp^{bc}_{stmt}}   \update{\excPostExpl}{\excType}{ \wpStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} } =\\
			  \wpi{s}{\methodd}{}
	      
	   \end{array}
	$$
\end{itemize}
\Qed \\
