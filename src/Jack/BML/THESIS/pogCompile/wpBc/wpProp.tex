\newtheorem{thm}{Theorem}[section]


%\newtheorem{wpBlock}[wpIns]{Lemma}
%\newtheorem{relWpExpr}[wpIns]{Lemma}
%\newtheorem{relWpStmt}[wpIns]{Lemma}

%\subsection{Properties of the \wpName \ functions}\label{pog:wpBcProp}
    
We shall first establish a relation between the \wpName{} predicate transformer functions for expressions 
on bytecode and source level. 
\begin{thm}\label{pogComp:relWpExpr}
     For every expression $\expressionSrc$ and its compilation  $\compileLabel{s}{\expressionSrc}{e}$, the following holds :

  $$ \begin{array}{l} 
      \forall \psi,   \forall w_1, \ldots w_{k}, k \ge 0 \\
	\psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \wedge \\
	 \forall \Exc ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\Exc, e ) \Rightarrow \\\\
	 \wpSrcExpr{\expressionSrc }{\psi}{\excPostExpl}{v} \subst{w_i}{\stack{\counter - i + 1}} _{i = 1 \ldots k} =
	\wpi{s}{\methodd}{}
	
     \end{array}
  $$    
 \end{thm}
Proof: the proof is by structural induction over the expression structure. We sketch 
the cases for field access and arithmetic expressions.


\begin{description}
       \item[field access]
            $$\begin{array}{l}
	             \comment{from the compiler definition we have} \\
		    \numConclusion{1} \ \compileLabel{s}{\fieldAccess{\expressionSrc}{\fieldd}}{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc}{e - 1}; \\ 
			    e : \getfield  \ \fieldd
		     \end{array}	\\ \\ 
		     
		     
		     
		  \comment{by initial hypothesis we have that we have a formula $\psi$ such that for some $k \ge 0$}       \\
		  \numConclusion{2} \  \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \\

		  \comment{from the definition of the \wpName{} for source field access expressions} \\ 
		  \numConclusion{3} \ \wpSrcExpr{\fieldAccess{\expressionSrc}{\fieldd} }{\psi}{\excPostExpl}{v} = 
		  \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1}  \\
		  where \\
		  \numConclusion{4} \ \psi'  =                   \begin{array}{l} 
		                                 v_1 \neq \Mynull \Rightarrow \psi \subst{v}{\fieldAccess{v_1}{\fieldd}} \\
						 \wedge \\
						 v_1 = \Mynull \Rightarrow  \excPostExpl(\NullPointerExc)
					       \end{array} \\
		
		  \mbox{\rm\textit{\{because the execution relation between $e$ and $e+1 $ is not a loop backedge}} \\
		  \mbox{\rm\textit{ by Lemma \ref{compile:prop:compProp3} which establishes that compilation of}}\\
		  \mbox{\rm\textit{ expressions does not contain loop entries and }}\\
		  \mbox{\rm\textit{from the Def. \ref{inter} of the function \interOnly \}}} \\
		  \numConclusion{5} \  \inter{e-1}{e} = \wpi{e}{\methodd}{} \\
		 
		 \comment{definition of the \wpName{} function for \getfield } \\
		 \numConclusion{6} \  \wpi{e}{\methodd}{} = \\
		                      \stack{\counter} \neq \Mynull \Rightarrow \inter{e}{e+1} \subst{\stack{\counter}}{\fieldAccess{\stack{\counter}}{\fieldd} } \\
		                      \wedge \\  
				      \stack{\counter}  = \Mynull \Rightarrow \methodd.\getExcPost(\NullPointerExc, e ) \\
		
		\comment{from \numConclusion{2}, \numConclusion{4}, \numConclusion{5} and \numConclusion{6}  } \\
		\numConclusion{7} \ 	\psi' \subst{v_1}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k} 	  = \inter{e-1}{e} \\ 	      
		
		
		\mbox{\rm\textit{\{from Lemma \ref{compile:prop:compProp9} and the initial}}\\
		\mbox{\rm\textit{ hypothesis about exceptional postcondition functions on source and bytecode get\}}} \\
		
		\numConclusion{8}  \ \forall \Exc ,  \excPostExpl( \Exc ) = \methodd.\getExcPost(\Exc, e - 1) \Rightarrow \\\\
		
		\comment{we apply the induction hypothesis over \numConclusion{7}  and  \numConclusion{8} } \\
		
		\numConclusion{9}  \ \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1} \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}  = \wpi{}{\methodd}{s}\\
	
	        \comment{from	\numConclusion{3}, \numConclusion{4} and 	\numConclusion{9} this case holds     }		     		
	     \end{array}
	   $$
       \item[arithmetic expression]
      $$\begin{array}{l}
	             \comment{from the compiler definition we have} \\
		    \numConclusion{1} \ \compileLabel{s}{\expressionSrc_1 \ \op \ \expressionSrc_2 }{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc_1}{e'}; \\
			   \compileLabel{e' + 1}{\expressionSrc_2}{e - 1}; \\ 
			    e : \op
		     \end{array}	\\ \\
		     
		     \comment{by initial hypothesis we have that we have a formula $\psi$ for some $k \ge 0$ such that }       \\
		     \numConclusion{2} \  \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \\\\

		     \comment{from the definition of the \wpName{} for source field access expressions} \\ 
		     \end{array}$$
		      $$\begin{array}{l}
		     \numConclusion{3} \ \wpSrcExpr{ \expressionSrc_1 \ \op \ \expressionSrc_2 }{\psi }{ \excPostSrc }{v}  =   \\
		     \begin{array}{l}
		     \wpSrcExpr{ \expressionSrc_1  }{\wpSrcExpr{\expressionSrc_2 }{\psi'     }{ \excPostSrc }{v_2}  }{ \excPostSrc }{v_1} \\
		     with \ \psi' = \psi \subst{v}{v_1 op v_2} \\

		     \end{array}\\\\
		     
		     			  
		     \mbox{\rm\textit{\{ it follows from Lemma \ref{compile:prop:compProp3} about expressions}}\\
		     \mbox{\rm\textit{ that the compilation of an expression results}}\\
		     \mbox{\rm\textit{ in a list of instructions which does not contain loop entries }}\\
		     \mbox{\rm\textit{ Thus, from the Def.\ref{inter} of the function \interOnly{} we get \} }  } \\
		     	  
		     \numConclusion{4} \  \inter{e -1}{e} = \wpi{e}{\methodd}{} \\
		   
		     \comment{it follows from the \wpName{} for an arithmetic instruction}\\
		     \numConclusion{5} \ \wpi{e}{\methodd}{} = \inter{e}{e+1}\subst{\counter}{\counter -1 } \subst{\stack{\counter - 1}}{\stack{\counter -1 }\op\stack{\counter} } = \\ 
		     \comment{which is equal to because of  \numConclusion{2} } \\
		     \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k} \subst{\counter}{\counter -1 } \subst{\stack{\counter - 1}}{\stack{\counter -1 }\op\stack{\counter} } = \\
		     \comment{$\psi$ is a source assertion and does not contain stack expressions  } \\
		     \psi \subst{v}{\stack{\counter  - 1 }}\subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k} \subst{\stack{\counter - 1}}{\stack{\counter -1 }\op\stack{\counter} } =\\
		      \comment{substitution} \\
		       \psi \subst{v}{\stack{\counter  - 1 } \op \stack{\counter} }\subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k} = \\
		       \comment{this is equal to}  \\
		       \psi'
		          \subst{v_2}{\stack{\counter} } 
		          \subst{v_1}{\stack{\counter -1} }
			  \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k} \\\\
			  \mbox{\rm\textit{ \{from the equalities \numConclusion{5} we can apply }}\\
			  \mbox{\rm\textit{the induction hypothesis over $\expressionSrc_2$ and  $\psi'$ and  get\}}} \\
			  \numConclusion{6} \ \wpSrcExpr{\expressionSrc_2 }{\psi'}{ \excPostSrc }{v_2} \subst{v_1 }{\stack{\counter }} \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}  =
			    \wpi{ e'+1}{\methodd}{} \\\\
			 
			 \comment{ it follows from Lemma \ref{compile:prop:compProp3}   } \\
			 \inter{e'}{e'+1} = \wpi{ e'+1}{\methodd}{} \\
			 \mbox{\rm\textit{\{we apply again the induction hypothesis over $\expressionSrc_1$,}} \\
			 \mbox{\rm\textit{ $\wpSrcExpr{\expressionSrc_2 }{\psi'}{ \excPostSrc }{v_2} $  \}}} \\
			 \wpSrcExpr{ \expressionSrc_1  }{\wpSrcExpr{\expressionSrc_2 }{\psi' }{ \excPostSrc }{v_2}  }{ \excPostSrc }{v_1} 
			 \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}   = \\
			 \wpi{s}{\methodd}{} \\ 
			 \comment{and this case holds}
			  
			  
       \end{array}
       $$ 
\end{description}
\Qed \\




The next lemma states the same property but this time for the compilation of statements.
\begin{thm}\label{relWpStmt}
     For every compiled statement $\compileLabel{s}{\stmt}{e}$  in  method \methodd, formula $\psi$ and 
    function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that 

      \begin{itemize}
            \item if $e+1$ exists  then $\psi = \inter{e}{e+1}$
	    \item if $e+1$ does not exist and $\ins{e} = \return$ then $\psi = \methodd. \normalPost$
	    \item $\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) $ 
      \end{itemize} then the following holds: 
  
     $$   \wpSrcStmt{\stmt}{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}}$$   
\end{thm}

Proof : the proof is  by structural induction on the compilation of a statement and uses the properties of the compiler 
        shown before. We scatch here the proof of few cases 


\begin{description}
       \item[compositional statement]
          $$\begin{array}{l}
	     \wpSrcStmt{  \stmt_1 ;  \stmt_2 }{\psi}{\excPostExpl} = \\
	     \comment{definition of \wpName } \\
	     \wpSrcStmt{\stmt_1 }{\wpSrcStmt{\stmt_2 }{\psi }{ \excPostSrc}} { \excPostSrc} \\\\
	     
		\comment{definition of the compiler} \\
                 \compileLabel{s}{ \stmt_1 ;  \stmt_2}{e} =
		    \begin{array}{l}
	                \compileLabel{s}{\stmt_1}{e'};\\
			\compileLabel{e'+1}{\stmt_2}{e}
	            \end{array}\\
	      \\\\

	       \mbox{\rm\textit{\{it follows from  the induction hypothesis }}\\
	       \mbox{\rm\textit{over $\stmt_2$ and the initial hypothesis about the postcondition\}}} \\
	       \numConclusion{1} \    \wpSrcStmt{  \stmt_2 }{   \psi }{\excPostExpl } = \wpi{}{\methodd}{\ins{e'+1}} \\\\

	       \mbox{\rm\textit{\{
	       Lemma \ref{compile:prop:compProp1} states that $e$ and $e+1$ are in execution relation}}\\
	      \mbox{\rm\textit{ Lemma \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$) }} \\
	       \mbox{\rm\textit{  appear only on loop statement compilation and thus, the edge between  $e'$ and $e' + 1$}}\\
	       \mbox{\rm\textit{ is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get \}  }} \\
	       \inter{e'}{e'+1} = \wpi{}{\methodd}{\ins{e'+1}}  \\\\

	       \comment{$\stmt_1$ is a strict substatement of $\stmt_1;\stmt_2$ and thus, from Property  \ref{compile:prop:compProp8} follows }  \\
	        \forall  \mbox{\rm\texttt{Exc}}, \methodd.\findExcHandler{\mbox{ \rm \texttt{Exc}}  }{e'}{\methodd.\excHandlerTable} = \\
		                                 \methodd.\findExcHandler{\mbox{ \rm \texttt{Exc}}  }{e}{\methodd.\excHandlerTable} \\
	       
                \comment{from the above conclusion and the Def. \ref{defExc}  of function \getExcPost } \\           
                \numConclusion{2} \               \forall \mbox{\rm\texttt{Exc}}, \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  
                                                                                   \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e'' )  \\\\
										   
		\comment{from   \numConclusion{1} and   \numConclusion{2}  we get that }	\\							   
		\wpSrcStmt{  \stmt_1  }{  \wpSrcStmt{  \stmt_2  }{   \psi }{\excPostExpl }    }{\excPostExpl} = 
			\wpi{}{\methodd}{\ins{s}}\\
			\comment{and this case holds }
		
	\end{array}$$
      \item[if statement] 
           
      $$\begin{array}{l}
	\numConclusion{1} \     \wpSrcStmt{   \Myif \ (\expressionSrc_1 \ \rel \ \expressionSrc_2 ) 
                                                               \Mythen \ \{ \stmt_1 \}   
							       \Myelse \ \{ \stmt_2 \}  }{\psi}{\excPostExpl} = \\
							       
	%\begin{array}{l} 
	 \wpSrcExpr{ \expressionSrc_1 }{  \wpSrcExpr{ \expressionSrc_2 }{ \phi'}{  \excPostSrc }{v_2} 
	 } { \excPostSrc }{v_1} \\
	 with  \phi' = \begin{array}{l}  
		            v_1 \rel v_2  \Rightarrow \wpSrcStmt{\stmt_1 }{\normalPostSrc }{ \excPostSrc } \\
			    \wedge \\
			    v_1 \rel v_2   \Rightarrow \wpSrcStmt{\stmt_2 }{\normalPostSrc }{ \excPostSrc } \\
	               \end{array}
	 \\\\
     %\end{array}  
			\comment{definition of the compiler} \\\\
	\numConclusion{2} \  
	\compileLabel{s}{\Myif \ (\expressionSrc_1 \ \rel \ \expressionSrc_2 ) 
                         \Mythen \ \{ \stmt_1 \}   
			 \Myelse \ \{ \stmt_2 \} }{e} = \\
	\compileLabel{s}{\expressionSrc_1}{e'}; \\
	\compileLabel{e'+1}{\expressionSrc_2}{e''}; \\
        e'' + 1: \ifCond \ e''' + 2;\\
        \compileLabel{e'' + 2}{\stmt_2}{e'''}\\
        e''' + 1: \goto \ e +  1; \\
        \compileLabel{e''' +  2}{\stmt_1}{ e  }; \\\\


	\comment{apply the induction hypothesis over $\stmt_1$ and the initial hypothesis } \\
	\numConclusion{3} \ 	\wpSrcStmt{\stmt_1}{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{e''' + 2}} \\\\
	
			
	\mbox{\comment{\rm by initial hypothesis, we have   } }\\
	\numConclusion{4} \ \psi = \inter{e}{e+1}  \\ 
	\mbox{\rm\textit{\{ by the compiler definition $ \ins{e''' + 1} = \goto \ e +  1; $  and thus}} \\
	\mbox{\rm{\textit{  $e'' + 1$ is in execution relation with $e + 1$ \}} }}\\
	\numConclusion{5} \ \ins{e''' + 1} \execRel \ins{e + 1} \\
				
				
                               	
	\mbox{\rm\textit{\{ from Property \ref{compile:prop:compProp5} which states that every instruction inside }} \\
	\mbox{\rm\textit{the compilation of $\compileLabel{s}{\stmt}{e}$ , }} \\
        \mbox{\rm\textit{is in the same execution relation with $\ins{e+1}$, }} \\
	\mbox{\rm\textit{    Def. \ref{inter} for the function \interOnly, \numConclusion{4} and \numConclusion{5}   we conclude that \} } }\\
	\numConclusion{6}  \   \inter{e}{e+1} = \inter{e''' + 1}{e+1}  = \psi\\
	\mbox{\rm\textit{\{Property \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$) }} \\
        \mbox{\rm\textit{  appear only on loop statement compilation and thus, the edge between  $e''$ and $e'' + 1$}}\\
	\mbox{\rm\textit{ is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get \}  }} \\
	\numConclusion{7} \ \inter{e'''}{e''' +1} = \wpi{e''' + 1}{m}{} \\
	\mbox{\rm \comment{ From the definition of the \wpName  \ for \goto \ instructions and \numConclusion{7}  }}\\
	\numConclusion{8}  \ \wpi{e''' + 1}{m}{} = \inter{e''' + 1}{e+1} \\
				
	\comment{ From \numConclusion{7}, \numConclusion{6}	and \numConclusion{8}{}}	\\
	\numConclusion{9}	\  \inter{e'''}{e''' +1} = \inter{e}{e+1}	= \psi	\\
								

	\mbox{\rm\comment{From Property  \ref{compile:prop:compProp8}  } } \\
	

      \numConclusion{10} \forall \mbox{\rm\texttt{Exc}}, \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  
      \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e'' )  \\
      \mbox{\rm\comment{apply the induction hypothesis over \numConclusion{9} and  \numConclusion{10}  } }\\ 
      
      \numConclusion{11} \	\wpSrcStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} = \wpi{e'+2}{m}{} \\
\end{array}$$
$$ \begin{array}{l}
      \comment{ apply the induction hypothesis over the initial hypothesis  }\\
      \numConclusion{12} \ \wpSrcStmt{\stmt_1}{\psi}{\excPostExpl} = \wpi{e'''+2}{m}{} \\\\

			

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
      \mbox{\rm\textit{\{ from Property \ref{compile:prop:compProp4}  follows that the execution relation between $e''$ }}\\
      \mbox{\rm\textit{and  $e'' + 1$ is not a loop edge. From Def. \ref{inter} for the function \interOnly{} we get   \}}}\\
      \numConclusion{13} \  \inter{e''}{e'' + 1} = \wpi{ e'' + 1 }{m}{ } \\\\

      \comment{by definition of conditional jump instruction follows } \\
      \numConclusion{14} \  \wpi{ e'' + 1 }{m}{ } = \\
      \stack{\counter} \ \rel \ \stack{\counter - 1 }  \Rightarrow \wpi{e'''+2}{m}{} \subst{\counter}{\counter - 2} \\
      \wedge \\
      \neg  ( \stack{\counter} \ \rel \ \stack{\counter - 1 } ) \Rightarrow \wpi{e''+2}{m}{} \subst{\counter}{\counter - 2} = \\
      \comment{  $\wpi{e'''+2}{m}{}$ and $\wpi{e''+2}{m}{}$ are source assertion formulas} \\
       \stack{\counter} \ \rel \ \stack{\counter - 1 }  \Rightarrow \wpi{e'''+2}{m}{} \\
      \wedge \\
      \neg  ( \stack{\counter} \ \rel \ \stack{\counter - 1 } ) \Rightarrow \wpi{e''+2}{m}{} \\

      \comment{from \numConclusion{14}, \numConclusion{13} and \numConclusion{1} }\\
      \numConclusion{15} \ \psi'\subst{ v_2}{\stack{\counter } } \subst{ v_1}{\stack{\counter - 1} }  = \inter{e''}{e''+1} \\
      
      \comment{apply Lemma  \ref{pogComp:relWpExpr} over $\psi'$, \numConclusion{15} and $\expression_2$} \\
      \numConclusion{16} \ \wpSrcExpr{ \expressionSrc_2 }{ \phi'}{  \excPostSrc }{v_2}  \subst{ v_1}{\stack{\counter} } = \wpi{e'+1}{\methodd}{}\\
       
      \mbox{\rm\textit{ Lemma \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$) }} \\
      \mbox{\rm\textit{  appear only on loop statement compilation and thus, the edge between  $e'$ and $e' + 1$}}\\
      \mbox{\rm\textit{ is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get \}  }} \\
      \numConclusion{17} \ \inter{e'}{e'+1} = \wpi{e'+1}{\methodd}{}\\
      
      \comment{from   \numConclusion{16} and \numConclusion{17}  apply Lemma  \ref{pogComp:relWpExpr} over 
      $\wpSrcExpr{ \expressionSrc_2 }{ \phi'}{  \excPostSrc }{v_2}$ and $\expression_1$} \\
      \numConclusion{18} \  \wpSrcExpr{ \expressionSrc_1 }{  \wpSrcExpr{ \expressionSrc_2 }{ \phi'}{  \excPostSrc }{v_2} 
	 } { \excPostSrc }{v_1}	= \wpi{s}{\methodd}{} \\

	 \comment{from \numConclusion{18} and	\numConclusion{1} this case holds  }				  
 \end{array}$$
	  
  \item[try catch statement] 
        $$
	  \begin{array}{l}
	    \numConclusion{1} \    \wpSrcStmt{    \try \ \{ \stmt_1 \} 
		                                              \catch \ (\excType \ \var )\{ \stmt_2 \} 
                                                }{\psi}{\excPostExpl} =  \\
			\comment{Def. of $\wpNameStmt$ for statements } \\
	        \wpSrcStmt{\stmt_1
	
                           }
                         { 
	                 \psi}
			 {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\stmt_2 }{\psi}{\excPostExpl }} } \\
			  
              \comment{apply the induction hypothesis over $\stmt_2$ and the initial hypothesis} \\
	      \numConclusion{2} \   \wpSrcStmt{\stmt_2}{\psi}{\excPostExpl} = \wpi{e'+2}{\methodd}{} \\ 
	      \comment{from the definition of \getExcPost \ and property \ref{compile:prop:compProp10}} \\
	      \numConclusion{3} \ \forall \mbox{\rm\texttt{Exc}} ,  \update{\excPostExpl}{\excType}{ \wpi{e'+2}{\methodd}{} } = \\ 
              \phantom{\forall \mbox{\rm\texttt{Exc}} ,}     \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' )\\
	      \comment{we can also conclude from Prop.  \ref{compile:prop:compProp5} and  \ref{compile:prop:compProp4}  } \\
	      \numConclusion{4} \ \inter{e'}{e' + 1} = \inter{e'+1 }{e + 1} = \inter{e}{e+1} \\
	      \comment{apply  induction hypothesis over  \numConclusion{1}, \numConclusion{3} and  \numConclusion{4}    } \\
	       \wpSrcStmt{
	                 \stmt_1;
	
                           }
                         {  \psi}
			 {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} } =\\
			  \wpi{s}{\methodd}{}
	      
	   \end{array}
	$$
\end{description}
\Qed \\
\clearpage
As a conclusion of the current chapter, we would like to make several remarks. 
Such an equivalence between proof obligations on source and bytecode and the fact that
we have proof for the soundness of the bytecode verification condition generator
 gives us the soundness of the source  weakest precondition calculus.  

Another remark is that here we ignore the difference between names and types on  source and bytecode level. 
Let us first focus on the naming on source and bytecode. 
In this chapter, we have considered that the compiler  does not change  variable, class and method  names.
 This is not true for Java compilers, as these names are basically compiled into 
indexes in the constant pool table. However, this difference is a minor detail and of course, this means that 
the equivalence between source and bytecode verification conditions in Java can be established modulo names.
The second detail in the formalization presented here is that the compilers compiles boolean types into boolean types.
This neither holds for real Java compiler. This is because JVM does not have a direct support  for booleans and thus,
Java compilers compile booleans into integers. This implies that the other difference between source and proof
obligations in Java is modulo types. Once again, we consider that this is a detail that would only make heavier
the presentation without being an important issue in establishing the equivalence of the verification conditions on source and bytecode. 
