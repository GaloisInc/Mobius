\newtheorem{thm}{Theorem}[section]


%\newtheorem{wpBlock}[wpIns]{Lemma}
%\newtheorem{relWpExpr}[wpIns]{Lemma}
%\newtheorem{relWpStmt}[wpIns]{Lemma}

%\subsection{Properties of the \wpName \ functions}\label{pog:wpBcProp}
 
In the following, we proceed with establishing the equivalence between source and bytecode 
proof obligations. As we have already seen, the source programming language supports 
expressions  and statements. Because statements and expressions play different roles in  a source program language 
they need a different treatment here in this proof. Let us remind briefly about the semantics of these constructs and their compilation. 
Expressions evaluate to a value and thus, their compilation affects the operand stack on execution time. 
As we have discussed previously, because we compile for a stack based virtual machine,
an expression compilation   results in a sequence of instructions whose execution must leave on the stack top the expression value.
Statements have a different role in the language. They do not have values, but they control the control flow in the program. 
   
We focus now on the relation between the \wpName{} predicate transformer functions for expressions 
on bytecode and source level. But before entering into technical details, we illustrate this relation
 by an example given in Fig.\ref{pogCompile:wpBc:expression}.
The figure contains three parts. The first part shows the compilation of a source expression \lstinline!sqr + 2*s! in a method \methodd{} starting at index \lstinline!i!.
There we show the steps that the compiler will take for the compilation of the expression: compile the access of the variable \lstinline!sqr!,
the multiplication  \lstinline! 2*s! and compile their addition. 

The second part calculates the preconditions of the instructions resulting from the 
 expression compilation against a postcondition that the stack top element is equal to 5 (\stack{\counter} = \lstinline! 5 !). 
Actually, this postcondition requires that the evaluation of the expression must be equal to \lstinline!5!. 
This is because as we said in the beginning of the section the compiler translates source expressions to a sequence of bytecode instructions
 such that their execution 
must leave the expression value on the stack top. 
Note that every instruction is followed by its postcondition and is preceded by its weakest  precondition.  This means that the weakest predicate of an instruction is the
postcondition of the predecessor instruction. This is because compilation of  expressions may not contain loop entries
 (see previous Section \ref{compile:prop:compProp3}, page \pageref{compile:prop:compProp3}).  

The third part shows how the precondition of the source expression is calculated w.r.t. the postcondition $v = 5$ where 
$v$ is the special logical variable which stands for the value of the expression \lstinline!sqr + 2*s!.
Thus, the bytecode postcondition \stack{\counter} = \lstinline! 5 ! and the source postcondition $v = 5$ express the same condition
respectively on source and bytecode.
Note that  substituting the abstract variable $v$ with the stack top in the source postcondition $ v = 5\subst{v}{\stack{\counter}}$ 
results in the bytecode postcondition.

 Let us focus on the intermediate stages in the calculation of the precondition of the whole expression.
We may  remark that the resulting 
postcondition   of the source expression   \lstinline!2*s! is $v_{sqr} +v_{2*s}=5$ and that the postcondition at line 1.9
for the last instruction of its compilation (instruction \lstinline!i+3: mul!) is $\stack{\counter - 1}  + \stack{\counter} =~\mbox{\rm \lstinline! 5!}  $.
Substituting in the source postcondition the abstract variable $v_{2*s}$ with \stack{\counter} and $v_{sqr}$  with \stack{\counter -1} results
in the bytecode postcondition
 $$ \numConclusion{1} \ (v_{sqr} +v_{2*s}=5)  \subst{v_{2*s}}{\stack{\counter}}\subst{v_{sqr}}{\stack{\counter-1}} \equiv\stack{\counter - 1}  + \stack{\counter} =~\mbox{\rm \lstinline! 5!} $$
We can remark that the precondition of  the first instruction (\lstinline!i+1: const 2!)
of the compilation of the expression \lstinline!2*s! is   $\stack{\counter} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}$. 
We may remark that the  precondition of the source expression \lstinline!2*s!  in the third part of the figure is equivalent to $v_{sqr} + 2*\lstinline!s!=5 $.
Substituting in the source precondition the abstract variable $v_{sqr}$ with \stack{\counter} results
in a formula which is equivalent to the bytecode precondition
 $$\numConclusion{2} \ (v_{sqr} +\mbox{\rm \lstinline!2*s!} =5) \subst{v_{sqr}}{\stack{\counter}} \equiv \stack{\counter }  + \mbox{\rm \lstinline!2*s!}  = ~\mbox{\rm \lstinline! 5!} $$

Equivalences \numConclusion{1}  and \numConclusion{2} give the intuition of how the predicate transformers work over  source expressions and 
their bytecode compilation. The predicate transformer over the instructions representing an expression
 substitutes the stack top element expression  \stack{\counter} with the value of the expression and the stack counter is decremented. The predicate transformer 
over a source expression calculates a predicate where the abstract variable representing its value is substituted with the expression value. 
More formally, this is expressed in the next lemma.  

\begin{figure}[ht!]
\begin{frameit}
  \scriptsize{ \begin{tabular}{lll} 
   $ \compileLabel{i}{ \lstinline!sqr + 2*s ! }{i+4}$ & = &
   \begin{tabular}{l} 
     $\compileLabel{i}{ \lstinline!sqr! }{i}$ \\
     $\compileLabel{i+1}{ \lstinline!2*s! }{i+3} $\\
     \lstinline!i+4: add!
      \end{tabular} \\
      where & & \\
      $\compileLabel{i}{ \lstinline!sqr! }{i}$ & = & \lstinline! i: load sqr!\\
      \\
      $\compileLabel{i+1}{ \lstinline!2*s! }{i+3}$ & = &
      \begin{tabular}{l} 
        % \lstinline!i  : load sqr! \\
	 \lstinline!i+1: const 2!  \\
	 \lstinline!i+2: load s!   \\
	 \lstinline!i+3: mul!	   \\
	 %\lstinline!i+4: add!	    
   \end{tabular}
    \end{tabular}
}
\end{frameit}

\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
         1.1   & $\mbox{\rm \lstinline!sqr!} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline!5!}  $\\ 
         1.2   &   \lstinline!i:  load sqr!  \\
         1.3   &   $\stack{\counter} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}  $\\
         1.4   &   \lstinline!i+1: const 2!	  \\
	 1.5   &    $\stack{\counter - 1} + \stack{\counter } *\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}  $\\
	 1.6   &   \lstinline!i+2: load s!	  \\
	 1.7   &   $\stack{\counter - 2}  + \stack{\counter - 1} * \stack{\counter} = \mbox{\rm \lstinline! 5!}  $\\
	 1.8   &     \lstinline!i+3: mul!	          \\
	 1.9   &   $\stack{\counter - 1}  + \stack{\counter} = \mbox{\rm \lstinline! 5!}  $\\
	 1.10  &   \lstinline!i+4: add!	          \\
	 1.11  &   $\stack{\counter} = \mbox{\rm \lstinline! 5 !}  $\\
  \end{tabular}}
\end{frameit}


\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
      2.1   &   $\wpSrcExpr{\lstinline!sqr + 2*s ! }{v = 5}{\excPostExpl}{v} = $ \\
      2.2   &  	$\wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2*s ! }{(v=5)\subst{v}{v_{sqr} + v_{2*s}} }{\excPostExpl}{v_{2*s}}  }{\excPostExpl}{v_{sqr}} = $ \\
      2.3   & 	$\wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2! }{\wpSrcExpr{\lstinline!s! }{(v_{sqr}+v_{2*s}=5)\subst{v_{2*s}}{v_{2}*v_{s}} }{\excPostExpl}{v_{s}}  }{\excPostExpl}{v_{2}} }{\excPostExpl}{v_{sqr}} = $ \\
      2.4   &	$\wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2! }{(v_{sqr} + v_{2}*v_{s}=5 ) \subst{v_{s}}{s} }{\excPostExpl}{v_{2}} }{\excPostExpl}{v_{sqr}} = $ \\
      2.5   &	$\wpSrcExpr{\lstinline!sqr!}{(v_{sqr} + v_{2}*\lstinline!s!=5 ) \subst{v_{2}}{2} }{\excPostExpl}{v_{sqr}} = $ \\
      2.6   &	$(v_{sqr} + 2*\lstinline!s!=5 ) \subst{v_{sqr}}{\lstinline!sqr!  } = $ \\
      2.7   &	$ \lstinline!sqr! + 2*\lstinline!s!=5 $
  \end{tabular}}
\end{frameit}
\caption{\sc Expression, its compilation  and their respective preconditions} \label{pogCompile:wpBc:expression}
\end{figure}

\begin{thm}\label{pogComp:relWpExpr}
     For every expression $\expressionSrc$ and its compilation  $\compileLabel{s}{\expressionSrc}{e}$, the following holds :

  $$ \begin{array}{l} 
      \forall \psi,   \forall w_1, \ldots w_{k}, k \ge 0 \\
	\psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \wedge \\
	 \forall \Exc ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\Exc, e ) \Rightarrow \\\\
	 \wpSrcExpr{\expressionSrc }{\psi}{\excPostExpl}{v} \subst{w_i}{\stack{\counter - i + 1}} _{i = 1 \ldots k} =
	\wpi{s}{\methodd}{}
	
     \end{array}
  $$    
 \end{thm}
Proof: the proof is by structural induction over the expression structure. We sketch 
the cases for field access and arithmetic expressions.


\begin{description}
       \item[field accesss]
            
	             \comment{From the compiler definition we have} 
		    $$ \numConclusion{1} \ \compileLabel{s}{\fieldAccess{\expressionSrc}{\fieldd}}{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc}{e - 1}; \\ 
			    e  : \getfield  \ \fieldd
		     \end{array}$$	\\ 
		 	
	       \comment{by initial hypothesis we have that we have a formula $\psi$ such that for some $k \ge 0$}       \\
		 $$ \numConclusion{2} \  \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} $$ 

		  \comment{from the definition of the \wpName{} for source field access expressions} 
		  $$ \begin{array}{l}\numConclusion{3} \ \wpSrcExpr{\fieldAccess{\expressionSrc}{\fieldd} }{\psi}{\excPostExpl}{v} = 
		  \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1}  \\
		  where \\ 
		  \numConclusion{4} \ \psi'  =                   \begin{array}{l} 
		                                 v_1 \neq \Mynull \Rightarrow \psi \subst{v}{\fieldAccess{v_1}{\fieldd}} \\
						 \wedge \\
						 v_1 = \Mynull \Rightarrow  \excPostExpl(\NullPointerExc)
					       \end{array}
				\end{array}  \\
		  $$
		 
		  \mbox{\rm\textit{\{because the execution relation between $e$ and $e+1 $ is not a loop backedge by Lemma \ref{compile:prop:compProp3} }} \\
		  \mbox{\rm\textit{ which establishes that compilation of expressions does not contain loop entries and }}\\
		  \mbox{\rm\textit{from the Def. \ref{inter} of the function \interOnly \}}} 
		  $$\numConclusion{5} \  \inter{e-1}{e} = \wpi{e}{\methodd}{} $$ 
		
		 \comment{definition of the \wpName{} function for \getfield } 
		 $$\numConclusion{6} \  \wpi{e}{\methodd}{} = \\
		                     \begin{array}{l} \stack{\counter} \neq \Mynull \Rightarrow \inter{e}{e+1} \subst{\stack{\counter}}{\fieldAccess{\stack{\counter}}{\fieldd} } \\
		                      \wedge \\  
				      \stack{\counter}  = \Mynull \Rightarrow \methodd.\getExcPost(\NullPointerExc, e ) \end{array}$$
		
		\comment{from \numConclusion{2}, \numConclusion{4}, \numConclusion{5} and \numConclusion{6}  } 
		$$\numConclusion{7} \ 	\psi' \subst{v_1}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k} 	  = \inter{e-1}{e} $$
		
		 
		\comment{from Lemma \ref{compile:prop:compProp9} and the initial hypothesis about exceptional postcondition functions on source and bytecode get} \\
		
		$$\numConclusion{8}  \ \forall \Exc ,  \excPostExpl( \Exc ) = \methodd.\getExcPost(\Exc, e - 1)  $$
		
		\comment{we apply the induction hypothesis over \numConclusion{7}  and  \numConclusion{8} } \\
		
		$$ \numConclusion{9}  \ \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1} \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}  = \wpi{}{\methodd}{s}$$
	
	        \comment{from	\numConclusion{3}, \numConclusion{4} and 	\numConclusion{9} this case holds     }	
	   
       		\item[arithmetic expression]
      
	             \comment{from the compiler definition we have} 
		   $$  \numConclusion{1} \ \compileLabel{s}{\expressionSrc_1 \ \op \ \expressionSrc_2 }{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc_1}{e'}; \\
			   \compileLabel{e' + 1}{\expressionSrc_2}{e - 1}; \\ 
			    e : \op
		     \end{array}$$ 	 
		     
		   
		       \comment{by initial hypothesis we have that we have a formula $\psi$ for some $k \ge 0$ such that }       
		     $$ \numConclusion{2} \  \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1}$$ 

		     \comment{from the definition of the \wpName{} for source field access expressions}  
		     
		     $$\numConclusion{3} \ \wpSrcExpr{ \expressionSrc_1 \ \op \ \expressionSrc_2 }{\psi }{ \excPostSrc }{v}  =   
		     \begin{array}{l}
		     \wpSrcExpr{ \expressionSrc_1  }{\wpSrcExpr{\expressionSrc_2 }{\psi'     }{ \excPostSrc }{v_2}  }{ \excPostSrc }{v_1} \\
		     with \ \psi' = \psi \subst{v}{v_1 op v_2} \end{array} $$

		         \mbox{\rm\textit{\{ it follows from Lemma \ref{compile:prop:compProp3} about expressions that the compilation }}\\
		     \mbox{\rm\textit{of an expression results in a list of instructions which does not contain loop entries }}\\
		     \mbox{\rm\textit{ Thus, from the Def.\ref{inter} of the function \interOnly{} we get \} }  } 
		     	 
		     $$ \numConclusion{4} \  \inter{e -1}{e} = \wpi{e}{\methodd}{}$$
		   
		     \comment{it follows from the \wpName{} for an arithmetic instruction}
		     $$\numConclusion{5} \ \wpi{e}{\methodd}{} = \inter{e}{e+1}\subst{\counter}{\counter -1 } \subst{\stack{\counter - 1}}{\stack{\counter -1 }\op\stack{\counter} } = $$
		     \comment{which is equal to because of  \numConclusion{2} } 		     
		     $$ \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k} \subst{\counter}{\counter -1 } \subst{\stack{\counter - 1}}{\stack{\counter -1 }\op\stack{\counter} } =  $$
		     \comment{$\psi$ is a source assertion and does not contain stack expressions  } 
		    $$ \psi \subst{v}{\stack{\counter  - 1 }}\subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k} \subst{\stack{\counter - 1}}{\stack{\counter -1 }\op\stack{\counter} } =$$
		      \comment{apply substitution} 
		       $$\psi \subst{v}{\stack{\counter  - 1 } \op \stack{\counter} }\subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k} = $$
		       \comment{which is equal to}  
		       $$\psi'
		          \subst{v_2}{\stack{\counter} } 
		          \subst{v_1}{\stack{\counter -1} }
			  \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}$$ 
			  \mbox{\rm\textit{ \{from the equalities \numConclusion{5} we can apply }}\\
			  \mbox{\rm\textit{the induction hypothesis over $\expressionSrc_2$ and  $\psi'$ and  get\}}} 
			  $$\numConclusion{6} \ 
			  \wpSrcExpr{\expressionSrc_2 }{\psi'}{ \excPostSrc }{v_2} \subst{v_1 }{\stack{\counter }} \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}  =
			    \wpi{ e'+1}{\methodd}{} $$
			 
			 \comment{ it follows from Lemma \ref{compile:prop:compProp3}   } 
			 $$\inter{e'}{e'+1} = \wpi{ e'+1}{\methodd}{} $$
			 \mbox{\rm\textit{\{we apply again the induction hypothesis over $\expressionSrc_1$,}} \\
			 \mbox{\rm\textit{ $\wpSrcExpr{\expressionSrc_2 }{\psi'}{ \excPostSrc }{v_2} $  \}}} 
			 $$\wpSrcExpr{ \expressionSrc_1  }{\wpSrcExpr{\expressionSrc_2 }{\psi' }{ \excPostSrc }{v_2}  }{ \excPostSrc }{v_1} 
			 \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}   = 
			 \wpi{s}{\methodd}{} $$
		     			  
		 
			 \comment{and this case holds}
			  	  

       
\end{description}
\Qed \\




The next lemma states the same property but this time for the compilation of statements.
\begin{thm}\label{relWpStmt}
     For every compiled statement $\compileLabel{s}{\stmt}{e}$  in  method \methodd, formula $\psi$ and 
    function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that 

      \begin{enumerate}
            \item if $e+1$ exists  then $\psi = \inter{e}{e+1}$
	    \item if $e+1$ does not exist and $\ins{e} = \return$ then $\psi = \methodd. \normalPost$
	    \item $\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) $ 
      \end{enumerate} then the following holds: 
  
     $$   \wpSrcStmt{\stmt}{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}}$$   
\end{thm}

Proof : the proof is  by structural induction on the compilation of a statement and uses the properties of the compiler 
        shown before. We give here the proof  for the cases of compositional statement, while and try catch statement.
The rest of the cases proceed in a similar way.


\begin{description}
       \item[compositional statement]
          
	     $$\wpSrcStmt{  \stmt_1 ;  \stmt_2 }{\psi}{\excPostExpl} = 
	     %\comment{by definition of \wpName{} this is  } 
	     \wpSrcStmt{\stmt_1 }{\wpSrcStmt{\stmt_2 }{\psi }{ \excPostSrc}} { \excPostSrc} $$
	     
		\comment{from the compiler definition we get} %\\
                 $$\compileLabel{s}{ \stmt_1 ;  \stmt_2}{e} =
		    %\begin{array}{l}
	                \compileLabel{s}{\stmt_1}{e'};%\\
			\compileLabel{e'+1}{\stmt_2}{e}  $$
	            %\end{array}
		  

	       \comment{it follows from  the induction hypothesis over $\stmt_2$ and the initial hypothesis about the postcondition }
	       %\mbox{\rm\textit{ \}}} 
	       $$ \numConclusion{1} \    \wpSrcStmt{  \stmt_2 }{   \psi }{\excPostExpl } = \wpi{}{\methodd}{\ins{e'+1}} $$

	       \mbox{\rm\textit{\{
	       Lemma \ref{compile:prop:compProp1} states that $e$ and $e+1$ are in execution relation}}\\
	      \mbox{\rm\textit{ Lemma \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$) }} \\
	       \mbox{\rm\textit{  appear only on loop statement compilation and thus, the edge between  $e'$ and $e' + 1$}}\\
	       \mbox{\rm\textit{ is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get \}  }} 
	        $$\numConclusion{2} \ \inter{e'}{e'+1} = \wpi{}{\methodd}{\ins{e'+1}} $$

	       \comment{statement $\stmt_1$ is a strict substatement of $\stmt_1;\stmt_2$ and thus, from Property  \ref{compile:prop:compProp8} follows }  
	         $$ \forall  \mbox{\rm\texttt{Exc}}, \methodd.\findExcHandler{\mbox{ \rm \texttt{Exc}}  }{e}{\methodd.\excHandlerTable} = 
		                                 \methodd.\findExcHandler{\mbox{ \rm \texttt{Exc}}  }{e'}{\methodd.\excHandlerTable}   $$
	       
                \comment{from the above conclusion and the Def. \ref{defExc}  of function \getExcPost } 
                $$ \numConclusion{3} \               \forall \mbox{\rm\texttt{Exc}}, \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  
                                                                                   \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' ) $$ 
										   
		\comment{from   \numConclusion{1},   \numConclusion{2} and \numConclusion{3} we get that }	
	 $$	\wpSrcStmt{  \stmt_1  }{  \wpSrcStmt{  \stmt_2  }{   \psi }{\excPostExpl }    }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}} $$
			\comment{and this case holds }
		
	
      

  \item[while statement]
  $$\numConclusion{1} \   \begin{array}{l}   
\wpSrcStmt{ \while \ (\expressionSrc_1 \ \rel \ \expressionSrc_2 ) \ \lbrack \invariant, \modLoop \rbrack \  \do \ \{ \stmt \}}{ \normalPostSrc}{\excPostSrc}=\\
    \invariant \ \wedge\\
	       \forall \  m, m \in \modLoop , \\
	       \invariant \Rightarrow %\\
	 	     %\Myspace    \Myspace 
		     \wpSrcExpr{\expressionSrc_1}{
                     \wpSrcExpr{\expressionSrc_2}{   %\\\phantom{wp^{src}} 
		     %\begin{array}{l}  		
		           ( v_1 \rel v_2 )        \Rightarrow \  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc} \wedge  
		          \neg (v_1 \rel v_2)    \Rightarrow  \normalPostSrc
		     %\end{array}
	       }{\excPostSrc } {v_2}}{\\ \phantom{\invariant \Rightarrow wpiSr\expressionSrc_1}
	      \excPostSrc}{v_1} 

                          \end{array}
    $$
   
\comment{By the compiler function we get}
 $$\begin{array}{l} \numConclusion{2} \  \compileLabel{s}{\while \ (\expressionSrc_1 \ \rel  \ \expressionSrc_2) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} }{e} = \\
         
	       s: \goto \ e' + 1; \\
	       \compileLabel{s +  1}{\stmt}{e' }; \\
	       \compileLabel{e' +  1}{\expressionSrc_1}{e''};\\
	       \compileLabel{e'' +  1}{\expressionSrc_2}{e-1};\\
	       e : \ifCond \ s +  1; \\
	       %e: \nop
	       \\\\
	       \addLoopTable{\methodd}{e'+1}{\invariant }{\modLoop}
	 \end{array}$$

\comment{From Lemma \ref{compile:prop:compProp4} we know that the execution relation between $e'$ and $e'+1$ is a loop execution relation. From Def. \ref{inter}, \pageref{inter} 
     of the function \interOnly{} we conclude that  }
 $$ \numConclusion{3} \  \inter{e'}{e'+1} = \invariant$$
\comment{From Lemma \ref{compile:prop:compProp8} we get that the exception handlers for the last index $e'$ in the compilation of $\stmt$ and the index $e$ are the same.
Thus, from the initial hypothesis for the exception handler function, we conclude that  }
$$ \numConclusion{4}  \  \forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' ) $$
\comment{We can apply the  induction hypothesis over \numConclusion{3}, \numConclusion{4}  and  statement $\stmt$}
$$ \numConclusion{5}  \  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc} =  \wpi{}{\methodd}{\ins{s+1}}  $$
\comment{From Lemma \ref{compile:prop:compProp4} we get that the execution relation between $e$ and $s+1$ is not a loop execution relation. From def. \ref{inter}, 
we  conclude that  }
$$\numConclusion{6}  \  \wpi{}{\methodd}{\ins{s+1}}  = \inter{e}{s+1}    $$
\comment{By definition of the \wpName{} function for \ifCond{} and \numConclusion{6}, we conclude that the \wpName{}   is equivalent to }
$$  \numConclusion{7}  \ \begin{array}{l}  \wpi{}{\methodd}{e} = \\
                   \stack{\counter} \ \rel \ \stack{\counter - 1}  \Rightarrow  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc}\\
			 \wedge  \\
		  \neg ( \stack{\counter} \ \rel \ \stack{\counter - 1} )  \Rightarrow \inter{e}{e+1}
           \end{array}  $$
\comment{From \numConclusion{7}, we can apply the previous Lemma \ref{pogComp:relWpExpr} for expressions twice over $\expressionSrc_1$ and $\expressionSrc_2$ and we get that }

$$ \numConclusion{8}  \ \begin{array}{l}\wpSrcExpr{\expressionSrc_1}{
                     \wpSrcExpr{\expressionSrc_2}{   %\\\phantom{wp^{src}} 
		     %\begin{array}{l}  		
		           ( v_1 \rel v_2 )        \Rightarrow \  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc} \wedge  
		          \neg (v_1 \rel v_2)    \Rightarrow  \normalPostSrc
		     %\end{array}
	       }{\excPostSrc } {v_2}}{\\ \phantom{\invariant \Rightarrow wpiSr\expressionSrc_1}
	      \excPostSrc}{v_1} = \\ \wpi{}{\methodd}{e'+1} \end{array}  $$

\comment{From  Lemma \ref{compile:prop:compProp4}, we  get that $e'+1$ is a loop entry instruction. From Def. \ref{inter} of the function \interOnly, we get that }
$$\numConclusion{9}  \  \begin{array}{l}\wpi{}{\methodd}{s} =  \inter{s}{e'+1} = \\
                \invariant \ \wedge \\
	       \forall \  m, m \in \modLoop ,
          i(\invariant \Rightarrow   \wpi{ }{ \methodd }{e'+1} ) \end{array}  $$  
\comment{from   \numConclusion{8} and \numConclusion{9}  we conclude that this case holds }



  \item[try catch statement] 
        
	   $$ \numConclusion{1} \   \begin{array}{l} \wpSrcStmt{    \try \ \{ \stmt_1 \} 
		                                              \catch \ (\excType \ \var )\{ \stmt_2 \} 
                                                }{\psi}{\excPostExpl} =\\ %$$
			%\comment{by the definition of $\wpNameStmt$} 
	   %$$    
	    \wpSrcStmt{\stmt_1 }{  \psi} {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\stmt_2 }{\psi}{\excPostExpl }} } 
	    \end{array}$$
	        
              \comment{By definition of the compiler}
	      $$\begin{array}{l}	\numConclusion{2} \    \compileLabel{s}{ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \} }{e} = \\
                      \compileLabel{s}{\stmt_1}{e'};   e' + 1: \goto \ e;  \compileLabel{e' + 2 }{\stmt_2}{e - 1}; e: \nop\\
		                           
			\addExceptionTable{\methodd}{ s }{ e'  }{ e' + 2 }{\excType}  \end{array} $$
              \comment{Apply the induction hypothesis over $\stmt_2$ and the initial hypothesis} 
	      $$\numConclusion{3} \   \wpSrcStmt{\stmt_2}{\psi}{\excPostExpl} = \wpi{e'+2}{\methodd}{} $$ 
	      \comment{ from Lemma \ref{compile:prop:compProp10}  we know that the indexes $e$ and $e'$ has the same exception handlers~}
	      $$ \begin{array}{l} \forall \mbox{\rm{\texttt{Exc}}},  \neg ( \mbox{\rm{\texttt{Exc}}} <: \excType ) \Rightarrow\\
	       \left(\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} = 
	       \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} \right) 
	       \wedge\\
	        \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e'+2\end{array}  $$
	      
	      \mbox{\rm\textit{\{from the definition of \getExcPost{} and  the initial hypothesis about the exceptional }}\\
	      \mbox{\rm\textit{  postcondition functions for indexes $e$ and $e' $ \}}}
	    	     $$ \numConclusion{4} \ \forall \mbox{\rm\texttt{Exc}} ,  \update{\excPostExpl}{\excType}{ \wpi{e'+2}{\methodd}{} }(\mbox{\rm\texttt{Exc}}) = 
                  \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' )$$
	      \comment{From Lemma   \ref{compile:prop:compProp4} that there are no loop edges between $e'$ and $e'+1$, $e'+1$ and $e$,
	       $e$ and $e+1$. We can conclude from the definition of the function \interOnly{} that  } 
	     $$ \numConclusion{5} \ \inter{e'}{e' + 1} = \inter{e'+1 }{e} = \inter{e}{e+1}$$
	      \comment{We apply  induction hypothesis over  \numConclusion{1}, \numConclusion{4} and  \numConclusion{5}    } 
	      $$ \wpSrcStmt{\stmt_1 }
                         {  \psi}
			 {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} } =
			  \wpi{s}{\methodd}{}$$
	      
	   
\end{description}
\Qed \\

As a conclusion of the current chapter, we would like to make several remarks. 
Such an equivalence between proof obligations on source and bytecode and the fact that
we have proof for the soundness of the bytecode verification condition generator
 gives us the soundness of the source  weakest precondition calculus.  

Another remark is that here we ignore the difference between names and types on  source and bytecode level. 
Let us first focus on the naming on source and bytecode. 
In this chapter, we have considered that the compiler  does not change  variable, class and method  names.
 This is not true for Java compilers, as these names are basically compiled into 
indexes in the constant pool table. However, this difference is a minor detail and of course, this means that 
the equivalence between source and bytecode verification conditions in Java can be established modulo names.
The second detail in the formalization presented here is that the compilers compiles boolean types into boolean types.
This neither holds for real Java compiler. This is because JVM does not have a direct support  for booleans and thus,
Java compilers compile booleans into integers. This implies that the other difference between source and proof
obligations in Java is modulo types. Once again, we consider that this is a detail that would only make heavier
the presentation without being an important issue in establishing the equivalence of the verification conditions on source and bytecode. 
