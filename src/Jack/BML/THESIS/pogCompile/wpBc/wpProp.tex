\newtheorem{thm}{Theorem}[section]


%\newtheorem{wpBlock}[wpIns]{Lemma}
%\newtheorem{relWpExpr}[wpIns]{Lemma}
%\newtheorem{relWpStmt}[wpIns]{Lemma}

%\subsection{Properties of the \wpName \ functions}\label{pog:wpBcProp}
 
In the following, we proceed with establishing the equivalence between source and bytecode 
proof obligations. As we have already seen, the source programming language supports 
expressions  and statements. Because statements and expressions play different roles in  a source program language 
they need a different treatment here in this proof. Let us remind briefly about the semantics of these constructs and their compilation. 
Expressions evaluate to a value and thus, their compilation affects the operand stack on execution time. 
As we have discussed previously, because we compile for a stack based virtual machine,
an expression compilation   results in a sequence of instructions whose execution must leave on the stack top the expression value.
Statements have a different role in the language. They do not have values, but they control the control flow in the program. 
   
We focus now on the relation between the \wpName{} predicate transformer functions for expressions 
on bytecode and source level. But before entering into technical details, we illustrate this relation
 by an example given in Fig.\ref{pogCompile:wpBc:expression}.
The figure contains three parts. The first part shows the compilation of a source expression \lstinline!sqr + 2*s! in a method \methodd{} starting at index \lstinline!i!.
There we show the steps that the compiler will take for the compilation of the expression: compile the access of the variable \lstinline!sqr!,
the multiplication  \lstinline! 2*s! and compile their addition. 

The second part calculates the preconditions of the instructions resulting from the 
 expression compilation against a postcondition that the stack top element is equal to 5 (\stack{\counter} = \lstinline! 5 !). 
Actually, this postcondition requires that the evaluation of the expression must be equal to \lstinline!5!. 
This is because as we said in the beginning of the section the compiler translates source expressions to a sequence of bytecode instructions
 such that their execution 
must leave the expression value on the stack top. 
Note that every instruction is followed by its postcondition and is preceded by its weakest  precondition.  This means that the weakest predicate of an instruction is the
postcondition of the predecessor instruction. This is because compilation of  expressions may not contain loop entries
 (see previous Section \ref{compile:prop:compProp3}, page \pageref{compile:prop:compProp3}).  

The third part shows how the precondition of the source expression is calculated w.r.t. the postcondition $v = 5$ where 
$v$ is the special logical variable which stands for the value of the expression \lstinline!sqr + 2*s!.
Thus, the bytecode postcondition \stack{\counter} = \lstinline! 5 ! and the source postcondition $v = 5$ express the same condition
respectively on source and bytecode.
Note that  substituting the abstract variable $v$ with the stack top in the source postcondition $ v = 5\subst{v}{\stack{\counter}}$ 
results in the bytecode postcondition.

 Let us focus on the intermediate stages in the calculation of the precondition of the whole expression.
We may  remark that the resulting 
postcondition   of the source expression   \lstinline!2*s! is $v_{sqr} +v_{2*s}=5$ and that the postcondition at line 1.9
for the last instruction of its compilation (instruction \lstinline!i+3: mul!) is $\stack{\counter - 1}  + \stack{\counter} =~\mbox{\rm \lstinline! 5!}  $.
Substituting in the source postcondition the abstract variable $v_{2*s}$ with \stack{\counter} and $v_{sqr}$  with \stack{\counter -1} results
in the bytecode postcondition
 $$ \numConclusion{1} \ (v_{sqr} +v_{2*s}=5)  \subst{v_{2*s}}{\stack{\counter}}\subst{v_{sqr}}{\stack{\counter-1}} \equiv\stack{\counter - 1}  + \stack{\counter} =~\mbox{\rm \lstinline! 5!} $$
We can remark that the precondition of  the first instruction (\lstinline!i+1: const 2!)
of the compilation of the expression \lstinline!2*s! is   $\stack{\counter} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}$. 
We may remark that the  precondition of the source expression \lstinline!2*s!  in the third part of the figure is equivalent to $v_{sqr} + 2*\lstinline!s!=5 $.
Substituting in the source precondition the abstract variable $v_{sqr}$ with \stack{\counter} results
in a formula which is equivalent to the bytecode precondition
 $$\numConclusion{2} \ (v_{sqr} +\mbox{\rm \lstinline!2*s!} =5) \subst{v_{sqr}}{\stack{\counter}} \equiv \stack{\counter }  + \mbox{\rm \lstinline!2*s!}  = ~\mbox{\rm \lstinline! 5!} $$

Equivalences \numConclusion{1}  and \numConclusion{2} give the intuition of how the predicate transformers work over  source expressions and 
their bytecode compilation. The predicate transformer over the instructions representing an expression
 substitutes the stack top element expression  \stack{\counter} with the value of the expression and the stack counter is decremented. The predicate transformer 
over a source expression calculates a predicate where the abstract variable representing its value is substituted with the expression value. 
More formally, this is expressed in the next lemma.  

\begin{figure}[ht!]
\begin{frameit}
  \scriptsize{ \begin{tabular}{lll} 
   $ \compileLabel{i}{ \lstinline!sqr + 2*s ! }{i+4}$ & = &
   \begin{tabular}{l} 
     $\compileLabel{i}{ \lstinline!sqr! }{i}$ \\
     $\compileLabel{i+1}{ \lstinline!2*s! }{i+3} $\\
     \lstinline!i+4: add!
      \end{tabular} \\
      where & & \\
      $\compileLabel{i}{ \lstinline!sqr! }{i}$ & = & \lstinline! i: load sqr!\\
      \\
      $\compileLabel{i+1}{ \lstinline!2*s! }{i+3}$ & = &
      \begin{tabular}{l} 
        % \lstinline!i  : load sqr! \\
	 \lstinline!i+1: const 2!  \\
	 \lstinline!i+2: load s!   \\
	 \lstinline!i+3: mul!	   \\
	 %\lstinline!i+4: add!	    
   \end{tabular}
    \end{tabular}
}
\end{frameit}

\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
         1.1   & $\mbox{\rm \lstinline!sqr!} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline!5!}  $\\ 
         1.2   &   \lstinline!i:  load sqr!  \\
         1.3   &   $\stack{\counter} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}  $\\
         1.4   &   \lstinline!i+1: const 2!	  \\
	 1.5   &    $\stack{\counter - 1} + \stack{\counter } *\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}  $\\
	 1.6   &   \lstinline!i+2: load s!	  \\
	 1.7   &   $\stack{\counter - 2}  + \stack{\counter - 1} * \stack{\counter} = \mbox{\rm \lstinline! 5!}  $\\
	 1.8   &     \lstinline!i+3: mul!	          \\
	 1.9   &   $\stack{\counter - 1}  + \stack{\counter} = \mbox{\rm \lstinline! 5!}  $\\
	 1.10  &   \lstinline!i+4: add!	          \\
	 1.11  &   $\stack{\counter} = \mbox{\rm \lstinline! 5 !}  $\\
  \end{tabular}}
\end{frameit}


\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
      2.1   &   $\wpSrcExpr{\lstinline!sqr + 2*s ! }{v = 5}{\excPostExpl}{v} = $ \\
      2.2   &  	$\wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2*s ! }{(v=5)\subst{v}{v_{sqr} + v_{2*s}} }{\excPostExpl}{v_{2*s}}  }{\excPostExpl}{v_{sqr}} = $ \\
      2.3   & 	$\wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2! }{\wpSrcExpr{\lstinline!s! }{(v_{sqr}+v_{2*s}=5)\subst{v_{2*s}}{v_{2}*v_{s}} }{\excPostExpl}{v_{s}}  }{\excPostExpl}{v_{2}} }{\excPostExpl}{v_{sqr}} = $ \\
      2.4   &	$\wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2! }{(v_{sqr} + v_{2}*v_{s}=5 ) \subst{v_{s}}{s} }{\excPostExpl}{v_{2}} }{\excPostExpl}{v_{sqr}} = $ \\
      2.5   &	$\wpSrcExpr{\lstinline!sqr!}{(v_{sqr} + v_{2}*\lstinline!s!=5 ) \subst{v_{2}}{2} }{\excPostExpl}{v_{sqr}} = $ \\
      2.6   &	$(v_{sqr} + 2*\lstinline!s!=5 ) \subst{v_{sqr}}{\lstinline!sqr!  } = $ \\
      2.7   &	$ \lstinline!sqr! + 2*\lstinline!s!=5 $
  \end{tabular}}
\end{frameit}
\caption{\sc Expression, its compilation  and their respective preconditions} \label{pogCompile:wpBc:expression}
\end{figure}

\begin{thm}\label{pogComp:relWpExpr}
     For every expression $\expressionSrc$ and its compilation  $\compileLabel{s}{\expressionSrc}{e}$  let have a 
formula  $\psi$ and expressions $w_1 \ldots w_{k}, k \ge 0 $ such that 
$$\begin{array}{l} 	
        \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \wedge \\
	 \forall \Exc ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\Exc, e )
\end{array} $$
then the following holds 
$$  \wpSrcExpr{\expressionSrc }{\psi}{\excPostExpl}{v} \subst{w_i}{\stack{\counter - i + 1}} _{i = 1 \ldots k} =
	\wpi{s}{\methodd}{} $$
 %  $$ \begin{array}{l} 
 %     \forall \psi,   \forall w_1, \ldots w_{k}, k \ge 0 \\
 %	\psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \wedge \\
 %	 \forall \Exc ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\Exc, e ) \Rightarrow \\\\
 %	 \wpSrcExpr{\expressionSrc }{\psi}{\excPostExpl}{v} \subst{w_i}{\stack{\counter - i + 1}} _{i = 1 \ldots k} =
 %	\wpi{s}{\methodd}{}
 %	
    %  \end{array}
  % $$    
 \end{thm}
Proof: the proof is by structural induction over the expression structure. We sketch 
the cases for field access and arithmetic expressions.


\begin{description}
       \item[field access]
            
	            From the compiler definition we have
                     \begin{equation*}\label{pog1} \tag{\ref{pogComp:relWpExpr}.1}
		       \compileLabel{s}{\fieldAccess{\expressionSrc}{\fieldd}}{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc}{e - 1}; \\ 
			    e  : \getfield  \ \fieldd
			    \end{array}
		     \end{equation*}
		 	
	       By initial hypothesis we have that we have a formula $\psi$ over the source language such that if the abstract variables $w_i$ 
	       which stand for expression values are substituted with stack expressions the formula will be the same as the formula
	      $\inter{e}{e+1} $. Or formally,  for some $k$ such that $k \ge 0$ we have the following equality:      \\
	      \begin{equation*}\label{pog2} \tag{\ref{pogComp:relWpExpr}.2}  
	            \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} 
	      \end{equation*}	    

		  From the definition of the \wpName{} for source field access expressions, we have also   
		   \begin{equation*}\label{pog3} \tag{\ref{pogComp:relWpExpr}.3}  
		   \begin{array}{l} \ \wpSrcExpr{\fieldAccess{\expressionSrc}{\fieldd} }{\psi}{\excPostExpl}{v} = 
		  \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1}  \\
		  where \\ 
		   \psi'  =                   \begin{array}{l} 
		                                 v_1 \neq \Mynull \Rightarrow \psi \subst{v}{\fieldAccess{v_1}{\fieldd}} \\
						 \wedge \\
						 v_1 = \Mynull \Rightarrow  \excPostExpl(\NullPointerExc)
					       \end{array}
				\end{array}  \\
		  \end{equation*}
		 
		  Because the execution relation between $e$ and $e+1 $ is not a loop backedge by Lemma \ref{compile:prop:compProp3}
		  which establishes that compilation of expressions does not contain loop entries and 
		  from the Def. \ref{inter} of the function \interOnly{}:
		  \numConclusion{5} $ \inter{e-1}{e} = \wpi{e}{\methodd}{}$ 
		
		 definition of the \wpName{} function for \getfield{}
		 \begin{equation*}   \wpi{e}{\methodd}{} = \\
		                     \begin{array}{l} \stack{\counter} \neq \Mynull \Rightarrow \inter{e}{e+1} \subst{\stack{\counter}}{\fieldAccess{\stack{\counter}}{\fieldd} } \\
		                      \wedge \\  
				      \stack{\counter}  = \Mynull \Rightarrow \methodd.\getExcPost(\NullPointerExc, e ) \end{array}
		\end{equation*}
		

		From \eqref{pog1}, \eqref{pog2} and  \eqref{pog3} and the above facts for the \wpName{} function over bytecode and source respectively,
		  we  conclude:
		 \begin{equation*}  	\label{pog4} \tag{\ref{pogComp:relWpExpr}.4}
		        \psi' \subst{v_1}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k} 	  = \inter{e-1}{e} 
		\end{equation*}
		
		 
		 For the exceptional postcondition functions on source and bytecode we get from Lemma \ref{compile:prop:compProp9} and the initial hypothesis that 
		
		\begin{equation*}  \label{pog5} \tag{\ref{pogComp:relWpExpr}.5}
		   \forall \Exc ,  \excPostExpl( \Exc ) = \methodd.\getExcPost(\Exc, e - 1)  
		 \end{equation*}
		
		We apply the induction hypothesis over   \eqref{pog4} and \eqref{pog5} and  obtain
		 
		\begin{equation*}   
		      \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1} \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}  = \wpi{}{\methodd}{s}
		\end{equation*}
	
	        Finally,  \eqref{pog3} and the last equality allows us to conclude that this case holds

	   
       		\item[arithmetic expression]
      
	            From the compiler definition we have    
		    \begin{equation*} %\label{pog6} \tag{\ref{pogComp:relWpExpr}.6}
		   \numConclusion{1} \ \compileLabel{s}{\expressionSrc_1 \ \op \ \expressionSrc_2 }{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc_1}{e'}; \\
			   \compileLabel{e' + 1}{\expressionSrc_2}{e - 1}; \\ 
			    e : \op
		     \end{array}	 
		     \end{equation*}
		     
		   
		      As in the previous case, we can conclude that there exists a formula $\psi$ over source expressions with the following property
		   \begin{equation*} \label{pog7} \tag{\ref{pogComp:relWpExpr}.6}  
		         \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1}
		    \end{equation*}
		     
		     We also remind the formulation of the \wpName{} function for source arithmetic expressions
		     
		     \begin{equation*} %\label{pog8} \tag{\ref{pogComp:relWpExpr}.8}  
		     \begin{array}{l} 
		       \wpSrcExpr{ \expressionSrc_1 \ \op \ \expressionSrc_2 }{\psi }{ \excPostSrc }{v}  =   
		     
		     \wpSrcExpr{ \expressionSrc_1  }{\wpSrcExpr{\expressionSrc_2 }{\psi'     }{ \excPostSrc }{v_2}  }{ \excPostSrc }{v_1}  
		      \\
		     \mbox{\rm with} \ \psi' = \psi \subst{v}{v_1 op v_2} \end{array}
		     \end{equation*}

		      It follows from Lemma \ref{compile:prop:compProp3} about expressions that the compilation 
		     of an expression results in a list of instructions which does not contain loop entries. 
		      Thus, from the Def.\ref{inter} of the function \interOnly{} we get
		     	 
		        \begin{equation*}   \inter{e -1}{e} = \wpi{e}{\methodd}{} \end{equation*}
		   
		     It follows from the \wpName{} for an arithmetic instruction
		    \begin{equation*}  \wpi{e}{\methodd}{} =
     \inter{e}{e+1}\subst{\counter}{\counter -1 } \subst{\stack{\counter - 1}}{\stack{\counter -1 } \ \op \ \stack{\counter} } \end{equation*} 
		    which because of \eqref{pog7} is equal to
		    \begin{equation*} 
		     \psi \subst{v}{\stack{\counter}}
                          \subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k} \subst{\counter}{\counter -1 } \subst{\stack{\counter - 1}}{\stack{\counter -1 } \ \op \ \stack{\counter} } \end{equation*}

		     Because the formula $\psi$ refers to  source expressions and does not contain stack expressions  
		     we can conclude by applying substitutions 
		      \begin{equation*} 		  
		            \psi \subst{v}{\stack{\counter  - 1 } \op \stack{\counter} }\subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k} 
		       \end{equation*}
		       which is equal to 
		       \begin{equation*} \psi'
		          \subst{v_2}{\stack{\counter} } 
		          \subst{v_1}{\stack{\counter -1} }
			  \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}
			\end{equation*}
			  
			  From the last equalities  we can apply 
			  the induction hypothesis over $\expressionSrc_2$ and  $\psi'$ and  get
			   \begin{equation*} \label{pog9} \tag{\ref{pogComp:relWpExpr}.7}
			       \wpSrcExpr{\expressionSrc_2 }{\psi'}{ \excPostSrc }{v_2} \subst{v_1 }{\stack{\counter }} \subst{w_i}{\stack{\counter - i + 1}}_{i = 1 \ldots k}  =
			       \wpi{ e'+1}{\methodd}{} 
			   \end{equation*}
			 
			 As it follows from Lemma \ref{compile:prop:compProp3} we have that 
			 $ \inter{e'}{e'+1} = \wpi{ e'+1}{\methodd}{}$ and because of the last result \eqref{pog9}, we can apply the induction  
			 hypothesis over $\expressionSrc_1$, we conclude that this case holds. 
			 
		     			  
		 
			
			  	  

       
\end{description}
\Qed \\




The next lemma states the same property but this time for the compilation of statements.
\begin{thm}\label{relWpStmt}
     Let us have the statement $\stmt$, its compilation $\compileLabel{s}{\stmt}{e}$  in  method \methodd, the formula $\psi$
     and the exceptional   function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that 

      \begin{enumerate}
            \item if $e+1$ exists  then $\psi = \inter{e}{e+1}$
	    \item if $e+1$ does not exist and $\ins{e} = \return$ then $\psi = \methodd. \normalPost$
	    \item $\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) $ 
      \end{enumerate} then the following holds: 
  
     $$   \wpSrcStmt{\stmt}{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}}$$   
\end{thm}

Proof : the proof is  by structural induction on  statements  and uses the properties of the compiler 
        shown before. We give here the proof  for the cases of compositional statement, while and try catch statement.
The rest of the cases proceed in a similar way.


\begin{description}
       \item[compositional statement]
          
	     \begin{equation*} \wpSrcStmt{  \stmt_1 ;  \stmt_2 }{\psi}{\excPostExpl} = 
	     %\comment{by definition of \wpName{} this is  } 
	     \wpSrcStmt{\stmt_1 }{\wpSrcStmt{\stmt_2 }{\psi }{ \excPostSrc}} { \excPostSrc} 
	     \end{equation*}
	     
		From the compiler definition we get
                \begin{equation*} \compileLabel{s}{ \stmt_1 ;  \stmt_2}{e} =
		    %\begin{array}{l}
	                \compileLabel{s}{\stmt_1}{e'};%\\
			\compileLabel{e'+1}{\stmt_2}{e} \end{equation*} 
	            %\end{array}
		  

	       It follows from  the induction hypothesis over $\stmt_2$ and the initial hypothesis about the postcondition 
	       %\mbox{\rm\textit{ \}}} 
	    \begin{equation*}  \label{pog10} \tag{\ref{relWpStmt}.1}    \wpSrcStmt{  \stmt_2 }{   \psi }{\excPostExpl } = \wpi{}{\methodd}{\ins{e'+1}} \end{equation*}  

	       
	       Lemma \ref{compile:prop:compProp1} states that $e$ and $e+1$ are in execution relation
	      Lemma \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$)
	       appear only on loop statement compilation and thus, the edge between  $e'$ and $e' + 1$
	        is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get 
	     \begin{equation*} \label{pog11} \tag{\ref{relWpStmt}.2}  \ \inter{e'}{e'+1} = \wpi{}{\methodd}{\ins{e'+1}}  \end{equation*}

	       The statement $\stmt_1$ is a strict substatement of $\stmt_1;\stmt_2$ and thus, from Property  \ref{compile:prop:compProp8} follows
	         \begin{equation*} \forall  \mbox{\rm\texttt{Exc}}, \methodd.\findExcHandler{\mbox{ \rm \texttt{Exc}}  }{e}{\methodd.\excHandlerTable} = 
		                                 \methodd.\findExcHandler{\mbox{ \rm \texttt{Exc}}  }{e'}{\methodd.\excHandlerTable}   \end{equation*}
	       
                From the above conclusion and the Def. \ref{defExc}  of function \getExcPost
                \begin{equation*} \label{pog12}    \tag{\ref{relWpStmt}.3} \               \forall \mbox{\rm\texttt{Exc}}, \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  
                                                                                   \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' )  \end{equation*}
										   
		From   \eqref{pog10},   \eqref{pog11} and \eqref{pog12} we get that 	
		\begin{equation*}
			\wpSrcStmt{  \stmt_1  }{  \wpSrcStmt{  \stmt_2  }{   \psi }{\excPostExpl }    }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}} 
		\end{equation*}
		From this last equality we conclude that this case holds.
		
	
      

  \item[while statement]
Let us remind the definition of the \wpName{} for  while statements
 \begin{equation*} %\label{pog13}    \tag{\ref{relWpStmt}.4}  
 \begin{array}{l}\wpSrcStmt{ \while \ (\expressionSrc_1 \ \rel \ \expressionSrc_2 ) \ \lbrack \invariant, \modLoop \rbrack \  \do \ \{ \stmt \}}{ \normalPostSrc}{\excPostSrc}=\\
    \invariant \ \wedge\\
	       \forall \  m, m \in \modLoop , \\
	       \invariant \Rightarrow %\\
	 	     %\Myspace    \Myspace 
		     \wpSrcExpr{\expressionSrc_1}{
                     \wpSrcExpr{\expressionSrc_2}{  \mbox{\rm\textsf{P}} 		     
	       }{\excPostSrc } {v_2}}{\excPostSrc}{v_1}      %\end{array}
     \\ \\
 where \\
%\begin{array}{l}
\mbox{\rm\textsf{P}} =   		
		           ( v_1 \rel v_2 )        \Rightarrow \  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc} \\ 
                           \wedge\\  
		          \neg (v_1 \rel v_2)    \Rightarrow  \normalPostSrc
		     \end{array}
\end{equation*}
    
   
We remind that the compilation of the while statement results as follows 
\begin{equation*} %\label{pog14}    \tag{\ref{relWpStmt}.5} 
       \begin{array}{l} \compileLabel{s}{\while \ (\expressionSrc_1 \ \rel  \ \expressionSrc_2) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} }{e} = \\
	       s: \goto \ e' + 1; \\
	       \compileLabel{s +  1}{\stmt}{e' }; \\
	       \compileLabel{e' +  1}{\expressionSrc_1}{e''};\\
	       \compileLabel{e'' +  1}{\expressionSrc_2}{e-1};\\
	       e : \ifCond \ s +  1; \\
	       %e: \nop
	       \\\\
	       \addLoopTable{\methodd}{e'+1}{\invariant }{\modLoop} \end{array}
 \end{equation*}

From Lemma \ref{compile:prop:compProp4} we know that the execution relation between $e'$ and $e'+1$ is a loop execution relation. From Def. \ref{inter}, \pageref{inter} 
     of the function \interOnly{} we conclude that  

\begin{equation*} \label{pog15}    \tag{\ref{relWpStmt}.4}  \
               \inter{e'}{e'+1} = \invariant \end{equation*}

From Lemma \ref{compile:prop:compProp8} we get that the exception handlers for the last index $e'$ in the compilation of $\stmt$ and the index $e$ are the same.
Thus, from the initial hypothesis for the exception handler function, we conclude that  
\begin{equation*} \label{pog16}    \tag{\ref{relWpStmt}.5}  
 \forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' )  \end{equation*}

We can apply the  induction hypothesis over \eqref{pog15} and \eqref{pog16}   and  statement $\stmt$ and we get 
\begin{equation*} \label{pog17}    \tag{\ref{relWpStmt}.6}   \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc} =  \wpi{}{\methodd}{\ins{s+1}} \end{equation*}

From Lemma \ref{compile:prop:compProp4} we get that the execution relation between $e$ and $s+1$ is not a loop execution relation. From def. \ref{inter}, 
we  conclude that  $  \wpi{}{\methodd}{\ins{s+1}}  = \inter{e}{s+1} $.
Thus, from \eqref{pog17}  and the definition of the \wpName{} function for \ifCond{}, we conclude that the \wpName{} of the instruction at index $e$ 
  is equivalent to 
   \begin{equation*}\begin{array}{l}  \wpi{}{\methodd}{e} = \\
                   \stack{\counter} \ \rel \ \stack{\counter - 1}  \Rightarrow  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc}\\
			 \wedge  \\
		  \neg ( \stack{\counter} \ \rel \ \stack{\counter - 1} )  \Rightarrow \inter{e}{e+1}
         \end{array} 
   \end{equation*}

Using  the latter,  the previous Lemma \ref{pogComp:relWpExpr} for expressions  is applied twice  over $\expressionSrc_1$ and $\expressionSrc_2$ and thus, we obtain

    \begin{equation*} \begin{array}{l}  \wpSrcExpr{\expressionSrc_1}{
                     \wpSrcExpr{\expressionSrc_2}{   %\\\phantom{wp^{src}} 
		     \begin{array}{l}  		
		           ( v_1 \rel v_2 )        \Rightarrow \  \wpSrcStmt{ \stmt }{\invariant} {\excPostSrc} \\
                           \wedge  \\
		           \neg (v_1 \rel v_2)    \Rightarrow  \normalPostSrc
		     \end{array}
	       }{\excPostSrc } {v_2}} { %\\ \phantom{\invariant \Rightarrow wpiSr\expressionSrc_1}
	      \excPostSrc}{v_1} = \\ \wpi{}{\methodd}{e'+1} \end{array} 
\end{equation*}

From Lemma \ref{compile:prop:compProp4}, we  get that $e'+1$ is a loop entry instruction. From Def. \ref{inter} of the function \interOnly, we get that 
 \begin{equation*} \begin{array}{l}  \wpi{}{\methodd}{s} =  \inter{s}{e'+1} = \\
                \invariant \ \wedge 
	       \forall \  m, m \in \modLoop ,
          (\invariant \Rightarrow   \wpi{ }{ \methodd }{e'+1} ) \end{array} \end{equation*}

From the last results, we obtain that this case holds.



  \item[try catch statement] 
	   Let us remind the definition of the weakest precondition predicate transformer for try catch statement % \numConclusion{1} \
	   \begin{equation*} \label{pog18}    \tag{\ref{relWpStmt}.7}  
                             \begin{array}{l} \wpSrcStmt{    \try \ \{ \stmt_1 \} 
		                                              \catch \ (\excType \ \var )\{ \stmt_2 \} 
                                                }{\psi}{\excPostExpl} =\\ 
			% $$
			% \comment{by the definition of $\wpNameStmt$} 
	                % $$    
	    \wpSrcStmt{\stmt_1 }{  \psi} {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\stmt_2 }{\psi}{\excPostExpl }} }  
	    \end{array}            
\end{equation*}
	    
	        
              Also, by definition of the compiler function, we have that the compilation of try catch statement results in the following
              list of instructions % \numConclusion{2} \ 
	      \begin{equation*}	 \begin{array}{l}  \compileLabel{s}{ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \} }{e} = \\
                      \compileLabel{s}{\stmt_1}{e'};   e' + 1: \goto \ e;  \compileLabel{e' + 2 }{\stmt_2}{e - 1}; e: \nop\\
		                           
			\addExceptionTable{\methodd}{ s }{ e'  }{ e' + 2 }{\excType}  \end{array} 
              \end{equation*}

              We apply the induction hypothesis over $\stmt_2$ and the initial hypothesis 
	      %\numConclusion{3} 
               \begin{equation*}  \wpSrcStmt{\stmt_2}{\psi}{\excPostExpl} = \wpi{e'+2}{\methodd}{} \end{equation*}
	       From Lemma \ref{compile:prop:compProp10},  we know that the indexes $e$ and $e'$ has the same exception handlers~
	       \begin{equation*} 
                      \begin{array}{l} \forall \mbox{\rm{\texttt{Exc}}},  \neg ( \mbox{\rm{\texttt{Exc}}} <: \excType ) \Rightarrow\\
	                 \left(\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} = 
		         \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} \right) 
		         \wedge\\
		         \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e'+2
                      \end{array}  
	        \end{equation*} 
	      
	      From the definition of \getExcPost{} and  the initial hypothesis about the exceptional 
	       postcondition functions for indexes $e$ and $e'$
	       %\numConclusion{4}
             \begin{equation*}  \label{pog19}    \tag{\ref{relWpStmt}.8} \forall \mbox{\rm\texttt{Exc}} ,  \update{\excPostExpl}{\excType}{ \wpi{e'+2}{\methodd}{} }(\mbox{\rm\texttt{Exc}}) = 
                  \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' ) \end{equation*}
	       Lemma   \ref{compile:prop:compProp4} tells us that there are no loop edges between $e'$ and $e'+1$, $e'+1$ and $e$,
	       $e$ and $e+1$. Thus, we can conclude from the definition of the function \interOnly{} that   
	    % \numConclusion{5}
             \begin{equation*}   \inter{e'}{e' + 1} = \inter{e'+1 }{e} = \inter{e}{e+1}   \end{equation*}
	      We apply  induction hypothesis over  the last conclusion 
	      and \eqref{pog18}, \eqref{pog19}, we get that this case holds.    
	      %\begin{equation*}  \wpSrcStmt{\stmt_1 }
               %          {  \psi}
		%	 {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} } =
			%  \wpi{s}{\methodd}{}  \end{equation*}
	      
	   
\end{description}
\Qed \\

As a conclusion of the current chapter, we would like to make several remarks. 
Such an equivalence between proof obligations on source and bytecode and the fact that
we have proof for the soundness of the bytecode verification condition generator
 gives us the soundness of the source  weakest precondition calculus:  
\begin{thm}[Soundness of bytecode \wpName{} implies soundness of source \wpName{}]\label{wpEq:bc2src}
If the weakest precondition over bytecode programs is sound  
then the weakest precondition over source programs is sound.
\end{thm}
Another point is that here we ignore the difference between names and types on  source and bytecode level. 
In this chapter, we have considered that the compiler  does not change  variable, class and method  names.
 This is not true for Java compilers, as these names are basically compiled into 
indexes in the constant pool table. The second point in the formalization presented here is that the compilers compiles boolean types into integer types. 
This neither holds for real Java compiler. However, this difference is a minor detail and this means that 
the equivalence between source and bytecode verification conditions in Java can be established modulo names. 

