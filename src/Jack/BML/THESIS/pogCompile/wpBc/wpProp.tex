\newtheorem{thm}{Theorem}[section]


%\newtheorem{wpBlock}[wpIns]{Lemma}
%\newtheorem{relWpExpr}[wpIns]{Lemma}
%\newtheorem{relWpStmt}[wpIns]{Lemma}

%\subsection{Properties of the \wpName \ functions}\label{pog:wpBcProp}
    
We shall first establish a relation between the \wpName{} predicate transformer functions
on bytecode and source level. 
\begin{thm}\label{relWpStmt}
     For every expression $\expressionSrc$ and its compilation  $\compileLabel{s}{\expressionSrc}{e}$, the following holds :

  $$ \begin{array}{l} 
      \forall \psi,   \forall w_1, \ldots w_{k}, k \ge 0 \\
	\psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \wedge \\
	 \forall \Exc ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\Exc, e ) \Rightarrow \\\\
	 \wpSrcExpr{\expressionSrc }{\psi}{\excPostExpl}{v} \subst{w_i}{\stack{\counter - i + 1}} _{i = 1 \ldots k} =
	\wpi{s}{\methodd}{}
	
     \end{array}
  $$    
 \end{thm}
Proof: the proof is by structural induction over the expression structure. We sketch 
the cases for field access and arithmetic expressions.


\begin{description}
       \item[field access]
            $$\begin{array}{l}
	             \comment{from the compiler definition we have} \\
		    \numConclusion{1} \ \compileLabel{s}{\fieldAccess{\expressionSrc}{\fieldd}}{e} = \\
		     \begin{array}{l}
			   \compileLabel{s}{\expressionSrc}{e - 1}; \\ 
			    e : \getfield  \ \fieldd
		     \end{array}	\\ \\ 
		     
		     
		     
		  \comment{by initial hypothesis we have that we have a formula $\psi$ such that }       \\
		  \numConclusion{2} \  \psi \subst{v}{\stack{\counter}}\subst{w_i}{\stack{\counter - i}}_{i = 1 \ldots k}  = \inter{e}{e+1} \\

		  \comment{from the definition of the \wpName{} for source field access expressions} \\ 
		  \numConclusion{3} \ \wpSrcExpr{\fieldAccess{\expressionSrc}{\fieldd} }{\psi}{\excPostExpl}{v} = 
		  \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1}  \\
		  where \\
		  \numConclusion{4} \ \psi'  =                   \begin{array}{l} 
		                                 v_1 \neq \Mynull \Rightarrow \psi \subst{v}{\fieldAccess{v_1}{\fieldd}} \\
						 \wedge \\
						 v_1 = \Mynull \Rightarrow  \excPostExpl(\NullPointerExc)
					       \end{array} \\
		
		  \mbox{\rm\textit{\{because the execution relation between $e$ and $e+1 $ is not a loop backedge by Lemma \ref{compile:prop:compProp3} which}} \\
		  \mbox{\rm\textit{ establishes that compilation of expressions does not contain loop entries and }}\\
		  \mbox{\rm\textit{from the Def. \ref{inter} of the function \interOnly \}}} \\
		  \numConclusion{5} \  \inter{e-1}{e} = \wpi{e}{\methodd}{} \\
		 
		 \comment{definition of the \wpName{} function for \getfield } \\
		 \numConclusion{6} \  \wpi{e}{\methodd}{} = \\
		                      \stack{\counter} \neq \Mynull \Rightarrow \inter{e}{e+1} \subst{\stack{\counter}}{\fieldAccess{\stack{\counter}}{\fieldd} } \\
		                      \wedge \\  
				      \stack{\counter}  = \Mynull \Rightarrow \methodd.\getExcPost(\NullPointerExc, e ) \\
		
		\comment{from \numConclusion{4}, \numConclusion{5} and \numConclusion{6}  } \\
		\numConclusion{7} \ 	\psi' \subst{\stack{\counter}}{v_1} 	  = \inter{e-1}{e} \\ 	      
		
		
		\mbox{\rm\textit{\{from Lemma \ref{compile:prop:compProp9} and the initial}}\\
		\mbox{\rm\textit{ hypothesis about exceptional postcondition functions on source and bytecode get\}}} \\
		
		\numConclusion{8}  \ \forall \Exc ,  \excPostExpl( \Exc ) = \methodd.\getExcPost(\Exc, e - 1) \Rightarrow \\\\
		
		\comment{we apply the induction hypothesis over \numConclusion{7}  and  \numConclusion{8} and we set k = 0 } \\
		
		\numConclusion{9}  \ \wpSrcExpr{\expressionSrc}{\psi'}{\excPostExpl }{v_1} = \wpi{}{\methodd}{s}\\
	
	        \comment{from	\numConclusion{3}, \numConclusion{4} and 	\numConclusion{9} this case holds     }		     		
	     \end{array}
	   $$
       \item[arithmetic expression]
\end{description}





The next lemma states the same property but this time for the compilation of statements.
\begin{thm}\label{relWpStmt}
     For every compiled statement $\compileLabel{s}{\stmt}{e}$  in  method \methodd, formula $\psi$ and 
    function $\excPostExpl : \mbox{ \rm \texttt{ExcType}}  \rightarrow \formulaBc $ such that 

      \begin{itemize}
            \item if $e+1$ exists  then $\psi = \inter{e}{e+1}$
	    \item if $e+1$ does not exist and $\ins{e} = \return$ then $\psi = \methodd. \normalPost$
	    \item $\forall \mbox{\rm\texttt{Exc}} ,  \excPostExpl( \mbox{\rm\texttt{Exc}} ) = \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) $ 
      \end{itemize} then the following holds: 
  
     $$   \wpSrcStmt{\stmt}{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{s}}$$   
\end{thm}

Proof : the proof is  by structural induction on the compilation of a statement and uses the properties of the compiler 
        shown before. We scatch here the proof of few cases 


\begin{description}
       \item[compositional statement]
          $$\begin{array}{l}
	     \wpSrcStmt{  \stmt_1 ;  \stmt_2 }{\psi}{\excPostExpl} = \\
	     \comment{definition of \wpName } \\
	     \wpSrcStmt{\stmt_1 }{\wpSrcStmt{\stmt_2 }{\psi }{ \excPostSrc}} { \excPostSrc} \\\\
	     
		\comment{definition of the compiler} \\
                 \compileLabel{s}{ \stmt_1 ;  \stmt_2}{e} =
		    \begin{array}{l}
	                \compileLabel{s}{\stmt_1}{e'};\\
			\compileLabel{e'+1}{\stmt_2}{e}
	            \end{array}\\
	      \\\\

	       \mbox{\rm\textit{\{it follows from  the induction hypothesis }}\\
	       \mbox{\rm\textit{over $\stmt_2$ and the initial hypothesis about the postcondition\}}} \\
	       \numConclusion{1} \    \wpSrcStmt{  \stmt_2 }{   \psi }{\excPostExpl } = \wpi{}{\methodd}{\ins{e'+1}} \\\\

	       \mbox{\rm\textit{\{
	       Lemma \ref{compile:prop:compProp1} states that $e$ and $e+1$ can be executed sequentially.}}\\
	      \mbox{\rm\textit{ Lemma \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$) }} \\
	       \mbox{\rm\textit{  appear only on loop statement compilation and thus, the edge between  $e'$ and $e' + 1$}}\\
	       \mbox{\rm\textit{ is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get \}  }} \\
	       \inter{e'}{e'+1} = \wpi{}{\methodd}{\ins{e'+1}}  \\\\

	       \comment{$\stmt_1$ is a strict substatement of $\stmt_1;\stmt_2$ and thus, from Property  \ref{compile:prop:compProp8}  }  \\
                               
                \numConclusion{2} \               \forall \mbox{\rm\texttt{Exc}}, \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  
                                                                                   \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e'' )  \\\\
										   
		\comment{from   \numConclusion{1} and   \numConclusion{2}  we get that }	\\							   
		\wpSrcStmt{  \stmt_1  }{  \wpSrcStmt{  \stmt_2  }{   \psi }{\excPostExpl }    }{\excPostExpl} = 
			\wpi{}{\methodd}{\ins{s}}\\
			\comment{and this case holds }
		
	\end{array}$$
      \item[if statement] 
           
      $$\begin{array}{l}
	\numConclusion{1} \     \wpSrcStmt{   \Myif \ (\expressionSrc_1 \ \rel \ \expressionSrc_2 ) 
                                                               \Mythen \ \{ \stmt_1 \}   
							       \Myelse \ \{ \stmt_2 \}  }{\psi}{\excPostExpl} = \\
							       
	%\begin{array}{l} 
	 \wpSrcExpr{ \expressionSrc_1 }{ \\
	              \phantom{wpiSr} \wpSrcExpr{ \expressionSrc_2 }{
		         \begin{array}{l}  
		            v_1 \rel v_2  \Rightarrow \wpSrcStmt{\stmt_1 }{\normalPostSrc }{ \excPostSrc } \\
			    \wedge \\
			    v_1 \rel v_2   \Rightarrow \wpSrcStmt{\stmt_2 }{\normalPostSrc }{ \excPostSrc } \\
	               \end{array}
		       }{  \excPostSrc }{v_2} 
	 } {\\  \phantom{wpiSr}  \excPostSrc }{v_1} \\\\
     %\end{array}  
			\comment{definition of the compiler} \\\\
	\numConclusion{2} \  
	\compileLabel{s}{\Myif \ (\expressionSrc_1 \ \rel \ \expressionSrc_2 ) 
                         \Mythen \ \{ \stmt_1 \}   
			 \Myelse \ \{ \stmt_2 \} }{e} = \\
	\compileLabel{s}{\expressionSrc_1}{e'}; \\
	\compileLabel{e'+1}{\expressionSrc_2}{e''}; \\
        e'' + 1: \ifCond \ e''' + 2;\\
        \compileLabel{e'' + 2}{\stmt_2}{e'''}\\
        e''' + 1: \goto \ e +  1; \\
        \compileLabel{e''' +  2}{\stmt_1}{ e  }; \\\\


	\comment{apply the induction hypothesis over $\stmt_1$ and the initial hypothesis } \\
	\numConclusion{3} \ 	\wpSrcStmt{\stmt_1}{\psi }{\excPostExpl} = \wpi{}{\methodd}{\ins{e''' + 2}} \\\\
	
			
	\mbox{\comment{\rm by initial hypothesis, we have   } }\\
	\numConclusion{4} \ \psi = \inter{e}{e+1}  \\ 
	\mbox{\rm\textit{\{ by the compiler definition $ \ins{e''' + 1} = \goto \ e +  1; $  and thus}} \\
	\mbox{\rm{\textit{  $e'' + 1$ is in execution relation with $e + 1$ \}} }}\\
	\numConclusion{5} \ \ins{e''' + 1} \execRel \ins{e + 1} \\
				
				
                               	
	\mbox{\rm\textit{\{ from Property \ref{compile:prop:compProp5} which states that every instruction inside }} \\
	\mbox{\rm\textit{the compilation of $\compileLabel{s}{\stmt}{e}$ , }} \\
        \mbox{\rm\textit{is in the same execution relation with $\ins{e+1}$, }} \\
	\mbox{\rm\textit{    Def. \ref{inter} for the function \interOnly, \numConclusion{4} and \numConclusion{5}   we conclude that \} } }\\
	\numConclusion{6}  \   \inter{e}{e+1} = \inter{e''' + 1}{e+1}  = \psi\\
	\mbox{\rm\textit{\{Property \ref{compile:prop:compProp4} states that loop edges ($\execRel^{l}$) }} \\
        \mbox{\rm\textit{  appears only on loop statement compilation and thus, the edge between  $e''$ and $e'' + 1$}}\\
	\mbox{\rm\textit{ is not a loop edge. In that case from Def. \ref{inter}  of the function \interOnly{} we get \}  }} \\
	\numConclusion{7} \ \inter{e'''}{e''' +1} = \wpi{e''' + 1}{m}{} \\
	\mbox{\rm \comment{ From the definition of the \wpName  \ for \goto \ instructions and \numConclusion{7}  }}\\
	\numConclusion{8}  \ \wpi{e''' + 1}{m}{} = \inter{e''' + 1}{e+1} \\
				
	\comment{ From \numConclusion{7}, \numConclusion{6}	and \numConclusion{8}{}}	\\
	\numConclusion{9}	\  \inter{e'''}{e''' +1} = \inter{e}{e+1}	= \psi	\\
								

	\mbox{\rm\comment{From Property  \ref{compile:prop:compProp8}  } } \\
\end{array}$$
$$ \begin{array}{l}
      \numConclusion{10} \forall \mbox{\rm\texttt{Exc}}, \ \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e ) =  
      \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e'' )  \\
      \mbox{\rm\comment{apply the induction hypothesis over \numConclusion{9} and  \numConclusion{10}  } }\\ 
      
      \numConclusion{11} \	\wpSrcStmt{\compileLabel{e' + 2}{\stmt_2}{e''} }{\psi}{\excPostExpl} = \wpi{e'+2}{m}{} \\

      \comment{ apply the induction hypothesis over the initial hypothesis  }\\
      \numConclusion{12} \ \wpSrcStmt{\stmt_1}{\psi}{\excPostExpl} = \wpi{e'''+2}{m}{} \\\\

			

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
      \comment{\mbox{\rm\textit{\{ from Property \ref{compile:prop:compProp4}  follows that the execution relation between $e''$ }}}\\
      \comment{\mbox{\rm\textit{and  $e'' + 1$ is not a loop edge. From Def. \ref{inter} for the function \interOnly{} we get   \}}}}\\
      \inter{e''}{e'' + 1} = \wpi{ e'' + 1 }{m}{ } \\

      \comment{by definition of conditional jump instruction follows} \\
      \wpi{ e'' + 1 }{m}{ } = \\
      \stack{\counter} \ \rel \ \stack{\counter - 1 }  \Rightarrow \wpi{e'''+2}{m}{} \\
      \wedge \\
      \neg  ( \stack{\counter} \ \rel \ \stack{\counter - 1 } ) \Rightarrow \wpi{e''+2}{m}{} \\\\



      
      
					  \comment{and this case holds}
	    \end{array}$$
	  
  \item[try catch statement] 
        $$
	  \begin{array}{l}
	    \numConclusion{1} \    \wpSrcStmt{    \try \ \{ \stmt_1 \} 
		                                              \catch \ (\excType \ \var )\{ \stmt_2 \} 
                                                }{\psi}{\excPostExpl} =  \\
			\comment{Def. of $\wpNameStmt$ for statements } \\
	        \wpSrcStmt{\stmt_1
	
                           }
                         { 
	                 \psi}
			 {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\stmt_2 }{\psi}{\excPostExpl }} } \\
			  
              \comment{apply the induction hypothesis over $\stmt_2$ and the initial hypothesis} \\
	      \numConclusion{2} \   \wpSrcStmt{\stmt_2}{\psi}{\excPostExpl} = \wpi{e'+2}{\methodd}{} \\ 
	      \comment{from the definition of \getExcPost \ and property \ref{compile:prop:compProp10}} \\
	      \numConclusion{3} \ \forall \mbox{\rm\texttt{Exc}} ,  \update{\excPostExpl}{\excType}{ \wpi{e'+2}{\methodd}{} } = \\ 
              \phantom{\forall \mbox{\rm\texttt{Exc}} ,}     \methodd.\getExcPost(\mbox{\rm\texttt{Exc}}, e' )\\
	      \comment{we can also conclude from Prop.  \ref{compile:prop:compProp5} and  \ref{compile:prop:compProp4}  } \\
	      \numConclusion{4} \ \inter{e'}{e' + 1} = \inter{e'+1 }{e + 1} = \inter{e}{e+1} \\
	      \comment{apply  induction hypothesis over  \numConclusion{1}, \numConclusion{3} and  \numConclusion{4}    } \\
	       \wpSrcStmt{
	                 \stmt_1;
	
                           }
                         {  \psi}
			 {  \update{\excPostExpl}{\excType}{ \wpSrcStmt{\compileLabel{e'+2}{\stmt_2}{e} }{\psi}{\excPostExpl }} } =\\
			  \wpi{s}{\methodd}{}
	      
	   \end{array}
	$$
\end{description}
\Qed \\
