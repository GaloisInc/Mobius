

\subsection{Compiling source program  constructs in bytecode instructions} \label{pogEq:compile:compExpr} 

 The compiler is defined inductively over the structure of the source constructs. 
 In the following, we shall focus only on the compiler cases which we consider 
 interesting or particular and we will assume that the rest of the cases are evident 
 from the compiler definition.

 Fig. \ref{pogEq:compile:compExpr:defExpr} shows the compilation scheme for expressions.
 Let us look in more detail the compilation of  the instance creation expression
 $\newSrc \ \class  (\expressionSrc )$.
 This case is not trivial because of the way the new instance is initialized.
 The first instruction in the compilation is the instruction $s : \new \ \class$ which 
 creates a new reference in the heap and pushes it on the stack top 
 (see for the operational semantics of the instruction in Section \ref{opSem}). 
 Once the new instance is created the instructor must be invoked in order to initialize
 its (instance) fields. This is done by first duplicating the reference (instruction \dup) and then invoking the constructor \Constructor{\class}
 of \class{} by passing it as argument the duplicated reference. 
 This has as effect that after the invokation of the constructor the stack top contains 
 the reference to the newly created instance which is
 now initialized. Note that this compilation follows closely 
 the JVM specification (see \cite[\S 7.8]{VMSpec}) which mandates 
 how standard Java compilers must compile instance creation expressions.  
  
% As the target language is interpreted by a stack based virtual machine,
%the evaluation of  expressions is stored on the stack.
%Thus, for every compilation we give how the compiled
%subexpressions affect the stack. The stack counter is denoted with \counter and the element at position \texttt{k} 
%from the stack top is denoted with $\stack{\counter - k}$ 
%and so for expressions the compiler function is denoted with $$ \compileExp{ \expression }{\stack{ind}}$$
%which means that after evaluating expression  $\expression$, its evaluation $ \compile{ \eval{\expression}}$
% is stored at index $\stack{ind}$ on the stack.


\begin{figure}[ht!]
\begin{frameit}
$${\scriptsize 
        \begin{array}{lll} 
	\compileLabel{s}{\constantInt}{s} &  =  & s : \push \  \constantInt \\
	& & \\ & & \\
%	\compileLabel{s}{\Mytrue}{s} & = &  s: \push  \ \Mytrue \\
%	& & \\ & & \\
%	\compileLabel{s}{\Myfalse}{s} & = &  s: \push \  \Myfalse \\
%	& & \\ & & \\
	\compileLabel{s}{\Mynull }{s } & = &  s: \push \ \Mynull\\
	& & \\ & & \\
	\compileLabel{s}{\this}{s } & = &  s:  \load \ \this \\
	& & \\ & & \\ 
	\compileLabel{s}{ \expressionSrc.f}{e} & = &    
         \begin{array}{l}
              \compileLabel{s}{\expressionSrc}{e - 1}; \\ 
              e : \getfield  \ f
           \end{array} \\
	& & \\ & & \\ 
	\compileLabel{s}{\expressionSrc.m( )}{e} & = &  
	   \begin{array}{l}  
                 \compileLabel{s}{\expressionSrc}{e - 1};\\
		  e  :\invoke \ m
            \end{array}  \\
	& & \\ & & \\
	\compileLabel{s}{ \var }{s} & = &   s: \load \ \var \\
	& & \\ & & \\
	\compileLabel{s}{ \expressionSrc_1 \ op \ \expressionSrc_2 }{e} & = &  
                 \begin{array}{l}
                       \compileLabel{s}{ \expressionSrc_1}{  e'  } ; \\
                       \compileLabel{e' + 1}{ \expressionSrc_2}{ e - 1  }; \\
                       e:\arithOp
                 \end{array}  \\
	& & \\ & & \\
	\compileLabel{s}{ (\class ) \ \expressionSrc }{e} & = &  
              \begin{array}{l}  
                 \compileLabel{s}{\expressionSrc}{e  - 1};\\
                  e : \checkcast \ \class ;
              \end{array}	 \\
	& & \\ & & \\ 

	% \compileLabel{s}{\expressionSrc \ \instanceofSrc \ \class }{e} & = &  
        %  \begin{array}{l}
       %        \compileLabel{s}{\expressionSrc}{ e  -1 };\\
       %         e : \instanceof \ \class;
% 	  \end{array} \\
% 	  & & \\ & & \\ 
\compileLabel{s}{ \newSrc \ \class  ( ) }{s+2} & = & 
                 \begin{array}{l}
                       s :    \new \ \class; \\ 
		       s + 1: \dup; \\
		       s + 2 : \invoke \ \Constructor{\class};     
	       \end{array}

	\end{array} 
} $$

\caption{\sc Definition of the compiler for expressions }
\label{pogEq:compile:compExpr:defExpr}
\end{frameit}
\end{figure}

Fig. \ref{pogEq:compile:compExpr:defStmt} presents the definition 
of the compiler function for statements which does not affect the exception handler table 
neither affect the specification tables.
Let us explain in more detail the rule for 
conditional statement. First the conditional expression is compiled. Its compilation comprises 
instructions from index $s$ to $e''+1$ 
where the latter is the  conditional branch instruction $e'' + 1: \ifCond \ e''' + 2$. Remind that the \ifCond \ 
instruction will compare the two stack top elements  (w.r.t. some condition ) and if they fulfill the condition
in question, the control will be transfered to instruction at index $ e''' +2 $, otherwise the next instruction
at index $e'' + 2$ will be executed. Note that at index $ e'''+2$ starts the compilation of the then branch 
$\compileLabel{e''' +  2}{\stmt_1}{ e  }$ and at index $ e''+2$ starts the compilation of the else branch 
$\compileLabel{e'' + 2}{\stmt_2)}{e'''}$. After the compilation of the else branch follows a $ e'' + 1: \goto \ e + 1$ \ instruction
which jumps at the first instruction  outside the compilation of the branch statement. 

\begin{figure}[ht!]
\begin{frameit}
$${\scriptsize 
        \begin{array}{lll}
	      \compileLabel{s}{\stmt_1; \stmt_2}{e} &  = & 
	      \begin{array}{l}
	            \compileLabel{s}{\stmt_1}{e'}\\
	    	    \compileLabel{e'+1}{\stmt_2}{e}\\
		    %e : \nop
	      \end{array}  \\
       & & \\  & & \\
       \compileLabel{s}{ \Myif \ ( \expressionSrc_1 \rel \expressionSrc_2 ) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   }{e}   & = &
	      \begin{array}{l}
	            \compileLabel{s}{\expressionSrc_1}{e'}; \\
		    \compileLabel{e'+1}{\expressionSrc_2}{e''}; \\
		    e'' + 1: \ifCond \ e''' + 2;\\
		    \compileLabel{e'' + 2}{\stmt_2}{e'''}\\
		    e''' + 1: \goto \ e; \\
		    \compileLabel{e''' +  2}{\stmt_1}{ e -1  }; \\
		    e: \nop
	      %e: \goto   e + 1        
	      \end{array}  \\ 
	  & & \\  & & \\
	\compileLabel{s}{\var = \expressionSrc}{e} & = & 
             \begin{array}{l}
                   \compileLabel{s}{\expressionSrc}{e - 1}\\
		   e :\store \ \var\\
		   
             \end{array}\\ 
	 & & \\  & & \\
	\compileLabel{s}{\expressionSrc_1.f= \expressionSrc_2}{e} & = &
             \begin{array}{l}
		   \compileLabel{s}{\expressionSrc_1}{e'};\\
		   \compileLabel{e'+1}{\expressionSrc_2}{e - 1 };\\
		   e :\putfield \ \fieldd
		   
             \end{array} \\ 
	& & \\  & & \\
	
	\compileLabel{s}{\athrow \ \expressionSrc}{e} & = &
             \begin{array}{l} 
	           \compileLabel{s}{ \expressionSrc}{e - 1}; \\
	           e: \athrow; 
	     \end{array} \\
	& & \\  & & \\
	\compileLabel{s}{\returnSrc  \  \expressionSrc }{e }  & = &
	     \begin{array}{l} 
	           \compileLabel{s}{ \expressionSrc }{e - 1};\\
		   e : \return
	     \end{array} 

	\end{array} 
} $$

\caption{\sc Definition of the compiler for statements }
\label{pogEq:compile:compExpr:defStmt}
\end{frameit}
\end{figure}

Fig. \ref{pogEq:compile:compExpr:defExc} shows the compiler definition for statements whose compilation will
change the  the exception handler of the current method.
The first such statement  is the try catch statement.
The compiler compiles the normal statement $\stmt_1$ and the exception handler $\stmt_2$.
Note that in the exception handler table of the bytecode representation of method \methodd, a new line is added 
which states that the if one of bytecode instructions from index $s$ to index $e'$  throw a not handled exception of type  \excType{}
control will be transfered to the instruction at index \excType.

 Fig \ref{pogEq:compile:compExpr:defExc} contains also the compilation scheme for a try finally statement.
 Remind that  the semantics of the statement is that however the try statement terminates execution 
 the finally statement must be executed after it and the whole statement terminates execution as the try terminated execution.
 Thus, the compilation of statement $\stmt_1$ is followed by 
 the compilation of statement $\stmt_2$. This should assure that after the normal execution of  $\stmt_1$ $\stmt_2$
 will be executed. However, we have also to guarantee that  $\stmt_2$ will execute after $\stmt_1$ if the latter 
 terminates on exception. For this, we create an exception handler  which protects $\stmt_1$ from any exception thrown.
 The exception handler stores the reference to the thrown object in variable  $l$ then executes the compiled
 finally statement  $\stmt_2$, then loads the exception reference on the stack and re-throws it.
  
 

 This compilation differs from the compilation scheme in the JVM specification for finally statements, which requires that the subroutines must be compiled using \instr{jsr} and 
 \ret \ instructions. However, the semantics of the programs produced by the compiler presented here and a compiler which follows closely the JVM specification 
 is equivalent. 
 In the following, we discuss informally why this is true.
 The semantics of a \jsr \ k instruction is to  jump to the first instruction of the compiled subroutine which starts at index $k$ and pushes on the
 operand stack the index of the next instruction of the \jsr \ that caused the execution of the subroutine. 
 The first instruction of the compilation
 of the subroutine stores the stack top element in the local variable at index $k$ ( i.e. stores in the local variable at index $k$ the
 index of the instruction following the \jsr{} instruction). Thus, after the code of the subroutine is 
 executed, the \ret \ k instruction jumps to 
 the instruction following the corresponding \jsr. This behavior can be actually simulated by programs without \jsr \ and \ret \ but which inline the subroutine code
 at the places where a \jsr \ to the subroutine is done.
 We assume that the local variable $l$ is not used in the compilation of the statement $\stmt_2$, which guarantees that after any execution which 
 terminates normally of $\compileLabel{e'' + 3}{\stmt_2}{e - 2}$ the local variable  $l$ will still hold the thrown object. We also assume that the 
 statement $\stmt_1$ does not contain a \return{} instruction. 




\begin{figure}[ht!]
\begin{frameit}
$${\scriptsize 
        \begin{array}{l}

	\compileLabel{s}{ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \} }{e} = \\
	\begin{array}{l}
             
                       \compileLabel{s}{\stmt_1}{e'}; \\
                       e' + 1: \goto \ e; \\
		  
                       \compileLabel{e' + 2 }{\stmt_2}{e - 1};\\
		       
		        e: \nop
		       \\ 
                    
			\addExceptionTable{\methodd}{ s }{ e'  }{ e' + 2 }{\excType} 
             \end{array} \\ 
	\\ \\  
 	
	\compileLabel{s}{ \try \ \{ \stmt_1 \} \ \finally \ \{ \stmt_2 \} }{e} = \\
       	\begin{array}{l} 
	\compileLabel{s}{\stmt_1}{e'}; \\
	\compileLabel{e'+1}{\stmt_2}{e''}; \\
        e''+1  : \goto \ e ;\\
        
        \\ 
        \{ \mbox{ \rm default exception handler} \} \\
        e'' +  2: \store \ l; \\
	\compileLabel{e'' + 3}{\stmt_2}{e - 3}; \\	                
        e - 2 :\load \ l;\\
        e - 1: \athrow;\\
	e: \nop
        \\
	\addExceptionTable{\methodd}{ s }{  e' }{ e''+2  }{ \Exception } 
        \end{array} \\ 
	\\ \\  
	
		

\end{array} 
} $$

\caption{\sc Definition of the compiler for statements that change the exception handler table}
\label{pogEq:compile:compExpr:defExc}
\end{frameit}
\end{figure}

 We have put separately in Fig.\ref{pogEq:compile:compExpr:defLoop} the compiler definition for loop statements as its compilation is particular
 because it is the unique case where the specification tables of the current method are affected. 
 Particularly, the compiler adds a new element in the table of loop invariants of the method \methodd. 
 This new element relates  the index $e'+1$  with the loop invariant \invariant \  and the
 list of modified expressions \modLoop.
 In the following, the index of the first instruction of the compilation of the loop test
 (in the figure this is the index $e'+1$) will be frequently referred to. 
 Thus, we introduce the notation $\loopStart{\stmt}$ to refer to the first instruction in the compilation of the test
 of the loop statement $\stmt$. Actually, in the control flow graph this instruction represents a loop entry
 instruction following Def. \ref{defLoop}, Section \ref{prelim:ctrFlow}.
 
 
\begin{figure}[ht!]
\begin{frameit}
$${\scriptsize 
        \begin{array}{l}
 \compileLabel{s}{\while \ (\expressionSrc_1 \ \rel  \ \expressionSrc_2) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} }{e} = \\
         \begin{array}{l}
	       s: \goto \ e' + 1; \\
	       \compileLabel{s +  1}{\stmt}{e' }; \\
	       \compileLabel{e' +  1}{\expressionSrc_1}{e''};\\
	       \compileLabel{e'' +  1}{\expressionSrc_2}{e-1};\\
	       e : \ifCond \ s +  1; \\
	       %e: \nop
	       \\\\
	       \addLoopTable{\methodd}{e'+1}{\invariant }{\modLoop}
	 \end{array}

\end{array} 
} $$

\caption{\sc Definition of the compiler for the loop statement}
\label{pogEq:compile:compExpr:defLoop}
\end{frameit}
\end{figure}



For an illustration, we show in Fig. \ref{pogComp:source:example} the source of method \lstinline!square! which calculates the 
the   square of the parameter \lstinline!i!.  First, the absolute value of \lstinline!i! is stored in the variable \lstinline!v!.
Then  the while statement  calculates the sum of the impair positive numbers whose whole division by 2 is smaller than
\lstinline!v! which is the square of \lstinline!i!.  The example is also
provided with specification written in JML. The specification states
that the method returns the square of its parameter and that the loop
invariant is \lstinline!(0 <= s) && (s <= v) && sqr == s*s!. In Fig. \ref{pogEquiv:compile:prop}, we 
then show the respective compilation of method \lstinline!square!.
The example shows the correspondence between  the bytecode (left) resulting from the compilation described above and the source lines(right)
 of method  \lstinline!square! from Fig. \ref{pogComp:source:example}.



\begin{figure}[ht!]
 \begin{lstlisting}[frame=trbl] 
//@ ensures \result == i*i; 
public int square( int i ) {
  int sqr  = 0;
   int v = 0;
   if ( i < 0)
     then {
       v = -i;} 
     else {
       v = i;}
   int s = 0;
   /*@ loop_modifies s, sqr;
     @ loop_invariant (0 <= s) && (s <= v) && sqr == s*s ;
      @*/
   while( s < v ) {
     sqr = sqr + 2*s + 1;
     s = s+1;}
   return sqr;}
 \end{lstlisting}
 \caption{\sc method  \lstinline!square! written in our source language}
 \label{pogComp:source:example}
 \end{figure}


We can see in the figure how the branch statement is compiled (bytecode instructions from 4 to 12).
 It also shows us the somewhat unusual way into which 
the while statement is compiled. More particularly, the compilation of the test of the \lstinline!while! is after its body while semantically the test must be executed 
at every iteration before the loop body.  The compilation is actually correct because the instruction 
\lstinline!15 goto 28! jumps to the compilation of the line \lstinline!while(s<v)! and thus, the execution proceeds in the expected way.
 We have also marked the instructions which correspond to the loop entry and loop end  which are the instructions at index 28 and 27. 
 

Note that the bytecode has been generated by a standard Java compiler. We have modified the compilation of  \lstinline!s = s+1;! to match the definition 
of our compiler\footnote{the Java compiler will tend to compile incrementation into \lstinline!iinc!} and introduced the \nop{} instructions.
 Note also that we keep the same names on bytecode and source. This is done for the sake of simplicity and in this chapter, we shall use always this convention.

 \begin{figure}[ht!]
\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
& \lstinline!int square( int i )!\\
\lstinline!0 const 0!      & \lstinline!int sqr  = 0;! \\
\lstinline!1 store sqr!	   & \\
                           & \\ & \\

\lstinline!2 const 0!      & \lstinline!int v = 0;! \\
\lstinline!3 store v!	   & \\
                           & \\ & \\

\lstinline!4 load i!       & \lstinline!if ( i >= 0)! \\ 
\lstinline!5 ifge 10!	   & \\
 & \\ & \\
\lstinline!6 load i!       & \Myspace \lstinline!else{v =-i;}! \\ 
\lstinline!7 neg!	   & \\
\lstinline!8 store v!	   & \\
                           & \\ & \\
\lstinline!9 goto 12!	   & \\ 

                           & \\ & \\
\lstinline!10 load i!	   &\Myspace \lstinline!then{v = i;}! \\ 
\lstinline!11 store v!	   & \\  
                           & \\ & \\
\lstinline!12 nop!	   & \\  
                           & \\ & \\
\lstinline!13 const 0!	   & \lstinline!int s = 0;! \\
\lstinline!14 store s!	   & \\ 
                           & \\ & \\
\lstinline!15 goto 28!	   & \\ 
	                   & \\ & \\
\lstinline!16 load sqr!      &\Myspace \lstinline!sqr = sqr + 2*s + 1;! \\ 
\lstinline!17 const 2!	   & \\ 
\lstinline!18 load s!	   & \\ 
\lstinline!19 mul!	   & \\        
\lstinline!20 add!	   & \\ 
\lstinline!21 const 1!	   & \\ 
\lstinline!22 add!	   & \\ 
\lstinline!23 store sqr!   & \\ 
                           & \\ & \\

\lstinline!24 load s!      & \Myspace \lstinline!s = s+1;! \\
\lstinline!25 const 1!	   & \\ 
\lstinline!26 add!	   & \\ 
\lstinline!27 store s!	   & \lstinline!LOOP END! \\ 
                           & \\  & \\ 

\lstinline!28 load s!      & \lstinline!LOOP ENTRY!  \lstinline!while( s < v )!\\ 
\lstinline!29 load v!      & \\  
\lstinline!30 if_icmplt 16!& \\  
                           & \\  & \\ 
\lstinline!31 load sqr!      &\lstinline!return sqr;!\\ 
\lstinline!32 return!      &\\
  \end{tabular}

}

  \caption{\sc  relation between bytecode and source code of method \lstinline!square! from Fig. \ref{pogComp:source:example} }
  \label{pogEquiv:compile:prop}
\end{frameit}  
\end{figure}
