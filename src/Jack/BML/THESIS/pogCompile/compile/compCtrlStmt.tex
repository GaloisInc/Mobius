\subsection{Compiling control statements in bytecode instructions}

\begin{itemize}
  \item compositional statement
      $$\compile{\stmt_1; \stmt_2} =  
      \begin{array}{l}
            \compile{\stmt_1};\\
	    \compile{\stmt_2}
       \end{array}$$
    
  \item   if statement
    $$\compile{ \Myif \ (\expressionSrc) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   } = 
        \begin{array}{l}
	    \compileExp{\expressionSrc}{\stack{\counter}}; \\
            \instr{if\_cond} \ l_{true} ;\\
            \compile{\stmt_2)}\\
             \instr{goto} \ l; \\
            l_{true}: \ \compile{\stmt_1)} \\ 
            l:
	\end{array}
    $$

\item assignment statement. We consider two cases - assignement to instance fields and assignemnts to method local variables and parameters. 

\begin{itemize}
    \item field assignement. The expressions of the form \textrm{ f = v}, where \textrm{f} is an instance field of \textrm{this} object
are desugared to \textrm{this.f = v}.
        $$\compile{\expressionSrc_1.f= \expressionSrc_2} =
             \begin{array}{l}
                        \compileExp{\expressionSrc_1}{\stack{\counter -1}};\\
			\compileExp{\expressionSrc_2}{\stack{\counter}};\\
			\instr{putfield} \ f;
             \end{array}
 $$ 

   %    where after the normal execution of the compilation of $\expressionSrc_1$ and $\expressionSrc_2$ the stack increments with 2 elements 
  % and the two top values are as follows: \\
    %    $$\begin{array}{l}
    %            %\counter = \counter + 1 \\
      %          \stack{\counter} = \compile{\eval{ \expressionSrc_2 }} \\
      %          \stack{\counter - 1} = \compile{\eval{ \expressionSrc_1 }} \\
     %      \end{array}
     %   $$
 
    \item method local variable or parameter update
        $$\compile{  \var = \expressionSrc } =   
             \begin{array}{l}
                        \compileExp{\expressionSrc}{  \stack{\counter}  };\\
			\instr{store} \ \locVar{i};
             \end{array}
        $$
%  where the normal execution of the compilation of $\expressionSrc$  affects the stack: \\
 %      $$\begin{array}{l}
%               %\counter = \counter + 1 \\
%               \stack{\counter} = \compile{\eval{ \expressionSrc}} \\
 %              
%          \end{array}
  %     $$
\end{itemize}
  %  If $\expressionSrc$ is of the form $ \expressionSrc_1 \rel \expressionSrc_2$ affects the stack :         
  % 		$$
  % 		  \begin{array}{l} 
  % 		        %\counter = \counter + 2 \\
  % 		        \stack{\counter } = \compile{\eval{ \expressionSrc_1 }} \\
  % 			 \stack{\counter -1} = \compile{\eval{ \expressionSrc_2 }}
  % 		 \end{array}
  % 	      $$
   %   Otherwise, if $\expressionSrc$ is a boolean variable or constant then the execution of 
  % its compilation  $\compile{\expressionSrc}$, affects the stack in the following way:
  % 	$$
  % 		  \begin{array}{l} 
  % 	  % 	        %\counter = \counter + 1 \\
		  %         \stack{\counter } = \compile{\eval{ \expressionSrc }} \\
	  % 		 
	  % 	 \end{array}
	     %    $$
  % 

                            
    \item try catch statement
        $$ \compile{ \try \ \{ \stmt_1 \} \ \catch \ (Class \  name)\{ \stmt_2 \} } =$$ 
	$$
              \begin{array}{l}
                       \compile{\stmt_1}; \\
                       goto \ l; \\
		  
                       \compile{\stmt_2};\\
		       goto \ l; \\
		       ...\\
		       l: \\ 
                       \\  
                    
			\addExceptionTable{ \stR{\compile{\stmt_1} }}{ \enR{  \compile{ \stmt_1 }  }}{ \stR{\compile{\stmt_2}} }{ Class} )
             \end{array}
        $$
	


	The compiler compiles the normal statement $\stmt_1$ and the exception handler $\stmt_2$. Then in the exception handler table a new element is added - it describes that the handler starting at $ \stR{ \compile{\stmt_2} }  $ protects the region from $\stR{\compile{\stmt_1} } $ to
 $\enR{\compile{\stmt_1}}  $ from exceptions of type $Class$.

\item try finally statement

   $$ \compile{ \try \ \{ \stmt_1 \} \ \finally \ \{ \stmt_2 \} } = $$
$$ \begin{array}{l}
       \compile{\stmt_1}; \\
       \instr{jsr} \ s;\\
        \instr{goto} \ l;\\
       \\ 
       \{ \mbox{ \rm default exception handler} \} \\
      h: \instr{astore} \ e; \\
       \instr{jsr} \ s; \\
       \instr{aload} \ e;\\
       \instr{athrow};\\

       \\ 
       \{ \mbox{ \rm compilation of the subroutine} \} \\
       s: \instr{astore} \ k; \\
       \compile{\stmt_2}; \\ 
       \instr{ret} \ k \\
\\
l: \ldots
\\
\\
		\addExceptionTable{ \stR{\compile{\stmt_1} }}{ \enR{  \compile{ \stmt_1 }  }}{ h }{ Exception} )
   \end{array}
   $$ 
We keep close to the JVM (short for Java Virtual Machine) specification, which requires that the subroutines must be compiled using \instr{jsr} and 
\instr{ret} instructions. The \instr{jsr} actually jumps to the first instruction of the compiled subroutine which starts at index $s$ and pushes on the
 operand stack the index of the next instruction of the \instr{jsr} that caused the execution of the subroutine. The first instruction of the compilation
of the subroutine stores the stack top element in the local variable at index $k$ ( i.e. stores in the local variable at index $k$ the index of the instruction following the \instr{jsr} instruction). Thus, after the code of the subroutine is 
executed, the \instr{ret \ k} instruction jumps to 
 the instruction following the corresponding \instr{jsr}. 

\textit{Note:} 
\begin{enumerate}
          \item we assume that the local variable $e$  and $k$ are not used in the compilation of the statement $\stmt_1$. 
          \item here we also assume that the statement $\stmt_1$ does not contain a \instr{return} instruction 
\end{enumerate}


The compiler adds a default exception handler whose 
implementation guarantees that in exceptional termination case, the subroutine is also executed. The exception handler is added in the exception handler table. 
It protects the instructions of the statement $ \compile{\stmt_1} $ against any thrown exception of type or subtype $Exception$.     

\item try catch finally statement

   $$  \begin{array}{l}  
               \compile{  \try \ \{ \stmt_1 \} \ \catch \ (Class ) \ \{ \stmt_2 \} \ \finally \ \{ \stmt_3 \} } 
                = \\
		\\ 
     \compile{ \try \ \{ \try \ \{ \stmt_1 \} \ \catch \ (Class ) \ \{ \stmt_2 \} \ \} \  \finally \ \{ \stmt_3 \} }
     \end{array}
 $$




 \item throw exception statement
 $$\begin{array}{l} 
             \compile{\throw \ \expressionSrc} = 
             \begin{array}{l} 
	           \compileExp{ \expressionSrc}{\stack{\counter}}; \\
	           \instr{athrow}; 
	        \end{array} 
 \end{array}$$ 
                               
  %  \textit{Note} : The execution of the compilation of $\expressionSrc$ affects the stack :         
 %		$$
 %		  \begin{array}{l} 
 %		        \counter = \counter + 1 \\
 %		        \stack{\counter + 1} = \compile{\eval{ \expressionSrc }}
 %		 \end{array}
 %	      $$

      \item loop statement

 $$\begin{array}{l} \compile{\while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} } = \\
         \begin{array}{l}
             \instr{goto} \ loopEntry; \\
	     loopBody: \compile{\stmt}; \\
	      \lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
	     loopEntry: \compileExp{\expressionSrc}{\stack{\counter}};\\
	               \instr{if\_cond} \ loopBody; \\
	      
	 \end{array}
    \end{array}
$$


  %	$$\begin{array}{l} 
		        %\counter = \counter + 1 \\
%%		        \stack{\counter } = \compile{\eval{ \expressionSrc }}
%		 \end{array}
%	$$

 \item return statement

 $$ \compile{\returnSrc  \  \expressionSrc } =  
\begin{array}{l} 
\compileExp{ \expressionSrc }{ \stack{\counter}};\\
\instr{return}
\end{array}   $$
\end{itemize}

%  where after the execution of $\compile{ \expressionSrc}$  the stack changes: 
                       
%		$$
%		  \begin{array}{l}
%		        \counter = \counter + 1 \\
%			 \stack{\counter + 1} =  \compile{\eval{ \expressionSrc} } \\
%		
%	          \end{array} 
%		$$  
%

