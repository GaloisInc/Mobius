\subsection{Compiling control statements in bytecode instructions} \label{compCtrlStmt}
\todo{about the compilation of exception handlers}
\begin{itemize}
  \item compositional statement \todo{a redundant  jump  added in the compilation in order  to see explicitely the relation between stmt1 and stmt2}
      $$\begin{array}{l} \compileLabel{s}{\stmt_1; \stmt_2}{e} = \\  
      
            \compileLabel{s}{\stmt_1}{e'};\\
	    
	    \compileLabel{e'+1}{\stmt_2}{e}
       \end{array}$$
    
  \item   if statement
    $$\begin{array}{l} \compileLabel{s}{ \Myif \ ( \expressionSrcRel ) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   }{e} =  \\
        
	    \compileLabel{s}{\expressionSrcRel}{e'}; \\
            e' + 1: \ifCond \ e'' + 2;\\
            \compileLabel{e' + 2}{\stmt_2)}{e''}\\
             e'' + 1: \goto \ e +  1; \\
            \compileLabel{e'' +  2}{\stmt_1}{ e  }; \\
	    %e: \goto   e + 1        
	\end{array}
    $$


\item assignment statement. We consider the case for  instance field assignment as well as  assignemnts to method local variables and parameters. 

\begin{itemize}
    \item field assignement.% The expressions of the form \textrm{ f = v}, where \textrm{f} is an instance field of \textrm{this} object are desugared to \textrm{this.f = v}.
        $$\begin{array}{l }\compileLabel{s}{\expressionSrc_1.f= \expressionSrc_2}{e} = \\
            
                        \compileLabel{s}{\expressionSrc_1}{e'};\\
			\compileLabel{e'}{\expressionSrc_2}{e - 1 };\\
			e  :\putfield \ \fieldd;
             \end{array}
 $$ 

   %    where after the normal execution of the compilation of $\expressionSrc_1$ and $\expressionSrc_2$ the stack increments with 2 elements 
  % and the two top values are as follows: \\
    %    $$\begin{array}{l}
    %            %\counter = \counter + 1 \\
      %          \stack{\counter} = \compileLabel{\eval{ \expressionSrc_2 }} \\ 
      %          \stack{\counter - 1} = \compileLabel{\eval{ \expressionSrc_1 }} \\
     %      \end{array}
     %   $$
 
    \item method local variable or parameter update
        $$ \begin{array}{l}  \compileLabel{s}{  \var = \expressionSrc }{e} =  \\  
            
                        \compileLabel{s}{\expressionSrc}{e  - 1 }\\
			e : \instr{store} \ \locVar{i};
             \end{array}
        $$
%  where the normal execution of the compilation of $\expressionSrc$  affects the stack: \\
 %      $$\begin{array}{l}
%               %\counter = \counter + 1 \\
%               \stack{\counter} = \compileLabel{\eval{ \expressionSrc}} \\
 %              
%          \end{array}
  %     $$
\end{itemize}
  %  If $\expressionSrc$ is of the form $ \expressionSrc_1 \rel \expressionSrc_2$ affects the stack :         
  % 		$$
  % 		  \begin{array}{l} 
  % 		        %\counter = \counter + 2 \\
  % 		        \stack{\counter } = \compileLabel{\eval{ \expressionSrc_1 }} \\
  % 			 \stack{\counter -1} = \compileLabel{\eval{ \expressionSrc_2 }}
  % 		 \end{array}
  % 	      $$
   %   Otherwise, if $\expressionSrc$ is a boolean variable or constant then the execution of 
  % its compilation  $\compileLabel{\expressionSrc}$, affects the stack in the following way:
  % 	$$
  % 		  \begin{array}{l} 
  % 	  % 	        %\counter = \counter + 1 \\
		  %         \stack{\counter } = \compileLabel{\eval{ \expressionSrc }} \\
	  % 		 
	  % 	 \end{array}
	     %    $$
  % 

                            
    \item try catch statement
        $$ \begin{array}{l} \compileLabel{s}{ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \} }{e} = \\

             
                       \compileLabel{s}{\stmt_1}{e'}; \\
                       e' + 1: \goto \ e + 1; \\
		  
                       \compileLabel{e' + 2 }{\stmt_2}{e - 1};\\
		       % e: \goto \ e + 1; \\
		       \\ \\
                    
			\addExceptionTable{ s }{ e'  }{ e' + 2 }{ Class} )
             \end{array}
        $$
	


	The compiler compiles the normal statement $\stmt_1$ and the exception handler $\stmt_2$.
% Then in the exception handler table a new element is added - it describes that the handler starting at $ \stR{ \compileLabel{\stmt_2} }  $ protects the region from $\stR{\compileLabel{\stmt_1} } $ to
 %$\enR{\compileLabel{\stmt_1}}  $ from exceptions of type $Class$.

\item try finally statement

   $$\begin{array}{l} 
        \compileLabel{s}{ \try \ \{ \stmt_1 \} \ \finally \ \{ \stmt_2 \} }{e} = \\
        \compileLabel{s}{\stmt_1}{e'}; \\
        e'+1  : \jsr \ e' + 7;\\
        e' + 2 : \goto \ e +  1;\\
        \\ 
        \{ \mbox{ \rm default exception handler} \} \\
        e' +  3: \store \ l; \\
        e' +  4: \jsr \ e' + 7; \\
        e' +  5:\load \ l;\\
        e' +  6: \athrow;\\

        \\ 
        \{ \mbox{ \rm compilation of the subroutine} \} \\
        e'  + 7 : \store \ k; \\
        \compileLabel{e' + 8}{\stmt_2}{e  - 1 } \\ 
        e : \ret \ k \\
        \\\\
	\addExceptionTable{ s }{  e' }{ e' + 8  }{ Exception} )
   \end{array}
   $$ 
We keep close to the JVM (short for Java Virtual Machine) specification, which requires that the subroutines must be compiled using \instr{jsr} and 
\ret \ instructions. The \jsr \ actually jumps to the first instruction of the compiled subroutine which starts at index $s$ and pushes on the
 operand stack the index of the next instruction of the \jsr \ that caused the execution of the subroutine. The first instruction of the compilation
of the subroutine stores the stack top element in the local variable at index $k$ ( i.e. stores in the local variable at index $k$ the index of the instruction following the \instr{jsr} instruction). Thus, after the code of the subroutine is 
executed, the \ret \ k instruction jumps to 
 the instruction following the corresponding \jsr. 

\textit{Note:} 
\begin{enumerate}
          \item we assume that the local variable $e$  and $k$ are not used in the compilation of the statement $\stmt_1$. 
          \item here we also assume that the statement $\stmt_1$ does not contain a \instr{return} instruction 
\end{enumerate}


The compiler adds a default exception handler whose 
implementation guarantees that in exceptional termination case, the subroutine is also executed. The exception handler is added in the exception handler table. 
%It protects the instructions of the statement $ \compileLabel{\stmt_1} $ against any thrown exception of type or subtype $Exception$.     

\item try catch finally statement

   $$  \begin{array}{l}  
               \compileLabel{s}{  \try \ \{ \stmt_1 \} \ \catch \ (Class ) \ \{ \stmt_2 \} \ \finally \ \{ \stmt_3 \} }{e} 
                = \\
		\\ 
     \compileLabel{s}{ \try \ \{ \try \ \{ \stmt_1 \} \ \catch \ (Class ) \ \{ \stmt_2 \} \ \} \  \finally \ \{ \stmt_3 \} }{e}
     \end{array}
 $$




 \item throw exception statement
 $$\begin{array}{l} 
             \compileLabel{s}{\athrow \ \expressionSrc}{e} = 
             \begin{array}{l} 
	           \compileLabel{s}{ \expressionSrc}{e - 1}; \\
	           e: \instr{athrow}; 
	        \end{array} \\
		 
 \end{array}$$ 
                               
  %  \textit{Note} : The execution of the compilation of $\expressionSrc$ affects the stack :         
 %		$$
 %		  \begin{array}{l} 
 %		        \counter = \counter + 1 \\
 %		        \stack{\counter + 1} = \compileLabel{\eval{ \expressionSrc }}
 %		 \end{array}
 %	      $$

      \item loop statement

 $$\begin{array}{l} \compileLabel{s}{\while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} }{e} = \\
         \begin{array}{l}
              s: \goto \ e'; \\
	      \compileLabel{s +  1}{\stmt}{e'}; \\
	      \lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
	      \compileLabel{e' +  1}{\expressionSrcRel}{e  -1 };\\
	      e: \ifCond \ s +  1; \\
	      
	 \end{array}
    \end{array}
$$



 \item return statement

 $$ \compileLabel{s}{\returnSrc  \  \expressionSrc }{e } =  
\begin{array}{l} 
\compileLabel{s}{ \expressionSrc }{e - 1};\\
 e : \return
\end{array}   $$
\end{itemize}


