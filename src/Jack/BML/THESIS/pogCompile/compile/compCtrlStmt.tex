\subsubsection{Compiling control statements in bytecode instructions} \label{pogEq:compile:compCtrlStmt}
%\todo{about the compilation of exception handlers}

Now, let us look at the compilation of source statements. 

\begin{itemize}
  \item compositional statement \todo{a redundant  jump  added in the compilation in order  to see explicitely the relation between stmt1 and stmt2}
      $$\begin{array}{l} \compileLabel{s}{\stmt_1; \stmt_2}{e} = \\  
      
            \compileLabel{s}{\stmt_1}{e'};\\
	    
	    \compileLabel{e'+1}{\stmt_2}{e}
       \end{array}$$
    
  \item   if statement
    $$\begin{array}{l} \compileLabel{s}{ \Myif \ ( \expressionSrcRel ) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   }{e} =  \\
        
	    \compileLabel{s}{\expressionSrcRel}{e'}; \\
            e' + 1: \ifCond \ e'' + 2;\\
            \compileLabel{e' + 2}{\stmt_2)}{e''}\\
             e'' + 1: \goto \ e +  1; \\
            \compileLabel{e'' +  2}{\stmt_1}{ e  }; \\
	    %e: \goto   e + 1        
	\end{array}
    $$


\item assignment statement. We consider the case for  instance field assignment as well as  assignemnts to method local variables and parameters. 

\begin{itemize}
    \item field assignement.% The expressions of the form \textrm{ f = v}, where \textrm{f} is an instance field of \textrm{this} object are desugared to \textrm{this.f = v}.
        $$\begin{array}{l }\compileLabel{s}{\expressionSrc_1.f= \expressionSrc_2}{e} = \\
            
                        \compileLabel{s}{\expressionSrc_1}{e'};\\
			\compileLabel{e'+1}{\expressionSrc_2}{e - 1 };\\
			e  :\putfield \ \fieldd;
             \end{array}
 $$ 

   %    where after the normal execution of the compilation of $\expressionSrc_1$ and $\expressionSrc_2$ the stack increments with 2 elements 
  % and the two top values are as follows: \\
    %    $$\begin{array}{l}
    %            %\counter = \counter + 1 \\
      %          \stack{\counter} = \compileLabel{\eval{ \expressionSrc_2 }} \\ 
      %          \stack{\counter - 1} = \compileLabel{\eval{ \expressionSrc_1 }} \\
     %      \end{array}
     %   $$
 
    \item method local variable or parameter update
        $$ \begin{array}{l}  \compileLabel{s}{  \var = \expressionSrc }{e} =  \\  
            
                        \compileLabel{s}{\expressionSrc}{e  - 1 }\\
			e : \instr{store} \ \locVar{i};
             \end{array}
        $$
%  where the normal execution of the compilation of $\expressionSrc$  affects the stack: \\
 %      $$\begin{array}{l}
%               %\counter = \counter + 1 \\
%               \stack{\counter} = \compileLabel{\eval{ \expressionSrc}} \\
 %              
%          \end{array}
  %     $$
\end{itemize}
  %  If $\expressionSrc$ is of the form $ \expressionSrc_1 \rel \expressionSrc_2$ affects the stack :         
  % 		$$
  % 		  \begin{array}{l} 
  % 		        %\counter = \counter + 2 \\
  % 		        \stack{\counter } = \compileLabel{\eval{ \expressionSrc_1 }} \\
  % 			 \stack{\counter -1} = \compileLabel{\eval{ \expressionSrc_2 }}
  % 		 \end{array}
  % 	      $$
   %   Otherwise, if $\expressionSrc$ is a boolean variable or constant then the execution of 
  % its compilation  $\compileLabel{\expressionSrc}$, affects the stack in the following way:
  % 	$$
  % 		  \begin{array}{l} 
  % 	  % 	        %\counter = \counter + 1 \\
		  %         \stack{\counter } = \compileLabel{\eval{ \expressionSrc }} \\
	  % 		 
	  % 	 \end{array}
	     %    $$
  % 

                            
    \item try catch statement
        $$ \begin{array}{l} \compileLabel{s}{ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \} }{e} = \\

             
                       \compileLabel{s}{\stmt_1}{e'}; \\
                       e' + 1: \goto \ e + 1; \\
		  
                       \compileLabel{e' + 2 }{\stmt_2}{e };\\
		       % e: \goto \ e + 1; \\
		       \\ \\
                    
			\addExceptionTable{\methodd}{ s }{ e'  }{ e' + 2 }{\excType} )
             \end{array}
        $$
	


	The compiler compiles the normal statement $\stmt_1$ and the exception handler $\stmt_2$.
	Note that in the exception handler table of the bytecode representation of method \methodd, a new line is added 
	which states that the if one of bytecode instructions from index $s$ to index $e'$  throw a not handled exception of type  \excType
	control will be transfered to the instruction at index \excType.
 
% Then in the exception handler table a new element is added - it describes that the handler starting at $ \stR{ \compileLabel{\stmt_2} }  $ protects the region from $\stR{\compileLabel{\stmt_1} } $ to
 %$\enR{\compileLabel{\stmt_1}}  $ from exceptions of type $Class$.

\item try finally statement

   $$\begin{array}{l} 
        \compileLabel{s}{ \try \ \{ \stmt_1 \} \ \finally \ \{ \stmt_2 \} }{e} = \\
        \compileLabel{s}{\stmt_1}{e'}; \\
	\compileLabel{e'+1}{\stmt_2}{e''}; \\
        e''+1  : \goto \ e + 1;\\
        
        \\ 
        \{ \mbox{ \rm default exception handler} \} \\
        e'' +  2: \store \ l; \\
	\compileLabel{e'' + 3}{\stmt_2}{e - 2}; \\	                
        e - 1 :\load \ l;\\
        e: \athrow;\\

        
        \\\\
	\addExceptionTable{\methodd}{ s }{  e' }{ e''+2  }{ \Exception } 
   \end{array}
   $$ 

As you can notice, we compile the finally statement $ \stmt_2 $ by inlining, it is first compiled as a code executed after $\stmt_1  $  and
then it is compiled as part of the default exception handler. The default exception handler which starts at index $e'' + 2 $ and 
which will  handle any exception thrown by $\compileLabel{s}{\stmt_1}{e'}$. The exception handler 
first stores the thrown exception in the local variable at index $l$, then executed the subroutine code and after the execution rethrows the exception 
stored in the local variable $l$. 

This compilation differs from the compilation scheme in the JVM specification for finally statements, which requires that the subroutines must be compiled using \instr{jsr} and 
\ret \ instructions. However, the semantics of the programs produced by the compiler presented here and a compiler which follows closely the JVM specification 
is equivalent. 
In the following, we discuss informally why this is true.
 The semantics of a \jsr \ k insruction is to  jump to the first instruction of the compiled subroutine which starts at index $k$ and pushes on the
 operand stack the index of the next instruction of the \jsr \ that caused the execution of the subroutine. 
The first instruction of the compilation
of the subroutine stores the stack top element in the local variable at index $k$ ( i.e. stores in the local variable at index $k$ the index of the instruction following the \instr{jsr} instruction). Thus, after the code of the subroutine is 
executed, the \ret \ k instruction jumps to 
 the instruction following the corresponding \jsr. This behaviour can be actually simulated by programs without \jsr \ and \ret \ but which inline the subroutine code
at the places where a \jsr \ to the subroutine is done.

\textit{Note:}
 \begin{enumerate}
           \item we assume that the local variable $l$ is not used in the compilation of the statement $\stmt_2$, which guarantees that after any execution which 
	   terminates normally of $\compileLabel{e'' + 3}{\stmt_2}{e - 2}$ the local variable  $l$ will still hold the thrown object
           \item here we also assume that the statement $\stmt_1$ does not contain a \instr{return} instruction 
\end{enumerate}

The  last remark that we would like to make is that subroutines and their compilation via \ret \ and \jsr has always presented a problem for Java.
First, they slow down the performance of the JVM  because of the special way \ret \ and \jsr \ work\todo{verify this}.
Second, the analysis performed by the  bytecode verifier in  the JVM becomes rather complex because  (and its first version was erroneus ) 
of the Java subroutines. In the last version of Java Sun compiler, subroutines has become obsolete 
 where they are compiled by inlining. Thus, the compiler presented here represents a realistic approximation of the Java Sun compiler.
%The compiler adds a default exception handler whose 
%implementation guarantees that in exceptional termination case, the subroutine is also executed. The exception handler is added in the exception handler table. 
%It protects the instructions of the statement $ \compileLabel{\stmt_1} $ against any thrown exception of type or subtype $Exception$.     

% \item try catch finally statement
%
%   $$  \begin{array}{l}  
%               \compileLabel{s}{  \try \ \{ \stmt_1 \} \ \catch \ (Class ) \ \{ \stmt_2 \} \ \finally \ \{ \stmt_3 \} }{e} 
%%                = \\
%		\\ 
%     \compileLabel{s}{ \try \ \{ \try \ \{ \stmt_1 \} \ \catch \ (Class ) \ \{ \stmt_2 \} \ \} \  \finally \ \{ \stmt_3 \} }{e}
%     \end{array}
% $$




 \item throw exception statement
 $$\begin{array}{l} 
             \compileLabel{s}{\athrow \ \expressionSrc}{e} = 
             \begin{array}{l} 
	           \compileLabel{s}{ \expressionSrc}{e - 1}; \\
	           e: \instr{athrow}; 
	        \end{array} \\
		 
 \end{array}$$ 
                               
  %  \textit{Note} : The execution of the compilation of $\expressionSrc$ affects the stack :         
 %		$$
 %		  \begin{array}{l} 
 %		        \counter = \counter + 1 \\
 %		        \stack{\counter + 1} = \compileLabel{\eval{ \expressionSrc }}
 %		 \end{array}
 %	      $$

      \item loop statement

 $$\begin{array}{l} \compileLabel{s}{\while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} }{e} = \\
         \begin{array}{l}
              s: \goto \ e' + 1; \\
	      \compileLabel{s +  1}{\stmt}{e' }; \\
	     % \lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
	      \compileLabel{e' +  1}{\expressionSrcRel}{e  -1 };\\
	      e: \ifCond \ s +  1; \\
	      \\\\
	      \addLoopTable{\methodd}{e'+1}{\invariant }{\modLoop}
	 \end{array}
    \end{array}
$$
Note that the compiler adds a new element in the table of loop invariants of the method \methodd. 
This new element relates  the index $e'+1$  with the loop invariant \invariant \  and the
 list of modified expressions \modLoop.



 \item return statement

 $$ \compileLabel{s}{\returnSrc  \  \expressionSrc }{e } =  
\begin{array}{l} 
\compileLabel{s}{ \expressionSrc }{e - 1};\\
 e : \return
\end{array}   $$
\end{itemize}


