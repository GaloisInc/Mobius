%\newtheorem{compProp0}{Property}[subsection]

\newtheorem{compProp0}{Property}[subsection]
\newtheorem{compProp1}[compProp0]{Property} % control flow statement property 
\newtheorem{compProp2}[compProp0]{Property} % control flow statement property  
\newtheorem{compProp11}[compProp0]{Property}
\newtheorem{compProp6}[compProp0]{Property} % a substatement is compiled in substatement
\newtheorem{compProp3}[compProp0]{Property} % expression property
\newtheorem{compProp7}[compProp0]{Property} % every element in the exception handler 
                                            % table corresponds to a statement

\newtheorem{compProp8}[compProp0]{Property} % if st' is a direct substatement of st then [s',st',e'] and  [s,st,e]
                                            % are such that for all Exc, findExcH( e, Exc )  = findExcH( e', Exc ) 
					    % if st != try {} catch() {}
\newtheorem{compProp9}[compProp0]{Property}
\newtheorem{compProp10}[compProp0]{Property}
\newtheorem{compProp4}[compProp0]{Property} % 
\newtheorem{compProp5}[compProp0]{Property} %
\newtheorem{seqInstr}{Definition}[subsection]




 
\newcommand{\isStartExc}[1]{\mbox{\rm\textit{isExcHandlerStart}}(#1)}
\subsection{Properties of the compiler function}\label{compile:prop}

In this subsection, we will focus on the properties of the  bytecode produced by the compiler presented above.
These properties although a straightforward consequence of the compiler definition
 are actually important for establishing formally the equivalence between source and bytecode 
proof obligations. Note also that those properties are respected by any non optimizing compiler.


In the following, we use the notation $\ExprStmt$ when we refer both to statements $\stmt$ and $\expressionSrc$.
 
The first property that we observe is that the last instruction $\ins{e}$ in the compilation
 $\compileLabel{s}{\stmt}{e}$  of a statement $\stmt$ is always in execution relation with the
  instruction $\ins{e + 1}$.

\begin{compProp0}[Compilation of statements and expressions]\label{compile:prop:compProp0}
 For any statement or expression $\ExprStmt$ which does not terminate on \return, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\stmt}{e}$ such that 
     $$ \ins{e} \execRel \ins{e+1}$$
\end{compProp0}
The proof is trivial by case analysis of the compiled statements.

Let us now turn to the next property of interest.
Informally, it states  that  if there are instructions inside a compiled statetement or expression 
 $\compileLabel{s}{\ExprStmt}{e}$ which are in execution relation\footnote{see Def. \ref{defEdge}}  with an instruction 
$\ins{k}$ which is not the start of an exception handler and which is outside the compilation $\compileLabel{s}{\ExprStmt }{e}$
of $\ExprStmt$ 
 then   $ k  = e +1$. 
 The conditions  $ \neg (\ins{k} \in  \compileLabel{s}{\ExprStmt}{e} )  $ and 
$\neg \isStartExc{\ins{k}}$  eliminate the case when the execution relation is between an instruction inside 
the compilation $\compileLabel{s}{\ExprStmt}{e}$ which may throw an exception and the start instruction of the proper handler exception handler.

\begin{compProp1}[Compilation of statements and expressions]\label{compile:prop:compProp1}
    For any statement or expression $\ExprStmt$, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\ExprStmt}{e}$ such that: 
           $$ \begin{array}{l} 
                             \forall i, ( \ins{i} \in \compileLabel{s}{\ExprStmt }{e} ) \wedge \\
			     \Myspace ( \ins{i} \execRel \ins{k}) \wedge \\
			     \Myspace \neg (\ins{k} \in   \compileLabel{s}{\ExprStmt}{e}  ) \\
			     \Myspace \neg \isStartExc{\ins{k}}     \Rightarrow   \\
                             \Myspace \Myspace k = e + 1  \\
			     
              \end{array}$$ 
\end{compProp1}


 The proof is done by induction on the structure of the compiled statement. 
We scatch the proof for the compilation of the if statement, the rest of the cases being similar \\
\textit{Proof:} 
$$
\begin{array}{l}
            \comment{Assume that $\exists i, i \in [  s \ldots e ], \exists k ,   k \notin [s \ldots e + 1] \wedge \ins{i} \execRel \ins{k}    $  }\\
            \\
            \mbox{\rm\comment{by definition of the compiler function for if statements in section \ref{pogEq:compile:compCtrlStmt} }} \\
            \compileLabel{s}{ \Myif \ ( \expressionSrcRel ) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   }{e} =  \\
        
	    \compileLabel{s}{\expressionSrcRel}{e'}; \\
            e' + 1 \ \ifCond \ e'' + 2;\\
            \compileLabel{e' + 2}{\stmt_2}{e''}\\
             e'' + 1 \ \goto \ e +  1; \\
            \compileLabel{e'' +  2}{\stmt_1}{ e  }; \\
	    %e: \goto   e + 1  \\
           
	    \\ 
	   \numConclusion{1} \ \comment{Assume that $ s \le i  \le e'$ } \\
	   \comment{by induction hypothesis for $\expressionSrcRel$ we get } \\

	    \numConclusion{2}   \forall  i ,  s \le i \le e' ,  \ \ins{i}   \execRel \ins{k}) \wedge \\
			     \Myspace \neg  ( \ins{k} \in  \compileLabel{s}{\stmt}{e} ) \\
			     \Myspace \neg  \isStartExc{\ins{k}}   \Rightarrow   \\
                             \Myspace \Myspace  k = e' + 1 \\ 
	    \comment{ From	\numConclusion{1} and 	 \numConclusion{2}  we get a contradiction in this case} \\\\
        
	    \numConclusion{3} \ \comment{Assume that $ e'+2 \le i  \le e''$ } \\			 
	    \numConclusion{4} \  \forall i ,  e' + 2 \ge i \le e'' ,  \ \ins{i}   \execRel \ins{k}) \wedge \\
			     \Myspace \neg ( \ins{k}  \in \compileLabel{s}{\stmt}{e} ) \\
			     \Myspace \neg \isStartExc{\ins{k}}   \Rightarrow   \\
                             \Myspace \Myspace k = e'' + 1\\
	    \comment{ From	\numConclusion{3} and 	 \numConclusion{4}  we get a contradiction in this case} \\\\
	    
	    \numConclusion{5} \ \comment{Assume that $ e'' +2 \le i  \le e $ } \\
	    \numConclusion{6} \  \forall i ,  e'' + 2 \ge i \le e ,  \ \ins{i}   \execRel \ins{k}) \wedge \\
			     \Myspace \neg ( \ins{k}  \in \compileLabel{s}{\stmt}{e}  ) \\
			     \Myspace \neg \isStartExc{\ins{k}}   \Rightarrow   \\
                             \Myspace \Myspace k = e + 1	     \\\\
       \comment{ From	\numConclusion{5} and 	 \numConclusion{6}  we get a contradiction in this case} \\\\
	    
      \numConclusion{7}  \comment{Assume that $s =  e' + 1 $ } \\
       \mbox{\rm\textit{ \{ as $ e' + 1 \ \ifCond \ e'' + 2$ and  $e'' + 2$ and $e' + 2$ are labels in }}\\
       \mbox{\rm\textit{  the compilation of the statement, we get a contradiction in this case \}  }}\\	\\
      
      \numConclusion{8}  \comment{Assume that $s =  e'' + 1 $ } \\
   \mbox{\rm\textit{ \{ as $ e''  + 1 \ \goto \ e+ 1$ we get a contradiction once again }}\\
\end{array}
$$
\Qed \\

The next three lemmas deal with the substatement relation. 
In the following, for denoting that  $\ExprStmt'$ is a substatement of  $\ExprStmt$ (i.e.$\ExprStmt'$ is contained in  $\ExprStmt$  )
we shall use the notation $\substatement{\ExprStmt }{\ExprStmt'}$.
For denoting that  $\ExprStmt'$ is a strict substatement of  $\ExprStmt$ ( i.e. that $\ExprStmt'$  is contained in $\ExprStmt$ 
and there is no   $\ExprStmt''$  such that  $\ExprStmt''$ is contained in   $\ExprStmt$ and  $\ExprStmt'$ is contained in  $\ExprStmt''$)
we use the notation $\strictsubstatement{\ExprStmt }{\ExprStmt'}$.

The next  property  of the compiler is that any statement or expression   is
 compiled in a list of bytecode instructions 
such that there could not be jumps  from outside inside the list, i.e.
the control flow can reach the instructions representing the compilation $\compileLabel{s}{\ExprStmt}{e}$ 
 of statement $\ExprStmt$  only by passing   through the beginning of the compilation, i.e. the instruction at index $s$.

\begin{compProp2}[Compilation of statements and expressions]\label{compile:prop:compProp2}
 For all  statements $\ExprStmt'$  and $\ExprStmt$, such that $\substatement{\ExprStmt }{\ExprStmt'} $
and their  compilations  are $\compileLabel{s}{\ExprStmt}{e}$ and  $\compileLabel{s'}{\ExprStmt'}{e'}$

%\begin{itemize}
    %\item  $\substatement{\ExprStmt }{\ExprStmt'} $

 %   \item   their  compilations  are $\compileLabel{s}{\ExprStmt}{e}$ and  $\compileLabel{s'}{\ExprStmt'}{e'}$
%\end{itemize}
then :

$$\begin{array}{l} \neg (\exists i_j, \exists i_k,  \\   
                       \Myspace   i_j \in \compileLabel{s}{\ExprStmt[\ExprStmt']}{e} \wedge\\
		       \Myspace \neg (i_j \in \compileLabel{s'}{\ExprStmt'}{e'} )   \wedge \\
		       \Myspace  i_k \in \compileLabel{s'}{\ExprStmt'}{e'}  \wedge \\
		       \Myspace s' \neq k   \wedge 
		       \Myspace i_j \execRel i_k )


  \end{array}$$ 

\end{compProp2}

The proof is done by induction over the structure of statements and expressions  and uses the previous lemma \ref{compile:prop:compProp1}.


 
The next lemma  states that the substatement relation on source expressions and statements is preserved
by the compiler.
\begin{compProp11}[Substatement and subexpression relation preserved]\label{compile:prop:compPropSubstmt}
For all statements $\ExprStmt'$ and $\ExprStmt $ with
respective compilations are $\compileLabel{s'}{\ExprStmt'}{e'}$ and  $\compileLabel{s}{\ExprStmt}{e}$ 
we have  that 
  $  \substatement{\ExprStmt }{\ExprStmt'} \Leftrightarrow \compileLabel{s'}{\ExprStmt'}{e'} \in  \compileLabel{s}{\ExprStmt}{e} $ 
\end{compProp11}
This follows directly from the compiler function definition.

The next property  states 
that if the compilations of two
statements in a method body share instructions then 
either the compilation of one of them is completely inside of the other or viceversa.


\begin{compProp6}[No overlapping compilation]\label{compile:prop:compProp6}
For all statements $\ExprStmt_1$ and $\ExprStmt_2$ such that their compilations are 
 $\compileLabel{s_1}{\ExprStmt_1}{e_1} $ and that   $\compileLabel{s_2}{\ExprStmt_2}{e_2} $, if we have that 
$ \exists k,  s_1 \le k  \le e_1 \wedge s_2 \le k  \le e_2  $ then the following holds:

$$\begin{array}{l}
         \compileLabel{s_2}{\ExprStmt_2}{e_2}  \in \compileLabel{s_1}{\ExprStmt_1}{e_1}\\   
	 \vee \\
	 \compileLabel{s_1}{\ExprStmt_1}{e_1}  \in \compileLabel{s_2}{\ExprStmt_2}{e_2} 
\end{array}$$
\end{compProp6}

Next, we give a definition for a set of instructions such that they execute sequentially which will be used for 
establishing afterwards the properties of the bytecode instructions resulting in expression compilation. 
\begin{seqInstr}[Block of instructions] \label{seqInstr}
If the list of  instructions \\ $l  = \lbrack \ins{i_1} \ldots \ins{i_n} \rbrack$ in the compilation of method \methodd is such that 
 \begin{itemize}
              
      \item none of the instructions is a target of an instruction $\ins{i_j}$ which does not belong to $l$ except for $\ins{i_1}$
      \item none of the instructions in the set is a jump instruction, i.e. $\forall m, m = 1..k \Rightarrow \neg( \ins{i_m} \in  \{\goto, \ifCond\} )  $ 
      \item $  \forall j, i_1 <  j \le i_n , \neg \exists k \in \methodd.\body, \ins{k} \execRel^{l} \ins{j} $ 
 \end{itemize}

We denote such a list of instructions with $\ins{i_1};...;\ins{i_k}$

\end{seqInstr}


The next lemma states that the compilation of an expression $\expressionSrc$ results in
 a block of bytecode instructions.  
\begin{compProp3}[Compilation of expressions]\label{compile:prop:compProp3}
    For any expression $\expressionSrc$, starting label $s$ and end label $e$,
    the compilation $\compileLabel{s}{\expressionSrc}{e}$ is a block of bytecode instruction in the sense of Def. \ref{seqInstr}
   
\end{compProp3}
Proof:

Following the Def. \ref{seqInstr} of block of bytecode instructions,  we have to see if the compilation of an expression respects
three conditions.
The first condition of Def.\ref{seqInstr}  follows from lemma \ref{compile:prop:compProp2}. 
Def. \ref{seqInstr} also requires that there are no jump instructions  in the list of instructions representing the  compilation of an expression.
This is established by induction over the structure of the expression.
The third condition in Def. \ref{seqInstr} states that  the compilation $\compileLabel{s}{\expressionSrc}{e}$ is such that 
  no instruction except $\ins{s}$ may be  a loop entry  in the sense of Def.  \ref{defLoop} in Chapter
\ref{wpGeneral}, Section \ref{prelim}. This is the case, as there are no jump instructions inside the compiled expression  and all the instructions inside an
expression are sequential\todo{this is not well explained}.\\
\Qed 

Next, we shall focus on properties which concern the compilation of exception handlers.
As we saw in the previous section, the compiler keeps track of the exception 
handlers by adding them in the exception handler table. We now establish that the elements in the exception handler
 table correspond to a statement
in the source language.

\begin{compProp7}[Exception handler element corresponds to a statement]\label{compile:prop:compProp7}
Every element  $ (s,e, eH, \mbox{\rm\texttt{Exc}} )$  in the exception handler table \methodd.\excHandlerTable  \
  is such that exists a statement $\stmt$ such that $\compileLabel{s}{\stmt}{e}$


%Assume we have a method \methodd \ and the compilation of its body results in  $\stmt$ is $\compileLabel{s}{\stmt}{e}$ and exception
%handler table \methodd.\excHandlerTable. Then every element  $ (s,e, eH, \mbox{\rm\texttt{Exc}} )$ in \methodd.\excHandlerTable \ is
%such that there exists a statement $\stmt'$ such that  $\stmt' $ is a substatement of $\stmt$  such that the compilation of 
% $\stmt' $ is $\compileLabel{s}{\stmt'}{e}$
\end{compProp7} 
\textit{Proof}:
This follows directly from the definition of the compiler. 
The proof is done by contradiction. From the compiler definition, we get that  elements are added in 
 \methodd.\excHandlerTable \ only in the cases of 
try catch and try finally statement compilation and that the guarded regions in the added elements correspond to statements. \\
\Qed

In the rest of this subsection we will look at properties of the compiler which are a consequence of the upper properties.



\todo{give the definition of the function  $\isStartExc{\ins{k}}$   }


The following property states that the exceptions thrown by a 
statement which is not a try catch and the  exceptions thrown by its strict substatement
will be handled by the same exception handler.

\begin{compProp8}[Exception handler property for statements]\label{compile:prop:compProp8}
  For every statement $\stmt$ which is not a try catch statement  in method \methodd \  and  its strict substatement $\stmt'$, i.e. 
$\strictsubstatement{\stmt}{\stmt'} $
if their respective compilations are  $\compileLabel{s}{\stmt}{e}$ and  $\compileLabel{s'}{\stmt'}{e'}$ then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \\
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} 
   \end{array}
$$

\end{compProp8}
\textit{Proof}:
The proof is by contradiction. Assume this is not true, i.e.
 $$\begin{array}{l} \exists \stmt, \stmt' ,   \\
       \numConclusion{1}    \Myspace \stmt \neq \try \{ \ldots \} \catch \{ \ldots \} \wedge \\
       \numConclusion{2}   \Myspace  \strictsubstatement{\stmt}{\stmt'} \\
       \numConclusion{3}  \Myspace  \compileLabel{s}{\stmt}{e} \wedge \\
       \numConclusion{4} \Myspace  \compileLabel{s'}{\stmt'}{e'} \wedge \\
       \numConclusion{5}  \Myspace \exists  \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} \neq \\
                                            \phantom{\exists \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable}    
\end{array}
$$

This means that there exists two elements $   (s_1,e_1, eH_1, \mbox{\rm\texttt{Exc}} ) $  and
$   (s_2,e_2, eH_2, \mbox{\rm\texttt{Exc}} )$  in the exception handler table of method \methodd \ \methodd.\excHandlerTable \  such that   : 
$$ \numConclusion{6}  \Myspace eH_1 \neq eH_2 $$
From lemma \ref{compile:prop:compProp7} we get that :

$$ \numConclusion{7}  \Myspace \begin{array}{l}
        \exists \stmt_1, s_1, e_1, \compileLabel{s_1}{\stmt_1}{e_1} \\
	\wedge \\
	\exists \stmt_2, s_2, e_2,\compileLabel{s_2}{\stmt_2}{e_2}
\end{array}	 $$


From the initial condition \numConclusion{2} by lemma \ref{compile:prop:compPropSubstmt}  we conclude that 
$$\numConclusion{8} \Myspace \compileLabel{s_1}{\stmt_1}{e_1} \notin   \compileLabel{s}{\stmt}{e} $$

%From \numConclusion{7}, it follows that the exception handler for $e'$ is obligatory outside $\compileLabel{s}{\stmt}{e}$.

 Because $e \in [s_2 \ldots e_2 ]  \wedge  e' \in [s_1 \ldots e_1 ] \wedge e,e' \in [s \ldots e]$, \numConclusion{8} by applying 
  Lemma \ref{compile:prop:compProp6}  we can conclude that

 $$  \begin{array}{l} 
          \compileLabel{s}{\stmt}{e} \in \compileLabel{s_1}{\stmt_1}{e_1} \in  \compileLabel{s_2}{\stmt_2}{e_2} \\
           \vee \\
	 \compileLabel{s}{\stmt}{e} \in   \compileLabel{s_2}{\stmt_2}{e_2} \in \compileLabel{s_1}{\stmt_1}{e_1}
 \end{array}$$	   

 In both of the cases and of the definition of \findExcHandlerOnly \ in Chapter \ref{opSem}, Section \ref{opSem:exc}  this means that 
$$ \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} $$
which is in contradiction with \numConclusion{6}.


A similar property can be established about expressions
 
\begin{compProp9}[Exception handler property for expressions]\label{compile:prop:compProp9}
  For every statement $\stmt$ which is not a try catch  in method \methodd \  and  its strict  subexpression
 $\expressionSrc$, i.e. $\strictsubstatement{\stmt}{\expressionSrc}$
 we have that 
if their respective compilations are  $\compileLabel{s}{\stmt}{e}$ and  $\compileLabel{s'}{\expressionSrc}{e'}$ and \numConclusion{2}
 then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \forall  \ i, s' \le i \le e' ,  \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \\
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{i}{\methodd.\excHandlerTable} 
   \end{array}
$$
\end{compProp9}

The last property concerns try catch statements
\begin{compProp10}[Exception handlers and try catch statements]\label{compile:prop:compProp10}
For every try catch statement $ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \}  $ 
its compilation $$
\begin{array}{l} 
\compileLabel{s}{\stmt_1}{e'}; \\
                       e' + 1: \goto \ e + 1; \\
		  
                       \compileLabel{e' + 2 }{\stmt_2}{e };\\
		       % e: \goto \ e + 1; \\
		       \\ \\

 \end{array}$$
is such that the following holds 
$$\begin{array}{l} \forall \neg ( \mbox{\rm{\texttt{Exc}}} <: \excType ) \Rightarrow
 \Myspace   \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} =\\ 
 \Myspace   \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable}  \\
 \wedge
  \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e'+2 \\ 
 \end{array} $$



\end{compProp10}


Next, we can establish also that the compilation of a statement $\stmt$ may  contain  cycles only if $\stmt$ is a cycle or contains
a substatement which is a cycle. 
\begin{compProp4}[Cycles in the control flow graph]\label{compile:prop:compProp4}  % cycles in bytecode only if the source has  
\todo{alternative formulation: say that the only loop entries are the first instructions of a loop body }
The compilation \\ $\compileLabel{s}{\stmt}{e}$ of a $\stmt$ may contain an instruction $\ins{k}$ and \ins{j}  which are respectively 
a loop entry and a loop end  in the sense of Def.
\ref{defLoop} (i.e. there exists $\ins{j}$ such that $\ins{j} \execRel^{l} \ins{k}$ ) only if  $\stmt$ is a loop or contains 
 a substatement $\stmt'$ which is a loop statement and the following holds:
  $$\begin{array}{l}
                        \stmt = \\             
	                \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} \\ \\ 
			\vee \\\\

                        \stmt[\stmt'] \wedge \\
			\stmt' = \\
             
	                \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} \\ \\ 

                        \compileLabel{s}{   \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \}   }{e} = \\
			s: \goto \ e' + 1; \\
	                \compileLabel{s +  1}{\stmt}{e'}; \\
			 %\lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
			 \compileLabel{e' +  1}{\expressionSrcRel}{e  -1 };\\
			 e: \ifCond \ s +  1; \\  \\
                        \Myspace \Rightarrow k = e' +1 \wedge j = e'  
                
	           \end{array} 
               $$ 
	   
              
             

\end{compProp4}
 
%A consequence from this property is that it cannot be that the start of  a $\execRel^{l}$ edge is in the compilation of one statement $\stmt_1$
% and its end is in another statement $\stmt_2$.
Another property concerning cycles in the control flow graph is that all the instructions in a compilation$\compileLabel{s}{\stmt}{e}$   of a statement $\stmt 
$which target the instruction $\ins{e+1}$  are in the same execution relation with  $\ins{e+1}$,i.e. if  
$\ins{e+1}$ is a  loop entry either all are loop ends or none of them is:
\begin{compProp5}[Cycles in the control flow graph]\label{compile:prop:compProp5} 
 For every statement $\stmt$ its compilation $\compileLabel{s}{\stmt}{e}$ is such that 
$(\exists k, s \le k \le e, \ins{k} \execRel^{l} \ins{e+1} ) \iff (\forall k, s \le k \le e, \ins{k} \execRel \ins{e+1}  \Rightarrow \ins{k} \execRel^{l} \ins{e+1} ) $
\end{compProp5}


%\todo{this is not sufficient. There must be established a property that the $\execRel^l$ is only in the compilation of while statements} 
% In the following, we  abstract
% from the labeling done by the compiler and we  will denote the compiler function with $ \lbrack \ \rbrack $.
% We assume that the compiler function $ \lbrack \ \rbrack $ does a labeling which has the above properties.
% Also, the notation for labeled instructions used here $ \ins{i} $ will be sometimes abbreviated just to the index of the instruction $ i $. 


%\begin{compProp2}[Compilation of statements ] \label{compProp2}
%  For any statement $\stmt$, the compiler will produce a sequence of bytecode instruction 
%  $\compileLabel{s}{\stmt}{e}$ such that
%  there may be no more than one instruction $ \ins{j} \in \compileLabel{s}{\stmt}{e}$, such that 
%  $ \ins{k} \execRel \ins{j} \wedge \neg ( \ins{k}  \ \in \  \compileLabel{s}{\stmt}{e} ) $
%\end{compProp2}
%The property states that 
%no more than one instruction in the compilation $\compileLabel{s}{\stmt}{e}$
%of the statement $\stmt$ may be targeted by an instruction 
%which does not belong to  $\compileLabel{s}{\stmt}{e}$.







%Another property of the compiler is that compilation of expressions result always 
%in a block of sequential instructions as defined in the above def. \ref{seqInstr}

%\begin{compProp3}[Compilation of expressions] \label{compProp3}
%  For any expression $\expressionSrc$,
%  starting label $s$ and end label $e$, the compiler
%  will produce a sequence of bytecode instructions
%  $ \compileLabel{s}{\expressionSrc}{e} =  \ins{s} ;...; \ins{e} $
%\end{compProp3}


%The property can be established by structural induction of the compilation $\compile{\expression}$

 
