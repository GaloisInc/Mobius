%\newtheorem{compProp0}{Property}[subsection]

\newtheorem{compProp0}{Property}[subsection]
\newtheorem{compProp1}[compProp0]{Property} % control flow statement property 
\newtheorem{compProp2}[compProp0]{Property} % control flow statement property  
\newtheorem{compProp6}[compProp0]{Property} % a substatement is compiled in substatement
\newtheorem{compProp3}[compProp0]{Property} % expression property
\newtheorem{compProp7}[compProp0]{Property} % every element in the exception handler 
                                            % table corresponds to a statement
\newtheorem{compProp4}[compProp0]{Property} % 
\newtheorem{compProp5}[compProp0]{Property} %
\newtheorem{compProp8}[compProp0]{Property} % if st' is a direct substatement of st then [s',st',e'] and  [s,st,e]
                                            % are such that for all Exc, findExcH( e, Exc )  = findExcH( e', Exc ) 
					    % if st != try {} catch() {}
\newtheorem{compProp9}[compProp0]{Property}
\newtheorem{compProp10}[compProp0]{Property}
\newtheorem{seqInstr}{Definition}[subsection]




 
\newcommand{\isStartExc}[1]{\mbox{\rm\textit{isExcHandlerStart}}(#1)}
\subsection{Properties of the compiler function}\label{compile:prop}

In this last subsection, we will look at the properties of the compiled statements.
In the following, we use the notation $\ExprStmt$ when we refer both to statements $\stmt$ and $\expressionSrc$.
 
The first property that we observe is that the last instruction $\ins{e}$ in the compilation $\compileLabel{s}{\stmt}{e}$  of a statement $\stmt$
is always in execution relation with the  instruction $\ins{e + 1}$
\begin{compProp0}[Compilation of statements and expressions]\label{compile:prop:compProp0}
 For any statement or expression $\ExprStmt$, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\stmt}{e}$ such that 
     $$ \ins{e} \execRel \ins{e+1}$$
\end{compProp0}
The proof is trivial by case analysis of the compiled statements.


Informally, the following property states  that  if there are instructions inside a compiled statetement or expression 
 $\compileLabel{s}{\ExprStmt}{e}$ which are in execution relation\footnote{see Def. \ref{defEdge}}  with an instruction 
$\ins{k}$ which is not the start of an exception handler and which is outside $\compileLabel{s}{\ExprStmt }{e}$
 then   $ k  = e +1$. 
 The conditions  $ \neg (  \isInList{\compileLabel{s}{\ExprStmt}{e} }{\ins{k}} )$ and \\
$\neg \isStartExc{\ins{k}}$  eliminate the case when the execution relation is between an instruction inside 
 $\compileLabel{s}{\ExprStmt}{e}$ which may throw an exception and the start instruction of the proper handler exception handler.

\begin{compProp1}[Compilation of statements and expressions]\label{compile:prop:compProp1}
    For any statement or expression $\ExprStmt$, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\ExprStmt}{e}$ such that: 
           $$ \begin{array}{l} 
                             \forall i, ( \isInList{\compileLabel{s}{\ExprStmt }{e}}{\ins{i}} ) \wedge \\
			     \Myspace ( \ins{i} \execRel \ins{k}) \wedge \\
			     \Myspace \neg (  \isInList{\compileLabel{s}{\ExprStmt}{e} }{\ins{k}} ) \\
			     \Myspace \neg \isStartExc{\ins{k}}     \Rightarrow   \\
                             \Myspace \Myspace k = e + 1 \wedge \\
			     
              \end{array}$$ 
\end{compProp1}


 The proof is done by induction on the structure of the compiled statement. 
We scatch the proof for the compilation of the if statement, the rest of the cases being similar 
\textit{Proof:} 
$$
\begin{array}{l}
            \comment{Assume that $\exists, s \le  i \le e, \exists k ,   k \notin [s \ldots e + 1] \wedge \ins{i} \execRel \ins{k}    $  }\\
            \\
            \mbox{\rm\comment{by definition of the compiler function for if statements in section \ref{compCtrlStmt} }} \\
            \compileLabel{s}{ \Myif \ ( \expressionSrcRel ) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   }{e} =  \\
        
	    \compileLabel{s}{\expressionSrcRel}{e'}; \\
            e' + 1 \ \ifCond \ e'' + 2;\\
            \compileLabel{e' + 2}{\stmt_2}{e''}\\
             e'' + 1 \ \goto \ e +  1; \\
            \compileLabel{e'' +  2}{\stmt_1}{ e  }; \\
	    %e: \goto   e + 1  \\
           
	    \\ 
	   \numConclusion{1} \ \comment{Assume that $ s \le i  \le e'$ } \\
	   \comment{by induction hypothesis for $\expressionSrcRel$ we get } \\

	    \numConclusion{2}   \forall  i ,  s \le i \le e' ,  \ \ins{i}   \execRel \ins{k}) \wedge \\
			     \Myspace \neg  (  \isInList{\compileLabel{s}{\stmt}{e} }{\ins{k}} ) \\
			     \Myspace \neg  \isStartExc{\ins{k}}   \Rightarrow   \\
                             \Myspace \Myspace  k = e' + 1 \\ 
	    \comment{ From	\numConclusion{1} and 	 \numConclusion{2}  we get a contradiction in this case} \\\\
        
	    \numConclusion{3} \ \comment{Assume that $ e'+2 \le i  \le e''$ } \\			 
	    \numConclusion{4} \  \forall i ,  e' + 2 \ge i \le e'' ,  \ \ins{i}   \execRel \ins{k}) \wedge \\
			     \Myspace \neg (  \isInList{\compileLabel{s}{\stmt}{e} }{\ins{k}} ) \\
			     \Myspace \neg \isStartExc{\ins{k}}   \Rightarrow   \\
                             \Myspace \Myspace k = e'' + 1\\
	    \comment{ From	\numConclusion{3} and 	 \numConclusion{4}  we get a contradiction in this case} \\\\
	    
	    \numConclusion{5} \ \comment{Assume that $ e'' +2 \le i  \le e $ } \\
	    \numConclusion{6} \  \forall i ,  e'' + 2 \ge i \le e ,  \ \ins{i}   \execRel \ins{k}) \wedge \\
			     \Myspace \neg (  \isInList{\compileLabel{s}{\stmt}{e} }{\ins{k}} ) \\
			     \Myspace \neg \isStartExc{\ins{k}}   \Rightarrow   \\
                             \Myspace \Myspace k = e + 1	     \\\\
       \comment{ From	\numConclusion{5} and 	 \numConclusion{6}  we get a contradiction in this case} \\\\
	    
      \numConclusion{7}  \comment{Assume that $s =  e' + 1 $ } \\
       \mbox{\rm\textit{ \{ as $ e' + 1 \ \ifCond \ e'' + 2$ and  $e'' + 2$ and $e' + 2$ are labels in }}\\
       \mbox{\rm\textit{  the compilation of the statement, we get a contradiction in this case \}  }}\\	\\
      
      \numConclusion{8}  \comment{Assume that $s =  e'' + 1 $ } \\
   \mbox{\rm\textit{ \{ as $ e''  + 1 \ \goto \ e+ 1$ we get a contradiction once again }}\\
\end{array}
$$



Another property of the compiler is that any statement or expression   is
 compiled in a list of bytecode instructions 
such that there could not be jumps  from outside inside the list, i.e.
the control flow can reach the instructions representing the compilation $\compileLabel{s}{\ExprStmt}{e}$ 
 of statement $\ExprStmt$  only by passing   through the beginning of the compilation $i_s$.

\begin{compProp2}[Compilation of statements and expressions]\label{compile:prop:compProp2}
 For all  statements $\ExprStmt'$  and $\ExprStmt$, such that

\begin{itemize}
    \item $\ExprStmt$  is such that it has as substatement $\ExprStmt'$, which we denote with 
          $ \ExprStmt[\ExprStmt' ]$ 
    \item  their  compilations  are $\compileLabel{s}{\ExprStmt}{e}$ and  $\compileLabel{s'}{\ExprStmt'}{e'}$
\end{itemize}
then :
$$\begin{array}{l} \neg (\exists i_j, \exists i_k,  \\   
                       \Myspace \isInList{\compileLabel{s}{\ExprStmt[\ExprStmt']}{e} }{i_j} \wedge\\
		       \Myspace \neg \isInList{\compileLabel{s'}{\ExprStmt'}{e'} }{i_j}   \wedge \\
		       \Myspace  \isInList{\compileLabel{s'}{\ExprStmt'}{e'} }{i_k} \wedge \\
		       \Myspace s' \neq k   \wedge 
		       \Myspace i_j \execRel i_k )


  \end{array}$$ 

\end{compProp2}
The proof is done by induction over the structure of statements and expressions  and uses the previous lemma \ref{compile:prop:compProp1}

The following property establishes that the compiler preserves the substatement relation between statements and expressions.
\begin{compProp6}[Substatement and subexpression relation preserved]\label{compile:prop:compProp6}
For all statements $\ExprStmt_1$ and $\ExprStmt_2$ such that their compilations are 
 $\compileLabel{s_1}{\ExprStmt_1}{e_1} $ and that   $\compileLabel{s_2}{\ExprStmt_2}{e_2} $, if we have that 
$ \exists k,  s_1 \le k  \le e_1 \wedge s_2 \le k  \le e_2  $ then the following holds:

$$\begin{array}{l}
         \compileLabel{s_2}{\ExprStmt_2}{e_2}  \in \compileLabel{s_1}{\ExprStmt_1}{e_1}\\   
	 \vee \\
	 \compileLabel{s_1}{\ExprStmt_1}{e_1}  \in \compileLabel{s_2}{\ExprStmt_2}{e_2} 
\end{array}$$
\end{compProp6}

Now, we give a definition for a set of instructions such that they execute sequentially 
\begin{seqInstr}[Block of instructions] \label{seqInstr}
If the list of  instructions \\ $l  = \lbrack \ins{i_1} \ldots \ins{i_n} \rbrack$ in the compilation of method \methodd is such that 
 \begin{itemize}
              
      \item none of the instructions is a target of an instruction $\ins{i_j}$ which does not belong to $l$ except for $\ins{i_1}$
      \item none of the instructions in the set is a jump instruction, i.e. $\forall m, m = 1..k \Rightarrow \neg( \ins{i_m} \in  \{\goto, \ifCond\} )  $ 
      \item $  \forall j, i_1 <  j \le i_n , \neg \exists k \in \methodd.\body, \ins{k} \execRel^{l} \ins{j} $ 
 \end{itemize}

We denote such a list of instructions with $\ins{i_1};...;\ins{i_k}$

\end{seqInstr}


The next lemma states that the compilation of an expression $\expressionSrc$ results in
 a block of bytecode instructions.  
\begin{compProp3}[Compilation of expressions]\label{compile:prop:compProp3}
    For any expression $\expressionSrc$, starting label $s$ and end label $e$,
    the compilation $\compileLabel{s}{\expressionSrc}{e}$ is a block of bytecode instruction in the sense of Def. \ref{seqInstr}
   
\end{compProp3}

Following the definition \ref{seqInstr} of block of bytecode instructions, 
the property states that the compilation of an expression results in a list of instructions that cannot be jumped from outside its compilation 
except for the first instruction of the compilation. This follows from lemma \ref{compile:prop:compProp2}. 

Definition \ref{seqInstr} also requires that there are no jump instructions  in the list of instructions representing the  compilation of an expression.
This is established by induction over the structure of the expression.

The third condition in Def. \ref{seqInstr} states that  the compilation $\compileLabel{s}{\expressionSrc}{e}$ is such that 
  no instruction except $\ins{s}$ may be  a loop entry  in the sense of Def.  \ref{defLoop} in Chapter
\ref{wpGeneral}, Section \ref{prelim}. This is the case, as there are no jump instructions inside the compiled expression  and all the instructions inside an
expression are sequential \todo{this is not well explained}.

Our source language supports also exception handling. As we saw in the previous section, the compiler will keep track of the exception 
handlers by adding them in the exception handler table. We now establish that the elements in the exception handler table correspond to a statement
in the source language.

\begin{compProp7}[Exception handler element corresponds to a statement]\label{compile:prop:compProp7}
Every element  $ (s,e, eH, \mbox{\rm\texttt{Exc}} )$  in the exception handler table \methodd.\excHandlerTable 
  is such that exists a statement $\stmt$ such that $\compileLabel{s}{\stmt}{e}$


%Assume we have a method \methodd \ and the compilation of its body results in  $\stmt$ is $\compileLabel{s}{\stmt}{e}$ and exception
%handler table \methodd.\excHandlerTable. Then every element  $ (s,e, eH, \mbox{\rm\texttt{Exc}} )$ in \methodd.\excHandlerTable \ is
%such that there exists a statement $\stmt'$ such that  $\stmt' $ is a substatement of $\stmt$  such that the compilation of 
% $\stmt' $ is $\compileLabel{s}{\stmt'}{e}$
\end{compProp7} 
\textit{Proof}:
The proof is done by contradiction. From the compiler definition, we get that  elements are added in 
 \methodd.\excHandlerTable \ only in the cases of 
try catch and try finally statement compilation and that the guarded regions in the added elements correspond to statements.


In the rest of this subsection we will look at properties of the compiler which are a consequence of the upper properties.
We can establish also that the compilation of a statement $\stmt$ may  contain  cycles only if $\stmt$ is a cycle or contains
a substatement which is a cycle. 
\begin{compProp4}[Cycles in the control flow graph]\label{compile:prop:compProp4}  % cycles in bytecode only if the source has  
\todo{alternative formulation: say that the only loop entries are the first instructions of a loop body }
The compilation \\ $\compileLabel{s}{\stmt}{e}$ of a $\stmt$ may contain an instruction $\ins{k}$ which is a loop entry in the sense of definition 
\ref{deLoop} (i.e. there exists $\ins{j}$ such that $\ins{j} \execRel^{l} \ins{k}$ ) only if  $\stmt$ is a loop or contains 
 a substatement $\stmt'$ which is a loop statement and the following holds:
  $$\begin{array}{l}
                        \stmt = \\
             
	                \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} \\ \\ 
			\vee \\\\

                        \stmt[\stmt'] \wedge \\
			\stmt' = \\
             
	                \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \} \\ \\ 

                        \compileLabel{s}{   \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \}   }{e} = \\
			s: \goto \ e' + 1; \\
	                \compileLabel{s +  1}{\stmt}{e'}; \\
			 %\lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
			 \compileLabel{e' +  1}{\expressionSrcRel}{e  -1 };\\
			 e: \ifCond \ s +  1; \\  \\
                        \Myspace \Rightarrow k = e' +1 \wedge j = e'  
                
	           \end{array} 
               $$ 
	   
              
             

\end{compProp4}
 
%A consequence from this property is that it cannot be that the start of  a $\execRel^{l}$ edge is in the compilation of one statement $\stmt_1$
% and its end is in another statement $\stmt_2$.
Another property concerning cycles in the control flow graph is that all the instructions in a compilation$\compileLabel{s}{\stmt}{e}$   of a statement $\stmt 
$which target the instruction $\ins{e+1}$  are in the same execution relation with  $\ins{e+1}$,i.e. if  
$\ins{e+1}$ is a  loop entry either all are loop ends or none of them is:
\begin{compProp5}[Cycles in the control flow graph]\label{compile:prop:compProp5} 
 For every statement $\stmt$ its compilation $\compileLabel{s}{\stmt}{e}$ is such that 
$(\exists k, s \le k \le e, \ins{k} \execRel^{l} \ins{e+1} ) \iff (\forall k, s \le k \le e, \ins{k} \execRel \ins{e+1}  \Rightarrow \ins{k} \execRel^{l} \ins{e+1} ) $
\end{compProp5}


\todo{give the definition of the function  $\isStartExc{\ins{k}}$   }



\begin{compProp8}[Exception handler property for statements]\label{compile:prop:compProp8}
  For every statement $\stmt$ which is not a try catch  in method \methodd \  and  its substatement $\stmt'$, which we denote with $\stmt[\stmt']$   
 such that \\ $\neg \ ( \exists \stmt'', \stmt[\stmt''] \wedge \stmt''[\stmt']  ) $ we have that 
if their respective compilations are  $\compileLabel{s}{\stmt}{e}$ and  $\compileLabel{s'}{\stmt'}{e'}$ then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \\
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} 
   \end{array}
$$

\end{compProp8}
\textit{Proof}:
The proof is by contradiction. Assume this is not true, i.e.
 $$\begin{array}{l} \exists \stmt, \stmt' ,   \\
       \numConclusion{1}    \Myspace \stmt \neq \try \{ \ldots \} \catch \{ \ldots \} \wedge \\
       \numConclusion{2}   \Myspace  \stmt[\stmt'] \wedge \neg \ ( \exists \stmt'', \stmt[\stmt''] \wedge \stmt''[\stmt']  ) \wedge \\
       \numConclusion{3}  \Myspace  \compileLabel{s}{\stmt}{e} \wedge \\
       \numConclusion{4} \Myspace  \compileLabel{s'}{\stmt'}{e'} \wedge \\
       \numConclusion{5}  \Myspace \exists  \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} \neq \\
                                            \phantom{\exists \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable}    
\end{array}
$$

This means that there exists two elements $   (s_1,e_1, eH_1, \mbox{\rm\texttt{Exc}} ) $  and
$   (s_2,e_2, eH_2, \mbox{\rm\texttt{Exc}} )$  in the exception handler table of method \methodd \ \methodd.\excHandlerTable \  such that   : 
$$ \numConclusion{6}  \Myspace eH_1 \neq eH_2 $$
From lemma \ref{compile:prop:compProp7} we get that :

$$ \numConclusion{7}  \Myspace \begin{array}{l}
        \exists \stmt_1, s_1, e_1, \compileLabel{s_1}{\stmt_1}{e_1} \\
	\wedge \\
	\exists \stmt_2, s_2, e_2,\compileLabel{s_2}{\stmt_2}{e_2}
\end{array}	 $$


From the initial condition \numConclusion{2} we conclude that 
$$\numConclusion{8} \Myspace \compileLabel{s_1}{\stmt_1}{e_1} \notin   \compileLabel{s}{\stmt}{e} $$

%From \numConclusion{7}, it follows that the exception handler for $e'$ is obligatory outside $\compileLabel{s}{\stmt}{e}$.

 Because $e \in [s_2 \ldots e_2 ]  \wedge  e' \in [s_1 \ldots e_1 ] \wedge e,e' \in [s \ldots e]$, \numConclusion{8} by applying 
  Lemma \ref{compile:prop:compProp6}  we can conclude that

 $$  \begin{array}{l} 
          \compileLabel{s}{\stmt}{e} \in \compileLabel{s_1}{\stmt_1}{e_1} \in  \compileLabel{s_2}{\stmt_2}{e_2} \\
           \vee \\
	 \compileLabel{s}{\stmt}{e} \in   \compileLabel{s_2}{\stmt_2}{e_2} \in \compileLabel{s_1}{\stmt_1}{e_1}
 \end{array}$$	   

 In both of the cases and of the definition of \findExcHandlerOnly \ in Chapter \ref{opSem}, Section \ref{opSem:exc}  this means that 
$$ \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} $$
which is in contradiction with \numConclusion{6}.


A similar property can be established about expressions
 
\begin{compProp9}[Exception handler property for expressions]\label{compile:prop:compProp9}
  For every statement $\stmt$ which is not a try catch  in method \methodd \  and  its subexpression $\expressionSrc$, which we
 denote with $\stmt[\expressionSrc]$   
 such that $\neg \ ( \exists \stmt'', \stmt''[\expressionSrc] \wedge \stmt[\stmt'']  ) $ we have that 
if their respective compilations are  $\compileLabel{s}{\stmt}{e}$ and  $\compileLabel{s'}{\expressionSrc}{e'}$ and \numConclusion{2}
 then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \forall  i, s' \le i \le e' ,  \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \\
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{i}{\methodd.\excHandlerTable} 
   \end{array}
$$
\end{compProp9}

The last property concerns try catch statements
\begin{compProp10}[Exception handlers and try catch statements]\label{compile:prop:compProp10}
For ever try catch statement $ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \}  $ 
its compilation $$
\begin{array}{l} 
\compileLabel{s}{\stmt_1}{e'}; \\
                       e' + 1: \goto \ e + 1; \\
		  
                       \compileLabel{e' + 2 }{\stmt_2}{e };\\
		       % e: \goto \ e + 1; \\
		       \\ \\

 \end{array}$$
is such that the following holds 
$$\begin{array}{l} \forall \neg ( \mbox{\rm{\texttt{Exc}}} <: \excType ) \Rightarrow
 \Myspace   \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} =\\ 
 \Myspace   \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable}  \\
 \wedge
  \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e'+2 \\ 
 \end{array} $$



\end{compProp10}


%\todo{this is not sufficient. There must be established a property that the $\execRel^l$ is only in the compilation of while statements} 
% In the following, we  abstract
% from the labeling done by the compiler and we  will denote the compiler function with $ \lbrack \ \rbrack $.
% We assume that the compiler function $ \lbrack \ \rbrack $ does a labeling which has the above properties.
% Also, the notation for labeled instructions used here $ \ins{i} $ will be sometimes abbreviated just to the index of the instruction $ i $. 


%\begin{compProp2}[Compilation of statements ] \label{compProp2}
%  For any statement $\stmt$, the compiler will produce a sequence of bytecode instruction 
%  $\compileLabel{s}{\stmt}{e}$ such that
%  there may be no more than one instruction $ \ins{j} \in \compileLabel{s}{\stmt}{e}$, such that 
%  $ \ins{k} \execRel \ins{j} \wedge \neg ( \ins{k}  \ \in \  \compileLabel{s}{\stmt}{e} ) $
%\end{compProp2}
%The property states that 
%no more than one instruction in the compilation $\compileLabel{s}{\stmt}{e}$
%of the statement $\stmt$ may be targeted by an instruction 
%which does not belong to  $\compileLabel{s}{\stmt}{e}$.







%Another property of the compiler is that compilation of expressions result always 
%in a block of sequential instructions as defined in the above def. \ref{seqInstr}

%\begin{compProp3}[Compilation of expressions] \label{compProp3}
%  For any expression $\expressionSrc$,
%  starting label $s$ and end label $e$, the compiler
%  will produce a sequence of bytecode instructions
%  $ \compileLabel{s}{\expressionSrc}{e} =  \ins{s} ;...; \ins{e} $
%\end{compProp3}


%The property can be established by structural induction of the compilation $\compile{\expression}$

 
