%\newtheorem{compProp0}{Property}[subsection]

\newtheorem{compProp}{Lemma}[subsection]
%\newtheorem{compProp1}[compProp0]{Property} % control flow statement property 
%\newtheorem{compProp2}[compProp0]{Property} % control flow statement property  
%\newtheorem{compProp11}[compProp0]{Property}
%\newtheorem{compProp6}[compProp0]{Property} % a substatement is compiled in substatement
%\newtheorem{compProp3}[compProp0]{Property} % expression property
%\newtheorem{compProp7}[compProp0]{Property} % every element in the exception handler 
                                            % table corresponds to a statement

%\newtheorem{compProp8}[compProp0]{Property} % if st' is a direct substatement of st then [s',st',e'] and  [s,st,e]
                                            % are such that for all Exc, findExcH( e, Exc )  = findExcH( e', Exc ) 
					    % if st != try {} catch() {}
%\newtheorem{compProp9}[compProp0]{Property}
%\newtheorem{compProp10}[compProp0]{Property}
%\newtheorem{compProp4}[compProp0]{Property} % 
%\newtheorem{compProp5}[compProp0]{Property} %
\newtheorem{seqInstr}{Definition}[subsection]

\newcommand{\isStartExc}[1]{\mbox{\rm\textit{isExcHandlerStart}}(#1)}

\subsection{Properties of the compiler function}\label{compile:prop}
In this subsection, we will focus on the properties of the  bytecode produced by the compiler presented above.
These properties although a straightforward consequence of the compiler definition
 are actually important for establishing formally the equivalence between source and bytecode 
proof obligations. Note that a standard non-optimizing Java compiler generates code which respects them and thus, we
do not restrict at all the compilation process.  We outline the categories of properties that we shall consider:
\begin{itemize}
     
     \item compilation of a statement (expressions) may contain instructions which either target instructions inside the compilation of a statement or  the 
           first instruction of the next statement, if there is next statement (Properties \ref{compile:prop:compProp0}).
     
     \item expressions are compiled into a sequence of instructions which does not contains jumps (Property \ref{compile:prop:compProp3}).
     
     %\item substatement relation preserved by the compiler (Properties \ref{compile:prop:compPropSubstmt}, \ref{compile:prop:compProp6}).

     \item a compilation of a source statement contains cycles only if the source statement contains cycles (Property \ref{compile:prop:compProp4}).
     
     \item exception handler preservation (Properties \ref{compile:prop:compProp8}, \ref{compile:prop:compProp9},  \ref{compile:prop:compProp10}).
     
\end{itemize}




In the following, we use the notation $\ExprStmt$ when we refer both to statements $\stmt$ and expressions $\expressionSrc$.
In the following, we take a closer look at the properties in question.
 
 The first property that we observe is that the last instruction $\ins{e}$ in the compilation
 $\compileLabel{s}{\stmt}{e}$  of a statement $\stmt$ is always in execution relation
 (see Fig. \ref{defEdge} for the definition of execution relation between instructions) with the
 instruction $\ins{e + 1}$.

In order to get a precise idea of what we mean, the reader may take a look at the example in Fig. \ref{pogEquiv:compile:prop}.
There, we can remark that the last instruction of the compilation of the statement \lstinline!int sqr  = 0;! is the instruction \lstinline!1 store sqr! 
and that it is in execution relation with the instruction at index \lstinline!2!. The same holds also for the compilation of the \lstinline!if!
statement where the last instruction  in its compilation is \lstinline!12 nop! and is  in execution relation with \lstinline!13 const 0!.
Actually, the compilation of every statement or expression in the example has this property.

\begin{compProp}[Compilation of statements and expressions]\label{compile:prop:compProp0}
 For any statement or expression $\ExprStmt$ which does not terminate on \return or \athrow, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\ExprStmt}{e}$ such that  instruction  $e+1$ may execute after
    $e$, i.e.   $ \ins{e} \execRel \ins{e+1}$
\end{compProp}





 


Next, we give a definition for a set of instructions such that they execute sequentially which will be used for 
establishing afterwards the properties of the bytecode instructions resulting in expression compilation.
 
\begin{seqInstr}[Block of instructions] \label{seqInstr}
We say that the list of instructions  $l  = \lbrack \ins{i_1} \ldots \ins{i_n} \rbrack$ is a block of instructions
 in the compilation of method \methodd{} if 
 \begin{itemize}
      \item none of the instructions is a target of an instruction $\ins{i_j}$ which does not belong to $l$ except for $\ins{i_1}$
      \item none of the instructions in the set is a jump instruction, a \return{} or an \athrow{} instruction
            i.e. %$\forall m, m = 1..k \Rightarrow \neg( \ins{i_m} \in  \{\goto, \ifCond, \return, \athrow \} )  $  
                $  \forall j, i_1 \le  j < i_n ,   ( \ins{j} \execRel \ins{j + 1} ) $ 
      \item none of the instructions except for the first one can be a loop entry in the sense of Def. \ref{defEdge}
             $  \forall j, i_1 \le  j < i_n , \neg  \ ( \ins{j} \execRel^{l} \ins{j + 1} ) $ 
 \end{itemize}

We denote such a list of instructions with $\ins{i_1};...;\ins{i_n}$

\end{seqInstr}


The next lemma states that the compilation of an expression $\expressionSrc$ results in
 a block of bytecode instructions.  For instance, consider the compilation of the expression \lstinline!sqr + 2*s + 1;! in Fig. \ref{pogEquiv:compile:prop}  
which comprised between instructions 16-22. Instructions  16-22 satisfy the three points from the above definition.
\begin{compProp}[Compilation of expressions]\label{compile:prop:compProp3}
    For any expression $\expressionSrc$, starting label $s$ and end label $e$,
    the compilation $\compileLabel{s}{\expressionSrc}{e}$ is a block of bytecode instruction in the sense of Def. \ref{seqInstr}
   
\end{compProp}


The following statement concerns  loops. In particular, it says  that a cycle appears in the compilation of a statement  $\stmt$  only if $\stmt$ contains a loop.
For instance, we can  see in Fig. \ref{pogEquiv:compile:prop} that the unique cycle in the bytecode corresponds to the source loop and that the 
instruction marked with \lstinline!LOOP END! and the instruction marked with \lstinline!LOOP ENTRY! correspond respectively to the end instruction   in the 
compilation of the source loop body   and to start instruction in the compilation of the compilation of the \lstinline!while! test. 
Stated formally, we get the following property. 

\begin{compProp}[Cycles in the control flow graph]\label{compile:prop:compProp4}  % cycles in bytecode only if the source has  

The compilation \\ $\compileLabel{s}{\stmt}{e}$ of a $\stmt$ may contain an instruction $\ins{k}$ and \ins{j}  which are respectively 
a loop entry and a loop end  in the sense of Def.
\ref{defLoop} (i.e. there exists $\ins{j}$ such that $\ins{j} \execRel^{l} \ins{k}$ ) if and only if  $\stmt$  contains 
 a substatement $\stmt'$ which is a loop statement:
 $$ \ins{j} = \loopStart{\stmt'}  - 1 \wedge  \ins{k} = \loopStart{\stmt'}  $$


 % and the following holds:
 %  $$\begin{array}{l}
 % %                        \substatement{\stmt}{\stmt'} \wedge \\
 %			\stmt' = 
  %                      \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt'' \} \\ \\ 
 %
 %                        \compileLabel{s}{   \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt'' \}   }{e} = \\
 %			s: \goto \ e' + 1; \\
 %	                \compileLabel{s +  1}{\stmt''}{e'}; \\
 %			 %\lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
 %			 \compileLabel{e' +  1}{\expressionSrcRel}{e  -1 };\\
 %			 e: \ifCond \ s +  1; \\  \\
 %                        \Myspace \Rightarrow k = e' +1 \wedge j = e'  
  %               
 %	           \end{array} 
  %              $$ 
	   
              
             

\end{compProp}
 
% A consequence from this property is that it cannot be that the start of  a $\execRel^{l}$ edge is in the compilation of one statement $\stmt_1$
%% and its end is in another statement $\stmt_2$.
%Another property concerning cycles in the control flow graph is that all the instructions in a compilation$\compileLabel{s}{\stmt}{e}$   of a statement $\stmt $which target the instruction $\ins{e+1}$  are in the same execution relation with  $\ins{e+1}$,i.e. if  
%$\ins{e+1}$ is a  loop entry either all are loop ends or none of them is:
%\begin{compProp}[Cycles in the control flow graph]\label{compile:prop:compProp5} 
% For every statement $\stmt$ its compilation $\compileLabel{s}{\stmt}{e}$ is such that 
%$(\exists k, s \le k \le e, \ins{k} \execRel^{l} \ins{e+1} ) \iff (\forall k, s \le k \le e, \ins{k} \execRel \ins{e+1}  \Rightarrow \ins{k} \execRel^{l} \ins{e+1} ) $
%\end{compProp}


Next, we shall focus on properties which concern the compilation of exception handlers. 
As we saw in the previous section, the compiler keeps track of the exception 
handlers by adding them in the exception handler table. 

We illustrate this by the example in Fig. \ref{pogEquiv:compile:prop:exc} which shows both the bytecode (on the left) and source code(on the right)
 of the method \lstinline!abs!.
The method \lstinline!abs! gets as parameter \lstinline!n! an object reference of class type  \lstinline!Number!. The class  \lstinline!Number!
models a integer numbers where the value of the integer represented by an instance of the class is stored in field \lstinline!value!. 
 Thus, method  \lstinline!abs! returns  the absolute value of the integer field \lstinline!n.value! of the parameter \lstinline!n!. The absolute value is stored
in the method local variable \lstinline!abs!. This is implemented by the if statement. However, in the test of the if statement, we dereference
 the parameter  \lstinline!n! ignoring whether it is \Mynull{} or not. That is why the \lstinline!if! statement may throw a \NullPointerExc{} and thus,
 it is wrapped in a \lstinline!try catch! block. 
The exception handler (the statement following the \lstinline!catch! keyword)
stores \lstinline!-1! in the local variable \lstinline!abs! which stands for that the 
the object  \lstinline!n! is \Mynull.   
Finally the method returns the value of the local variable \lstinline!abs!.

 The exception handler table  \lstinline!abs!.\ExcHandler{}  contains one element which describes the unique exception handler
in the method. In particular, it states that the region between 2 and 20 is protected from \NullPointerExc{} by the bytecode starting at index 22.
 We may remark that the region between 2 and 20 corresponds to the compilation of the \lstinline!if! statement. 

 \todo{change the example}
  \begin{figure}[ht!]
\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
\lstinline!int abs(Number n)!    & \lstinline!int abs(Number n )! \\
				     
\lstinline!0 const 0!                 &  \lstinline!int abs = 0;!\\
\lstinline!1 store abs!		      & \\ 
				      & \\ &\\ &\\
				      & \lstinline!try {!\\
\lstinline!2 load n!                  & \Myspace \lstinline!if (n.value >= 0)!\\
\lstinline!3 getfield Number.value! & \\
\lstinline!4 iflt 9!                  & \\
                                      & \\ &\\ &\\
\lstinline!5 load n!                  & \Myspace\Myspace\lstinline!else {abs = - n.value;}!\\			
\lstinline!6 getfield Number.value! & \\
\lstinline!7 store abs!                 & \\
                                      & \\ &\\ &\\
\lstinline!8 goto 21!		      & \\
                                      & \\ &\\ &\\
\lstinline!9 load n!		      & \Myspace\Myspace\lstinline!then {abs = n.value;}!\\
\lstinline!18 getfield Number.value!&   \\
\lstinline!19 neg!                    & \\
\lstinline!20 store abs!	      & \\

\lstinline!21 nop!		      & \\
                                      & \\ &\\ &\\
\lstinline!22 goto 26!		      & \\
                                      & \lstinline!}!\\
                                      & \lstinline!catch(NullPointerExc e) {!\\
\lstinline!23 store e!		      & \Myspace\lstinline!abs = -1! \\
\lstinline!24 const -1!	              & \\
\lstinline!25 store abs!              & \\
                                      & \lstinline!}!\\
\lstinline!26 nop! 
 & \\ &\\ &\\

\lstinline!27 load abs! & \lstinline!return abs! \\			     
\lstinline!28 return! & \\ 
 & \\ &\\ &\\
\lstinline!abs!.\ExcHandler =  & \\
         \begin{tabular}{lll}
	                               \pcStart &=& 2\\
				       \pcEnd &=& 21\\
				        \pcHandler &=&22\\
					\exc  &=& \NullPointerExc
                               \end{tabular}   & 
    \end{tabular}
}

  \caption{\sc  relation between bytecode and source code of method \lstinline!abs! }
  \label{pogEquiv:compile:prop:exc}
\end{frameit}  
\end{figure}


This illustrates the next property of the compiler. More particularly, it states  that the fields  \pcStart{} and  \pcEnd{}  of an 
 exception handler element are the start and end indexes of the compilation of a source statement in the original source program and this statement 
is the try statement of either try finally or try catch statement.

%In the rest of this subsection we will look at properties of the compiler which are a consequence of the upper properties.



%\todo{give the definition of the function  $\isStartExc{\ins{k}}$   }


In the following,  we will need the notion of substatement relation.
 For denoting that  $\ExprStmt'$ is a substatement of  $\ExprStmt$ (i.e.$\ExprStmt'$ is contained in  $\ExprStmt$  )
we shall use the notation $\substatement{\ExprStmt }{\ExprStmt'}$. 
We also use the notion of a direct substatement(subexpression) which  means the following:

\begin{seqInstr}[Direct substatement(subexpression)] \label{pogCompile:compile:prop:direct}
 The statement (expression) $\ExprStmt'$ is a direct substatement (subexpression) of  $\ExprStmt$
if $\ExprStmt'$  is contained in $\ExprStmt$ 
and there does not exist  $\ExprStmt''$  such that  $\ExprStmt''$ is contained in   $\ExprStmt$ and  $\ExprStmt'$ is contained in  $\ExprStmt''$.
For denoting that  $\ExprStmt'$ is a direct substatement of  $\ExprStmt$
we use the notation $\strictsubstatement{\ExprStmt }{\ExprStmt'}$.
\end{seqInstr}
Direct substatements are also substatements. But the contrary does not always hold. 
For, instance if we have $\stmt = \try \{ \stmt_1;\stmt_2 \} \catch ( \Exc \ e ) \{ \stmt_3\} $,
 the statement $\stmt_1;\stmt_2  $ is a direct substatement of $\stmt$ and is also its substatement. However,   $\stmt_2  $ is a substatement of    $\stmt$
but is not a direct substatement of $\stmt$.

The following property states that the exceptions thrown by a 
statement which is not a try catch and the  exceptions thrown by its direct substatement
will be handled by the same exception handler, i.e. the result of the function \findExcHandlerOnly{} will be the same 
if we pass as an argument their respective last instructions. Note that we can establish this property only
for direct substatement because  substatements could be contained in try catch substatements and
 thus, they   break the property.

 For instance, consider in Fig. \ref{pogEquiv:compile:prop:exc} 
the bytecode version of the program. The last  instruction in the compilation of the \lstinline!if! statement is the 
instruction at index 21 and the last instruction in the compilation of the \lstinline!else! branch is 7. 
For any exception type \mbox{\rm\tt{Exc}}, the application \findExcHandler{\mbox{\rm\tt{Exc}} }{21}{\lstinline!abs!.\ExcHandler} returns the same value  as
\findExcHandler{\mbox{\rm\tt{Exc}} }{7}{\lstinline!abs!.\ExcHandler}. 

\begin{compProp}[Exception handler property for statements]\label{compile:prop:compProp8}
 Assume that we have a statement  $\stmt$  which is not a try catch  neither a try finally statement in method \methodd. Assume that 
  statement $\stmt'$ is its direct substatement, i.e. 
$\strictsubstatement{\stmt}{\stmt'} $. 
Then the exception handlers for the instruction points $e$ and $e'$ are the same:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = 
	 \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} 
   \end{array}
$$


\end{compProp}
%The proof is done in Appendix \ref{appendix:compile:prop}.

A similar property can be established for expressions. This time however, the property holds for
every instruction in the compilation of an expression.
 
\begin{compProp}[Exception handler property for expressions]\label{compile:prop:compProp9}
  For every expression $\expressionSrc$,
  for every instruction $i$ inside the compilation  $\compileLabel{s}{\expressionSrc}{e}$,
  any exception type \mbox{\rm\tt{Exc}} thrown by  $i$  will be handled by the same exception handler 
  as in the case where \mbox{\rm\tt{Exc}}   is thrown by the last instruction $e$ in the compilation, i.e.
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \forall  \ i, s \le i < e , 
	   \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = 
	  \findExcHandler{\mbox{\rm\tt{Exc}} }{i}{\methodd.\excHandlerTable} 
   \end{array}
$$
\end{compProp}

The next property states that a try catch statement is such that $ \try \ \{ \stmt_1 \} $ $ \catch \ (\excType \ \var )\{ \stmt_2 \}  $ 
any exception \texttt{E} which is a subtype of \excType{} and thrown by  the last instruction in the compilation of the try statement $ \stmt_1 $ is handled by the 
compilation of the exception handler $\stmt_2$. Moreover, an 
 an exception \texttt{E'} which is not a subtype of \excType{} thrown by the  last instruction in the compilation of $\stmt_1$
or the last instruction  in the compilation of $\stmt_2$ will be handled by the same exception handler. 

For instance, the last instruction in the compilation of the try catch statement  in Fig. \ref{pogEquiv:compile:prop:exc} 
is the instruction at index 26 and the last instruction in the compilation of the try statement is the instruction at index 21. 
From the exception handler, we can see that any exception except \NullPointerExc{} which might be thrown from these instructions 
will be handled in the same way. 
 
\begin{compProp}[Exception handlers and try catch statements]\label{compile:prop:compProp10}
For every try catch statement $ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \}  $ 
whose compilation  results in 
$ \compileLabel{s}{\stmt_1}{e'}; e' + 1: \goto \ e;  $ $\compileLabel{e' + 2 }{\stmt_2}{e - 1}; e: \nop$
and modifies the exception handler table  
	$\addExceptionTable{\methodd}{ s }{ e'  }{ e' + 2 }{\excType} $
is such that the following holds 
$$\begin{array}{l} \forall \mbox{\rm{\texttt{Exc}}},  \neg ( \mbox{\rm{\texttt{Exc}}} <: \excType ) \Rightarrow
  \left( \begin{array}{l}  
         \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} =\\ 
    \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable}  \\
   \end{array}\right) \\
   \wedge\\
  \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e'+2 \\ 
 \end{array} $$

\end{compProp}

The next property states establishes a similar condition for try finally statements.

\begin{compProp}[Exception handlers and try finally statements]\label{compile:prop:compProp10}
For every try finally statement $ \try \ \{ \stmt_1 \} \ \finally \ \{ \stmt_2 \}  $ 
whose compilation  results in \\
$  \compileLabel{s}{\stmt_1}{e'}; \  \compileLabel{e'+1}{\stmt_2}{e''}; \ e''+1  : \goto \ e; \  e'' +  2: \store \ l; \ 
\compileLabel{e'' + 3}{\stmt_2}{e - 3};\  e - 2 :\load \ l;\  e - 1: \athrow ;\  e: \nop$
and modifies the exception handler table $\addExceptionTable{\methodd}{ s }{  e' }{ e''+2  }{ \Exception }$
is such that the following holds 
$$\begin{array}{l} \forall \mbox{\rm{\texttt{Exc}}}  \Rightarrow
  \left(\begin{array}{l}  
         \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} =\\ 
	  \findExcHandler{\mbox{\rm\tt{Exc}} }{e-3}{\methodd.\excHandlerTable}=  \\
	    \findExcHandler{\mbox{\rm\tt{Exc}} }{e''}{\methodd.\excHandlerTable}
   \end{array}\right) \\
   \wedge\\
  \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e''+2 \\ 
 \end{array} $$



\end{compProp}

%\todo{this is not sufficient. There must be established a property that the $\execRel^l$ is only in the compilation of while statements} 
% In the following, we  abstract
% from the labeling done by the compiler and we  will denote the compiler function with $ \lbrack \ \rbrack $.
% We assume that the compiler function $ \lbrack \ \rbrack $ does a labeling which has the above properties.
% Also, the notation for labeled instructions used here $ \ins{i} $ will be sometimes abbreviated just to the index of the instruction $ i $. 


%\begin{compProp2}[Compilation of statements ] \label{compProp2}
%  For any statement $\stmt$, the compiler will produce a sequence of bytecode instruction 
%  $\compileLabel{s}{\stmt}{e}$ such that
%  there may be no more than one instruction $ \ins{j} \in \compileLabel{s}{\stmt}{e}$, such that 
%  $ \ins{k} \execRel \ins{j} \wedge \neg ( \ins{k}  \ \in \  \compileLabel{s}{\stmt}{e} ) $
%\end{compProp2}
%The property states that 
%no more than one instruction in the compilation $\compileLabel{s}{\stmt}{e}$
%of the statement $\stmt$ may be targeted by an instruction 
%which does not belong to  $\compileLabel{s}{\stmt}{e}$.







%Another property of the compiler is that compilation of expressions result always 
%in a block of sequential instructions as defined in the above def. \ref{seqInstr}

%\begin{compProp3}[Compilation of expressions] \label{compProp3}
%  For any expression $\expressionSrc$,
%  starting label $s$ and end label $e$, the compiler
%  will produce a sequence of bytecode instructions
%  $ \compileLabel{s}{\expressionSrc}{e} =  \ins{s} ;...; \ins{e} $
%\end{compProp3}


%The property can be established by structural induction of the compilation $\compile{\expression}$

 
