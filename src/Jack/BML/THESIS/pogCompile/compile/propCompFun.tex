%\newtheorem{compProp0}{Property}[subsection]

\newtheorem{compProp}{Lemma}[subsection]
%\newtheorem{compProp1}[compProp0]{Property} % control flow statement property 
%\newtheorem{compProp2}[compProp0]{Property} % control flow statement property  
%\newtheorem{compProp11}[compProp0]{Property}
%\newtheorem{compProp6}[compProp0]{Property} % a substatement is compiled in substatement
%\newtheorem{compProp3}[compProp0]{Property} % expression property
%\newtheorem{compProp7}[compProp0]{Property} % every element in the exception handler 
                                            % table corresponds to a statement

%\newtheorem{compProp8}[compProp0]{Property} % if st' is a direct substatement of st then [s',st',e'] and  [s,st,e]
                                            % are such that for all Exc, findExcH( e, Exc )  = findExcH( e', Exc ) 
					    % if st != try {} catch() {}
%\newtheorem{compProp9}[compProp0]{Property}
%\newtheorem{compProp10}[compProp0]{Property}
%\newtheorem{compProp4}[compProp0]{Property} % 
%\newtheorem{compProp5}[compProp0]{Property} %
\newtheorem{seqInstr}{Definition}[subsection]

\newcommand{\isStartExc}[1]{\mbox{\rm\textit{isExcHandlerStart}}(#1)}

\subsection{Properties of the compiler function}\label{compile:prop}
In this subsection, we will focus on the properties of the  bytecode produced by the compiler presented above.
These properties although a straightforward consequence of the compiler definition
 are actually important for establishing formally the equivalence between source and bytecode 
proof obligations. Note that a standard non-optimizing Java compiler generates code which respects them and thus, we
do not restrict at all the compilation process.  We outline the categories of properties that we shall consider:
\begin{itemize}
     
     \item compilation of a statement (expressions) may contain instructions which either target instructions inside the compilation of a statement or  the 
           first instruction of the next statement, if there is next statement (Properties \ref{compile:prop:compProp0}).
     
     \item expressions are compiled into a sequence of instructions which does not contains jumps (Property \ref{compile:prop:compProp3}).
     
     %\item substatement relation preserved by the compiler (Properties \ref{compile:prop:compPropSubstmt}, \ref{compile:prop:compProp6}).

     \item a compilation of a source statement contains cycles only if the source statement contains cycles (Property \ref{compile:prop:compProp4}).
     
     \item exception handler preservation (Properties \ref{compile:prop:compProp8}, \ref{compile:prop:compProp9},  \ref{compile:prop:compProp10}).
     
\end{itemize}




In the following, we use the notation $\ExprStmt$ when we refer both to statements $\stmt$ and expressions $\expressionSrc$.
In the following, we take a closer look at the properties in question.
 
 The first property that we observe is that the last instruction $\ins{e}$ in the compilation
 $\compileLabel{s}{\stmt}{e}$  of a statement $\stmt$ is always in execution relation
 (see Fig. \ref{defEdge} for the definition of execution relation between instructions) with the
 instruction $\ins{e + 1}$.

In order to get a precise idea of what we mean, the reader may take a look at the example in Fig. \ref{pogEquiv:compile:prop}.
There, we can see that the last instruction of the compilation of the statement \lstinline!int sqr  = 0;! is the instruction \lstinline!1 store sqr! 
and that it is in execution relation with the instruction at index \lstinline!2 const 0!. The same holds also for the compilation of the \lstinline!if!
statement where the last instruction  in its compilation is \lstinline!11 store v! and is  in execution relation with \lstinline!12 const 0!.
Actually, the compilation of every statement or expression in the example has this property.

\begin{compProp}[Compilation of statements and expressions]\label{compile:prop:compProp0}
 For any statement or expression $\ExprStmt$ which does not terminate on \return, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\stmt}{e}$ such that 
     $$ \ins{e} \execRel \ins{e+1}$$
\end{compProp}
The proof is trivial and is by case analysis of the compiled statements.


 


Next, we give a definition for a set of instructions such that they execute sequentially which will be used for 
establishing afterwards the properties of the bytecode instructions resulting in expression compilation.
 
\begin{seqInstr}[Block of instructions] \label{seqInstr}
We say that the list of instructions  $l  = \lbrack \ins{i_1} \ldots \ins{i_n} \rbrack$ is a block of instructions
 in the compilation of method \methodd{} if 
 \begin{itemize}
      \item none of the instructions is a target of an instruction $\ins{i_j}$ which does not belong to $l$ except for $\ins{i_1}$
      \item none of the instructions in the set is a jump instruction, a \return{} or an \athrow instruction
            i.e. $\forall m, m = 1..k \Rightarrow \neg( \ins{i_m} \in  \{\goto, \ifCond, \return, \athrow \} )  $ 
      \item $  \forall j, i_1 \le  j < i_n , \neg  \ ( \ins{j} \execRel^{l} \ins{j + 1} ) $ 
 \end{itemize}

We denote such a list of instructions with $\ins{i_1};...;\ins{i_n}$

\end{seqInstr}


The next lemma states that the compilation of an expression $\expressionSrc$ results in
 a block of bytecode instructions.  For instance, consider the compilation of the expression \lstinline!sqr + 2*s + 1;! in Fig. \ref{pogEquiv:compile:prop}  
 comprised between instructions 16-21. Instructions  16-21 satisfy the three points from the above definition.
\begin{compProp}[Compilation of expressions]\label{compile:prop:compProp3}
    For any expression $\expressionSrc$, starting label $s$ and end label $e$,
    the compilation $\compileLabel{s}{\expressionSrc}{e}$ is a block of bytecode instruction in the sense of Def. \ref{seqInstr}
   
\end{compProp}


The following two statements concern the loops on bytecode and source. 
In particular, we want that a cycle appears in the compilation of a statement  $\stmt$  only if it contains a loop (or is itself a loop).
For instance, we can  see in Fig. \ref{pogEquiv:compile:prop} that the unique cycle in the bytecode corresponds to the source loop and that the 
instruction marked with \lstinline!LOOP END! and the instruction marked with \lstinline!LOOP START! correspond respectively to the end instruction   in the 
compilation of the source loop body   and to start instruction in the compilation of the compilation of the \lstinline!while! test. 
Stated formally, we get the following property. 

\begin{compProp}[Cycles in the control flow graph]\label{compile:prop:compProp4}  % cycles in bytecode only if the source has  
\todo{alternative formulation: say that the only loop entries are the first instructions of a loop body }
The compilation \\ $\compileLabel{s}{\stmt}{e}$ of a $\stmt$ may contain an instruction $\ins{k}$ and \ins{j}  which are respectively 
a loop entry and a loop end  in the sense of Def.
\ref{defLoop} (i.e. there exists $\ins{j}$ such that $\ins{j} \execRel^{l} \ins{k}$ ) if and only if  $\stmt$  contains 
 a substatement $\stmt'$ which is a loop statement:
 $$ \ins{j} = \loopStart{\stmt'}  - 1 \wedge  \ins{k} = \loopStart{\stmt'}  $$
 % and the following holds:
 %  $$\begin{array}{l}
 % %                        \substatement{\stmt}{\stmt'} \wedge \\
 %			\stmt' = 
  %                      \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt'' \} \\ \\ 
 %
 %                        \compileLabel{s}{   \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt'' \}   }{e} = \\
 %			s: \goto \ e' + 1; \\
 %	                \compileLabel{s +  1}{\stmt''}{e'}; \\
 %			 %\lbrack  \compileSynt{\invariant} , \compileSynt{\modLoop} \rbrack \\ 
 %			 \compileLabel{e' +  1}{\expressionSrcRel}{e  -1 };\\
 %			 e: \ifCond \ s +  1; \\  \\
 %                        \Myspace \Rightarrow k = e' +1 \wedge j = e'  
  %               
 %	           \end{array} 
  %              $$ 
	   
              
             

\end{compProp}
 
A consequence from this property is that it cannot be that the start of  a $\execRel^{l}$ edge is in the compilation of one statement $\stmt_1$
 and its end is in another statement $\stmt_2$.
Another property concerning cycles in the control flow graph is that all the instructions in a compilation$\compileLabel{s}{\stmt}{e}$   of a statement $\stmt $which target the instruction $\ins{e+1}$  are in the same execution relation with  $\ins{e+1}$,i.e. if  
$\ins{e+1}$ is a  loop entry either all are loop ends or none of them is:
\begin{compProp}[Cycles in the control flow graph]\label{compile:prop:compProp5} 
 For every statement $\stmt$ its compilation $\compileLabel{s}{\stmt}{e}$ is such that 
$(\exists k, s \le k \le e, \ins{k} \execRel^{l} \ins{e+1} ) \iff (\forall k, s \le k \le e, \ins{k} \execRel \ins{e+1}  \Rightarrow \ins{k} \execRel^{l} \ins{e+1} ) $
\end{compProp}


Next, we shall focus on properties which concern the compilation of exception handlers. 
As we saw in the previous section, the compiler keeps track of the exception 
handlers by adding them in the exception handler table. 

We illustrate this by the example in Fig. \ref{pogEquiv:compile:prop:exc} which shows both the bytecode (on the left) and source code(on the right)
 of the method \lstinline!abs!.
The method \lstinline!abs! gets as parameter \lstinline!n! an object reference of class type  \lstinline!Number!. The class  \lstinline!Number!
models a integer numbers where the value of the integer represented by an instance of the class is stored in field \lstinline!value!. 
 Thus, method  \lstinline!abs! returns  the absolute value of the integer field \lstinline!n.value! of the parameter \lstinline!n!. The absolute value is stored
in the method local variable \lstinline!abs!. This is implemented by the if statement. However, in the test of the if statement, we dereference
 the parameter  \lstinline!n! ignoring whether it is \Mynull{} or not. That is why the \lstinline!if! statement may throw a \NullPointerExc{} and thus,
 it is wrapped in a \lstinline!try catch! block. 
The exception handler (the statement following the \lstinline!catch! keyword)
stores \lstinline!-1! in the local variable \lstinline!abs! which stands for that the 
the object  \lstinline!n! is \Mynull.   
Finally the method returns the value of the local variable \lstinline!abs!.

 The exception handler table  \lstinline!abs!.\ExcHandler{}  contains one element which describes the unique exception handler
in the method. In particular, it states that the region between 2 and 20 is protected from \NullPointerExc{} by the bytecode starting at index 22.
 We may remark that the region between 2 and 20 corresponds to the compilation of the \lstinline!if! statement. 

 \todo{change the example}
  \begin{figure}[ht!]
\begin{frameit}
  \scriptsize{
  \begin{tabular}{ll}
\lstinline!int abs(Number n)!    & \lstinline!int abs(Number n )! \\
				     
\lstinline!0 const 0!                 &  \lstinline!int abs = 0;!\\
\lstinline!1 store abs!		      & \\ 
				      & \\ &\\ &\\
				      & \lstinline!try {!\\
\lstinline!2 load n!                  & \Myspace \lstinline!if (n.value >= 0)!\\
\lstinline!3 getfield Number.value! & \\
\lstinline!4 iflt 9!                  & \\
                                      & \\ &\\ &\\
\lstinline!5 load n!                  & \Myspace\Myspace\lstinline!else {abs = - n.value;}!\\			
\lstinline!6 getfield Number.value! & \\
\lstinline!7 store abs!                 & \\
                                      & \\ &\\ &\\
\lstinline!8 goto 21!		      & \\
                                      & \\ &\\ &\\
\lstinline!9 load n!		      & \Myspace\Myspace\lstinline!then {abs = n.value;}!\\
\lstinline!18 getfield Number.value!& \\
\lstinline!19 neg!                   & \\
\lstinline!20 store abs!		      & \\
                                      & \\ &\\ &\\
\lstinline!21 goto 29!		      & \\
                                      & \lstinline!}!\\
                                      & \lstinline!catch(NullPointerExc e) {!\\
\lstinline!22 store e!		      & \Myspace\lstinline!abs = -1! \\
\lstinline!23 const -1!	              & \\
\lstinline!24 store abs!              & \\
                                      & \lstinline!}!\\
 & \\ &\\ &\\

\lstinline!28 load abs! & \lstinline!return abs! \\			     
\lstinline!29 return! & \\ 
 & \\ &\\ &\\
\lstinline!abs!.\ExcHandler =  & \\
         \begin{tabular}{lll}
	                               \pcStart &=& 2\\
				       \pcEnd &=& 20\\
				        \pcHandler &=&22\\
					\exc  &=& \NullPointerExc
                               \end{tabular}   & 
    \end{tabular}
}

  \caption{\sc  relation between bytecode and source code of method \lstinline!abs! }
  \label{pogEquiv:compile:prop:exc}
\end{frameit}  
\end{figure}


This illustrates the next property of the compiler. More particularly, it states  that the fields  \pcStart{} and  \pcEnd{}  of an 
 exception handler element are the start and end indexes of the compilation of a source statement in the original source program.

%In the rest of this subsection we will look at properties of the compiler which are a consequence of the upper properties.



%\todo{give the definition of the function  $\isStartExc{\ins{k}}$   }


The following property states that the exceptions thrown by a 
statement which is not a try catch and the  exceptions thrown by its strict substatement
will be handled by the same exception handler, i.e. the result of the function \findExcHandler{}{}{} will be the same 
if we pass as an argument their respective last instructions. Note that we can establish this property only
for strict subexpressions because  substatements could be contained in try catch substatements and
 thus, they   break the property.

 For instance, consider in Fig. \ref{pogEquiv:compile:prop:exc} 
the bytecode version of the program. The last  instruction in the compilation of the \lstinline!if! statement is the 
instruction at index 20 and the last instruction in the compilation of the \lstinline!else! branch is 7. 
For any exception type \mbox{\rm\tt{Exc}}, the application \findExcHandler{\mbox{\rm\tt{Exc}} }{20}{\lstinline!abs!.\ExcHandler} returns the same value  as
\findExcHandler{\mbox{\rm\tt{Exc}} }{7}{\lstinline!abs!.\ExcHandler}. 

\begin{compProp}[Exception handler property for statements]\label{compile:prop:compProp8}
  For every statement $\stmt$ which is not a try catch statement  in method \methodd \ for  any $\ExprStmt$ such that
  either$\ExprStmt$ is a  strict substatement of $\stmt$ 
  or is  an expression contained in  $\stmt$
if their respective compilations are  $\compileLabel{s}{\stmt}{e}$ and  $\compileLabel{s'}{\ExprStmt}{e'}$ then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \\
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} 
   \end{array}
$$

\end{compProp}
The proof is done in Appendix \ref{appendix:compile:prop}.

A similar property can be established for expressions. This time however, the property holds for
every instruction in the compilation of an expression.
 
\begin{compProp}[Exception handler property for expressions]\label{compile:prop:compProp9}
  For every expression $\expressionSrc$
% and its subexpression
% $\expressionSrc'$, i.e. $\substatement{\expressionSrc}{\expressionSrc'}$
 we have that if its respective compilation is  $\compileLabel{s}{\expressionSrc}{e}$
 then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \forall  \ i, s \le i < e ,  \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \\
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{i}{\methodd.\excHandlerTable} 
   \end{array}
$$
\end{compProp}

The next property states that a try catch statement is such that $ \try \ \{ \stmt_1 \} $ $ \catch \ (\excType \ \var )\{ \stmt_2 \}  $ 
any exception except \excType{} thrown by  the last instruction in the compilation of $ \stmt_1 $ or the last instruction of the compilation 
of $ \stmt_2$ are handled by the same exception handler. In particular, if the last instruction in the compilation of
 $ \stmt_1 $ throws an exception of type \excType \  it will be handled by the start instruction of the compilation of $\stmt_2 $.

For instance, the last instruction in the compilation of the the try catch statement  in Fig. \ref{pogEquiv:compile:prop:exc} 
is the instruction at index 27 and the last instruction in the compilation of the try statement is the instruction at index 20. 
We can see that any excepition except \NullPointerExc{} which might be thrown from these instructions 
will be handled in the same way. This in particular is evident if we look at the exception handler table.
 
\begin{compProp}[Exception handlers and try catch statements]\label{compile:prop:compProp10}
For every try catch statement $ \try \ \{ \stmt_1 \} \ \catch \ (\excType \ \var )\{ \stmt_2 \}  $ 
its compilation $\compileLabel{s}{\stmt_1}{e'}; e' + 1: \goto \ e + 1; \compileLabel{e' + 2 }{\stmt_2}{e };$
is such that the following holds 
$$\begin{array}{l} \forall \mbox{\rm{\texttt{Exc}}},  \neg ( \mbox{\rm{\texttt{Exc}}} <: \excType ) \Rightarrow
  \begin{array}{l}  
         \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} =\\ 
    \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable}  \\
   \end{array} \\
   \wedge\\
  \findExcHandler{\excType }{e'}{\methodd.\excHandlerTable} = e'+2 \\ 
 \end{array} $$



\end{compProp}



%\todo{this is not sufficient. There must be established a property that the $\execRel^l$ is only in the compilation of while statements} 
% In the following, we  abstract
% from the labeling done by the compiler and we  will denote the compiler function with $ \lbrack \ \rbrack $.
% We assume that the compiler function $ \lbrack \ \rbrack $ does a labeling which has the above properties.
% Also, the notation for labeled instructions used here $ \ins{i} $ will be sometimes abbreviated just to the index of the instruction $ i $. 


%\begin{compProp2}[Compilation of statements ] \label{compProp2}
%  For any statement $\stmt$, the compiler will produce a sequence of bytecode instruction 
%  $\compileLabel{s}{\stmt}{e}$ such that
%  there may be no more than one instruction $ \ins{j} \in \compileLabel{s}{\stmt}{e}$, such that 
%  $ \ins{k} \execRel \ins{j} \wedge \neg ( \ins{k}  \ \in \  \compileLabel{s}{\stmt}{e} ) $
%\end{compProp2}
%The property states that 
%no more than one instruction in the compilation $\compileLabel{s}{\stmt}{e}$
%of the statement $\stmt$ may be targeted by an instruction 
%which does not belong to  $\compileLabel{s}{\stmt}{e}$.







%Another property of the compiler is that compilation of expressions result always 
%in a block of sequential instructions as defined in the above def. \ref{seqInstr}

%\begin{compProp3}[Compilation of expressions] \label{compProp3}
%  For any expression $\expressionSrc$,
%  starting label $s$ and end label $e$, the compiler
%  will produce a sequence of bytecode instructions
%  $ \compileLabel{s}{\expressionSrc}{e} =  \ins{s} ;...; \ins{e} $
%\end{compProp3}


%The property can be established by structural induction of the compilation $\compile{\expression}$

 
