

\newtheorem{Compiler}{Definition}

\section{Compiler} \label{compile}

We now turn to specify a simple compiler from the source language presented in Section
\ref{source} into the bytecode language.

The compiler is the triple
 $$< \compile{ }_{\methodd}, \addExceptionTableOnly , \addLoopTableOnly >$$

 The first component in the triple is a  function $\compile{ }_{\methodd}$  which transforms statements and expressions
 into a sequence of bytecode instructions of the body of the method \methodd.
 Note that it does not perform any optimizations.

 The second component is the procedure  
\addExceptionTableOnly \ which adds elements in exception handler table of the compiled bytecode \methodd.
Note that the source language supports syntactic structure for encoding exception handlers while
 bytecode programs keep track of them via a data structure called exception handler table which describes how  regions 
in the bytecode are protected from exceptions.

 The third component of the compiler is the procedure
  \addLoopTableOnly \ which adds  loop
specifications in the loop specification table (see Chapter \ref{assertLang} section \ref{methExtend}).

The compiler presented here is realistic as the first and second component actually resemble closely 
a non-optimizing Java compiler and as we shall later in this section, the produced bytecode 
is very close to the bytecode produced by  a Java compiler.

The third component is not a typical part of a Java compiler. It actually corresponds to our 
\JMLtoBML{} compiler which compiles  loop invariants into class attributes and finds their respective place in the bytecode.  


In the following, in the next subsection \ref{pogEq:compile:excHandlers} we define the procedure for the compilation of exception handlers,
 in subsection \ref{pogEq:compile:loopInv},  we will present the procedure for compiling loop invariants.
 In  subsection
\ref{pogEq:compile:compExpr} 
we proceed with the definition of the compiler function $\compile{ }_{\methodd} $ for exressions and statements. 
The last subsection \ref{compile:prop} states the properties of the bytecode produced by the compiler.




% \subsection{Compilation of source values}
%In our modelisation, the source language presented in Section~\ref{source} keeps close to the Java 
%language semantics and the bytecode language defined in \ref{P05BSV} is close to the 
%Java Virtual Machine \cite{VMSpec}. This implies that our source language supports booleans while the bytecode
%language does not support them. In particular, values of type boolean on source level
% are represented as values of type integer. That's we formalise this fact by defining a compiler from source values 
%to bytecode values :
%
%$$
%\compile{\eval{\expressionSrc} } = 
%\left\{ \begin{array}{ll}
%1 &  if \expressionSrc == \Mytrue \\
%& \\
%0 &  if \expressionSrc == \Myfalse \\
%& \\
%\eval{\expressionSrc}  & else
%\end{array} \right.
%$$


