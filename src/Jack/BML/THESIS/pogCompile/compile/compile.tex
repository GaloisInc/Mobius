

\newtheorem{Compiler}{Definition}

\section{Compiler} \label{compile}

We now turn to specify a simple compiler from the source language presented in Section
\ref{source} into the bytecode language. The compiler does not perform any optimizations. 

The compiler is the triple
 $$< \compileLabel{*}{*}{*}, \addExceptionTableOnly , \addLoopTableOnly >$$
 The first element in the triple is a  function $\compile{}$ which transforms statements and expressions
 into a sequence of bytecode instructions, the second element is the procedure 
 \addExceptionTableOnly \ which  keeps track of the exception handlers. The third element of the compiler is the procedure
  \addLoopTableOnly \ which manages the compilation of loop
specification, namely loop invariants and the modified expressions.

In the following, in the next Section \ref{pogEq:compile:excHandlers} we define the procedure for exception handlers,
 in Section \ref{pogEq:compile:loopInv},  we will present the procedure for compiling loops and in  Sections 
\ref{pqogE:compile:compExpr} and  \ref{pogEq:compile:compCtrlStmt}
we will proceed with the definition of the function $\compile{}$ for exressions and statements.





% \subsection{Compilation of source values}
%In our modelisation, the source language presented in Section~\ref{source} keeps close to the Java 
%language semantics and the bytecode language defined in \ref{P05BSV} is close to the 
%Java Virtual Machine \cite{VMSpec}. This implies that our source language supports booleans while the bytecode
%language does not support them. In particular, values of type boolean on source level
% are represented as values of type integer. That's we formalise this fact by defining a compiler from source values 
%to bytecode values :
%
%$$
%\compile{\eval{\expressionSrc} } = 
%\left\{ \begin{array}{ll}
%1 &  if \expressionSrc == \Mytrue \\
%& \\
%0 &  if \expressionSrc == \Myfalse \\
%& \\
%\eval{\expressionSrc}  & else
%\end{array} \right.
%$$

\todo{the exception handler function}

