

\newtheorem{Compiler}{Definition}

\section{Compiler} \label{compile}

We now turn to specify a simple compiler from the source language presented in Section
\ref{source} into the bytecode language. The compiler does not perform any optimizations. 

The compiler is the triple
 $$< \compileLabel{*}{*}{*}, \addExceptionTableOnly , \addLoopTableOnly >$$
 The first element in the triple is a  function $\compile{}$ which transforms statements and expressions
 into a sequence of bytecode instructions. 
The second element is the procedure  \addExceptionTableOnly \ which compiles  the source exception handlers.
Note that that the source language supports syntactic structure for encoding exception handlers while
 bytecode programs keep track of them via a data structure which describes how  regions 
in the bytecode are protected from exceptions.

 The third element of the compiler is the procedure
  \addLoopTableOnly \ which manages the compilation of loop
specification, namely loop invariants and the modified expressions. 

In the following, in the next subsection \ref{pogEq:compile:excHandlers} we define the procedure for the compilation of exception handlers,
 in subsection \ref{pogEq:compile:loopInv},  we will present the procedure for compiling loop invariants.
 In  subsections 
\ref{pogEq:compile:compExpr} and  \ref{pogEq:compile:compCtrlStmt}
we proceed with the definition of the compiler function $\compile{}$ for exressions and statements. 
The last subsection \ref{compile:prop} states the properties of the bytecode produced by the compiler.




% \subsection{Compilation of source values}
%In our modelisation, the source language presented in Section~\ref{source} keeps close to the Java 
%language semantics and the bytecode language defined in \ref{P05BSV} is close to the 
%Java Virtual Machine \cite{VMSpec}. This implies that our source language supports booleans while the bytecode
%language does not support them. In particular, values of type boolean on source level
% are represented as values of type integer. That's we formalise this fact by defining a compiler from source values 
%to bytecode values :
%
%$$
%\compile{\eval{\expressionSrc} } = 
%\left\{ \begin{array}{ll}
%1 &  if \expressionSrc == \Mytrue \\
%& \\
%0 &  if \expressionSrc == \Myfalse \\
%& \\
%\eval{\expressionSrc}  & else
%\end{array} \right.
%$$



