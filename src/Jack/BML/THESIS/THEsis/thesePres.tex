\documentclass{beamer}
%\usetheme{default}

\usetheme{JuanLesPins}
\usepackage{listings}
\usepackage{times}

%\usepackage{xkeyval}
\usefonttheme{structurebold}

\usepackage[english]{babel}
%\usepackage{pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,graphics}\usepackage{pgflibraryshapes}
%\usepackage{graphics}
\usepackage{epsfig}
\usepackage{amsmath,amssymb}
\usepackage[latin1]{inputenc}


%%%%%%%%%%%%%%CARDIS%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}
\usepackage{graphics}
\usepackage{pgflibraryshapes}

\usepackage{listings}

\lstset{escapeinside={(*@}{@*)}}
\lstset{commentstyle=\color{blue!50!black}\textit,tabsize=2,keywordstyle=\color{green!50!black}}
\lstset{backgroundcolor=\color{lightgray!50}}
%\lstset{frame=trbl,frameround=DDDD}
\lstset{numbers=left, numberstyle=\footnotesize}

\usepackage{multirow}
\newcommand{\benchname}[1]{\texttt{#1}}


\setbeamercovered{dynamic}
%\beamertemplatenavigationsymbolsempty

\title[]{Java bytecode specification and verification}
\author[mariela.pavlova@sophia.inria.fr]{\textbf{Mariela Pavlova}}
\date[CARDIS'06]{Seventh Smart Card Research and Advanced Application IFIP Conference, April 19th, 2006}
\date[INRIA Sophia Antipolis ]{Supervisors Gilles Barthe and Lilian Burdy}

\AtBeginSection[]{\frame{\frametitle{Outline}\tableofcontents[current]}}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

%\newcommand{\stack}[1]{\mbox{\rm\textbf{st}}(#1)}% element on top stack 
%\newcommand{\counter}{\mbox{\rm\textbf{c}}}
%\newcommand{\locVar}[1]{\mbox{\rm{\textbf{reg}}}(#1) }


\input{cmd.tex}

\newcommand{\wpi}{\mbox{\rm\textit{wp}}}%\xspace}
\newcommand{\Pred}{\mbox{\rm\texttt{Pred}}}
%\newcommand{\ins} {\mbox{\rm\texttt{Ins}}}
\newcommand{\program}{\mbox{\rm\texttt{P}}}%\xspace}
\newcommand{\Method}{\mbox{\rm\texttt{Method}}}% method type \xspace}
\newcommand{\methodd}{\mbox{\rm\textsf{meth}}}

%\newcommand{\subst}[2]{[ #1 \backslash #2]}
%\newcommand{\requires}{\texttt{requires}}
%\newcommand{\ensures}{\texttt{ensures}}
%\newcommand{\annotation}{BML}
%\newcommand{\exsures}[1]{ \texttt{exsures} (#1)}
%\newcommand{\invariant}{ \texttt{invariant}}
%\newcommand{\variant}{ \texttt{variant}}
%\newcommand{\ghost}{ \texttt{Model}}
%\newcommand{\declare}{ \texttt{declare}}
%\newcommand{\assert}{ \texttt{assert}}
%\newcommand{\modifies}{ \texttt{modifies}}
%\newcommand{\ghostSet}{ \texttt{set}}
%\newcommand{\expression}{\mathcal{E}}
%\newcommand{\predicate}{\mathcal{P}}
% \input mydef.tex   



\section{Context}
\begin{frame}[shrink]
\frametitle{Mobile code}
Welcome to Imserba\bigskip\\

The best mobile phones portal and community in the world
Mobile phones Portal and Community\bigskip\\

Imserba brings you the latest mobile phones related \\
news, informations, stuffs you need for your phones. \\
No matter which phone you are using: Nokia, Sony\\
erricson, Siemens, Samsung, Motorola or anything\\ 
else, here you can find our best collection of ring- \\
tones, cell phone games, themes, screensavers,\\
backgrounds
\begin{center}
\includegraphics[width=4cm]{figs/beestje.ps}
\end{center}
\alert{Are you sure that you can trust these applications?}
\end{frame}


% \begin{frame}[shrink]\frametitle{Mobile code}
%   \begin{definition}{Mobile code}
%    small pieces of software automatically downloaded into
%    the user's workstation and executed without the user's initiation or knowledge.
%   \end{definition}
% \begin{center}
% % \epsfig{file=figs/mobileCode.eps}
% \end{center}
%  \end{frame}

% security trusted personal devices 
% are used for security sensitive applications, they manage confidential data
% and rely on limitted resources
\begin{frame}\frametitle{Security and trusted personal devices}
\begin{itemize}
\item Trusted personal devices: phones, smart cards, pda's, set
top boxes, \dots
\item Used for security-sensitive applications
\item Network connected
%\item Support for complex applications (contain a full JVM)
%\item Shift from hardware attacks to logical attacks
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Mobile code and Java}
 % the de facto language for web applications , mobile phones, what ever smart cards
The defacto language for web applications:
 \begin{itemize}
  \item platform independent execution framework
  % \item  % With the JVM available in most popular browsers, the concept of mobile code was born. 
  \item widely used in   smart card applications
 \end{itemize}

Security guarantees: 
\begin{itemize}
    \item type safety,  bytecode verifier
     \item sandbox mechanism
\end{itemize}

But malicious code may use also 
\begin{itemize}
     \item logical attacks
     \item resource attacks
       \item information leaks
\end{itemize}
\end{frame}



\begin{frame}\frametitle{Guaranteeing security with formal verification}
  \begin{itemize}
    \item Specification language 
         \begin{itemize}
	    \item formalism for expressing program properties
	  \end{itemize}
    \item Program calculi for reasoning about program correctness 
       \begin{itemize}
	  \item reasoning directly on the operational semantics
	  \item Hoare logic  
	  \item Verification condition generators
       \end{itemize}
    \item Decision procedure 
        \begin{itemize}
	    \item automatic decision procedures
	    \item interactive theorem prover
	\end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}[fragile,shrink]\frametitle{JML.Features}
  \begin{itemize}
     \item Contract based approach
             \begin{itemize}
	         \item preconditions
		 \item postconditions
	     \end{itemize}
       \item Class specification 
	 \begin{itemize}
	         \item object invariants
		 \item class history constraints
	     \end{itemize}
       \item Method annotations
	  \begin{itemize}
	         \item loop invariants 
		   \item assertions at particular program points
	    \end{itemize}

	         \item Special specification constructs  
	  \begin{itemize}
	         \item keywords \lstinline!\TYPE!, \lstinline!\result!
		 \item operators   \lstinline!\old!, \lstinline!\typeof!
		 \item ghost variables   \lstinline!//@ ghost int Memory!
	    \end{itemize}

  \end{itemize}

\end{frame}

\begin{frame}[fragile,shrink]\frametitle{JML.Example}
  \begin{lstlisting}[language=java]
//@ requires k >= 0 ;
//@ ensures \result == k*(k+1)/2;
public int sum (int k) {
  int sum = 0;		
  //@loop_modifies sum,i;
  //@loop_invariant i >= 0 && i<=k && 
  //@(sum == i*(i+1)/2);
  for  (int i = 0; i < k; i++ ) {
    sum = sum + i;
  } 	
  return sum;
}
\end{lstlisting} 
\end{frame}

 \begin{frame}\frametitle{Program calculi. Weakest precondition predicate transformers}
	% \begin{block}{Rules}
	   \begin{itemize}
	      \item handles possible side effects
		{\tiny $$ \wpSrcStmt{ \var = \expressionSrc_2}{\normalPostSrc }{ \excPostSrc } =
                  \wpSrcExpr{\expressionSrc_2 }{ 
				    \normalPostSrc \subst{\var}{v}   
				   }{ \excPostSrc}{v} 
		  $$ } 
	      \item exceptional termination 
		{\tiny $$   \begin{array}{l}  \wpSrcExpr{\expressionSrc.\fieldd  }{\normalPostSrc }{ \excPostSrc }{v}  = \\
	                        \wpSrcExpr{\expressionSrc }{%\\
			                  % \phantom{wpiSr} 
                                             %\begin{array}{l} 
						        v_1 \neq \Mynull \Rightarrow \normalPostSrc \subst{v}{v_1.\fieldd} %\\
			                                \wedge% \\
						        v_1 = \Mynull \Rightarrow%\\
							 %\Myspace 
							 %\left( \begin{array}{l} 
							      % \forall \freshVar, 
							     % \neg \instances(\freshVar) \wedge \\
							       %\freshVar \neq \Mynull \Rightarrow%\\ 
							       \excPostSrc(\NullPointerExc ) %\subst{\EXC}{\freshVar}
							 % \end{array}\right)
							        
		                                 % \end{array}
						   }{% \\ 
                                          % \phantom{wpiSrc}
					    \excPostSrc }{v_1}  
				\end{array} $$ }
	      
	  \end{itemize}
    %\end{block}
 \end{frame}


\begin{frame}[shrink]\frametitle{Architecture of a program verification tool}
\begin{center}
\epsfig{file=figs/sourceVerification.eps}
\end{center}

Several verification tools for Java exist:  The Loop tool, ESC/java, Krakatoa, Loop, Jive, the Key tool, JACK ...
\end{frame}



\begin{frame}\frametitle{History of JACK}
\begin{itemize}
\item Development started at Gemplus (Jan 2002 to April 2003)\\
Objective: Give developers tools that help them to provide and be
accountable for quality of their code
\begin{itemize}
\item Conform to specification requirements
\item Well-documented
\item Without bugs
\end{itemize}
\item Transfered to INRIA (September 2003)
\end{itemize}
\end{frame}



\begin{frame}\frametitle{Features of JACK}
\begin{itemize}
\item Tight integration with IDE Eclipse
\item JML used as annotation language
\item Support for Simplify (automatic) and Coq (interactive) prover
\item Special JACK view for verification condition browsing
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Developing an application in Eclipse}
\vspace*{-1.5em}
\includegraphics[height=\textheight]{figs/screen1.ps}
\end{frame}

% source not sufficient
\begin{frame}\frametitle{However...}
  Source verification not always suitable
   \begin{itemize}
     \item in mobile code  scenarios, the client receives only executable code   
     \item software audit which does not trust the compiler
   \end{itemize}  
\end{frame}



\begin{frame}\frametitle{Motivation}
  \begin{itemize}
   \item How  to  bring to bytecode programs the benefit from source verification?
     \item How to check mobile code against complex functional policies? 
  \end{itemize}
\end{frame}


\begin{frame}[fragile, shrink]\frametitle{Proposal}
\begin{center}
\epsfig{file=figs/toolSetPCC.eps}
\end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CONTRIBUTIONS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}\frametitle{Contributions}   
  \begin{itemize}
     \item Specification language for bytecode BML
     \item Compilation from source JML to BML specification
     \item Verification procedure for bytecode 
     \item Proof preserving compilation
\end{itemize}
\end{frame} 






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%BML%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



  \begin{frame}[shrink]\frametitle{BML.Design features}
   \begin{itemize}
      \item Corresponds to subset of JML
       \item  semantics - the same  as JML
     \item Java compiler independent
        \begin{itemize}
	    \item compilation process separate from Java compiler
	      
	  \end{itemize}
     \item Java Virtual Machine (JVM) compatibility 
       \begin{itemize}
	      \item compiled into user defined class attributes 
		 in compliance with the JVM specification
	  \end{itemize}     
      \item Syntax - does not support all the syntactic sugar in JML
   \end{itemize} 
\end{frame}



  \begin{frame}[shrink]\frametitle{BML. Restrictions}
   \begin{itemize} 
      \item Compiler 
	   \begin{itemize} 
               \item non optimizing compiler
	       \item not so restrictive as up to date most Java compilers 
		     do not perform optimizations
	   \end{itemize}
      \item Class file format
	 \begin{itemize} 
               \item \textbf{Line Number Table} - needed for identifying the exact points of the 
		 intra method specification
		 \item \textbf{Local Variable Table}  - needed for linking the names of method parameters
         \end{itemize}
   \end{itemize}
 \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%Compiler from JML to BML%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[shrink]\frametitle{Compiler from JML to BML}
     
   Input : annotated  Java source and its corresponding class file
   Output : class file containing BML specification 
     \begin{itemize}
         \item annotated Java file 
          \item Compilation of the Java source file 
	    \item Compilation of ghost variables
	      \item Desugaring of JML specification
		\item Linking phase
		  \item Locating the points for intra method specification 
		    \item Encoding the BML specification into user defined class attributes
       \end{itemize}
\end{frame}


\begin{frame}[fragile,shrink]\frametitle{Example}
\begin{columns}
\begin{column}{5.1cm}
{\tiny
\begin{lstlisting}[language=java]
//@ requires k >= 0 ;
//@ ensures \result == k*(k+1)/2;
public int sum (int k) {
  int sum = 0;		
  //@loop_modifies sum,i;
  //@loop_invariant i >= 0 && i<=k && 
  //@(sum == i*(i+1)/2);
  for  (int i = 0; i < k; i++ ) {
    sum = sum + i;
  } 	
  return sum;
}
\end{lstlisting}}
\end{column}

\begin{column}{5.1cm}
{\tiny
\begin{lstlisting}[language=jvmis]
//@requires lv[1] >= 0;
//@ensures result == lv[1]*(lv[1] + 1)/2;
Loop specification
//@atIndex 14 
//@modifies  lv[2], lv[3]
//@invariant lv[3]>=0 && lv[3]<=lv[1] &&
//@    lv[2]==lv[3]*(lv[3]+1)/2
0 iconst_0
1 istore_2
2 iconst_0
3 istore_3
4 goto 14 
7 iload_2
8 iload_3
9 iadd
10 istore_2 
11 iinc 3 
14 iload_3
15 iload_1
16 if_icmplt 7 
19 iload_2
20 ireturn
\end{lstlisting}}
\end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%VC gen%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Verification condition generator for Java bytecode}
\begin{frame}[fragile,shrink]\frametitle{Support} 
  \begin{itemize}
   \item Generates verification conditions for every method separately
   \item Works over the control flow graph of a method
   \item Support for object manipulation, exceptions, method invokations, stack manipulation
   \item Based on weakest precondition calculus
\end{itemize}

\end{frame}

\begin{frame}[fragile,shrink]\frametitle{Weakest precondition predicate transformer for bytecode}
\begin{definition}
   $$\wpi:  nat \rightarrow \Method  \rightarrow \Pred $$
\end{definition}


   $$ {\small \begin{array}{l}
        
      \frac{ \begin{array}{l}
	       \wpi(i+1,\methodd)\subst{\counter}{\counter+1} \subst{\stack{\counter + 1}}{\locVar{k}} \\
              \methodd[i] = \load \  \locVar{k}
             \end{array}
           }{\wpi(i,\methodd )} 
         
	 
	\\\\\\

      \frac{\begin{array}{l} 
                  \stack{\counter } \neq \Mynull \Rightarrow 
                            \wpi(i+1,\methodd)\subst{\stack{\counter}}{f(\stack{\counter} )} \ \wedge \\ 
			   
			     \stack{\counter } == \Mynull \Rightarrow \methodd.\excPost( i, \NullPointerExc) \\
                  \methodd[i] = \getfield \ f 
          \end{array}
     } { \wpi(i,\methodd ) }
        
      \end{array} } $$

\end{frame}

\begin{frame}[fragile,shrink]\frametitle{Correctness}
  \begin{definition} 
    If a method \methodd{} starts execution in state $s_0$, and terminates execution in $s_1$, i.e.  \ $\methodd: \  s_0 \rightarrow^{*} s_1 $ and
    $s_0 \vDash \methodd.Pre $ holds     then $s_1 \vDash \methodd.Post$
    \end{definition}
 
Assumption: 
\begin{itemize}
   \item reducible control flow graph 
\end{itemize}

\end{frame}



\begin{frame}[fragile,shrink]\frametitle{Example}
\begin{lstlisting}[language=jvmis]
method min((*@ \locVar{1} , \locVar{2}  @*) )
(*@\alert<7->{ \{ {\tiny $\locVar{1} \le \locVar{2} \wedge \locVar{1} > \locVar{2} \Rightarrow \locVar{1}  == \locVar{2} \wedge 
                          \locVar{1} > \locVar{2}    \wedge \locVar{1} \le \locVar{2} \Rightarrow \locVar{2} == \locVar{1} $} \}} @*)
   0: load 1
(*@\alert<6->{ \{ {\tiny $\stack{\counter } \le \locVar{2} \wedge \locVar{1} > \locVar{2} \Rightarrow \locVar{1}  == \locVar{2} \wedge 
                          \stack{\counter} > \locVar{2}    \wedge \locVar{1} \le \locVar{2} \Rightarrow \locVar{2} == \locVar{1} $} \}} @*)
   1: load 2
(*@\alert<5->{ \{ {\tiny $\stack{\counter - 1} \le \stack{\counter} \wedge \locVar{1} > \locVar{2} \Rightarrow \locVar{1}  == \locVar{2} \wedge 
                          \stack{\counter - 1} > \stack{\counter}    \wedge \locVar{1} \le \locVar{2} \Rightarrow \locVar{2} == \locVar{1} $} \}} @*)
   2: if_icmpgt 5
(*@\alert<4->{ \{ {\tiny $ \locVar{1} > \locVar{2} \Rightarrow \locVar{1}  == \locVar{2} \wedge 
		\locVar{1} \le \locVar{2} \Rightarrow \locVar{1} == \locVar{1} $} \}} @*)
   3: load 1
(*@\alert<3->{ \{ {\tiny $ \locVar{1} > \locVar{2} \Rightarrow \stack{\counter}== \locVar{2} \wedge 
		\locVar{1} \le \locVar{2} \Rightarrow   \stack{\counter} == \locVar{1} $} \}} @*)
   4: return
(*@\alert<2->{ \{ {\tiny $ \locVar{1} > \locVar{2} \Rightarrow \result == \locVar{2} \wedge 
		\locVar{1} \le \locVar{2} \Rightarrow \result == \locVar{1} $} \}} @*)

(*@\alert<4->{ \{ {\tiny $ \locVar{1} > \locVar{2} \Rightarrow \locVar{2}  == \locVar{2} \wedge 
		\locVar{1} \le \locVar{2} \Rightarrow \locVar{2} == \locVar{1} $} \}} @*)
   5: load 2
(*@\alert<3->{ \{ {\tiny $ \locVar{1} > \locVar{2} \Rightarrow \stack{\counter} == \locVar{2} \wedge 
		\locVar{1} \le \locVar{2} \Rightarrow \stack{\counter} == \locVar{1} $} \}} @*)
   6: return
(*@\alert<2->{ \{ {\tiny $ \locVar{1} > \locVar{2} \Rightarrow \result == \locVar{2} \wedge 
		\locVar{1} \le \locVar{2} \Rightarrow \result == \locVar{1} $} \}} @*)
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%% Proof preserving compilation %%%%%%%%%%%%%%%%%%%%5

\section{Proof preserving compilation}

\begin{frame}\frametitle{Compiler}

       \begin{itemize}
           \item Non - optimizing 
           \item Targets a stack based virtual machine
	   %\item close to standard Java compilers 
       \end{itemize}
       Not so bad as  most of the Java compilers today are non optimizing  and  the result is relevant for the JVM 
 \end{frame}



\begin{frame}[fragile,shrink]\frametitle{Equivalence of proof obligations.Example}

\begin{block}
  {\small \begin{tabular}{lll} 
   $ \compileLabel{i}{ \lstinline!sqr + 2*s ! }{i+4}$ & = &
   \begin{tabular}{l} 
     $\compileLabel{i}{ \lstinline!sqr! }{i}$ \\
     $\compileLabel{i+1}{ \lstinline!2*s! }{i+3} $\\
     \lstinline!i+4: add!
      \end{tabular} \\
      where & & \\
      $\compileLabel{i}{ \lstinline!sqr! }{i}$ & = & \lstinline! i: load sqr!\\
      \\
      $\compileLabel{i+1}{ \lstinline!2*s! }{i+3}$ & = &
      \begin{tabular}{l} 
        % \lstinline!i  : load sqr! \\
	 \lstinline!i+1: const 2!  \\
	 \lstinline!i+2: load s!   \\
	 \lstinline!i+3: mul!	   \\
	 %\lstinline!i+4: add!	    
   \end{tabular}
    \end{tabular}
}
\end{block}


%\begin{block}
  {\small
  $$  \begin{array}{ll}
         1.1   &     \alert<7->{ \mbox{\rm \lstinline!sqr!} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline!5!}   } \\ 
         1.2   &   \lstinline!i:  load sqr!  \\
         1.3   &     \alert<6->{  \stack{\counter} + \mbox{\rm \lstinline!2!}*\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}   }\\
         1.4   &   \lstinline!i+1: const 2!	  \\
	 1.5   &     \alert<5->{   \stack{\counter - 1} + \stack{\counter } *\mbox{\rm \lstinline!s!} = \mbox{\rm \lstinline! 5!}    }\\
	 1.6   &   \lstinline!i+2: load s!	  \\
	 1.7   &     \alert<4->{   \stack{\counter - 2}  + \stack{\counter - 1} * \stack{\counter} = \mbox{\rm \lstinline! 5!}    }\\
	 1.8   &   \lstinline!i+3: mul!	          \\
	 1.9   &     \alert<3->{  \stack{\counter - 1}  + \stack{\counter} = \mbox{\rm \lstinline! 5!}   }\\
	 1.10  &   \lstinline!i+4: add!	          \\
	 1.11  &     \alert<2->{  \stack{\counter} = \mbox{\rm \lstinline! 5 !}    } \\       
               & \\
	       & \\
  %\end{array}$$}

%\end{block}



  % \begin{Example} {
  %{\small $$\begin{array}{ll}
      2.1   &    \wpSrcExpr{\lstinline!sqr + 2*s ! }{\alert<2->{ v = 5} }{\excPostExpl}{v} =   \\
      2.2   &  	 \wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2*s ! } { \alert<3->{ (v=5)\subst{v}{v_{sqr} + v_{2*s}} } }{\excPostExpl}{v_{2*s}}  }{\excPostExpl}{v_{sqr}} =   \\
      2.3   & 	 \wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2! }{\wpSrcExpr{\lstinline!s! }{ \alert<4->{ (v_{sqr}+v_{2*s}=5)\subst{v_{2*s}}{v_{2}*v_{s}}} }{\excPostExpl}{v_{s}}  }{\excPostExpl}{v_{2}} }{\excPostExpl}{v_{sqr}} =   \\
      2.4   &	 \wpSrcExpr{\lstinline!sqr!}{\wpSrcExpr{\lstinline!2! }{\alert<5->{ (v_{sqr} + v_{2}*v_{s}=5 ) \subst{v_{s}}{s}} }{\excPostExpl}{v_{2}} }{\excPostExpl}{v_{sqr}} =   \\
      2.5   &    \wpSrcExpr{\lstinline!sqr!}{\alert<6->{(v_{sqr} + v_{2}*\lstinline!s!=5 ) \subst{v_{2}}{2} } } {\excPostExpl}{v_{sqr}} =   \\
      %2.6   &	 (v_{sqr} + 2*\lstinline!s!=5 ) \subst{v_{sqr}}{\lstinline!sqr!  } =   \\
      2.6   & \alert<7->{  \lstinline!sqr! + 2*\lstinline!s!=5  }
\end{array}$$
} %}  \end{Example}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%APPLICATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Applications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Java To native compilation%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 \subsection{Java-to-Native Compilation}

\begin{frame}[shrink]\frametitle{Java-to-Native Compilation}
 Compiling Java bytecode into native code brings runtime advantages:
\begin{itemize}
    \item Faster execution
    \item Especially beneficial for restrained systems with non-sophisticated JVMs
\end{itemize}
But Java-to-Native compilation also comes with a drawback:
\begin{itemize}
    \item Native code is typically 3 to 4 times bigger than bytecode,
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Why is Native Code so Huge? An Example}
The \emph{idiv} bytecode throws an \texttt{ArithmeticException} if the divisor is equal to zero:

\begin{columns}
\begin{column}{5.1cm}
\begin{lstlisting}[language=jvmis]
iload i
iload j
idiv
ireturn
\end{lstlisting}
\end{column}
\begin{column}{5.1cm}
\begin{lstlisting}[language=C]
int i, j;
 \alert{if (j == 0)}
   \alert{THROW(ArithmeticException);}
RETURN_INT(i / j);
\end{lstlisting}
\end{column}
\end{columns}
\bigskip
There are many checks of this kind:
\begin{itemize}
\item Checking a pointer is not \emph{null} before dereferencing it,
\item Checking an array is accessed inside its bounds,
\item Checking an array is created with a positive size,
\item Checking affected types are compatible,
\item ...
\end{itemize}
SPECjvm98: 2964 exception check sites for a native size of 23598 bytes (Ishizaki et al.).
\end{frame}


\begin{frame}\frametitle{Suppressing Exceptions Check Sites using formal verification}

Runtime exceptions are (usually) a safety against programming errors. They should not be triggered by sane code.

We propose to formally prove that runtime exceptions are never thrown by a program.

Methodology:
\begin{enumerate}
\item Annotate source code with JML specification to express that no runtime exception will be thrown
\item Compile JML specification into BML as user-defined class file attributes
\item Generate and prove verification conditions over the bytecode and BML
\item Annotate class files with useless runtime exception check sites attribute
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Experimental Results}
\begin{center}
  Number of necessary exception check sites

  \bigskip
  \begin{tabular}{|l|r@{\extracolsep{0.2cm}}rr|}
    \hline
    \multirow{2}*{Program} & \multicolumn{3}{c|}{\# of exception check sites} \\
    \cline{2-4} & Bytecode & ~~~~~~JC & Proven AOT\\
    \hline
    \benchname{crypt} & 190 & 79 & 1\\
    \benchname{banking} & 170 & 12 & 0\\
    \benchname{scheduler} & 215 & 25 & 0\\
    \benchname{tcpip} & 1893 & 288 & 0\\
    \hline
  \end{tabular}
  \bigskip
  \begin{tabular}{|l|r@{\extracolsep{0.2cm}}rr|}
    \hline
    \multirow{2}*{Program} &  \multicolumn{3}{c|}{Memory footprint (bytes)}\\
    \cline{2-4} & Bytecode & Native AOT & Proven AOT\\
    \hline
    \benchname{crypt} & 1256 & 5330 & 1592\\
    \benchname{banking} & 2320 & 5634 & 3582\\
    \benchname{scheduler} & 2208 & 5416 & 2504\\
    \benchname{tcpip} & 15497 & 41540 & 18064\\
    \hline
  \end{tabular}
\end{center}
\end{frame}

% \begin{frame}
%\frametitle{The good and the bad news}
%\begin{itemize}
% \item The ratio between the bytecode and the proven native code is smaller than 2 
% \item Methodology - suitable for closed system. If a new system composant is added the whole system must be reverified
%\end{itemize}
%\end{frame}

\subsection{Constraint memory consumption policies using BML}
 
\begin{frame} \frametitle{Problem}

     \begin{itemize} 
        \item smart card devices, embedded devices, TPDs have limitted computational resources
	  \item vulnerable to denial of service attacks. 
	    \item need of mechanisms for guaranteeing that an application 
	      respects the limitation of the device
   \end{itemize}
\end{frame}

\begin{frame}[containsverbatim] \frametitle{Modeling the memory heap}  
  \begin{block}<+->{Used heap space is a ghost variable}
    \begin{verbatim} //@ public ghost static int Mem \end{verbatim}
  \end{block}
  

  \begin{block}<1->{ The upper bound of the memory space that can be used is a model variable}
    \begin{verbatim} //@ public ghost static int Max \end{verbatim}   
  \end{block}
\end{frame}


\begin{frame}[containsverbatim,shrink] \frametitle{Principles for specifying memory allocations}
  \begin{Example} {
    \begin{lstlisting}[language=jvmis]
      method m
         new A
         //@set Mem = Mem+memUnit(A)
         dup
         invokevirtual A
    \end{lstlisting}
 }   
  \end{Example} 
  
  \begin{block}<+->{The $wp$ rule for the set specification construction }
     $wp(\verb!set Mem = M! , \psi , \psi') = \psi[\verb!Mem! \leftarrow \verb!M!] $
  \end{block}
\end{frame}

\begin{frame} \frametitle{Specifying methods}
  \begin{block}<+->{Method Specification}
    \begin{itemize}
      \item  <1->{ expresses the fact that the method does not break the bounded memory consumption policy }
      
      \item  <2->{  assume in the precondition that  when method starts execution the application has consumed so much memory units such that the method execution 
 will not break the memory consumption restrictions}
      \item  <3->{ guarantee postcondition -  when method ends execution it should have consumed not more than what it has assumed in the precondition  }
     \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile,shrink]\frametitle{Principles. Specifying Methods}
  \begin{Example}{
      \begin{lstlisting}[language=jvmis]
      //@requires Mem+memUnit(A)+
      //@            methCons(init_A)<=Max
      //@ensures Mem<=old(Mem)+
      //@           memUnit(A)+methCons(init_A)
      method m
         new A
         //@set Mem = Mem+memUnit(A)
         dup
         invokevirtual A
      \end{lstlisting}         
       }
  \end{Example} 
\end{frame}


\begin{frame}[fragile,shrink]\frametitle{Principles. Loops}
 \begin{Example}{ {\tiny 
 \begin{lstlisting}[language=jvmis]
//@requires Mem + iter*( memUnit(A) + methCons(init_A)) <= Max
//@ensures Mem <= \old(Mem) +   iter*(memUnit(A) +  methCons(init_A))   
 method m(int iter)
  //@ghost int MemL
  //@set MemL = Mem
  Loop specification
  (*@\textsf{atIndex:}@*)16
  (*@\textsf{modifies}:@*)Mem, i
  (*@\textsf{invariant}:@*) Mem <= MemL + i*(memUnit(A) + methCons(init_A)) && i <= iter
  (*@\textsf{variant:}@*) iter-i
  0 const 0
  1 store i
  2 goto 16 
  5 new A
  //@set Mem=Mem+memUnit(A);
  8 dup
  9 invokespecial init_A
  12 store a
  13 iinc i
  16 load i
  17 load iter
  18 if_icmplt 5 
  21 return
 \end{lstlisting}}  
}\end{Example} 
\end{frame}



 
\section{Results}

\begin{frame}[fragile,shrink]\frametitle{What has been done?}
\begin{center}
\includegraphics[height=\textheight]{figs/toolset.eps}
\end{center}
\end{frame}


 \section{Future work}

\begin{frame}[fragile,shrink]\frametitle{Towards  a PCC }
  Still missing the certificate. Desirable properties
                    \begin{itemize}
	                \item  small 
			  \item easily checked 
			  \item  hybrid certificates 
		     \end{itemize}

\begin{center}
\includegraphics{figs/toolSetPCC.eps}
\end{center}
\end{frame}


\begin{frame}[fragile,shrink]\frametitle{Future directions. Verification condition generator }
         \begin{itemize}	   
	    \item Extension of the verification condition generator 
                 \begin{itemize}
	             \item multithreading
		  \end{itemize}
           \item Machine checked proof
                 \begin{itemize}
	             \item reliable
		       \item important for a PCC framework
		  \end{itemize}
          \end{itemize}
\end{frame}




\begin{frame}[fragile,shrink]\frametitle{Future directions. Property coverage  }
	   
                  \begin{itemize}
	                \item pure methods 
			  \item alias control
			  \item modular verification of class invariants
			    
		   \end{itemize}  

\end{frame}


\section{Related work}

\begin{frame}[fragile,shrink]\frametitle{Related Work. Low level verification}


 \begin{itemize}
   \item The Spec\# programming system

     \item Peter Muller and Barnwatt

     \item Nipkow Wildmoser

      \item  The Grail project 
\end{itemize}

\end{frame}

\begin{frame}[fragile,shrink]\frametitle{ Relation between compiled and source code}
\begin{itemize}
   \item G.Barthe, T.Rezk A.Saabas - Proof Preserving Compilation 

 \item Peter Muller and Barnwatt - Translating Source Logic derivation  into bytecode derivation trees 


\item  C.Kunz, G.Barthe T.Rezk, B.Gregoire - Transforming annotations and proofs from source to optimized bytecode

 \end{itemize}

\end{frame}





\end{document}

