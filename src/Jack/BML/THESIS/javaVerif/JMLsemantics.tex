\subsection{Semantics of JML} \label{javaVerif:JMLsemantics}


We would like to discuss in the following how JML constructs like class invariants and history constraints and inherited specification
(multiple specification cases for a method) can be expressed as 
method pre and postconditions:

\begin{description} 
  \item [Class invariants] A class invariant (\ClassInv)  is a property that must hold at every visible state of the class. This means that a
        class invariant must hold when a method is called and also must be established at the end of a method execution. 
	A class invariant must be established in the poststate 
	of the constructor of this class.
	Thus the semantics of
	a class invariant is part of the pre and  postcondition of every method and is a part of the postcondition of the constructor of
	the class to which it refers.
	
        
  \item [History constraints] A class history constraint (\ClassHistoryConstr) gives a relation between the pre and poststate of every method in the class. 
        A class history constraint thus can be expressed as a postcondition of every method in the class.
        
  \item [Behavioral subtyping for overriding methods]
        Method overriding appears in case when in a subclass a method is reimplemented.  For instance, in Fig. \ref{assertLang:lang:inherit},
	we give an example of a class \lstinline!B! which extends class   \lstinline!A! and overrides method  \lstinline!m!. 
	To deal with method overriding the virtual machine uses dynamically bounding, i.e. it is on execution time that the virtual machine decides which method to execute.
	If we go back to the figure, this means that the invocation of method   \lstinline!m! on the object reference of type \lstinline!A!
        may stand for the method  \lstinline!m! declared in class \lstinline!B! or the one declared in \lstinline!A! because the dynamic type of the
	reference stored in the field  \lstinline!a! may be \lstinline!A! or \lstinline!B!. Because  method \lstinline!m! from
        class \lstinline!B! can be called whenever method  \lstinline!m! from  \lstinline!A! may be called, we want that the former has the same 
	return and argument types as the latter. We also require that method \lstinline!m! from
        class \lstinline!B! behaves like method \lstinline!m! from \lstinline!A! or as we say that method is a behavioral subtype of \lstinline!A!. 
	
        This is expressed by the two covariant conditions over their postconditions:
	\begin{itemize}
	   \item the precondition of the  overridden method must  imply
	         the precondition of the overriding method 
	   \item the postcondition of the overriding method must imply 
	         the postcondition of the overriden method.
	\end{itemize}
	We adopt the specification inheritance technique which allows to encode behavioral subtyping in the specification of the 
	overriding method. The methodology consists in expressing the specification of the overriden method 
	as part of the specification of the overriding method. The reader may have a look for a detailed description of
	specification inheritance  in  the article \cite{Dhara-Leavens95} of K.Dhara and G.T.Leavens. Here, we will 
	illustrate the specification inheritance through the example given in Fig. \ref{assertLang:lang:inherit}. We show in the second part of 
	the figure the specification of method  \lstinline!m!  from class \lstinline!B! which will be used in the verification of the method.
	Its precondition is the disjunction of the its specified postcondition and the precondition of the method it overrides. On the other hand, its new postcondition expresses
	that depending what held in the precondition of the  method then either its postcondition holds or the postcondition of the method it
	overrides. Note that the new specification of \lstinline!m!  declared in class \lstinline!B!  respects the two covariant condition described above.
	This approach allows to encode directly as preconditions and postconditions the subtyping relation. 
	

\begin{figure}[ht!]
%\begin{tabular}{ll}
\begin{lstlisting}[frame=trbl]
class A {
  //@ requires Pre1;
  //@ ensures  Post1;
  int m(){
  }
}

class B extends A {
  //@ requires Pre2;
  //@ ensures  Post2;
  int m(){
  }
}

class C{
  A a;
  void n (){
    ...
    a.m()
  }
} 
\end{lstlisting}

\begin{lstlisting}[frame=trbl]
class B extends A {
  //@ requires Pre1 || Pre2;
  //@ ensures  (\old(Pre2) ==> Post2) && 
               (\old(Pre1)==> Post1) ;
  int m(){
  }
}

\end{lstlisting}
 
%\end{tabular}
 \caption{\sc An example for a specification inheritance} \label{assertLang:lang:inherit}
\end{figure}

\end{description}

 % why do we discard the rest. 
% We abstract from the rest of the JML grammar, as it boils down to JML
% expressions and  predicates. 


