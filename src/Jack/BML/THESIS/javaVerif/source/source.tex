
\newtheorem{Expression}{Definition}[section]
\newtheorem{ExpressionRel}[Expression]{Definition}
\newtheorem{Statement}[Expression]{Definition}

\section{Java like statements and expressions} \label{source}
 
 Java programs are a set of classes. 
 As the JVM says \textit{`` A class declaration specifies a new reference type and provides its implementation. \ldots The body of a class declares members (fields and methods) and constructors.''}. Fields represent the state of an object of the class where those fields are declared. 
Fields have a name and a type. Thus, a  field declaration in a class states the name and type of the field.
Methods are the constructs in a class which execute and allow to change the state of the objects at runtime.
Class constructors are special methods which  initialize a new object of this class. 
Constructors have the same name as the class to which they belong. 
 A method declaration includes
 the method name, the list of arguments which specifies their names and  types, the method return type as well as the method body.
A method body in Java represents a Java statement. Statements are program constructs whose role is to determine the control flow of the program during execution. 
Statements manipulate program constructs which represent values. Those constructs are the expressions of the language.
Expressions do not determine the control flow but they evaluate to values. Values in our language are either references
 or integers.
For an illustration, consider the class declaration:
\lstset{numbers=left}
\begin{lstlisting}[frame=trbl] 
class A {
  int (*@ \fieldd @*);
  
  A(int c) {
   (*@\fieldd@*) = c;
  }

  int (*@ \texttt{eqField} @*) ( A a ) {
    if (a !=  (*@ \Mynull @*)) {
      return 0;
    }
    if ( a.(*@\fieldd@*) == this.(*@\fieldd @*) ) {
      return 1;
    } else {
      return 0;
    }
  }
}
\end{lstlisting}


The example shows  the declaration of class  \lstinline!A!.
The class first declares a field named \fieldd{} of type integer (line 2).
 Then follows the declaration of the class  constructor which initializes the field \fieldd{} to the value
of the parameter \lstinline!c! (lines 4-6). The last component of the class is the  method \texttt{eqField}
 which tests if the parameter \lstinline!a! of type  \lstinline!A!  is
 equal to the receiver of the method call by returning 0 or 1 (lines 8-18).
 Thus, the body of \texttt{eqField} first checks if  \lstinline!a!
 is not \Mynull{} and if it is returns 0. Otherwise, if the field  \fieldd{} in the current object  and in the object 
passed as the parameter \lstinline!a! are equal then the method returns 1 and if not returns 0. 



%In the following, we shall concentrate on the syntax and  semantics of statements and expression language which is close to the statements and expressions in Java. 
 %We present a source Java-like programming language which supports the following features:
%object manipulation and creation, method invocation, throwing and handling exceptions, subroutines etc. 
In the following, we shall concentrate in more detail on the statements and expressions typical for 
object oriented languages e.g.\ object manipulation and creation, method invocation, throwing and handling exceptions and subroutines.
Fig. \ref{source:grammar} gives the formal grammar.
 
\begin{figure}[ht!] 
\begin{frameit}
   $$ \begin{array} {ll}
   % %   \program :: = & \class;\\
    %                 & \\
 %                  & \\
 %
 %
    %  \class ::=      & list \fieldDecls list \methods\\
    %                  & \\
 %                   & \\
    %  \fieldDecls ::= & \Type \id \\ 
    %                  %& \mid \Type \id;\fieldDecls  \\
                
 %                   & \\ 
 %                   & \\
  %    \method ::=& id (list type argName) type \{ \stmt \}  \\
   %              & \\ 
 %              & \\
                        
     \expressionSrc  & ::=         \constantInt  \\
                                %& \mid \Mytrue \\ 
                                %& \mid \Myfalse \\
                                & \mid \Mynull  \\
                                & \mid \this \\
                                & \mid \expressionSrc \ \op \ \expressionSrc \\  
                                & \mid \expressionSrc.\fieldd \\
                                & \mid \var \\
                                & \mid (\class) \ \expressionSrc \\
                                & \mid \expressionSrc.\methodd() \\
                                & \mid  \newSrc \ \class  ( ) \\
                                & \\
                                &  \op \in \{ +, - , *, \}  \\
                                %& \mid \expressionSrcRel \\
                                & \\
                                & \\
     \expressionSrcRel  &::=      \expressionSrc \ \rel \ \expressionSrc \\
                                %& \mid \expressionSrc \ \instanceofSrc \ Class\\
                                & \\   
                                & \rel \in \{ \le, < ,  \ge, >, = , \neq \}      \\
                                & \\
                                & \\
      \stmt & ::=                       %& \Myskip \\
                                 \stmt;\stmt \\
                                & \mid \Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} \  \Myelse \ \{ \stmt \}  \\
                                & \mid \try  \ \{ \stmt \}  \ \catch \ ( \mbox{\rm\texttt{Exc} } )\ \{ \stmt \} \\
                                & \mid \try  \ \{ \stmt \} \ \finally \ \{ \stmt \} \\
                        %       & \mid \try  \ \{ \stmt \} \ \catch \ ( \mbox{\rm\texttt{Exc} }  )\ \{ \stmt \} \ \finally \ \{ \stmt \} \\
                                & \mid \throw \ \expressionSrc  \\
                                & \mid \while \ (\expressionSrcRel) \lbrack \invariant, \modLoop \rbrack \ \do \ \{ \stmt \}\ \\
                                & \mid \returnSrc \  \expressionSrc \\
                        %       & \mid \returnSrc \\
                                & \mid \expressionSrc = \expressionSrc \\        
    \end{array} $$
\caption{\sc Source language}
\label{source:grammar}
\end{frameit}
\end{figure}


   The nonterminal \stmt{} introduces the grammar for statements.  
   The statements that are supported are standard control flow constructs like 
    compositional statement, conditional statement, assignment statement, return statement etc.
    They have the usual semantics of programs with exceptional and normal termination.
     For instance, the meaning of the compositional statements $\stmt;\stmt  $
    is that if the first statement terminates execution normally then the second statement is executed. Moreover, if the first or second statement 
    terminates on exception then the whole statement terminates on exception 
    
% the statement which does nothing \Myskip, the  compositional statement
%  $\stmt;\stmt$. The conditional statement
%  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ $  \Myelse \ \{ \stmt \}  $ which stands for
%  an if statement.%  We also have a construct  $\Myif \ (\expressionSrcRel) \ \Mythen \ \{ \stmt \} $ which has the semantics 
%   The semantics of the construct is the standard one, i.e. if the relation expression $\expressionSrcRel$ 
%  evaluates to true then the statement in the $ \Mythen$ branch is executed, otherwise the statement in the
%  $\Myelse$ branch is executed. 
  The construct  $ \try  \ \{ \stmt \} $ $ \catch \ (\mbox{\rm\texttt{Exc}})\ \{ \stmt \}  $  allows for handling exceptions.
  Its meaning is that if the statement following the $ \try $ keyword throws an exception of type \texttt{Exc} then
  the exception will be caught by the statement following the  $ \catch $ keyword. The language also supports 
  try finally statements, a construct which is particular to the Java language.
  The meaning of the construct is that  no matter how the statement following the keyword \try \ terminates (on an exception or normally),
  the statement introduced by the keyword \finally \ must execute after it. If the try block terminates normally then the
  whole try statement will terminate as the finally block. If the try block terminates on exception \Exc{} and if the finally block
  terminates normally, the whole try finally statement terminates  on the exception  \Exc{}.  If the try block terminates on exception \Exc{} and if the finally block
  terminates on exception \Exc' then the whole try finally  terminates on exception \Exc'.
  Loop statements are also supported.  Note that their syntax includes  a formula \invariant \ which must hold whenever 
  the loop entry is reached as well as a  list of expressions
  \modLoop \ which lists the locations that  may not have the same value at the beginning
  and at the end of a loop iteration. Note that a  variable should not be in the list \modLoop{} even if during a loop iteration its value is changed
  as far as at the end of the iteration the value it had in the beginning of the iteration is restored.
%  The construct $ \returnSrc \  \expressionSrc $ is
%   the statement by which method execution may terminate and control will be transfered to the method caller.
%   The last statement that we consider is the assignment statement $ \expressionSrc = \expressionSrc$.
%    It states that the expression on the left of the assignment sign $=$ is assigned the value of the expression on the right.

% In Fig. \ref{pogComp:source:example}, we give an example program written in our source language. The figure shows 
%the method \lstinline!square! which calculates the 
%the   square of the parameter \lstinline!i!. First, the absolute value of \lstinline!i! is stored in the variable \lstinline!v!.
%Then  the while statement  calculates the sum of the impair positive numbers whose whole division by 2 is smaller than
%\lstinline!v! which is the square of \lstinline!i!.  The example is also
%provided with specification written in JML. The specification states
%that the method returns the square of its parameter and that the loop
%invariant is \lstinline!(0 <= s) && (s <= v) && sqr == s*s!.
%
%\begin{figure}[ht!]
% \begin{lstlisting}[frame=trbl] 
%//@ ensures \result == i*i; 
%public int square( int i ) {
%  int sqr  = 0;
%  int v = 0;
%  if ( i < 0)
%    then {
%      v = -i;} 
%    else {
%      v = i;}
%  int s = 0;
%  /*@ loop_modifies s, sqr;
%    @ loop_invariant (0 <= s) && (s <= v) && sqr == s*s ;
%    @*/
%  while( s < v ) {
%    sqr = sqr + 2*s + 1;
%    s = s+1;}
%  return sqr;}
%\end{lstlisting}
%\caption{\sc method  \lstinline!square! written in our source language}
%\label{pogComp:source:example}

%\end{figure}
Let us now turn to the expression grammar. As we can see from the figure, the language supports 
    integer constants $\constantInt$, the null constant \Mynull \ 
    denoting  the empty reference, a construct \this \ for referring to the current object,  
    arithmetic expressions  $\expressionSrc \ op \ \expressionSrc$ where $op \in  \{+ , - , div , rem, * \}$.
    The value stored in a field named \fieldd \ for the object reference $\expressionSrc $ is denoted with
    the construct  $ \fieldAccess{\expressionSrc}{\fieldd} $, cast expressions with   $(\class) \expressionSrc$
    and method local variables  and parameters with identifiers taken from the set  \var.  
    The language also has constructs for expressing method invocation. 
    Thus, the first expression in the syntax of the method invocation
    $\expressionSrc.\methodd()$ stands for the receiver object of the method
    call and \methodd{} is the name of the invoked method. For the sake of clarity we consider only non void  instance  methods which does not 
    receive parameters. Moreover, we assume that methods always return a
    value. The language supports also instance creation construct. Note that constructors like methods do not take arguments.
    The semantics of instance creation expression $\newSrc \ \class{}$  is that it 
    creates a new reference of type \class{} in the heap  which is initialized by the class constructor $\class$.
    For class constructors, we also assume that they do not take parameters
    for the same reasons as above.   A relation between    expressions is denoted with
    $\expressionSrc \ \rel \ \expressionSrc $ where $\rel  \in \{ \le, < ,  \ge, >, = , \neq \}$.  
    We could have considered a larger set of boolean expressions like for instance logical connectors $\wedge, \vee \ldots$
     but we limit our language only to  relational expressions for the sake of simplicity without losing any particular feature of the language.
