\newtheorem{compPropApp}{Lemma}[section]
%\newtheorem{compProp1}[compProp2]{Lemma}
%\newtheorem{compProp7}[compProp2]{Lemma}
%\newtheorem{compProp11}[compProp2]{Lemma}
%\newtheorem{compProp6}[compProp2]{Lemma}

\newtheorem*{compProp0A}{Lemma  \ref{compile:prop:compProp0}}
\newtheorem*{compProp3A}{Lemma  \ref{compile:prop:compProp3}}
\newtheorem*{compProp8A}{Lemma  \ref{compile:prop:compProp8}}
\newtheorem*{compProp9A}{Lemma  \ref{compile:prop:compProp4}}

\section{Proofs of properties from Section \ref{compile:prop} }\label{appendix:compile:prop}


\begin{compProp0A}%[Compilation of statements and expressions]\label{compile:prop:compProp0}
 For any statement or expression $\ExprStmt$ which does not terminate on \return{} or \athrow, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\ExprStmt}{e}$ such that  instruction  $e+1$ may execute after
    $e$, i.e.   $ \ins{e} \execRel \ins{e+1}$
\end{compProp0A}
\textit{Proof:} 
The proof  is by structural induction over the compiled statement.
We scatch the case for compositional statement, the other cases being similar. 
Remind that by compiler definition, we get that the compilation of $\stmt_1; \stmt_2$ starting at index $s$ is
 $\compileLabel{s}{\stmt_1; \stmt_2}{e} = \compileLabel{s}{\stmt_1}{e'};\compileLabel{e'+1}{\stmt_2}{e}$.
By  induction hypothesis, we get that the lemma holds for $\compileLabel{e'+1}{\stmt_2}{e}$ and we get that $e \execRel e+1$ 
which means that this case holds.
\Qed \\


In the next, we will need several auxiliary lemmas that will allow us to prove the statements from Section \ref{compile:prop}. 
The next lemma states that all the jump instructions in the compilation of a statement target instruction which are also 
in the compilation of the statement.
For illustration, we may return back to the example Fig. \ref{pogEquiv:compile:prop}  on page \pageref{pogEquiv:compile:prop} and focus on the 
compilation of the \lstinline!if!  statement   
\lstinline!if ( i >= 0) then {v = i}! \lstinline!else {v = -i}! 
which comprises instructions from 4 to 11. Note that sequential instructions   have as  successor the next instruction.  Thus, sequential
instructions respect this condition. 
Only jump instructions may cause control transfer outside the \lstinline!if! compilation. 
We notice that the compilation contains two jump instructions. 
The first is the instruction \lstinline!5 ifge 10! which jumps inside the compilation of the if statement
and the instruction \lstinline!9 goto 12!  which jumps apparently to instruction 12. 
Thus, the compilation of the \lstinline!if! statement respects the property.


\begin{compPropApp}[Jumps in statement compilation target instructions inside the statement compilation]\label{compile:prop:compProp1}

    For any statement $\ExprStmt $, start label $s$ and end label $e$,
    the compiler will produce a list of bytecode instruction $\compileLabel{s}{\ExprStmt}{e}$ such that every jump instruction(\goto {} or \ifCond) which is in the compilation 
    and transfer the control flow outside the compilation jumps to the instruction $e + 1$  .

\end{compPropApp}
\textit{Proof:} 
The proof is done by contradiction and uses structural induction. 
We scatch the proof for the compilation of the if statement, the rest of the cases being similar. \\
Suppose that this is not true.
Recall that the compilation of a conditional statement starting at index $s$  
(Fig. \ref{pogEq:compile:compExpr:defStmt} on page \pageref{pogEq:compile:compExpr:defStmt}) is of the form:
$${\scriptsize \compileLabel{s}{ \Myif \ ( \expressionSrc_1 \rel \expressionSrc_2 ) \ \Mythen \ \{ \stmt_1 \}  \  \Myelse \ \{ \stmt_2 \}   }{e}= 
\begin{array}{l}
\compileLabel{s}{\expressionSrc_1}{e'} \\
\compileLabel{e'+1}{\expressionSrc_2}{e''}\\ 
 e'' + 1: \ifCond \ e''' + 2; \\
 \compileLabel{e'' + 2}{\stmt_2}{e'''}\\
 e''' + 1: \goto \ e\\  
\compileLabel{e''' +  2}{\stmt_1}{ e -1 };\\
 e : \nop
\end{array}}
		    $$
 
Because by induction hypothesis every jump in  $\compileLabel{e''' +  2}{\stmt_1}{ e} $ targets  instructions inside $\compileLabel{e''' +  2}{\stmt_1}{ e} $,
 it  is not possible that there be  a jump  inside 
$\compileLabel{e''' +  2}{\stmt_1}{ e} $  which targets outside the compilation of the conditional statement.
 Similarly, we conclude that such a  jump cannot be contained in 
$\compileLabel{e''' +  2}{\stmt_1}{ e -1  } $, $ \compileLabel{s}{\expressionSrc_1}{e'}$ nor $\compileLabel{e'+1}{\expressionSrc_2}{e''}$
The only cases that remain possible are the  jumps  $ e'' + 1: \ifCond \ e''' + 2 $  and $ e''' + 1: \goto \ e  $.
 But for both instructions that is not true. Thus, the lemma holds for this case.

\Qed\\

%The next lemma states that if we have a compilation of the statement or expression, there exists a path from in the control flow
%graph from the first instruction to the last instruction of its compilation. 
% \begin{compPropApp}[Path from the first instruction in the compilation of source construct to its last instruction ]\label{compile:prop:compPropPathInternal} 
%  For any  statement or expression $\ExprStmt$ its compilation $\compileLabel{s}{\ExprStmt}{e}$ is such that there exists a path from $s$ to $e$ 
% which contains only instruction from the compilation $\compileLabel{s}{\ExprStmt}{e}$
% \end{compPropApp}
% \textit{Proof} by structural induction using Lemmas \ref{compile:prop:compProp0} and  \ref{compile:prop:compProp1}.
% % We sketch the case for compositional statement. The compilation of $\stmt_1;\stmt_2$ starting at index $s$ with last instruction index $e$ 
% is  
% $ \compileLabel{s}{\stmt_1}{e'}\compileLabel{e'+1}{\stmt_2}{s}  $. By induction hypothesis there is a path $P_1$ from 
% instruction $e$  to instruction $e'+1$ which is inside  $ \compileLabel{s}{\stmt_1}{e'}$. By induction hypothesis, we can also conclude that there is a path $P_2$
% from $e'+1$ to $s$. From Lemma  \ref{compile:prop:compProp0}, we know that there is an execution relation between $e'$ and $e'+1$. This means that there is a path from 
% $s$ to $e$ such that it is inside  $ \compileLabel{s}{\stmt_1}{e'}\compileLabel{e'+1}{\stmt_2}{s}$ and thus this case holds
% \Qed\\

The next  property  of the compiler is that any statement or expression   is
 compiled in a list of bytecode instructions 
such that instructions inside the compilation of a statement or expression cannot be targetted by instructions 
 which are outside the statement compilation except for the first instruction in the compilation.
 For instance, the instructions 14-29 in the compilation of the while statement
 in Fig. \ref{pogEquiv:compile:prop} from Section \ref{compile:prop}
 can be reached from outside of the statement compilation only via the instruction at index 14.

\begin{compPropApp}[Compilation of statements and expressions cannot be jumped from outside inside]\label{compile:prop:compProp2}
 For all  statements and expressions $\ExprStmt'$  and $\ExprStmt$, such that $\ExprStmt'$  is a substatement of
 $\ExprStmt$ ($\substatement{\ExprStmt }{\ExprStmt'}$)
 and their  compilations  are $\compileLabel{s}{\ExprStmt}{e}$ and  $\compileLabel{s'}{\ExprStmt'}{e'}$. Let us have instruction at index $j$ 
 in the compilation of  $\ExprStmt$ ( $j \in \compileLabel{s}{\ExprStmt}{e}$)
 but which is not in the compilation of  $\compileLabel{s'}{\ExprStmt'}{e'}  $ ( $\neg (j \in \compileLabel{s'}{\ExprStmt'}{e'} ) $ ).
 Let us also have instruction $k$ in the compilation   $ \compileLabel{s'}{\ExprStmt'}{e'}$. 
  Suppose that $j$ may execute after $k$ ($ j \execRel k$). It then follows that  $k$ is the first instruction in the compilation of  $ \ExprStmt'$
 \end{compPropApp}
  \textit{Proof:}The proof is by induction over the structure of statements and expressions. % and uses  Lemma \ref{compile:prop:compProp1}
We sketch here the case for compositional statement, the other cases are similar and use previous Lemma \ref{compile:prop:compProp1} and Lemma \ref{compile:prop:compProp0}
The compositional statement $\stmt_1;\stmt_2$ has the compilation $ \compileLabel{s}{\stmt_1;\stmt_2}{e}$ which by the compiler definition is 
 $ \compileLabel{s}{\stmt_1}{e'} \compileLabel{e'+1}{\stmt_2}{e}$. By induction hypothesis the lemma holds both for   $ \compileLabel{s}{\stmt_1}{e'}$
and $\compileLabel{e'+1}{\stmt_2}{e}$. It is also necessary to show that there are no jumps from the compilation of $\stmt_1$ into the compilation of
$\stmt_2$ and vice versa. Both directions follow from Lemma \ref{compile:prop:compProp1} that all jumps in a statement compilation are inside the statement.
Moreover, from Lemma \ref{compile:prop:compProp0} we have that $e' \execRel e'+1$ which conforms to the statement.
Thus, the  case for compositional statement holds.
 

\Qed \\





\begin{compProp3A}[Compilation of expressions]
    For any expression $\expressionSrc$, starting label $s$ and end label $e$,
    the compilation $\compileLabel{s}{\expressionSrc}{e}$ is a block of bytecode instruction in the sense of Def. \ref{seqInstr}
   
\end{compProp3A}
\textit{Proof:}

Following the Def. \ref{seqInstr} of block of bytecode instructions,  we have to see if the compilation of an expression respects
three conditions.
The first condition of Def.\ref{seqInstr} states that none of the instructions is a target of an instruction
outside of the compilation of the expression except from the first instruction. This follows from lemma \ref{compile:prop:compProp2}. 
The second condition in Def. \ref{seqInstr}  requires that there are no control 
transfer instructions (jumps, \return and \athrow)  in the list of instructions representing the  compilation of an expression.
This is established by induction over the structure of the expression.
The third condition in Def. \ref{seqInstr} states that  the compilation $\compileLabel{s}{\expressionSrc}{e}$ is such that 
no instruction except possibly for the first instruction in the expression compilation is in a loop execution relation with its predecessor in the sense of 
Def.  \ref{defLoop} in Chapter \ref{wpGeneral}, Section \ref{opSem:prelim}, page \pageref{opSem:prelim}.
Assume that this is not the case. This would mean that there exist $i, s < i \le e  $  such that between it and its predecessor there is a loop edge
 $ i-1 \execRel^{l} i$.  Following Def. \ref{defLoop}  this would mean that every execution path reaching instruction $i-1$  must pass before through instruction $i$.
As all the instructions in the compilation of an expression are sequential in order that the latter be true there should be a jump to instruction $i$ from outside
the compilation of the expression. But this contradicts the first condition. Thus, it follows that our hypothesis is false and we can conclude that the third condition 
of Def. \ref{seqInstr} holds for compilation of expressions.
 \Qed \\
 
We shall now proceed to the lemma which establishes that there are loops in the bytecode control flow graph corresponding to the compilation of a statement
only if the statement contains loops. 

\begin{compProp9A}  The compilation $\compileLabel{s}{\stmt}{e}$ of a statement $\stmt$ may contain an instruction $\ins{k}$ and $\ins{j}$  which are respectively 
a loop entry and a loop end  in the sense of Def.
\ref{defLoop}, page \pageref{defLoop}  (i.e. there exists $\ins{j}$ such that $\ins{j} \execRel^{l} \ins{k}$ ) if and only if  $\stmt$  contains 
 a substatement $\stmt'$ which is a loop statement:
 $$ \ins{j} = \loopStart{\stmt'}  - 1 \wedge  \ins{k} = \loopStart{\stmt'}  $$
\end{compProp9A}
\textit{Proof:}
By structural induction over the compiled statement. The direction when statement contains a loop statement is trivial.
We will show the other direction for compositional statements.
\begin{description}
\item[Compositional statement]
Let us have the statement $\stmt_1;\stmt_2$ and its compilation 
 $\compileLabel{s}{\stmt_1;\stmt_2}{e}$. From the compiler definition,
we have that  
$$ \scriptsize{\compileLabel{s}{\stmt_1;\stmt_2}{e} = \compileLabel{s}{\stmt_1}{e'}\compileLabel{e'+1}{\stmt_2}{s}}$$
 By induction hypothesis, the lemma holds for  the compilations of $\stmt_1$ and   $\stmt_2$ which are 
$\compileLabel{s}{\stmt_1}{e'}$ and  $\compileLabel{e'+1}{\stmt_2}{s}$.
Let us which are the other possible execution edges in the compilation.

% We know  from Lemma \ref{compile:prop:compProp0} that instruction 
%$e' + 1$ may execute immediately after $e'$, i.e. $e' \execRel e'+ 1$. Let us assume that $e' \execRel^{l} e'+ 1 $.  Following Def. \ref{defLoop},
%this means that every path that reaches $e'$ passes before through  $e'+ 1 $. Suppose that there is a path $P$  from the program entry point  to the 
%$e'+1$  which does not pass through $e'$. There is a subpath $subP$ which first reaches the instruction $s$ (from Lemma \ref{compile:prop:compProp2})
%From Lemma \ref{compile:prop:compPropPathInternal} we get that there is a path $P_{s,e}$ from instruction $s$ to instruction $e'$  which does not go outside
%$\compileLabel{s}{\stmt_1}{e'}$. Thus there is a path from 
%Because there are no jumps from outside inside statements by Lemma \ref{compile:prop:compProp2} except for the first instruction, this means that 
%every path that reaches $e'+1$ passes through instruction $s$

The only possibility which remains following
  Lemma \ref{compile:prop:compProp0} and Lemma \ref{compile:prop:compProp2}  is
$e' \execRel e'+1$. We will show  by contradiction that the execution relation between $e'$ and $e'+1$ is not a loop execution relation.
Assume that the execution is a loop execution relation, i.e. $e' \execRel^{l} e'+1$. Following Def. \ref{defLoop}, this means that every path $P$ in the control flow graph 
 from the program entry point instruction which reaches $e'$ has a subpath $ subP $ which does not pass through $e'$ and which passes through $e'+1$.
 This is possible in two cases:
\begin{itemize}
\item  if there is a jump from outside $\compileLabel{s}{\stmt_1;\stmt_2}{e}$ to the instruction $e'+1$. This is not possible following Lemma \ref{compile:prop:compProp2}.

\item there is a jump from an instruction from $\compileLabel{s}{\stmt_1}{e'}$ to  $e'+1$ but this is not possible following Lemma \ref{compile:prop:compProp1}
\end{itemize}


\item[Conditional statement]
By definition, its compilation results in
  $$ \scriptsize{\compileLabel{s}{ \Myif \ ( \expressionSrc_1 \rel \expressionSrc_2 ) \ \Mythen \ \{ \stmt_1 \} \  \Myelse \ \{ \stmt_2 \}   }{e} = 
\begin{array}{l}
  \compileLabel{s}{\expressionSrc_1}{e'}\\
  \compileLabel{e'+1}{\expressionSrc_2}{e''}\\  
  e'' + 1: \ifCond \ e''' + 2 \\
  \compileLabel{e'' + 2}{\stmt_2}{e'''}\\ 
  e''' + 1: \goto \ e \\ 
  \compileLabel{e''' +  2}{\stmt_1}{ e -1  }\\ 
  e: \nop 
\end{array}}
$$
 By induction hypothesis, we get that the lemma holds for the substatement compilations. The possible loop execution edges are :

 \begin{itemize}
       \item  $e' \execRel^{l} e'+1 $ This would mean that every execution path reaching $e'$ passes before through $e'+1$.
             Let us see how $e'+1$ can be reached from the program entry point.
             From Lemma \ref{compile:prop:compProp2} we know that there could be no jumps from outside the statement compilation inside it 
	     except for the first instruction. Thus, every control flow path $P$ reaching $e'+1$ has a subpath $subP_s$ which first 
	     reaches the instruction at index $s$ and does not pass through any instruction from the conditional statement.
	      Because all the instructions in $\compileLabel{s}{\expressionSrc_1}{e'}$ are sequential (Lemma \ref{compile:prop:compProp3}), every path from the 
	     program entry point reaching $e'+1$ passes through $e'$. Thus the assumption is false.
	     We may apply similar reasoning to establish that it is not true that  $e'' \execRel^{l} e''+1 $ neither $e''+ 1 \execRel^{l} e''+2$, 
	     $e'' + 1 \execRel^{l} e'''+2 $

      
      \item $e''' \execRel^{l} e'''+1$ This is not possible because $e'''$ can be reached from the program entry point by a path $P $ which has 
           a subpath $subP_s$ which reaches $s$ and which does not pass through any instruction from the conditional statement.
	   From the instruction $s$, the control flow path 
	   passes through $s \ldots e', e' +1 \ldots e'', e''+1, e''+2\ldots e''' $. Thus there is a path from the 
	   program entry point to  $e'''$ which does not pass through $e'''+1$ and thus, it is not true  that $e''' \execRel^{l} e'''+1$
	   In the same way, we can show that it is not true that  $e''' + 1 \execRel^{l} e$, neither $ e -1 \execRel^{l} e  $
	       
 \end{itemize}

\end{description}
\Qed\\


For establishing Property \ref{compile:prop:compProp8}, we will need several auxiliary lemmas. First, we have to show that the regions described in the exception  handler table elements  
correspond to statements which are declared in the try clause of try catch or try finally statements.  
 \begin{compPropApp}[Exception handler element corresponds to a statement]\label{compile:prop:compProp7}
    Every element  $ (s,e, eH, \Exc )$  in the exception handler table \methodd.\excHandlerTable  \
    resulting from the compilation of method \methodd{}
    is such that exist statements $\stmt_1$, $\stmt_2$  and $\stmt$  such that $\compileLabel{s}{\stmt_1}{e}$
    and  statement $\stmt$ is either a try catch statement of the form 
    $\stmt = \try \{ \stmt_1 \} \catch ( \Exc )  \{ \stmt_2 \} $ or a try finally statement of the form 
    $\stmt = \try \{ \stmt_1 \} \finally \{ \stmt_2 \} $
\end{compPropApp} 
\textit{Proof}:
The proof is done by contradiction and follows directly from the definition of the compiler. 
 Particularly, from the compiler definition, we get that  elements are added in 
 \methodd.\excHandlerTable \ only in the cases of 
try catch and try finally statement compilation and that the guarded region in the  the newly added element
 correspond to the try  statement. \\
\Qed\\
In the following when we refer to the fact that a statement  $\stmt$  is either a try catch or a try finally statement with 
a try substatement $\stmt'$ and we 
are not interested in the catch or  finally  part we denote this with  $\stmt = \try{\stmt'} \ldots$


% The next lemma  states that the substatement relation on source expressions and statements is preserved
%by the compiler. For instance, the compilation of the loop body (comprising instructions from 15 to 26) in Fig. \ref{pogEquiv:compile:prop}  
%is part of the compilation of the loop itself (comprising instructions from 14 to 29).

%\begin{compPropApp}[Substatement and subexpression relation preserved]\label{compile:prop:compPropSubstmt}
%For all statements $\ExprStmt'$ and $\ExprStmt $ with
%respective compilations are $\compileLabel{s'}{\ExprStmt'}{e'}$ and  $\compileLabel{s}{\ExprStmt}{e}$ 
%if 
%  $  \substatement{\ExprStmt }{\ExprStmt'} \Leftrightarrow \compileLabel{s'}{\ExprStmt'}{e'} \in  \compileLabel{s}{\ExprStmt}{e} $ 
%\end{compPropApp}
%This follows directly from the compiler function definition.


From the compiler definition, we can also see that the indexes of the instructions corresponding to the compilation 
$\compileLabel{s}{\ExprStmt}{e}$  of $ \ExprStmt$  are all comprised in between $s$ and $e$.  
\begin{compPropApp}[Indexes  of the compilation of expressions and statements]\label{compile:prop:compPropIndex}
The compilation $\compileLabel{s}{\ExprStmt}{e}$ 
of $ \ExprStmt$ is such that 

\begin{itemize}
 \item $s \le e$
 \item every instruction in $\compileLabel{s}{\ExprStmt}{e}$  has an index  in between $s$ and $e$
\end{itemize}
\end{compPropApp}
The latter follows directly from the compiler definition function.
 

We establish now several properties concerning substatement relation which has been introduced in Section \ref{compile:prop}, page \ref{compile:prop}.
The next lemma establishes that the substatement relation between statements is preserved by the compiler. 
In particular, we establish that if a statement is a substatement of another then all of its instructions are contained in 
the compilation of the other one. Also, if two statements are not in a substatement relation neither their compilations are.
\begin{compPropApp}[Substatement relation preserved by the compiler]\label{compile:prop:compProp6}
   For all statements $\stmt_1$ and $\stmt_2$, with respective compilations 
   $\compileLabel{s_1}{\stmt_1}{e_1}$ and  $\compileLabel{s_2}{\stmt_2}{e_2}$ the following holds
   \begin{itemize} 
         \item if $\stmt_2$ is a substatement of  $\stmt_1$ ($\substatement{\stmt_1}{\stmt_2}$) then 
	     $s_1 \le s_2$ and $ e_2 \le e_1$
	  \item if  $\stmt_2$ is not  substatement of  $\stmt_1$ ($\neg \substatement{\stmt_1}{\stmt_2}$), neither $\stmt_1$ is a substatement of  $\stmt_2$ 
                ($\neg \substatement{\stmt_2}{\stmt_1}$) then
	     $e_1 < s_2  $ or $ e_2 < s_1$
   \end{itemize}
\end{compPropApp}
This also follows from the compiler function.


The next lemma states that if an instruction is part of the compilation 
of two source statements then we have that these statements are in a substatement relation. 

\begin{compPropApp}[Common instructions in the compilation of statements ]\label{compile:prop:commonInstr}
   For all statements $\stmt_1$ and $\stmt_2$, with respective compilations 
   $\compileLabel{s_1}{\stmt_1}{e_1}$ and  $\compileLabel{s_2}{\stmt_2}{e_2}$ if it is true that 
   $s_1 \le k \le e_1 $ and $ s_2 \le k \le e_2$ then
   $ \substatement{\stmt_1}{\stmt_2}$ or   $ \substatement{\stmt_2}{\stmt_1}$
   
\end{compPropApp}
\textit{Proof}: by contradiction.\\
The case when  $\stmt_1$ and $\stmt_2$ are the same is trivial.
Let $\stmt_1$ and $\stmt_2$ are different.
Assume that the above is not true, i.e. 
$\numConclusion{1} \ \compileLabel{s_1}{\stmt_1}{e_1}  $,
$\numConclusion{2} \ \compileLabel{s_2}{\stmt_2}{e_2}$, 
$\numConclusion{3} \ s_1 \le k \le e_1 \wedge  s_2 \le k \le e_2$, 
$\numConclusion{4} \  \neg \substatement{\stmt_1}{\stmt_2} \wedge \neg   \substatement{\stmt_2}{\stmt_1} $.
From  \numConclusion{4} and previous Lemma \ref{compile:prop:compProp6}, case 2 we obtain $e_1 < s_2  $ or $ e_2 < s_1$
But this is in contradiction with \numConclusion{3} and thus the lemma holds also in this case.

\Qed\\




% The next property states that if the compilations of two
%statements in a method body share instructions then 
%either the compilation of one of them is completely inside of the other or viceversa.
%This is also evident from Fig. \ref{pogEquiv:compile:prop}.

%\begin{compPropApp}[No overlapping compilation]\label{compile:prop:compProp6}
%For all statements $\ExprStmt_1$ and $\ExprStmt_2$ such that their compilations are 
% $\compileLabel{s_1}{\ExprStmt_1}{e_1} $ and that   $\compileLabel{s_2}{\ExprStmt_2}{e_2} $, if we have that 
%$ \exists k,  s_1 \le k  \le e_1 \wedge s_2 \le k  \le e_2  $ then the following holds:
%
%$$\begin{array}{l}
%         \compileLabel{s_2}{\ExprStmt_2}{e_2}  \in \compileLabel{s_1}{\ExprStmt_1}{e_1}\\   
%	 \vee \\
%	 \compileLabel{s_1}{\ExprStmt_1}{e_1}  \in \compileLabel{s_2}{\ExprStmt_2}{e_2} 
%\end{array}$$
%\end{compPropApp}


\begin{compProp8A}[Exception handler property]
  Let us have a statement $\stmt$ which is not a try catch statement  neither a try finally statement in method \methodd. Assume that 
  statement $\stmt'$ is its direct substatement, i.e. 
$\strictsubstatement{\stmt}{\stmt'} $. Let 
 their respective compilations be  $\compileLabel{s}{\stmt}{e}$ and  $\compileLabel{s'}{\stmt'}{e'}$, then the following holds:
$$ \begin{array}{l}
          \forall \mbox{\rm\tt{Exc}}, \\
	  \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = 
	  \phantom{\forall \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} 
   \end{array}
$$
\end{compProp8A}
\textit{Proof}: by contradiction \\
\comment{i.e. assume that} \\
$\numConclusion{1} \ \strictsubstatement{\stmt}{\stmt'}   $, \\
$\numConclusion{2} \ \compileLabel{s}{\stmt}{e}$,\\
$\numConclusion{3} \ \compileLabel{s'}{\stmt'}{e'}$ \\
$\numConclusion{4} \ \exists s_1, e_1, eH_1, s_2, e_2, eH_2, \Exc $ such that\\
   $ (s_1,e_1, eH_1, \Exc )$ is in the exception handler table $\methodd.\excHandlerTable$\\
   $ (s_2,e_2, eH_2, \Exc )$ is in the exception handler table $\methodd.\excHandlerTable$\\
   $\findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = eH_1$  \\
   $\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} = eH_2$  \\
   $ eH_1 \neq  eH_2  $ \\
\comment{from definition of the function  \findExcHandlerOnly{} in Section \ref{opSem:exc}, page \pageref{opSem:exc} } \\
$\numConclusion{5} \  s_1 \le e \le e_1$ \\
$\numConclusion{6} \  s_2 \le e' \le e_2$ \\
\comment{from Lemma \ref{compile:prop:compProp7} for the elements in the exception handler table  of a method  resulting from the compiler } \\
$\numConclusion{7} \ \exists \stmt_1, stmt^{try}_1 $ such that $  \compileLabel{s_1}{\stmt_1}{e_1}$ and $  stmt^{try}_1 = \try\{ \stmt_1\} \ldots $ \\
$\numConclusion{8} \ \exists \stmt_2,stmt^{try}_2$ such that $ \compileLabel{s_2}{\stmt_2}{e_2} $ and $ stmt^{try}_2 = \try\{ \stmt_2\} \ldots $ \\
\comment{from \numConclusion{1} and Lemma \ref{compile:prop:compProp6} for substatement preservation } \\
$\numConclusion{9} \ s \le s' \wedge e' \le e  $ \\
\comment{from Lemma \ref{compile:prop:compPropIndex} for instructions in a source statement compilation } \\
$\numConclusion{10} \ s \le  e  \wedge s' \le  e'  $ \\
\comment{from  \numConclusion{9}  and  \numConclusion{10}   } \\
$  \numConclusion{11}   s  \le  e' \le  e  $\\
\comment{from  \numConclusion{11}, \numConclusion{6} and Lemma \ref{compile:prop:commonInstr} for common instructions in the compilation} \\
$  \numConclusion{12} \    \substatement{\stmt}{\stmt_2} \vee \substatement{\stmt_2}{\stmt}  $

\comment{from  \numConclusion{6}, \numConclusion{3} and Lemma \ref{compile:prop:commonInstr} for common instructions in the compilation} \\
$  \numConclusion{13} \    \substatement{\stmt'}{\stmt_2} \vee \substatement{\stmt_2}{\stmt'}  $\\
\comment{ from \numConclusion{12} and \numConclusion{13} we have 4 cases: }\\ 

\begin{description}
  \item[$ \substatement{\stmt'}{\stmt_2}  $] 
       We show that the case $\substatement{\stmt'}{\stmt_2}$ is not possible. 
       Because from \numConclusion{8}, we get that  $ \stmt_2$ is a direct substatement of $\stmt^{try}_2$ we conclude that
       $\stmt^{try}_2 $ is a substatement of $\stmt'$, i.e.    $\substatement{\stmt'}{ \stmt^{try}_2  }$.
       But from Lemma \ref{compile:prop:compProp6} and the way try catch  and try finally statements are compiled
       we get that $e_2 <  e'$. From the last inequality and \numConclusion{6} we get  a contradiction
       
  \item[$\substatement{\stmt_2} {\stmt'} \wedge \substatement{\stmt}{\stmt_2}    $] 
       This is in contradiction with \numConclusion{1}  which states that $\stmt'$ is a direct substatement 
       of  $\stmt$

  \item[$ \substatement{\stmt_2} {\stmt'} \wedge \substatement{\stmt_2}{\stmt}  $] 
       From this, by Lemma \ref{compile:prop:compProp6} for compiler substatement preservation  we get that
       \numConclusion{14}    $s_2 \le e \le e_2$ and $s_2 \le e' \le e_2 $.
       Using \numConclusion{7}, we also get by a similar reasoning as in the first case that 
       it is not possible that the statement $\stmt_1$ is a substatement of $\stmt$, i.e. we have that
       \numConclusion{15} $\neg \substatement{\stmt}{\stmt_1}$. From \numConclusion{2} and \numConclusion{5} by Lemma 
       \ref{compile:prop:compProp6}, we get that  \numConclusion{16}  $ \substatement{\stmt}{\stmt_1} \vee \substatement{\stmt_1}{\stmt} $ holds.
       From  \numConclusion{15} and  \numConclusion{16} we get \numConclusion{17}  $ \substatement{\stmt_1}{\stmt}$ which also implies that 
       \numConclusion{18} $ \substatement{\stmt_1}{\stmt'}$ as $\stmt'$ is a (direct) substatement of $\stmt$. 
       From  \numConclusion{17}  and \numConclusion{18} and  Lemma \ref{compile:prop:compProp6}, we conclude that   
       \numConclusion{19}    $s_1 \le e \le e_1$ and $s_1 \le e' \le e_1$. From  \numConclusion{14} and \numConclusion{19} and 
       definition of the function \findExcHandlerOnly{}  Section \ref{opSem:exc}, page \pageref{opSem:exc} we conclude that either
       $\findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} =  e_1 $ and 
        $\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} =  e_1 $
	or that \\
         $\findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} =  e_2 $ and 
        $\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} =  e_2 $. But this means 
	 $\findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = $\\
	  $\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable}$
	 which is contradiction with \numConclusion{4}.
	
 
      
\end{description}



 

% The proof is by contradiction. Assume this is not true, i.e.
%  $$\begin{array}{l} \exists \stmt, \stmt' ,   \\
%        \numConclusion{1}    \Myspace  \stmt \neq \try \{ \ldots \} \catch \{ \ldots \} \wedge \\
%        \numConclusion{2}    \Myspace  \strictsubstatement{\stmt}{\stmt'} \\
%        \numConclusion{3}    \Myspace  \compileLabel{s}{\stmt}{e} \wedge \\
%        \numConclusion{4}    \Myspace  \compileLabel{s'}{\stmt'}{e'} \wedge \\
%        \numConclusion{5}    \Myspace  \exists  \mbox{\rm\tt{Exc}}, \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} \neq \\
%                                             \phantom{\exists \mbox{\rm\tt{Exc}} }\findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable}    
% \end{array}
% $$

% This means that there exists two elements $   (s_1,e_1, eH_1, \mbox{\rm\texttt{Exc}} ) $  and
% $   (s_2,e_2, eH_2, \mbox{\rm\texttt{Exc}} )$  in the exception handler table of method \methodd \ \methodd.\excHandlerTable \  such that   : 

% $$ \numConclusion{6}  \Myspace eH_1 \neq eH_2  $$
% $$ \numConclusion{7}  \Myspace \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = eH_1 $$
% $$ \numConclusion{8}  \Myspace \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} = eH_2 $$



% From lemma \ref{compile:prop:compProp7}, we know that the first elements of the exception handler element correspond 
% to a statement :
% $$ \numConclusion{7}  \Myspace 
% \begin{array}{l}
%         \exists \stmt_1, s_1, e_1, \compileLabel{s_1}{\stmt_1}{e_1} \\
% 	\wedge \\
% 	\exists \stmt_2, s_2, e_2,\compileLabel{s_2}{\stmt_2}{e_2}
% \end{array} $$
% 
% From the definition of the  \findExcHandlerOnly{} and \numConclusion{8} it follows that 
% $$ \numConclusion{9} \Myspace e' \in \compileLabel{s_2}{\stmt_2}{e_2}  $$ 
% 
% From the initial condition \numConclusion{2} by lemma \ref{compile:prop:compPropSubstmt}  we conclude that 
% $$\numConclusion{8} \Myspace \compileLabel{s_1}{\stmt_1}{e_1} \notin   \compileLabel{s}{\stmt}{e} $$



% Because $e \in [s_2 \ldots e_2 ]  \wedge  e' \in [s_1 \ldots e_1 ] \wedge e,e' \in [s \ldots e]$, \numConclusion{8} by applying 
%  Lemma \ref{compile:prop:compProp6}  we can conclude that
%
% $$  \begin{array}{l} 
%          \compileLabel{s}{\stmt}{e} \in \compileLabel{s_1}{\stmt_1}{e_1} \in  \compileLabel{s_2}{\stmt_2}{e_2} \\
%           \vee \\
%%	 \compileLabel{s}{\stmt}{e} \in   \compileLabel{s_2}{\stmt_2}{e_2} \in \compileLabel{s_1}{\stmt_1}{e_1}
% \end{array}$$	   
%
% In both of the cases and of the definition of \findExcHandlerOnly \ in Chapter \ref{opSem}, Section \ref{opSem:exc}  this means that 
%$$ \findExcHandler{\mbox{\rm\tt{Exc}} }{e}{\methodd.\excHandlerTable} = \findExcHandler{\mbox{\rm\tt{Exc}} }{e'}{\methodd.\excHandlerTable} $$
%which is in contradiction with \numConclusion{6}.\\
\Qed \\


