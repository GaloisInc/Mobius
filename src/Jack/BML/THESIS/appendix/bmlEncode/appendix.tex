


%\begin{appendix}

 \chapter{Encoding of BML in the class file format} \label{appendix1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\section{Class annotation} 
\label{Classspecification}
The following attributes can be added (if needed) only to the array of attributes of  the \texttt{class\_info } structure.

\subsection{Ghost variables} \label{modelvar}
\textbf{
\begin{tabbing}
Gho\=st\_Field\_attribute \{\\
\\
\> u2 attribute\_name\_index; \\
\> u4 attribute\_length;\\
\> u2 fields\_count;\\
\> \{\hspace{3 mm}\= u2 access\_flags; \\  
\> \> u2 name\_index;\\
\> \> u2 descriptor\_index;\\
\> \} fields[fields\_count];\\
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index}\\
    The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a 
\textbf{CONSTANT\_Utf8\_info} structure representing the string "Ghost\_Field".\\

\textbf{ attribute\_length }\\
   the length of the attribute in bytes = 2 + 6*fields\_count.\\

\textbf{ access\_flags} \\
  The value of the access\_flags item is a mask of modifiers used to describe access permission to and properties of a field. \\

\textbf{ name\_index} \\
The value of the name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a \textbf{CONSTANT\_Utf8\_info} structure which must represent a valid Java field name stored as a simple (not fully qualified) name, that is, as a Java identifier. \\

\textbf{ descriptor\_index} \\
   The value of the descriptor\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a CONSTANT\_Utf8 structure which must represent a valid Java field descriptor.

% \subsubsection{Model(pure)  methods} \label{modelvar}
%\textbf{
%\begin{tabbing}
%Pur\=e\_Method\_attribute \{\\
%\\
%%\> u2 attribute\_name\_index; \\
%\> u4 attribute\_length;\\
%\> u2 methods\_count;\\
%\> \{\hspace{3 mm}\= u2 access\_flags; \\
%\> \> u2 name\_index;\\
%\> \> u2 descriptor\_index;\\
%\> \> u2 attributes\_count;\\
%\> \> attribute\_info attributes[attributes\_count];\\
%\> \} method\_info\_structure[methods\_count];\\
%\}
%\end{tabbing}
%}

%\textbf{  attribute\_name\_index}\\
%    The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table  . The \textbf{constant\_pool} entry at that index must be a \textbf{CONSTANT\_Utf8\_info} structure representing the string "Model\_Method".\\

%\textbf{ attribute\_length }\\
%   the length of the attribute in bytes.\\

%\textbf{ method\_info\_structure } \\
% a structure where the name\_index, descriptor\_index are indexes in the constant pool.

\subsection{Class invariant}
\textbf{
\begin{tabbing}
JML\=ClassInvariant\_attribute \{ \\ 
\> u2 attribute\_name\_index;\\ 
\> u4 attribute\_length;\\ 
\> formula attribute\_formula;\\ 
\}  
\end{tabbing}
}

\textbf{   attribute\_name\_index}\\
  The value of the attribute\_name\_index item must be a valid index into the  \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a \textbf{CONSTANT\_Utf8\_info} structure representing the string "ClassInvariant".\\

\textbf{   attribute\_length}\\
   the length of the attribute in bytes - 6.\\

\textbf{   attribute\_formula} \\
   code of the formula that represents the invariant

\subsection{History Constraints}
\textbf{
\begin{tabbing}
JML\=HistoryConstraints\_attribute \{ \\ 
\> u2 attribute\_name\_index;\\ 
\> u4 attribute\_length;\\ 
\> formula attribute\_formula;\\ 
\}
\end{tabbing}
}

\textbf{   attribute\_name\_index}\\
  The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a \textbf{CONSTANT\_Utf8\_info} structure representing the string "Constraint".\\

\textbf{   attribute\_length}\\
   the length of the attribute in bytes - 6.\\

\textbf{   attribute\_formula} \\
   code of the formula that is a predicate of the form \texttt{P\( state, old(state)\)} that establishes relation between the prestate and the postate  of a method execution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Method annotation}

\subsection{Method specification}
The \rm{JML} keywords \texttt{requires, ensures, exsures} will be defined in a newly attribute in Java VM bytecode that can be inserted into the structure \texttt{method\_info}  as elements of the array \texttt{attributes}.


\textbf{    
\begin{tabbing}
JML\=Method\_attribute \{ \\ 
\> u2 attribute\_name\_index;\\ 
\> u4 attribute\_length;\\ 
\> formula requires\_formula;\\
\> u2 spec\_count;\\
\> \{\hspace{3 mm}\= formula spec\_requires\_formula; \\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula ensures\_formula;\\
\> \> u2 exsures\_count;\\
\> \> \{\hspace{3 mm}\= u2 exception\_index; \\
\> \> \> formula exsures\_formula;\\
\> \> \} exsures[exsures\_count];\\
\> \} spec[spec\_count];   \\
\}
\end{tabbing}
}

\textbf{   attribute\_name\_index}\\
  The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index
 must be a \textbf{CONSTANT\_Utf8\_info} structure representing the string "MethodSpecification".\\

\textbf{   attribute\_length}\\
   The length of the attribute in bytes.\\

\textbf{   requires\_formula} \\
   The formula that represents the precondition \\

\textbf{   spec\_count} \\
   The number of specification case.\\

\textbf{   spec[]} \\
   Each entry in the spec array represents a case specification. Each entry must contain the following items:\\

\textbf{   spec\_requires\_formula} \\
   The formula that represents the precondition\\

\textbf{   modifies\_count} \\
   The number of modified variable.\\

\textbf{   modifies[]} \\
   The array of modified formula.\\

\textbf{  ensures\_formula } \\
   The formula that represents the postcondition \\\\

\textbf{   exsures\_count} \\
   The number of exsures clause.\\

\textbf{   exsures[] } \\
   Each entry in the exsures array represents an exsures clause. Each entry must contain the following items:\\

\textbf{   exception\_index} \\
   The index must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at this index must be a CONSTANT\_Class\_info structure representing a class type that this clause is declared to catch.\\

\textbf{  exsures\_formula } \\
   The formula that represents the exceptional postcondition \\
% \textit{Note:}\\
%if the exsures clause is of the form: \\  
%\texttt{ exsures} (\texttt{Exception\_name}  e) P(e) 
%it is first  transformed in : 
%\texttt{exsures} \texttt{Exception\_name} P(e)[e $\leftarrow$ \textrm{EXCEPTION}], 
%where \textrm{ EXCEPTION} is a special keyword for the specification language, for which in JML there is no correspondent one.

\subsection{Set}
These are particular assertions that assign to ghost fields. 
 %Asserts must bve relied the proper place where the loop starts. To identify where exactly the bytecode for a loop starts, the assumption that the \texttt{code } attribute   \texttt{LineNumberTable} must be present.    
\textbf{  
\begin{tabbing}
Se\=t\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;\\
\> u2 set\_count;\\
\> \{\hspace{3 mm}\= u2 index; \\
\> \> expression e1; \\
\> \> expression e2; \\
\> \} set[set\_count];\\
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index}\\
    The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a
 \textbf{CONSTANT\_Utf8\_info} structure representing the string "Set".\\

\textbf{  attribute\_length} \\
   The length of the attribute in bytes.

\textbf{  set\_count} \\
   The number of set statement.\\

\textbf{  set[]} \\
   Each entry in the set array represents a set statement. Each entry must contain the following items:\\

\textbf{  index} \\
   The index in the bytecode where the  assignment to the ghost field is done.\\

\textbf{  e1 } \\
the expression to which is assigned a value. It must be a JML expression, i.e. a JML field, or a dereferencing a field of JML reference object
  an assignment expression \\

\textbf{  e2 } \\
the expression that is assigned as value to the JML expression\\ 


\subsection{Assert}
 %Asserts must bve relied the proper place where the loop starts. To identify where exactly the bytecode for a loop starts, the assumption that the \texttt{code } attribute   \texttt{LineNumberTable} must be present.    
\textbf{  
\begin{tabbing}
Ass\=ert\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;\\
\> u2 assert\_count;\\
\> \{\hspace{3 mm}\= u2 index; \\
\> \> formula predicate; \\
\> \} assert[assert\_count];\\
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index}\\
    The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must
 be a\textbf{CONSTANT\_Utf8\_info} structure representing the string "Assert".\\

\textbf{  attribute\_length} \\
   The length of the attribute in bytes.

\textbf{  assert\_count} \\
   The number of assert statement.\\

\textbf{  assert[]} \\
   Each entry in the assert array represents an assert statement. Each entry must contain the following items:\\

\textbf{  index} \\
   The index in the bytecode where the \textbf{ predicate} must hold

\textbf{  predicate } \\
  the predicate that must hold at index  \textbf{index} in the bytecode 


\subsection{Loop specification}
%Loops are ordered by giving to every loop entry a different number. An inner loop has always a number bigger than the loop that contains it. A loop that is after another loop has always a bigger number than the loop that is  executed before it. One can find the same order of loops on source and bytecode level. 
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;\\
\> u2 loop\_count;\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\textbf{   attribute\_name\_index }\\
    The value of the attribute\_name\_index item must be a valid index into the \textbf{constant\_pool} table. The \textbf{constant\_pool} entry at that index must be a\textbf{ CONSTANT\_Utf8\_info} structure representing the string "Loop\_Specification''.

\textbf{   attribute\_length }\\
    The length of the attribute in bytes\\

\textbf{   loop\_count }\\
    The length of the array of loop specifications\\

\textbf{   index }\\  
    The index of the instruction in the bytecode array that corresponds to the  entry of the loop 
\\ %in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described\\

\textbf{   modifies\_count}\\
    The number of modified variable.\\

\textbf{   modifies[]} \\
    The array of modified expressions.\\

\textbf{  invariant } \\
    The predicate that is the loop invariant. It is a formula written in the grammar specified in the section Formula\\

\textbf{  decreases } \\
    The expression whose decreasing after every loop execution will guarantee loop termination 

% \subsubsection{Block specification}
%Here also the   \texttt{LineNumberTable}  attribute must be present.    

%\textbf{  
%\begin{tabbing}
%Blo\=ck\_attribute \{\\
%\> u2 attribute\_name\_index;\\
%\> u4 attribute\_length;     \\
%\> u2 start\_index;          \\
%\> u2 end\_index;            \\
%\> formula precondition;\\
%%\> u2 modifies\_count;\\
%\> formula modifies[modifies\_count];\\
%\> formula postcondition; \\ 
%\}
%\end{tabbing}
%}

%\textbf{  attribute\_name\_index }\\
%    The value of the attribute\_name\_index item must be a valid index into the \texttt{ \textbf{constant\_pool} table}. The \texttt{constant\_pool} entry at that index must be a\texttt{ CONSTANT\_Utf8\_info} structure representing the string "\_specification ".\\
%
%\textbf{  attribute\_length } \\
%   The length of the attribute in bytes - 6, i.e. equals \texttt{n+m}.\\

%\textbf{start\_index} \\
%   The index in the  \texttt{LineNumberTable } where the beginning of the block  is described

%\textbf{end\_index} \\
%   The index in the  \texttt{LineNumberTable } where the end of the block  is described
%
%\textbf{  precondition} \\
%  The predicate that is the precondition of the block
%
%\textbf{   modifies\_count} \\
%   The number of modified variable.\\
%
%\textbf{   modifies[]} \\
%   The array of modified formula.\\

%\textbf{  postcondition} \\
%  the predicate that is the postcondition of the block





\section{Codes for BML expressions and formulas}
%\begin{description}
%\item[Formulas]
\begin{center}
\begin{tabular}[t]{|c|c|l|}
\hline
\multicolumn{3}{|c|}{Formulas $\formulaBc $  } \\ 
\hline
\texttt{Code}&\texttt{Symbol}&\texttt{Grammar}\\
\hline
0x00 & $\true$  & \\
0x01 & $\false$ &\\
0x02 & $\wedge$ & $\formulaBc$ $\formulaBc$ \\
0x03 & $\vee$ & $\formulaBc$ $\formulaBc$ \\
0x04 & $\Rightarrow$ & $\formulaBc$ $\formulaBc$ \\
0x05 & $\neg$ & $\formulaBc$\\
0x06 & $\forall$ &  $ \boundVar$ $\formulaBc$ \\
0x07 & $\exists$ &  $ \boundVar$ $\formulaBc$ \\
0x10 & $= $ & $\expression$ $\expression$ \\
0x11 & $>  $ & $\expression$ $\expression$ \\
0x12 & $< $ & $\expression$ $\expression$ \\
0x13 & $\le $ & $\expression$ $\expression$ \\
0x14 & $\ge$ & $\expression$ $\expression$ \\
0x16 & $\subtypeSpec$ & $\type{\ident}$  $\type{\ident}$  \\
0x17 & $\neq$ & $\expression$ $\expression$ \\ 
& & \\
\hline
\multicolumn{3}{|c|}{Expressions $\expression$ } \\ 
\hline
\texttt{Code}&\texttt{Symbol}&\texttt{Grammar}\\
\hline

0x20 & $+$ & $\expression$ $\expression$ \\
0x21 & $-$ & $\expression$ $\expression$ \\
0x22 & $*$ & $\expression$ $\expression$ \\
0x23 & $/$ & $\expression$ $\expression$ \\
0x24 & $\%$ & $\expression$ $\expression$ \\
0x25 & $-$ & $\expression$ \\
%0x30 & $and$ & $\expression$ $\expression$ \\
%0x31 & $or$ & $\expression$ $\expression$ \\
%0x32 & $xor$ & $\expression$ $\expression$ \\
%0x33 & $<<$ & $\expression$ $\expression$ \\
%0x34 & $>>$ & $\expression$ $\expression$ \\
%0x35 & $>>>$ & $\expression$ $\expression$ \\
0x40 & $\tt{int \ constant}$ & i \\
%0x41 & $\tt{char \ constant}$ & i \\

0x50 & \typeOnly & \ident \\
0x51 & \elemtypeOnly & $\expression$ \\
0x52 & \result & \\
0x53 & \typeofOnly  & $\expression$ \\ 
0x54 & \TYPE & \\ 
0x55 & \oldOnly & \\ 

%0x60 & \texttt{(} & $\expression$ n $($ $\expression$ $)_n$\\
0x61 & \arrayAccess{}{} & $\expression$ $\expression$ \\
%0x62 & \texttt{cast} & Type $\expression$ \\
0x63 & \texttt{.}& $\expression$ $\expression$ \\
%0x64 & \texttt{? :} & $\formulaBc$ $\formulaBc$ $\formulaBc$ \\
0x70 & \this & \\
0x80 & \Mynull & \\
0x90 & \FieldConstRef & \ident \\
0xA0 & \locVarOnly & \digits \\
%0xA0 & JML ghost field& i\\
%0xB0 & Methodref & i \\
0xD0 & \EXC &  \\
0xE0 & $\boundVar$ & \intLiteral \\
& & \\
\hline
\multicolumn{3}{|c|}{Modifies  $\modifiesLoc$} \\ 
\hline
 & & \\
\texttt{Code}&\texttt{Symbol}&\texttt{Grammar}\\
\hline
0xD2 &  \nothing    & \\  
0xD3 & \everything & \\
0xD4 &  \arrayAccessMod{}{} & $\expression$ \specIndex \\
0xD5 &  \fieldAccess{}{} & $\expression$ \FieldConstRef \\
0xD6 & \locVarOnly & \ident\\
& & \\
\hline
\multicolumn{3}{|c|}{Index of modified array elements $\specIndex $} \\ 
\hline

& & \\
\texttt{Code}&\texttt{Symbol}&\texttt{Grammar}\\
\hline
0xE1 & $\all$ &  \\
0xE2 &  \ldots  & $\expression$ $\expression$  \\
0xE3 & $\expression$ & \\
\hline
\end{tabular}\\[2 mm]
\end{center}


%\end{description}

%\end{appendix}


