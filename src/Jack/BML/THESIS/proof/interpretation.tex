\newtheorem{interpExpr}{Definition}[section]
\newtheorem{interpPred}[interpExpr]{Definition}
\newtheorem{valid}[interpExpr]{Definition}

\newtheorem{substHeap}{Lemma}[section]
\newtheorem{newHeap}[substHeap]{Lemma}
\newtheorem{substStack}[substHeap]{Lemma}
\newtheorem{substCntr}[substHeap]{Lemma}
\newtheorem{substLv}[substHeap]{Lemma}
\newtheorem{substRet}[substHeap]{Lemma}


\section{Substitution} \label{subst}
 Expression substitution is defined inductively in a standard way over the expression structure. Still, we allow also
 substitution over objects that are not from our language, i.e. we apply substitution over field objects which results 
 in an update version of the field. 
 This is done by establishing the substitution rule for field access as follows:
 $$  \substitution{\fieldd (o)}{\expression_1}{\expression_2} =\substitution{\fieldd}{\expression_1}{\expression_2} (  \substitution{o}{\expression_1}{\expression_2}) $$


 In the next, we define a substitution over field function objects:
$$  
\begin{array}{l}
\substitution{\fieldd}{\expression_1}{\expression_2} = 
\left\{\begin{array}{ll}
\fieldd  & if \ \expression_1 \neq \fieldd\\ 
&\\ 

\expression_2  &  if \  \expression_1 = \fieldd \wedge \\
               &  \expression_2 = \fieldd[ \oplus \mbox{ \rm \texttt{r} } \longrightarrow \mbox{  \rm \texttt{v} } ]
\end{array}
\right. \\
\\
\substitution {\update{\fieldd}{ \mbox{ \rm \texttt{r} }}{ \mbox{  \rm \texttt{v} } }} {\expression_1}{\expression_2} = 
\left\{\begin{array}{ll}
\update{\fieldd}{ \substitution{\mbox{ \rm \texttt{r'} }}{ \expression_1 }{ \expression_2}}{ \substitution{\mbox{ \rm \texttt{v'} }}{ \expression_1 }{ \expression_2}  } 
%\fieldd[ \oplus \mbox{ \rm \texttt{r} }\substitution{\expression_1}{\expression_2} \longrightarrow  \mbox{ \rm \texttt{v} }\substitution{\expression_1}{\expression_2} ] 
 & if \ \expression_1 \neq \fieldd\\
& \\ 
\fieldd \begin{array}{l}
             \lbrack \oplus \substitution{ \mbox{ \rm \texttt{r'}}}{\expression_1}{\expression_2} \longrightarrow  \substitution{ \mbox{ \rm \texttt{v'}} }{\expression_1}{\expression_2} \rbrack \\
	     \lbrack \oplus \mbox{ \rm \texttt{r} } \longrightarrow \mbox{  \rm \texttt{v} } \rbrack
	     \end{array}
&  

                if \   \expression_1 = \fieldd \wedge \\
               &  \expression_2 = \fieldd[ \oplus \mbox{ \rm \texttt{r} } \longrightarrow \mbox{  \rm \texttt{v} } ]

\end{array}
\right. 
\end{array}
$$ 


For example, consider the following substitution  
$$ \substitution{\fieldd(o)}{\fieldd}{\update{\fieldd}{e }{v }} $$
This results in the new expression : 
$$\update{\fieldd}{ e}{ v} (\substitution{o}{ \fieldd}{ \update{ \fieldd}{ e}{ v }}) $$


The same kind of substitution is allowed for array access expressions, where the array object \arrayAccessOnly  can be updated. 

\section{Interpretation of assertions in a state}\label{interpret}

We discuss the evaluation of expressions and interpretation of predicates  in a particular program state configuration.
Thus, we need a function for expression evaluation, a function for interpretation of predicates 
The function $eval$ will evaluate expressions in a given state:
$$
eval : \expression \rightarrow \SetConfigs \rightarrow \Values
$$



\begin{interpExpr}[Evaluation of expressions] \label{interpExpr} 
The evaluation in a state \\
$s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$  or $s = \configFinal{\heap}{\Final }$  of an expression $\expression$
 is denoted with $\evalExp{\expression}{s}$  and is defined inductively on the grammar of expressions as follows:
 
$$
\begin{array}{l}
\evalExp{ v  }{s } = v\\
  where \  v \in \  \Myint \mbox{\rm literal } \ \vee  \  v \in  \RefValues \\
\\
 \evalExp{\fieldd(\expression ) }{s} = \\
 = \heap(\fieldd) (\evalExp{ \expression}{ s } ) \\
\\

 \evalExp{\update{\fieldd}{\expression_1}{\expression_2}(\expression_3)}{ s } = \\
=  \update{\heap}{\fieldd }{\update{\fieldd}{  \evalExp{\expression_1}{s } }{ \evalExp{\expression_2}{s }  }} (\fieldd)
                                            (  \evalExp{\expression_3}{ s } ) \\
 \\


 \evalExp{\arrayAccess{\expression_1} {\expression_2}  }{ s } = \\
 = \heap (\evalExp{ \expression_1}{ s } ,\evalExp{ \expression_2}{ s } )   \\
\\

 \evalExp{ \update{ \arrayAccessOnly}{ (\expression_1 , \expression_2)}{ \expression_3} (\expression_4,\expression_5)  } { s } = \\
 = \update{\heap}{ ( \evalExp{\expression_1}{s } ,  \evalExp{\expression_2}{s } ) }  
                 { \evalExp{\expression_3}{s }}
                 ( \evalExp{\expression_4}{s } ,  \evalExp{\expression_5}{ s  } ) \\
\\
 \evalExp{ \locVar{i} } { s } = \locVarOnly(i) \\
\\

 \evalExp{\expression_1 \ \op \ \expression_2   } { s } =   \evalExp{\expression_1}{s} \op  \evalExp{\expression_2}{s}  \\

\end{array}
$$

The evaluation of stack expressions can be done only in intermediate state configurations $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ :
$$
\begin{array}{ll}
 \evalExp{ \counter   } { s } = \counterOnly \\
\\

 \evalExp{ \stack{ \expression}   } { s } = \stackOnly ( \evalExp{\expression}{s} ) \\
\\

\end{array}
$$
The evaluation of the following expressions can be done only in a final state $s = \configFinal{\heap}{\Final }$:
$$
\begin{array}{ll}
\evalExp{ \result }{s } = \Res  & where \ s=  \configFinalNorm{\heap}{\Res} \\
\evalExp{ \EXC }{s } = \Exc  & where \ s=  \configFinalExc{\heap}{\Exc}
\end{array}
$$
  

\end{interpExpr}
The relation $\vDash$ that we define next, gives a meaning to the formulas from our
 assertion language $\formulaBc$.
%$$ \vDash :  \SetConfigs *  \formulaBc  $$
 
\begin{interpPred}[Interpretation of predicates] \label{interpPred} 
The interpretation $ s \vDash \formulaBc$ of a predicate $\formulaBc$ in a state configuration $s$ is defined inductively as follows:
$$
\begin{array}{l}
\interp{\true}{s} \  is \ true \ in \ any \ state \ s \\
\\
\interp{\false}{s} \ is \ false \ in \ any \ state \ s \\
\\

\interp{\formulaBc_1  \wedge  \formulaBc_2 }{s} \ iff \ \interp{\formulaBc_1}{s} \ and \ \interp{\formulaBc_2}{s}  \\
\\

\interp{\formulaBc_1  \vee  \formulaBc_2 }{s} \ iff \ \interp{\formulaBc_1}{s} \ or \ \interp{\formulaBc_2}{s}  \\
\\
\interp{\formulaBc_1  \Rightarrow  \formulaBc_2 }{s} \ iff \ if \ \interp{\formulaBc_1}{s} \ then \ \interp{\formulaBc_2}{s}  \\
\\
\interp{\forall x : T .  \formulaBc(x)   }{s} \ iff \ forall \ value \ \mbox{ \rm \textbf{v}} \ of \  type \  T \ \interp{\formulaBc(\mbox{ \rm \textbf{v}})}{s}  \\
\\

\interp{\exists x : T .  \formulaBc(x)   }{s} \ iff \ a \ value \ \mbox{ \rm \textbf{v}} \ of \  type \  T \ exists \ such \ that \ \interp{\formulaBc(\mbox{ \rm \textbf{v}})}{s}  \\
\\
\interp{\expression_1 \  \predicates \  \expression_2 }{s} \ iff \evalExp{\expression_1 }{s} \evalExp{\predicates }{s}  \evalExp{\expression_2 }{s} \ evaluates \ to \ true
\end{array}
$$   
\end{interpPred}


The following lemmas estasblish that substitution over state configurations or expressions / formulas result in the same evaluation

\begin{substHeap}[Update of the heap]\label{substHeap}
For any expressions $ \expression_1, \expression_2, \expression_3 $ and any field \fieldd
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
  $s_2 =  \config{ \update{\heap}{\fieldd }{\update{\fieldd}
                                                   {\evalExp{\expression_2}{ s_1 } }
                                                   {\evalExp{ \expression_3}{ s_1 } } } }
                                          {\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }   $  the following holds
\begin{itemize}
  \item $ \evalExp{\substitution{\expression_1}{\fieldd}{ \update{ \fieldd  }{\expression_2}{\expression_3} }}{ s_1 } =  \evalExp{\expression_1}{ s_2  }  $
  \item $ \interp{\substitution{\psi}{\fieldd}{ \update{ \fieldd  }{\expression_2}{\expression_3} }}{ s_1 } \iff  \interp{\psi}{ s_2  }  $
\end{itemize}
\end{substHeap}

\begin{newHeap}[Update of the heap with a newly allocated object]\label{newHeap}
For any expressions $ \expression_1$ 
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
  $s_2 =  \config{\heap'}{\counterOnly}{ \update{\stackOnly}{\counterOnly}{\referenceOnly} }{\locVarOnly}{\pc } $ where
 $  \newRef{\heap}{\clazz} = (\heap', \referenceOnly)   $  the following holds
\begin{itemize}
  \item \[ \begin{array}{l} \evalExp{\expression_1 \begin{array}{l}
                             \subst{ \stack{\counter}}{ \referenceOnly} \\
			     \lbrack  \fieldd \leftarrow \update{\fieldd } { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) }  
                             \rbrack_{ \forall \fieldd: \FieldSet, \subtype{ \fieldd.\declaredIn}{ \clazz} }
                             \end{array}}{s_1} \\
			     = \\
                             \evalExp{\expression_1}{ s_2  } 
			     \end{array}  \]

    \item \[\begin{array}{l}  \interp{\psi \begin{array}{l}
                             \lbrack \expression_2 \leftarrow \referenceOnly \rbrack \\
			     \lbrack  \fieldd \leftarrow \update{\fieldd } { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) }  
                             \rbrack_{  \forall \fieldd: \FieldSet, \subtype{ \fieldd.\declaredIn}{ \clazz}   }
                             \end{array}}{s_1}\\
			      \iff \\ 
			     \interp{\psi}{ s_2  } 
			     \end{array}  \]


\end{itemize}
\end{newHeap}



\begin{substStack}[Update the stack]\label{substStack} 
For any expressions $ \expression_1, \expression_2, \expression_3 $ 
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
  $s_2 = \config{\heap}{\counterOnly}{ \update{\stackOnly}
                                                                 {\evalExp{\expression_2}{ s_1 } }
                                                                 { \evalExp{\expression_3}{ s_1  } } }{\locVarOnly}{\pc }$ then
 the following holds:
\begin{itemize}
      \item  $     \evalExp{\substitution{\expression_1}{\stack{\expression_2}}{\expression_3}}{s_1 } = 
      \evalExp{\expression_1}{s_2 }$
      \item  $     \interp{\substitution{\psi}{\stack{\expression_2}}{\expression_3}}{s_1 } \iff
      \interp{\psi}{s_2 }$
\end{itemize}
\end{substStack}

\begin{substCntr}[Update the stack counter]\label{substCntr}
For any expressions $ \expression_1, \expression_2 $ 
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
$s_2 =  \config{\heap}{\evalExp{ \expression_2}{ s_1  } }{ \stackOnly }{\locVarOnly}{\pc }  $ then 
the following holds:
\begin{itemize}
      \item $\evalExp{\substitution{\expression_1}{ \counter }{ \expression_2 }}{ s_1 } = \evalExp{\expression_1}{s_2} $
      \item $\interp{\substitution{\psi}{ \counter }{ \expression_2 }}{ s_1 } \iff \interp{\psi}{s_2} $
\end{itemize}
\end{substCntr} 

\begin{substLv}[Update  a local variable]\label{substLv}
For any expressions $ \expression_1, \expression_2 $ 
if we have that the states $s_1$ and $s_2$ are such that
$ s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
$ s_2 =   \config{\heap}{\counterOnly }{ \stackOnly }{\update{\locVarOnly}{i}{ \evalExp{ \expression_2}{ s_1 } }}{\pc }  $ then 
the following holds:
\begin{itemize}
      \item $\evalExp{\substitution{\expression_1}{ \locVar{i} }{ \expression_2 }}{ s_1 } = \evalExp{\expression_1}{s_2} $
      \item $\interp{\substitution{\psi}{ \locVar{i} }{ \expression_2 }}{ s_1 } \iff \interp{\psi}{s_2} $
\end{itemize}
\end{substLv}


\begin{substRet}[Return value property]\label{substRet} 
For any expression $\expression_1$ and $\expression_2$,
for any two states $s_1$ and $s_2$  such that
$ s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and \\
$ s_2 =   \configFinalNorm{\heap}{\evalExp{\expression_2}{s_1} } $ then 
the following holds:
\begin{itemize}
      \item $\evalExp{\substitution{\expression_1}{ \result }{ \expression_2 }}{ s_1 } = \evalExp{\expression_1}{s_2} $
      \item $\interp{\substitution{\psi}{ \result}{ \expression_2 }}{ s_1 } \iff \interp{\psi}{s_2} $
\end{itemize}
\end{substRet}


The next definition defines a particular set of assertion formulas.
\begin{valid}
  If an assertion formula  $ f \in \formulaBc $ holds in all states we say that this is a valid formula and we note it with :
  $ \interp{f}{}$
\end{valid}
