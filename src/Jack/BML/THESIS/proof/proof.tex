
%\newtheorem{lemma_1}{Lemma}[section] 
\newtheorem{lemma}{Lemma}[section] % one step sequential execution
%\newtheorem{lemma1}[lemma0]{Lemma} % progress
%\newtheorem{lemma3}[lemma0]{Lemma} % progress
%\newtheorem{lemma2}[lemma0]{Lemma} % if the wp holds of \methodd.\body[0] there exists n such that
% \pc_n = \return or  \ins{\pc_n }  throws a not handled exception E and 
%\pc_n = \return  then  in state_n holds post
% else in state_n holds the exceptional postcondition for E
\newtheorem*{vcGenCorrect1}{Theorem  \ref{vcGenCorrect}}
\newcommand{\state}[1]{ \tau_{#1} } 
\newcommand{\straightBraces}[1]{ \texttt{ (} #1 \texttt{ )} }
\newcommand{\tbc}{\textit{TBC}}


\section{Proof of Correctness } \label{proof}


 
% The next issue that is important for understanding our approach is that we follow the design by 
% contract paradigm \cite{M97oos}. This means that when verifying a method body, we assume that the
% rest of the methods respect their
% specification in the sense of the previous definition \ref{defCorrect}.


% Once generated the verification conditions are proved with the first-order predicate logic rules. We denote that a formula $ f $ 
% has a proof in the empty context like this 
% $$ \vdash f $$

% The following lemma states
% that the proof rules preserve the meaning of predicates as defined in the previous section \ref{interpret}.   
% \begin{lemma_1}[Provability implies validity]
%      $$ \forall f , f \in \formulaBc,  \vdash f \ \Rightarrow \ \interp{f}{} $$
% \end{lemma_1}

Our first concern now will  be to establish that the rules for single bytecode instructions have the following property:
 if the \fwpi \ (short for weakest precondition ) of an 
instruction holds in the prestate then in the poststate of the instruction the postcondition upon which the wp is caclulated holds. 

\begin{lemma}[Single execution step correctness] \label{lemma0}
Let us have a program \Program{} and a method \methodd{} in \Program.
For every intermediate state $s_n =\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } $ and
 initial state $s_{0} =\config{\heap_{0}  }{ 0 }{\lbrack \ \rbrack }{\locVarOnly }{ 0 } $ 
   of the execution of method \methodd \  if the following conditions hold: 
 \begin{itemize}
         \item $ \methodd.\body[0] : s_{0} \stateTransWeight{k}^{*} s_n$
         \item $ \methodd.\body[\pc_n] : s_n \stateTransWeight{k} s_{n+1}$
         \item $ \interp{\wpi{\ins{\pc_n}}{\methodd}{}}{s_n} $
	 \item all methods in \Program{} respect their specification at level \level{k-1}  
	 \item the verification conditions for \Program{} are valid formulas
        % \item    %$ \forall \mbox{ \rm \texttt{n}} : \MethodSet . \mbox{ \rm \texttt{n}}   \neq \methodd \ n$  is correct w.r.t. its specification
 \end{itemize}
  
  then : 
 \begin{itemize}
         
        \item if  $ \methodd.\body[\ins{\pc_n}] = \return $ and $s_{n+1} =\configFinalNorm{\heap_n}{\stackOnly_n( \counterOnly_n )} $  then  $ \interp{\methodd.\normalPost}{s_{n+1}}  $   holds
%	\item else if $ \ins{\pc_n } \neq \return $ and the instruction terminates on a not handled exception \Exc , then
	%      $ \interp{\methodd.\excPostSpec( \Exc )}{ s_{n+1} }  $ 
	
	\item if $\methodd.\body[\ins{\pc_n}] \neq \athrow  $ throws a not handled exception of type $\Exc$,
	 $ s_{n+1} = \configFinalExc{ \heap_{n+1}}{  \referenceOnly   }$ and $\heapTypeOf(\referenceOnly) = \Exc  $ and  $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds.
	
	 \item if $\methodd.\body[\ins{\pc_n}] = \athrow $ throws a not handled exception of type $\Exc$,
	 	 $ s_{n+1} =\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)} $ and $\heap.\heapTypeOf(\stackOnly (\counterOnly) ) = \Exc  $ 
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $  holds.
	 
       \item  else $ \interp{\inter{\pc_n}{\pc_{n+1}}}{s_{n+1}}  $   holds 
        % if  $ \ins{\pc_n} \neq \return $ and the instruction does not terminate on exception, \\
	      % $ s_{n+1} = \config{\heap_{n+1} }{\counterOnly_{n+1} }{ \stackOnly_{n+1}}{\locVarOnly_{n+1} }{ \pc_{n+1} }  $ then
	    %   else $ \interp{\inter{\pc_n}{\pc_{n+1}}}{s_{n+1}}  $   holds 
  \end{itemize} 
\end{lemma}
\textit{Proof:}
The proof is by case analysis on the type of instruction. %that will be next executed and by induction on the maximal depth call $k$. 
We are going to see only the proofs for the instructions \return , \load, \new{} and \putfield{} the other cases being the same
\begin{enumerate} 
		\item    $\methodd.\body[\ins{\pc_n}] = \return$ 
		 
		     
		    	\comment{by initial hypothesis we have that the \wpName{} of the current instruction holds } 
			$$\interp{\wpi{\return}{\pc_{n}}{\methodd}} {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }}  $$
			\mbox{\rm\comment{by definition the weakest precondition for \return } }
		        $$\interp {\substitution{ \methodd.\normalPost }{ \result }{\stack{\topStack} }}  { \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } }  $$
			\mbox{\rm\comment{by the substitution property \ref{substRet}  }}
			 
                          $$\interp { \normalPost} { \configFinalNorm{\heap_n  }
				                                   { \evalExp{ \stack{\topStack}}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } }
                         }$$
			\comment{by definition of the evaluation function $\evalExpName$}
			 $$  \interp{ \normalPost} { \configFinalNorm{\heap_n  }  
							    { \stackOnly_n ( \counterOnly_n  )  } } $$
			\comment{from the operational semantics for \return }\\
		 	$$ s_{n+1} = \configFinalNorm{\heap_n  } { \stackOnly_n ( \counterOnly_n  )  }$$
				\comment{and we obtain that }
			$$	\interp{ \normalPost} {s_{n+1} } $$ 
							    
		
	\item   $\methodd.\body[\ins{\pc_n }] = \load \ i $ 
	          All the cases like \store, \arithOp, \iinc, \nop, \dup, \pop, \push {} are proven in a similar way
	                  
			  
			\comment{by initial hypothesis } \\
			 $$ \interp{\wpi{\load \ i}{\methodd}{\pc_n  }}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} $$ 
			 \mbox{\rm\comment{definition of the wp function} } \\
			  $$
			   \interp{  \inter{\pc_n }{\pc_n  +1 } \begin{array}{l} \subst{\topStack}{\topStack + 1} \\
		                                                 \subst{\stack{\topStack + 1} } {\locVar{i} }
	                                        \end{array}}{ \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } }  $$	
			\comment{applying the substitution properties \ref{substCntr} and \ref{substStack} }\\
		
		       
		      $$ \numConclusion{1} \ \interpTwoLines{\inter{\pc_n }{\pc_n  +1 }   }
                                  { \config{\heap_n }{\counterOnly_n  + 1}{ \update{\stackOnly_n }{\counterOnly_n  + 1 }{\locVarOnly_n (i) } }{\locVarOnly_n }{\pc_{n+1} } } $$
		    
		   
			\comment{from the operational semantics of the \load{} instruction in section \ref{opSem}} \\
		$$ \numConclusion{2} \ s_{n+1} = \config{\heap_n }{\counterOnly_n  + 1}{ \update{\stackOnly_n }{\counterOnly_n  + 1 }{\locVarOnly_n (i) } }{\locVarOnly_n }{\pc_{n+1} } $$
			 \comment{ from \numConclusion{1} and \numConclusion{2} follows } \\
			 $$\interp{\inter{\pc_n }{\pc_n  +1 }  }{s_{n + 1}} $$
		  	 \comment{and the lemma holds in this case } 
			 
	\item   $\methodd.\body[\ins{\pc_n}] = \new  \ \clazz $ 
	        
		      	\mbox{\rm\comment{by initial hypothesis }} \\ 
                        $$ \interp{\wpi{\new \ \clazz }{\methodd}{\pc  }}{\config{\heap_n }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }} $$
			  \mbox{\rm\comment{definition of the wp function} } \\
			 
	  $$	\numConclusion{1} \	\interpTwoLines{
		      \begin{array}{l}
			\forall \referenceOnly,  (\neg \ \instances(\referenceOnly )\wedge  \typeof{\referenceOnly} = \clazz \wedge
			   \referenceOnly \neq \Mynull) \Rightarrow \\
                          %\phantom{\forall}      \typeof{\referenceOnly} = \type{\clazz} \Rightarrow \\ 
			\phantom{\forall} \phantom{\forall} \inter{i}{i+1} 
			\begin{array}{l} 
                               \subst{ \counter}{ \counter + 1 } \\
			       \subst{ \stack{ \counter + 1} }{\referenceOnly} \\
		               \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } \\
			       %	\subst{ \typeof{\referenceOnly}}{ \clazz } 
		       \end{array} \end{array}} {\config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }}   $$
		       
		       \comment{from the operational semantics of \new \ in section \ref{opSem}} \\
		       
		      $$\numConclusion{2} \ s_{n+1} = \config{\heap_{n +1}}{\counterOnly_n  +1  }{\update{\stackOnly_n }{\counterOnly_n  +  1}{ \referenceOnly'} }{\locVarOnly_n  }{\pc_n  +1} $$ 
		      $$\numConclusion{3} \newRef{\heap}{\clazz} = (\heap_{n+1},\referenceOnly' )$$ 
		       \\
		       \comment{instantiate \numConclusion{1} with \mbox{\rm\referenceOnly}$'$  } \\
		       $$ \numConclusion{4}  \  	 \interpTwoLines{\begin{array}{l}
			 \neg \ \instances(\referenceOnly' ) \wedge
			  \referenceOnly' \neq \Mynull \Rightarrow \\
			  %\typeof{\referenceOnly'} = \clazz  \Rightarrow \\  
			  
			\phantom{\forall}	\inter{i}{i+1} 
			\begin{array}{l} 
                               \subst{ \counter}{ \counter + 1 } \\
			       \subst{ \stack{ \counter + 1} }{\referenceOnly'} \\
		               \subst{ \fieldd} { \update{\fieldd} { \referenceOnly' }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } %\\
			     %  	\subst{ \typeof{\referenceOnly'}}{ \clazz } 
		       \end{array}\end{array} } {\config{\heap _n }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }}$$
		       \mbox{\rm\comment{ from     \numConclusion{3}   }} \\
		       \numConclusion{5} \\
		       $$\interp{ \begin{array}{l}
			              \neg \ \instances(\referenceOnly' ) \wedge 
				      \referenceOnly' \neq \Mynull \wedge 
				      \typeof{\referenceOnly'} = \clazz 
				\end{array}} { \config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }  }$$
		
		       \comment{ from     \numConclusion{4} and   \numConclusion{5} we obtain that the intermediate predicate holds in state $s_n$ } \\	  
                        $$ \interpTwoLines{\inter{i}{i+1} 
			      \begin{array}{l} 
                                    \subst{ \counter}{ \counter + 1 } \\
			            \subst{ \stack{ \counter + 1} }{\referenceOnly'} \\
		                    \subst{ \fieldd} { \update{\fieldd} { \referenceOnly' }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } \\
                                    %\subst{ \typeof{\referenceOnly'}}{ \clazz } 
			    \end{array} }{ \config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }  } $$
		       
		       \mbox{\rm\textit{\{from lemmas \ref{substCntr},  \ref{substStack} and \ref{substHeap}, \ref{newHeap} }} \\
		       \mbox{\rm\textit{ and the operational semantics of the instruction \new \} }} \\  
		       $$\interp{ \inter{i}{i+1} }{s_{n+1}}$$ 
		
\item  $\methodd.\body[\ins{\pc_n }] = \putfield   \ \fieldd $  \\
                The cases \getfield, \arrstore, \arrload,  \arraylength{} are similar to this case.
		This instruction may potentially throw a \NullPointerExc{} as the object reference whose field is updated may be \Mynull.
		Thus, we should consider three cases : the case when the reference is \Mynull{} and the \NullPointerExc{} exception is not caught,
		case when the reference is \Mynull{} and the \NullPointerExc{} exception is  caught, and the case when the reference is not \Mynull.
		We consider in the following only the case, when an uncaught exception of type \NullPointerExc{} is thrown. 
                		   \comment{by initial hypothesis } \\ 
                        %$$ \interp{\wpi{\pc_n   }{\methodd}{}}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} $$
			 %\comment{definition of the \wpName{}  function}  \\
	
                %   \comment{ we get three cases }
		%   \begin{enumerate}
		%          \item the dereferenced reference on the stack top is \Mynull \ and an exception handler starting at 
                %                instruction $k$ exists for \NullPointerExc \  and $\ins{\pc_n} $ is in its scope   
		% 		             \comment{thus, we get  the hypothesis   } \\
		% 		             $$ \interp{ \stack{\counter } = \Mynull }{ \config{\heap_n }{\counterOnly_n}{\stackOnly_n }{\locVarOnly_n }{\pc_n }  }$$  \\
		% 			      \mbox{\rm\comment{ from the above conclusion and \numConclusion{1} we get   } } \\
		% 			      $$\interp{ \methodd.\excPost( \pc_n , \NullPointerExc ) 
		  % 										 }{ \config{\heap _n}{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } $$ \\
		  % 			     \mbox{\rm\textit{\{ from Def. \ref{wp:exc:defExcRuntime}  of the function $ \methodd.\excPost$ }} \\
                   %                              \mbox{\rm\textit{ and the assumption that the exception is handled we get \} } } \\
		  % 		     
                   %    	 $$\interpTwoLines{ \begin{array}{l} 
		  % 	       \forall \referenceOnly,\\
		  % 	       	\Myspace \neg \ \instances(\referenceOnly) \wedge \\
		  % 		\Myspace \referenceOnly \neq \Mynull \Rightarrow	\\
		  % 		\Myspace \Myspace  \inter{\pc_n}{\pc_{n+1}} \\
		  % 		\Myspace \Myspace		         \begin{array}{l}
		  % 			           \subst{\counter}{0} \\
		  % 				   \subst{\stack{0}}{\referenceOnly} \\
		  % 				   \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) } }_{{\small \forall \fieldd : \FieldSet, \% 
					  % 	   \subtype{\fieldd.\declaredIn}{ \mbox{ \rm \texttt{Exc}}} } }
		   % 		                 \end{array} 
                   %                       \end{array} } {\config{\heap_n  }{\counterOnly_n  }{\stackOnly_n }{\locVarOnly_n }{\pc_n }}$$
		    %   	\mbox{\rm\textit{\{ from lemmas \ref{substCntr},  \ref{substHeap}, \ref{substStack} and \ref{newHeap}}}\\
		%	\mbox{\rm\textit{ and the operational semantics of  \putfield \} }}\\
                        
		%		$$\interp{ \inter{\pc_n}{\pc_{n+1}}}{ s_{n+1}}$$
		
		    		 
		 $$  \interpTwoLines{ \stack{\counter } \ne \Mynull \Rightarrow \\
		 				 \Myspace \inter{i}{i+1} \subst{ \counter }{  \counter -2 } 
		 					     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
		 				        
		 				        \\
		 					\wedge \\
		 					\stack{\counter} = \Mynull \Rightarrow   \methodd.\excPost( i, \NullPointerExc ) }
                        {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} $$     
                   \comment{ because the instruction terminates on an exception of type \NullPointerExc{}, i.e. \stack{\counter}=\Mynull{}  which is not caught we get    } 
		    
		  $$ \interp{   \methodd.\excPost( i, \NullPointerExc ) }
                        {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} $$
                 \comment{by Def. \ref{wp:exc:defExcRuntime}  of the function \excPost{} and because the exception is not caught, we obtain } 
                $$
               \interp{   \begin{array}{l}
                     \forall \referenceOnly
                        (\neg \ \instances(\referenceOnly) \wedge 
		       \referenceOnly \neq \Mynull	
		       \typeof{\referenceOnly} = \NullPointerExc )  \Rightarrow\\
            \methodd.\excPostSpec( \NullPointerExc )
                    \begin{array}{l}
                        \subst{\counter}{0} \\
			\subst{\stack{0}}{\referenceOnly} \\
                         \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) } }_{{\small{\fieldd}}}^
{ {\small \subtype{\fieldd.\declaredIn}{ \NullPointerExc } }} \end{array} }{s_1} \end{array}	$$
		\comment{because we assume that  \putfield{} makes an exceptional step which is not caught, we get from the operational semantics of \putfield}
                $$ s_{n+1} = \configFinalExc{\heap'}{\referenceOnly'}, where \ (\heap', \referenceOnly' )= \newRef{\heap}{\NullPointerExc}$$
		 \comment{from the definition of the function \newRefOnly{} in Section \ref{heap} }
		 $$ \interp{\methodd.\excPostSpec( \NullPointerExc )
                    \begin{array}{l}
                        \subst{\counter}{0} \\
			\subst{\stack{0}}{\referenceOnly'} \\
                         \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) } } 
                        _{{\small{\fieldd}}}^{ {\small \subtype{\fieldd.\declaredIn}{ \NullPointerExc } }} \end{array}}{s_{n}} $$


 	\comment{ from lemmas \ref{substCntr},  \ref{substHeap}, \ref{substStack} and \ref{newHeap} we obtain}\\
           $$ \interp{\methodd.\excPostSpec( \NullPointerExc ) }{s_{n+1}}$$
   
		 %  $$\interp{  \begin{array}{l} 
		 % 	\forall \referenceOnly,\\
		 % 	( \neg \ \instances(\referenceOnly) \wedge \\
		 % 	\referenceOnly \neq \Mynull \Rightarrow	\\
                 %     	 \methodd.\excPostSpec( \NullPointerExc ) \\
	 % 		 \begin{array}{l}
		  %                \subst{\EXC }{\referenceOnly  }\\
		 % 	        \subst{ \fieldd}{ \update{\fieldd } { \referenceOnly }{\defaultValueOnly( \fieldd.\fieldType ) } }_{\fieldd}^{ 
		 % 	        \subtype{\fieldd.\declaredIn}{ \mbox{ \rm \texttt{Exc}}} } }    \\
	 % 		   \end{array} 
	 % 	    \end{array}  }{ \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } $$  \\  
	 % 		\mbox{\rm \textit{\{ from lemmas   \ref{substStack}, \ref{substHeap}, \ref{newHeap}  and}}\\
	 % 		\mbox{\rm \textit{ the operational semantics of \putfield \}}}\\
	 % 		$$\interp{  \methodd.\excPostSpec(\NullPointerExc  )}{s_{n+1}}	$$	    
		
             %     % \item the reference on the stack top is not \Mynull 
	 % 		 \comment{thus, we get  the hypothesis   } 
	 % 		$$  \interp{ \stack{\counter } \neq \Mynull }{ \config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{\pc }  } $$\\
	 % 		 \comment{ from the above conclusion and \numConclusion{1} we get   } \\
	 % 		 $$ \interpTwoLines{\inter{i}{i+1}
          %                                            
          %                                                      \subst{ \counter }{  \counter -2 } 
	 % 						     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
	 % %  					        }{\config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{\pc }} $$
	 % 		 \mbox{\rm\textit{\{ applying lemmas \ref{substCntr} and \ref{substHeap}  and }}\\
	 % 		\mbox{\rm\textit{ of the operational semantics of \putfield \}} } \\
	 % 		$$\interp{ \inter{i}{i+1}}{s_{n+1}}$$			       
						       
	           

               
	   %\end{enumerate}

 \item method invocation $\methodd.\body[\pc_n] =\invoke \ \mbox{\rm\texttt{n} }$
We shall ignore here the part of the \wpName{} which concerns the exceptional termination for reasons of clarity. Treating the whole 
definition of the \wpName{} for method invokation is done in a rather similar way as the part that we sketch here.

\newcommand{\mInv}{\mbox{\rm \texttt{n}}}
         %$$\interp{\wpi{ }{\methodd}{\pc_n  }}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }}$$ \\
       \comment{definition of the \wpName{} function for method invokation, we get first that the precondition of the invoked method holds  } 

	 $$  \numConclusion{1} \   
\interp{  \mbox{\rm\texttt{n} } .\pre\subst{\locVar{s}}{ \stack{\counter + s - \mbox{\rm\texttt{n} }.\numArgs}}_{s = 0}^{ \mbox{\rm\texttt{n} }  .\numArgs } } {s_n}$$
 
\comment{and second we get also that the postcondition of the invoked method \mbox{\rm\texttt{n'} } .\normalPost implies $\inter{i}{i+1}$ }
 $$\begin{array}{l}		
   					
	 \numConclusion{2} \  	 s_0, s_n \vDash
                       \forall res, \boundVar_1 , \ldots ,\boundVar_{\mbox{\rm\texttt{n} } .\modif.length }  \\
           
	 				 				      \mbox{\rm\texttt{n} } .\normalPost %\begin{array}{l}
									\subst{\result}{  res } %\\
									%\subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} } .\modif.length }
									%\subst{\old{\ast}}{\ast}	 
									\subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }                                                                                                	%\end{array}  
                                                                   \Rightarrow \\ 
										      
										      \inter{i}{i+1 } %\begin{array}{l}
										                                   \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs}
														   \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ res }																%	\end{array}																									
	 				 			 	\end{array} $$

	   \mbox{\rm\textit{\{ As the verification conditions for the program \Program{} are valid, we can}}\\
	   \mbox{\rm\textit{ get that the verification conditions that  \mbox{\rm \texttt{n'}} }}\\
	    \mbox{\rm\textit{  is a behavioral subtype the overriden method \mbox{\rm\texttt{n}}  }} \\
	    \mbox{\rm\textit{ and we get that the first two conditions from Def. \ref{wp:vc:subt} on page \pageref{wp:vc:subt}  hold which we denote as }}\\
           \mbox{\rm\textit{ \mbox{\rm \ref{wp:vc:subt}.1}  and  \mbox{\rm\ref{wp:vc:subt}.2 } \}}}
	   $$  \begin{array}{l}\numConclusion{3} \  \validFormula{ \ref{wp:vc:subt}.1 } \\
	     \numConclusion{4} \  \validFormula{ \ref{wp:vc:subt}.2  } 
	      \end{array}$$
  \mbox{\rm\textit{\{from the fact that we consider only valid states, we can deduce from the validity of \numConclusion{1} and  }}\\
  \mbox{\rm\textit{   \numConclusion{5} that the the precondition of the overriding method holds in state $s_n$ w.r.t. initial state $s_0$ \}} }\\
      $$\interp{\mbox{\rm \texttt{n'}}.\pre \subst{\locVar{i} }{ \stack{\counter + s - \mbox{\rm\texttt{n} }.\numArgs} }_{i=0}^{\mbox{\rm\texttt{n}}.\numArgs }   }{ s_n}  $$

 \mbox{\rm\textit{\{      From the operational semantics of method invocation the method lookup function}}\\
 \mbox{\rm\textit{   \lookupOnly{} will find the method \mbox{\rm \texttt{n'}} which overrides method }}\\
 \mbox{\rm\textit{   \mbox{\rm\texttt{n}} and which will be actually executed.  }}\\
 \mbox{\rm\textit{  The method  \mbox{\rm \texttt{n'}} will be executed at initial state $s'$ described below and ends in the state $ \configFinalNorm{\heap'}{\Res}$}}\\
 \mbox{\rm\textit{ Because \mbox{\rm \texttt{n'}} respects its specification level at \level{k-1}, }}\\
 \mbox{\rm\textit{ we can apply the initial hypothesis for \mbox{\rm\texttt{n'}} and the}} \\
 \mbox{\rm\textit{   concrete initial and ffinal states  and we then get\}}}
                $$  \begin{array}{l}
		  \numConclusion{6} \  \interp{ \mbox{\rm \texttt{n'}}.\pre  }{s'}
                                           \Rightarrow 
                                 \interp{ \mbox{\rm \texttt{n'}}.\normalPost  }{\configFinalNorm{\heap'}{\Res}} \\\\
		             where \\              s'=  \config{\heap_n}       
                                                       {0}
						       {\newStack }
                                                       {\lbrack \stackOnly_n( \counterOnly_n - \mbox{\rm \texttt{n'}}.\numArgs ),\ldots ,\stackOnly_n( \counterOnly_n)\rbrack }
						       {0} \\
						       
				                      \counterOnly_{n+1} = \counterOnly_n - \mbox{\rm \texttt{n}}.\numArgs + 1 \\
						       \stackOnly_{n+1} = \update{\stackOnly_n}{\counterOnly_n}{\Res} \\
						       \pc_{n+1}  = \pc_n + 1 \\
						       \heap_{n+1} = \heap' \\\\
            \end{array}$$


 \mbox{\rm\textit{\{ From the validity of method  \mbox{\rm \texttt{n'}} \numConclusion{6} and \numConclusion{5}, we get that the postcondition of  \mbox{\rm \texttt{n'}}  }}\\ 
 \mbox{\rm\textit{ holds in the terminal state $ \configFinalNorm{\heap'}{\Res}$ w.r.t. the initial state $s'$ of the execution of method \mbox{\rm \texttt{n'}}   \} }}
    $$\numConclusion{7}  \ \interp{\mbox{\rm \texttt{n'}}.\normalPost }{\configFinalNorm{\heap'}{\Res} } $$ 

  \mbox{\rm\textit{\{  Because the postcondition \mbox{\rm \texttt{n'}}.\normalPost{} does not mention the operand stack, neither the stack counter   }}\\
 \mbox{\rm\textit{ and because of the relation between $s_{n+1}$ and  $ \configFinalNorm{\heap'}{\Res}$  we can conclude that the following also holds } }

$$\numConclusion{7}  \ \interp{\mbox{\rm \texttt{n'}}.\normalPost \subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }  \subst{\result}{\Res } }{s_{n} } $$
 
 \mbox{\rm\textit{ \{ We can apply the second part of the behavioral subtyping from Lemma  \ref{wp:vc:subt} which expresses that } } \\
 \mbox{\rm\textit{the method respects its postcondition and because of \numConclusion{7} and get \}} }\\ 
$$
\interp{\mbox{\rm \texttt{n}}.\normalPost \subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }  \subst{\result}{\Res } }{s_{n} } 
$$
\mbox{\rm\textit{ \{ We can apply the resulting judgement with modus ponens to \numConclusion{2}  where}}\\
\mbox{\rm\textit{  we initialise the quantification over the modified locations with their }}\\
\mbox{\rm\textit{  values in state $s_n$ and the variable $res$ to \Res \} }}
$$ 
\interp{\inter{i}{i+1 }   \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs} \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ \Res }}{s_n}
$$

\mbox{\textit{\{we can apply Lemma \ref{substCntr} for substitution of the stack counter as well as the stack }}\\
\mbox{\textit{ \label{substStack} and by the operational semantics of the instruction \invoke{} in case of normal termination get  \}}}

$$ 
\interp{\inter{i}{i+1 }  }{s_{n+1}}
$$
\end{enumerate}
\Qed \\

%The next lemma establishes formally a relation between the \wpName{} of an instruction and the intermediate predicate that must hold
%in between the instruction and its successor. In particular, that whenever $\wpi{i}{\methodd}{} $  holds in the prestate of the instruction point $i$
%the predicate  $\wpi{\inter{i}{j}}{\methodd}{} $  holds where $j$ is the next instruction to be executed.
% 
%\begin{lemma}[\wpName{} implies \interOnly ] \label{proof:wpImpInter}
%For every state $s =\config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{s } $  $s' =\config{\heap' }{\counterOnly' }{\stackOnly }{\locVarOnly }{s } $ and
%initial state $s_{0} =\config{\heap_{0}  }{ 0 }{\lbrack \ \rbrack }{\locVarOnly }{ 0 } $ such that 
% \begin{itemize}
%         \item $ \methodd.\body[0] : s_{0} \stateTransWeight{k}^{*} s$
%         \item $ \methodd.\body[s] : s \stateTransWeight{k} s'$
%%         \item $ \interp{\wpi{\ins{\pc}}{\methodd}{}}{s} $
%\end{itemize}
% we have that :
%$ \interp{\inter{\pc}{\pc'}}{s'}$
%%\end{lemma}
%\textit{Proof:}
%The proof is by case analysis on the instruction at point $\pc_n$. We sketch the  proof for the instruction \load.
%
%$\interp{ \wpi{\pc : \load \ i }{\methodd}{}}{s} $\\
%\mbox{\rm \comment{by definition of  the wp function in Section \ref{wpRules} } } \\
%%$ \interp{ \inter{\pc_n}{ \pc_n + 1}   \subst{\counter}{\counter +1}  \subst{  \stack{ \counter  + 1}}{\locVar{j}}  }{s} $ \\
%\comment{from lemmas \ref{substCntr} and \ref{substStack}} 	 \\
%                         $\iff \\
  %               \interpTwoLines{  \inter{\pc}{ \pc + 1} } 
%                                    { s  \subst{\counterOnly}{\evalExp{\counter + 1}{s_n} }\subst{\stackOnly} { \update{\stackOnly}{ ( \evalExp{\counter + 1}{s_n} ) }{ \evalExp{ \locVar{i} } {s_n} }}  }$ \\
%				    
%           \comment{from the operational semantics of the instruction \load{} follows}\\
%	   
%          $s' = s  \subst{\counterOnly}{\evalExp{\counter + 1}{s_n} }\subst{\stackOnly} { \update{\stackOnly}{ ( \evalExp{\counter + 1}{s_n} ) }{ \evalExp{ \locVar{i} } {s_n} }} $\\
%	  
%	  \comment{we conclude then }\\
%	  $\interpTwoLines{  \inter{\pc}{ \pc +1} }  { s'}$
%	  
%\Qed\\



We now establish a property of the correctness of the wp function  for an execution path. The following lemma states that if the calculated preconditions
of all the instructions in an execution path holds then either the execution terminates normally (executing a \return) or exceptionally, or 
another step can be made and the \fwpi \ of the next instruction holds.



\begin{lemma}[Subject reduction] \label{lemma1}
Let us have a program \Program{} and a method \methodd{} in \Program. 
%Assume we have a method \methodd \ with normal postcondition  $\methodd.\normalPost$ and exception function $\methodd.\excPostSpec$. 
For every state  
 $ \config{\heap_{0}}{\counterOnly_{0}}{\stackOnly_{0}}{\locVarOnly_{0}}{\pc_{0}}$ 
and state $\config{\heap_n}{\counterOnly_n}{\stackOnly_n}{\locVarOnly_n}{\pc_n} $ denoted respectively with $s_0$ and  $s_n$,
such that :
 \begin{itemize}
         \item $ \methodd.\body[0] : s_{0} \stateTransWeight{k}^{n} s_n$
         \item $ \methodd.\body[\pc_n] : s_n \stateTransWeight{k} s_{n+1}$
         \item $ \forall i, (\ 0 \leq i \leq n ) , \ \interp{\wpi{\ins{\pc_{i}} }{ \methodd } {  }}{ s_i } $  
	 \item all methods in \Program{} respect their specification at level \level{k-1}  
	 \item the verification conditions for \Program{} are valid formulas
        % \item    %$ \forall \mbox{ \rm \texttt{n}} : \MethodSet . \mbox{ \rm \texttt{n}}   \neq \methodd \ n$  is correct w.r.t. its specification
 \end{itemize}

then the folloing holds:
\begin{enumerate}
	\item if $\methodd.\body[\ins{\pc_n}] = \return$ and $s_{n+1} =\configFinalNorm{\heap_n}{\stackOnly_n( \counterOnly_n )} $ then $\interp{\methodd.\normalPost} {s_{n+1} } $ holds.  
	
        	\item if $\methodd.\body[\ins{\pc_n}] \neq \athrow  $ throws a not handled exception of type $\Exc$,
	 $ s_{n+1} = \configFinalExc{ \heap_{n+1}}{  \referenceOnly   }$, $\heap.\heapTypeOf(\referenceOnly) = \Exc  $ and  $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds.
	
	 \item if $\methodd.\body[\ins{\pc_n}] = \athrow $ throws a not handled exception of type $\Exc$,
	 	 $ s_{n+1} =\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)} $ and $\heap.\heapTypeOf(\stackOnly (\counterOnly) ) = \Exc  $ 
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $  holds.


%	\item if $\ins{\pc_n}\neq \athrow  $ throws a not handled exception of type $\Exc$ \\ then
%	$\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds 
%	where  $\heap.\heapTypeOf(\referenceOnly) = \Exc  $ and  $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$.
%	
%	 \item if $\ins{\pc_n} = \athrow $ throws a not handled exception of type $\Exc$ \\
%	 then $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $  holds
%	 where $\heap.\heapTypeOf(\stackOnly (\counterOnly) ) = \Exc  $ 
	
	
	\item else   $\interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{  } } { s_{n+1} } $  holds
\end{enumerate}
\end{lemma}

\textit{Proof :}
The proof is by case analysis on the execution relation $\execRel{}$  between the current instruction and the next instruction.

 We consider three cases: the case when the next execution step does not enter a cycle (the next instruction is not a loop entry in the sense of Def.\ref{defLoop} )
the case when the current instruction is a loop end and the next instruction to be executed is a loop entry instruction (the execution step is $\execRel_l$ )
and the case when the current instruction is not a loop end and the next instruction is a loop entry instruction ( corresponds to the first iteration of a loop) 

  
\begin{enumerate}
  \item the next instruction to be executed is not a loop entry instruction. 
           $$ \begin{array}{l}
	      \mbox{\rm \comment{following Def. \ref{inter} of the function \interOnly \ in this case }}\\
              \numConclusion{1} \ \inter{\pc_n}{\pc_{n+1}} = \wpi{ \ins{\pc_{n+1} }}{\methodd}{}\\
	      \mbox{\rm \comment{ by initial hypothesis}} \\
	      \numConclusion{2} \ \interp{\wpi{\ins{\pc_{n}} }{ \methodd }{} }{ s_n }\\
	      \mbox{\rm \comment{from the previous lemma \ref{lemma0} and \numConclusion{2} , we know that}}\\
	      \numConclusion{3} \   \interp{\inter{\pc_n}{\pc_{n+1}} }{ s_{n+1} }\\
	      \mbox{\rm \comment{from \numConclusion{1} and  \numConclusion{3} }}\\
	      \interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{} }{ s_{n+1} }
	      \end{array}$$

 
  
\item $\ins{\pc_n} $ is not a loop end and the next instruction to be executed is a loop entry 
instruction at index $loopEntry $ in the array of bytecode instructions of the method \methodd{}.
 %(i.e. the execution step is of kind $\execRel^l$, see Def.\ref{defLoop}  ).
 Thus, there exists a natural number  $ i , 0 \le i < \methodd.\loopSpecTable.length   $   such that
 $ \methodd. \loopSpecTable[i].\posL = loopEntry $,  $ \methodd. \loopSpecTable[i].\invL = I $ and
   $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$.

$$ \begin{array}{l}
\mbox{\rm\comment{by initial hypothesis}} \\
\interp{\wpi{\pc_n}{\methodd}{}}{s_n} \\
\comment{from Lemma \ref{lemma0} we have }\\
\interp{\inter{\pc_n}{\pc_{n+1}}}{s_{n+1}} \ = \\

 \comment{from the Def. \ref{inter} for an edge between a loop entry and a loop end }\\				    
            
                 \interp{  I \  \wedge
                                             \forall mod_i ,  i = 1..s \left( I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{} \right) 
                                 }  { s_{n+1}  }\\
  
\mbox{\rm \textit{\{we can get from the last formulation and}}\\
\mbox{\rm \textit{the semantics of the universal quantification\}}}\\
  \numConclusion{1} \   \interp{I}   {s_{n+1} } \\
                              
                 \numConclusion{2}  \ \interp{ I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{} }
                                     {s_{n+1}  } \\
   % \end{array} 
\mbox{\rm \comment{ from \numConclusion{1}  and \numConclusion{2}  }}\\
  \interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{} }{s_{n+1}  }\\
\end{array} $$
\item $\ins{\pc_n} $ is an end of a cycle \ and the next instruction to be executed is a loop entry 
instruction at index $loopEntry $ in the array of bytecode instructions of the method \methodd
 (i.e. the execution step is of kind $\execRel^l$ ).
 Thus, there exists a natural number  $ i , 0 \le i < \methodd.\loopSpecTable.length   $   such that
 $ \methodd. \loopSpecTable[i].\posL = loopEntry $,  $ \methodd. \loopSpecTable[i].\invL = I $ and
   $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$.
We consider the case when the current instruction is a sequential instruction. The cases when the current instruction 
is a jump instruction are similar.   \\ 
		
\comment{by hypothesis we get} \\
 $$ \interp{ \wpi{\ins{\pc_n} }{\methodd}{}}{s_n}$$

\comment{ from Def. \ref{inter} and transformation over the above statement} 
$$\begin{array}{ll} \numConclusion{1} &  \interp{ I}{s_{n + 1}}  \end{array}$$
\comment{by hypothesis,  $loopEntry = \pc_{n +1}$.
         From def. \ref{defLoop}, we
         conclude that there is a prefix  $subP = \methodd.\body[0] \execRel^{*} \ins{loopEntry}$  of the current execution path which does not pass through
	 $\ins{\pc_n}$. We can conclude that the transition between   $\ins{loopEntry}$ and its predecessor  $ \ins{k} $ ( which is at index $k$ in \methodd.\body)
	  in the path $subP$ is not a backedge. By hypothesis we know that 
           $ \forall i , 0 \le i \le  n, \interp{\wpi{\ins{\pc_i}}{\methodd}{}}{s_i}$.  From def.\ref{inter} and
	 lemma \ref{lemma0} we conclude }
          
   $$  \numConclusion{2 } \  
         \exists k, 0 \le k \le n \Rightarrow 
         \interp{ \begin{array}{l}
	                                    I 
					    \wedge
                                           \forall mod_i ,  i = 1..s \left( \begin{array}{l } 
	                                                           I \Rightarrow 
	                                                           \wpi{\ins{loopEntry}}{\methodd}{} 
							      \end{array}\right)
				 \end{array} }{s_k}  $$
         \mbox{\rm\textit{\{it also follows that the states $s_k$ and $s_{n+1}$ are the same except for the locations in the}}\\
        \mbox{\rm\textit{ modifies list \modifL of the loop  \}}} \\ 
$$ \numConclusion{3} \ 	    s_k =^{\modifL} s_{n+1}   $$
   \comment{because $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$  and    from \numConclusion{2} and  \numConclusion{3}     }
 $$  \numConclusion{4} \ \interp { I \Rightarrow \wpi{\ins{loopEntry}}{\methodd}{}} {s_{n+1}}    $$
 \comment{from \numConclusion{1} and  \numConclusion{4} }
   
 $$  \interp{ \wpi{\ins{loopEntry}}{\methodd}{}}{s_{n+1}} $$
 \comment{because \ins{loopEntry} = $\ins{\pc_{n+1}} $ we conclude}
	      $$\interp{ \wpi{\ins{\pc_{n+1}} }{\methodd}{} }{s_{n+1}} $$
         

\end{enumerate}

\Qed

We now show that starting execution of a method in a state where the \fwpi{}
 predicate for the entry instruction holds implies that the  
\fwpi{} for all the instructions in the execution path hold. 

\begin{lemma}[\fwpi \ precondition for method entry point holds initially ]\label{lemma3}
Let us have a program \Program{} and a method \methodd{} in \Program.
 Let us have states  $s_{0}$ and $s_n$ such that: 
\begin{itemize} 
     \item execution of method  \methodd{} starts  in state $s_{0}$ 
     \item  makes $n$ steps to reach the intermediate state $s_n$: $s_{0} \stateTransWeight{k}^{n} s_{n} $
     \item $\interp{ \wpi{0 } {\methodd}{}}{ s_{0}}$ holds
     \item all methods in \Program{} respect their specification at level \level{k-1}  
     \item the verification conditions for \Program{} are valid formulas
\end{itemize}  
 then the following holds
$$\forall i,  0 < i \le n, \  \interp{ \wpi{\pc_i} {\methodd}{ }}{ s_{i}} $$

\end{lemma}
Proof : Induction over the number of execution steps $n$
\begin{enumerate}
    \item\textit{ $s_{0} \stateTransWeight{k} s_{1}$. By initial hypothesis we have that  $\interp{ \wpi{0 } {\methodd}{}}{ s_{0}}$
             we can apply lemma \ref{lemma1}, we get that 
             $\interp{ \wpi{\ins{\pc_{1}}}{\methodd}{  } } { s_{1} }  $ and thus, the  case when one step is made from the initial state
             $s_0$  holds}   
    \item \textit{Induction step:   $s_{0} \stateTransWeight{k}^{n - 1} s_{n - 1}$ and \\
           $\forall i,  0 < i \le n - 1, \  \interp{ \wpi{\pc_i} {\methodd}{}}{ s_{i}} $
           and there can be made one step $s_{n- 1} \stateTransWeight{k} s_n$.  Lemma \ref{lemma1} \ can be applied and we get that
           $\numConclusion{1} \ \interp{ \wpi{\pc_n } {\methodd}{ } }{ s_{n}} $. 
	   From the induction hypothesis and \numConclusion{1} follows that 
	   $$\forall i,  0 < i \le n, \  \interp{ \wpi{\pc_i } {\methodd}{ }}{ s_{i}} $$ }
\end{enumerate}
\Qed \\

Having the last lemma we can  establish that if a method starts
execution in a state in which the \fwpi{} precondition  for the method entry instruction 
holds and the method terminates then the method postcondition holds in the method final state.

\begin{lemma}[\fwpi \ precondition for method entry point holds initially]\label{lemma2}
Let us have a program \Program{} and a method \methodd{} in program \Program.
For all states $s_0$ and $s_n$ such that   $\methodd : s_0  \stateTransTermWeight{k} s_n $
and let $\interp{ \wpi{} {\methodd}{0}}{ s_{0}}$ holds. Assume that
  all methods in \Program{} respect their specification at level \level{k-1} and 
the verification condition for \Program{} are valid formulas.
Let the program counter in state $s_n$ points to an instruction $\return $ or
 an instruction which throws an unhandled exception of type \mbox{\rm\texttt{Exc}}, then  the following holds:
\begin{itemize}
    \item if $\methodd.\body[\pc_{n-1}] = \return $     then $\interp{ \methodd.\normalPost}{s_{n}}$

    	\item if $\methodd.\body[\pc_{n-1}]$ throws a not handled exception of type $\Exc$  then  $\interp{\methodd.\excPostSpec( \Exc)}{ s_{n} } $ holds.
	

%    \item  if $\ins{\pc_n}$ throws a not handled exception of type \mbox{\rm\texttt{Exc}} then  $\interp{ \methodd.\excPostSpec(\mbox{\rm\texttt{Exc}}  )}{s_{n}}$
\end{itemize}
\end{lemma}
\textit{Proof:} 
%By hypothesis the execution of method \methodd \ always terminates, i.e. there exists $n$ steps such that
\textit{Let $ \ s_{0} \stateTransWeight{k}^{*} s_n $ and $\methodd.\body[\pc_n]$ is a \return \ or an instruction that throws a  not handled exception.
 Applying lemma \ref{lemma3}, we can get that $\forall i, 0 \le i < n , \ \interp{ \wpi{\pc_i } {\methodd}{ } }{ s_{i}}$. 
We apply lemma \ref{lemma1} for the case for a \return \ or instruction that throws an unhandled exception which allows to conclude that the current statement holds.
}\\
\Qed\\

Now, we establish under what conditions we can conclude that a method respects its specification at level \level{k}.
\begin{lemma}[method respects its specification at level \level{k}]\label{lemmaMethRespSpec}
Let us have a program \Program{} and a method \methodd{} in \Program.
If  all methods in \Program{} respect their specification at level  \level{k -1} and 
 the verification conditions for \Program{} are valid formulas
then \methodd{}  respects its specification at level \level{k} 
\end{lemma}
 The proof  follows directly from Lemma \ref{lemma2}. We are now ready to prove Theorem \ref{vcGenCorrect}.


\begin{vcGenCorrect1}
 If the verification conditions  of program \Program{} (see  subsection \ref{wp:vcMeth})
are valid then \Program{} is correct w.r.t. Def. \ref{defCorrectProgram}
\end{vcGenCorrect1}
\textit{Proof:}
We want to establish now  that if for every \methodd{}
 in every class \class{} in a program \Program{}  the respective verification conditions are valid then 
the \Program{} is correct as defined in Def. \ref{defCorrectProgram}.
 This, in particular, means that for all levels $\level{k} \ge 0 $ the program is correct in  level \level{k}.
We reason by induction on the level \level{k}. 
\begin{description} 
\item[base case \level{k} = 0]
 In this case, because we can not have an execution step at level \level{0}, we conclude that all methods at level  \level{0}
are correct
\item[induction step] Let us have that the program is correct at level $\level{k-1}$. 
In particular, this means that for every class \class{}, every method \methodd{} in \class{} is correct at level \level{k-1}.
We can apply Lemma \ref{lemmaMethRespSpec} to every single method  \methodd{} in \Program{}, 
 the induction hypothesis  and the initial hypothesis that  verification conditions  of \methodd{} are valid and we obtain that 
every method  \methodd{} is correct w.r.t. its specification at level \level{k}. This means that the program is correct at level k. 
\end{description}
From the base case and the inductive case, we can conclude that the program \Program{} is correct for every level \level{k} 
and thus, we have proven the statement.
 
\Qed







