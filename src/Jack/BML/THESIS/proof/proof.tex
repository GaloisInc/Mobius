
\newtheorem{proofDef}{Definition}[section] 
\newtheorem{lemma}{Lemma}[section] % one step sequential execution
%\newtheorem{lemma1}[lemma0]{Lemma} % progress
%\newtheorem{lemma3}[lemma0]{Lemma} % progress
%\newtheorem{lemma2}[lemma0]{Lemma} % if the wp holds of \methodd.\body[0] there exists n such that
% \pc_n = \return or  \ins{\pc_n }  throws a not handled exception E and 
%\pc_n = \return  then  in state_n holds post
% else in state_n holds the exceptional postcondition for E
\newtheorem*{vcGenCorrect1}{Theorem  \ref{vcGenCorrect}}
\newcommand{\state}[1]{ \tau_{#1} } 
\newcommand{\straightBraces}[1]{ \texttt{ (} #1 \texttt{ )} }
\newcommand{\tbc}{\textit{TBC}}


\section{Proof of Correctness } \label{proof}

In the following, we shall consider also that we manipulate meaningful states. A meaningful state means that the heap is 
well - formed as defined in Definition \ref{heap:wf}. Moreover, in a meaningful state local variables and the stack  contain only 
 references from the current heap or integer values.
\begin{proofDef}[Meaningful state]\label{meaningful}
The state $\config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}  $ is meaningful if the heap respects conditions in Def. \ref{heap:wf}
and every local variable   $ l $ ($l \in \locVarOnly $)  $ l \in \heap.\heapLocs \vee l \in \Myint  $ 
Moreover, the stack also must contain well formed values : 
$ (\forall i, 0 \le i \le \counterOnly \Rightarrow \stackOnly(i) \in \heap.\heapLocs \vee \stackOnly(i)\in \Myint   )$
\end{proofDef}

Actually, the operational semantics preserves the meaninful states, i.e. if an instruction starts execution in a meaningful state 
it terminates execution in such state

\begin{lemma}[Operational semantics preserves meaningful states]\label{proof:opPresMeaningful}
If a state $\config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{ \pc}$ is meaningful state and results in the execution of method \methodd{}
 then the state resulting from one execution step is also meaningful $\methodd \vdash \methodd[\pc] : s \stateTrans s' $ 
\end{lemma}

 
% The next issue that is important for understanding our approach is that we follow the design by 
% contract paradigm \cite{M97oos}. This means that when verifying a method body, we assume that the
% rest of the methods respect their
% specification in the sense of the previous definition \ref{defCorrect}.


% Once generated the verification conditions are proved with the first-order predicate logic rules. We denote that a formula $ f $ 
% has a proof in the empty context like this 
% $$ \vdash f $$

% The following lemma states
% that the proof rules preserve the meaning of predicates as defined in the previous section \ref{interpret}.   
% \begin{lemma_1}[Provability implies validity]
%      $$ \forall f , f \in \formulaBc,  \vdash f \ \Rightarrow \ \interp{f}{} $$
% \end{lemma_1}


Our first concern now will  be to establish that the rules for single bytecode instructions have the following property:
 if the \fwpi \ (short for weakest precondition ) of an 
instruction holds in the prestate then in the poststate of the instruction the postcondition upon which the wp is caclulated holds. 

\begin{lemma}[Single execution step correctness] \label{lemma0}
Let us have a program \Program{} and a method \methodd{} in \Program.
For every intermediate state $s_n =\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } $ and
 initial state $s_{0} =\config{\heap_{0}  }{ 0 }{\lbrack \ \rbrack }{\locVarOnly }{ 0 } $ 
   of the execution of method \methodd \  if the following conditions hold: 
 \begin{itemize}
         \item $ \methodd.\body[0] : s_{0} \stateTransWeight{k}^{*} s_n$
         \item $ \methodd.\body[\pc_n] : s_n \stateTransWeight{k} s_{n+1}$
         \item $ \interp{\wpi{\ins{\pc_n}}{\methodd}{}}{s_n} $
	 \item all methods in \Program{} respect their specification at level \level{k-1}  
	 \item the verification conditions for \Program{} are valid formulas
        % \item    %$ \forall \mbox{ \rm \texttt{n}} : \MethodSet . \mbox{ \rm \texttt{n}}   \neq \methodd \ n$  is correct w.r.t. its specification
 \end{itemize}
  
  then : 
 \begin{itemize}
         
        \item if  $ \methodd.\body[\ins{\pc_n}] = \return $ and $s_{n+1} =\configFinalNorm{\heap_n}{\stackOnly_n( \counterOnly_n )} $  then  $ \interp{\methodd.\normalPost}{s_{n+1}}  $   holds
%	\item else if $ \ins{\pc_n } \neq \return $ and the instruction terminates on a not handled exception \Exc , then
	%      $ \interp{\methodd.\excPostSpec( \Exc )}{ s_{n+1} }  $ 
	
	\item if $\methodd.\body[\ins{\pc_n}] \neq \athrow  $ throws a not handled exception of type $\Exc$,
	 $ s_{n+1} = \configFinalExc{ \heap_{n+1}}{  \referenceOnly   }$ and $\heapTypeOf(\referenceOnly) = \Exc  $ and  $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds.
	
	 \item if $\methodd.\body[\ins{\pc_n}] = \athrow $ throws a not handled exception of type $\Exc$,
	 	 $ s_{n+1} =\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)} $ and $\heap.\heapTypeOf(\stackOnly (\counterOnly) ) = \Exc  $ 
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $  holds.
	 
       \item  else $ \interp{\inter{\pc_n}{\pc_{n+1}}}{s_{n+1}}  $   holds 
        % if  $ \ins{\pc_n} \neq \return $ and the instruction does not terminate on exception, \\
	      % $ s_{n+1} = \config{\heap_{n+1} }{\counterOnly_{n+1} }{ \stackOnly_{n+1}}{\locVarOnly_{n+1} }{ \pc_{n+1} }  $ then
	    %   else $ \interp{\inter{\pc_n}{\pc_{n+1}}}{s_{n+1}}  $   holds 
  \end{itemize} 
\end{lemma}
\textit{Proof:}
The proof is by case analysis on the type of instruction. %that will be next executed and by induction on the maximal depth call $k$. 
We are going to see only the proofs for the instructions 
\return , \load, \new, \putfield{} and \invoke{}, the other cases being the same
\begin{description} 
		\item[ Return instruction]
		  By initial hypothesis we have that the \wpName{} of the current instruction holds
		 \begin{equation*}
          \interp {\substitution{ \methodd.\normalPost }{ \result }{\stack{\topStack} }}  { \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } }  
\end{equation*}
		 From Lemma \ref{substRet}, which describes a substitution property for the expression \result, we get:  
		  $$\interp { \normalPost} { \configFinalNorm{\heap_n  }
				                                   { \evalExp{ \stack{\topStack}}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } }
                         }$$
			 By the definition of the evaluation function, we can get that the postcondition \normalPost{} 
			 holds in the configuration  $\configFinalNorm{\heap_n  }   { \stackOnly_n ( \counterOnly_n  )  }$
			
			 $$  \interp{ \normalPost} { \configFinalNorm{\heap_n  }  
							    { \stackOnly_n ( \counterOnly_n  )  } } $$
			From the operational semantics for \return (Section \ref{opSem}), we have $ s_{n+1} = \configFinalNorm{\heap_n  } { \stackOnly_n ( \counterOnly_n  )  }$
			which allows us to conclude that this case holds.
							    
	
			 
	\item [Instance creation]
	        From the definition of the \wpName{} instruction for the instruction \new{} we obtain that the following holds:
			 
	   \begin{equation*}\label{eq1} \tag{8.1.1.1}	\interpTwoLines{
		      \begin{array}{l}
			\forall \referenceOnly,  (\neg \ \instances(\referenceOnly )\wedge  \typeof{\referenceOnly} = \clazz \wedge
			   \referenceOnly \neq \Mynull) \Rightarrow \\
                          %\phantom{\forall}      \typeof{\referenceOnly} = \type{\clazz} \Rightarrow \\ 
			\phantom{\forall} \phantom{\forall} \inter{i}{i+1} 
			\begin{array}{l} 
                               \subst{ \counter}{ \counter + 1 } \\
			       \subst{ \stack{ \counter + 1} }{\referenceOnly} \\
		               \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValue{ \fieldd.  \fieldType } } }_{\small \fieldd: \FieldSet}^{\subtype{\fieldd.\declaredIn}{  \clazz}}   \\
			       %	\subst{ \typeof{\referenceOnly}}{ \clazz } 
		       \end{array} \end{array}} {\config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }} 
		       \end{equation*}  
		       
		       Moreover, from the operational semantics of the \new{}  instruction, we obtain that the state $s_{n+1}$ is of the form 
		       
		      \begin{equation*}\label{eq2} \tag{8.1.1.2}
		      s_{n+1} = \config{\heap_{n +1}}{\counterOnly_n  +1  }{\update{\stackOnly_n }{\counterOnly_n  +  1}{ \referenceOnly'} }{\locVarOnly_n  }{\pc_n  +1} \\
	      	      \end{equation*}
		      where the heap $\heap_{n+1}$ in state $s_{n+1}$ is obtained from the allocation operator  $\newRef{\heap}{\clazz} = (\heap_{n+1},\referenceOnly' )$
		      
		      We can instantiate in \eqref{eq1} with $\referenceOnly'$. Moreover, because the $\referenceOnly'$ is not \Mynull{}  not in the heap $\heap_n$ and is of type \clazz{}
		      (see Def. \ref{heap:instAlloc} ) we get that  
		       		       
                        \begin{equation*} \interpTwoLines{\inter{i}{i+1} 
			      \begin{array}{l} 
                                    \subst{ \counter}{ \counter + 1 } \\
			            \subst{ \stack{ \counter + 1} }{\referenceOnly'} \\
		                   \subst{ \fieldd} { \update{\fieldd} { \referenceOnly' }{\defaultValue{ \fieldd.  \fieldType } } }_{\small \fieldd: \FieldSet}^{ \subtype{\fieldd.\declaredIn}{  \clazz}}  			    \end{array} }{ \config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }  } 
			    \end{equation*}
		       
		       From lemmas \ref{substCntr},  \ref{substStack} and \ref{substHeap}, \ref{newHeap} which state substitution properties for 
		       the stack counter, the stack and the heap and from  \eqref{eq2}, we conclude that this case holds

		
\item [Field update] 
                The cases \getfield, \arrstore, \arrload,  \arraylength{} are similar to this case.
		This instruction may potentially throw a \NullPointerExc{} as the object reference whose field is updated may be \Mynull.
		Thus, we should consider three cases : the case when the reference is \Mynull{} and the \NullPointerExc{} exception is not caught,
		case when the reference is \Mynull{} and the \NullPointerExc{} exception is  caught, and the case when the reference is not \Mynull.
		We consider in the following only the case, when an uncaught exception of type \NullPointerExc{} is thrown. 
		By initial hypothesis, we have that the \wpName{} function holds. In particular, we consider the case when an exception is thrown we get that
		 	
                     		    		 
		 \begin{equation*}\label{eq3} \tag{8.1.3.1}  
		 			\interp{		\stack{\counter} = \Mynull \Rightarrow   \methodd.\excPost( i, \NullPointerExc ) }
                        {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} 
			\end{equation*}     
			From the operational semantics of the instruction \putfield{} in case of a thrown exception we get that 
                    $\stack{\counter}=\Mynull{}$ and thus from \eqref{eq3} we conclude that 
		      \begin{equation*} \interp{ \methodd.\excPost( i, \NullPointerExc ) } {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} 
			\end{equation*}
		  We unfold the function \excPost{} (see its  Def. \ref{wp:exc:defExcRuntime} ) and obtain
                \begin{equation*}\label{eq4} \tag{8.1.3.2}  
               \interp{   \begin{array}{l}
                     \forall \referenceOnly
                        (\neg \ \instances(\referenceOnly) \wedge 
		       \referenceOnly \neq \Mynull \wedge 	
		       \typeof{\referenceOnly} = \NullPointerExc )  \Rightarrow\\
            \methodd.\excPostSpec( \NullPointerExc )
                    \begin{array}{l}
                        \subst{\counter}{0} \\
			\subst{\stack{0}}{\referenceOnly} \\
                         \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) } }_{{\small{\fieldd}}}^
{ {\small \subtype{\fieldd.\declaredIn}{ \NullPointerExc } }} \end{array} }{s_1} \end{array}	\end{equation*}
              We assume that the exception is not caught. Thus from the operational  semantics of \putfield{} we get that the instruction 
	      execution terminates in a terminal exceptional state $\configFinalExc{\heap'}{\referenceOnly'}$ 
                \begin{equation*}\label{eq5} \tag{8.1.3.3}
                 s_{n+1} = \configFinalExc{\heap'}{\referenceOnly'}, where \ (\heap', \referenceOnly' )= \newRef{\heap}{\NullPointerExc}
		 \end{equation*}

		 From Def.\ref{heap:instAlloc}  of the function \newRefOnly, we know that the reference $\reference'$ is not \Mynull, is not in the heap 
		 $\heap_{n}$ and moreover it is of type   \NullPointerExc. This allows us to instantiate \eqref{eq4} and obtain
		 \begin{equation*}\label{eq6} \tag{8.1.3.4} \interp{\methodd.\excPostSpec( \NullPointerExc )
                    \begin{array}{l}
                        \subst{\counter}{0} \\
			\subst{\stack{0}}{\referenceOnly'} \\
                         \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) } } 
                        _{{\small{\fieldd}}}^{ {\small \subtype{\fieldd.\declaredIn}{ \NullPointerExc } }} \end{array}}{s_{n}} \end{equation*}
			From substitution  lemmas \ref{substCntr},  \ref{substHeap}, \ref{substStack} and \ref{newHeap} conclude that the result holds in this case.
   
	
 \item [method invocation]
In the following, we  ignore here the part of the \wpName{} which concerns the exceptional termination for reasons of clarity. Treating the whole 
definition of the \wpName{} for method invokation is done in a rather similar way as the part that we sketch here.
By initial hypothesis, we get that the \wpName{} of method invocation holds.
This in particular means that the precondition  $ \mbox{\rm\texttt{n} } .\pre$ of the invoked method  \mbox{\rm\texttt{n} } holds

 \begin{equation*}\label{eq7} \tag{8.1.4.1} 
	 \interp{  \mbox{\rm\texttt{n} } .\pre \subst{\locVar{s}}{ \stack{\counter + s - \mbox{\rm\texttt{n} }.\numArgs}}_{s = 0}^{ \mbox{\rm\texttt{n} }  .\numArgs } } {s_n}
\end{equation*}
Moreover, we get that the postcondition  $\mbox{\rm\texttt{n} } .\normalPost{}$ of the invoked method implies the intermediate predicate \inter{i}{i+1}
 between  the current and the next instruction in the execution
 \begin{equation*} \label{eq8} \tag{8.1.4.2}   					
 s_n \vDash \begin{array}{l} \forall res, m (m \in \mbox{\rm\texttt{n}}.\modif),  \\
	 		\Myspace	 \mbox{\rm\texttt{n} } .\normalPost 
						\subst{\result}{  res }	 
						\subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^{ \mbox{\rm\texttt{n} }. \numArgs }                                                                                            \Rightarrow \\   \inter{i}{i+1 }  \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs}
														   \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ res }	\end{array}	   	
\end{equation*}	
As the verification conditions for the program \Program{} are valid, we can
 get that the verification conditions that  \mbox{\rm \texttt{n}$'$}
 is a behavioral subtype the overriden method \mbox{\rm\texttt{n}}  
 and we get that the first two conditions from Def. \ref{wp:vc:subt} (page \pageref{wp:vc:subt}) hold which concern the behavioral subtyping of 
   \mbox{\rm \texttt{n}$'$} and \mbox{\rm\texttt{n}}.  
  From this  fact and  that we consider only meaningful states and from the validity of \eqref{eq8} we deduce that the 
precondition of  \mbox{\rm \texttt{n}$'$} holds in state $s_n$
      \begin{equation*}\label{eq9} \tag{8.1.4.3}   
        \interp{\mbox{\rm \texttt{n}$'$}.\pre \subst{\locVar{i} }{ \stack{\counter + s - \mbox{\rm\texttt{n} }.\numArgs} }_{i=0}^{\mbox{\rm\texttt{n}}.\numArgs }   }{ s_n} 
      \end{equation*}

    From the operational semantics of method invocation the method lookup function $\lookupOnly{}$ will find the method \mbox{\rm \texttt{n}$'$} which overrides method 
     \mbox{\rm\texttt{n}} and which will be actually executed. 
    The method  \mbox{\rm \texttt{n}$'$} will be executed in initial state $s'$ described below and ends in the state $ \configFinalNorm{\heap'}{\Res}$
   Because \mbox{\rm \texttt{n}$'$} respects its specification level at \level{k-1} 
   we can apply the initial hypothesis for \mbox{\rm\texttt{n}$'$} and the
     concrete initial and final states  and we then get
               
	 \begin{equation*}\label{eq10} \tag{8.1.4.4}  \begin{array}{l} \interp{  \mbox{\rm \texttt{n}$'$}.\pre  }{s'}
                                           \Rightarrow 
                                 \interp{ \mbox{\rm \texttt{n}$'$}.\normalPost  }{\configFinalNorm{\heap'}{\Res}} \\\\
		             where \\              s'=  \config{\heap_n}       
                                                       {0}
						       {\newStack }
                                                       {\lbrack \stackOnly_n( \counterOnly_n - \mbox{\rm \texttt{n}$'$}.\numArgs ),\ldots ,\stackOnly_n( \counterOnly_n)\rbrack }
						       {0} \\
						       \counterOnly_{n+1} = \counterOnly_n - \mbox{\rm \texttt{n}}.\numArgs + 1 \\
						       \stackOnly_{n+1} = \update{\stackOnly_n}{\counterOnly_n}{\Res} \\
						       \pc_{n+1}  = \pc_n + 1 \\
						       \heap_{n+1} = \heap'
						       \end{array} 
            \end{equation*}


   From the fact that method  \mbox{\rm \texttt{n}$'$} respects its specification at level \level{k}, \eqref{eq9} and \eqref{eq10}
    we get that the postcondition of  \mbox{\rm \texttt{n}$'$}    holds in the terminal state $ \configFinalNorm{\heap'}{\Res}$ w.r.t.
   the initial state $s'$ of the execution of method \mbox{\rm \texttt{n}$'$}   
  
    \begin{equation*}\label{eq11} \tag{8.1.4.5}     
    \interp{\mbox{\rm \texttt{n}$'$}.\normalPost }{\configFinalNorm{\heap'}{\Res} } 
    \end{equation*}

     Because the postcondition $\mbox{\rm \texttt{n}$'$}.\normalPost{}$ does not mention the operand stack, neither the stack counter   
   and because of the relation between $s_{n+1}$ and  $ \configFinalNorm{\heap'}{\Res}$  we can conclude from \eqref{eq11} that the
   following holds

\begin{equation*} \interp{\mbox{\rm \texttt{n}$'$}.\normalPost \subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }  \subst{\result}{\Res } }{s_{n} }  
  \end{equation*}
This and the fact that the states operational semantics preserves meaningful states (Lemma \ref{proof:opPresMeaningful}), 
 we can apply  the  verification condition  concerning the fact that   the method \mbox{\rm\texttt{n}$'$ } is a behavioral subtype of \mbox{\rm\texttt{n}}, the postcondition 
of the former is stronger than latter 
\begin{equation*} 
\interp{\mbox{\rm \texttt{n}}.\normalPost \subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^{ \mbox{\rm\texttt{n} }. \numArgs }  \subst{\result}{\Res } }{s_{n} } 
\end{equation*}
  We can apply the resulting judgement with modus ponens to \eqref{eq10}  where
   we initialise the quantification over the modified locations with their
   values in state $s_n$ and the variable $res$ to \Res 
\begin{equation*} 
\interp{\inter{i}{i+1 }   \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs} \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ \Res }}{s_n}
\end{equation*}

From Lemma \ref{substCntr} for substitution of the stack counter as well as the stack
 \label{substStack} and by the operational semantics of the instruction \invoke{} in case of normal termination we conclude that this case holds.


\end{description}
\Qed \\

%The next lemma establishes formally a relation between the \wpName{} of an instruction and the intermediate predicate that must hold
%in between the instruction and its successor. In particular, that whenever $\wpi{i}{\methodd}{} $  holds in the prestate of the instruction point $i$
%the predicate  $\wpi{\inter{i}{j}}{\methodd}{} $  holds where $j$ is the next instruction to be executed.
% 
%\begin{lemma}[\wpName{} implies \interOnly ] \label{proof:wpImpInter}
%For every state $s =\config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{s } $  $s' =\config{\heap' }{\counterOnly' }{\stackOnly }{\locVarOnly }{s } $ and
%initial state $s_{0} =\config{\heap_{0}  }{ 0 }{\lbrack \ \rbrack }{\locVarOnly }{ 0 } $ such that 
% \begin{itemize}
%         \item $ \methodd.\body[0] : s_{0} \stateTransWeight{k}^{*} s$
%         \item $ \methodd.\body[s] : s \stateTransWeight{k} s'$
%%         \item $ \interp{\wpi{\ins{\pc}}{\methodd}{}}{s} $
%\end{itemize}
% we have that :
%$ \interp{\inter{\pc}{\pc'}}{s'}$
%%\end{lemma}
%\textit{Proof:}
%The proof is by case analysis on the instruction at point $\pc_n$. We sketch the  proof for the instruction \load.
%
%$\interp{ \wpi{\pc : \load \ i }{\methodd}{}}{s} $\\
%\mbox{\rm \comment{by definition of  the wp function in Section \ref{wpRules} } } \\
%%$ \interp{ \inter{\pc_n}{ \pc_n + 1}   \subst{\counter}{\counter +1}  \subst{  \stack{ \counter  + 1}}{\locVar{j}}  }{s} $ \\
%\comment{from lemmas \ref{substCntr} and \ref{substStack}} 	 \\
%                         $\iff \\
  %               \interpTwoLines{  \inter{\pc}{ \pc + 1} } 
%                                    { s  \subst{\counterOnly}{\evalExp{\counter + 1}{s_n} }\subst{\stackOnly} { \update{\stackOnly}{ ( \evalExp{\counter + 1}{s_n} ) }{ \evalExp{ \locVar{i} } {s_n} }}  }$ \\
%				    
%           \comment{from the operational semantics of the instruction \load{} follows}\\
%	   
%          $s' = s  \subst{\counterOnly}{\evalExp{\counter + 1}{s_n} }\subst{\stackOnly} { \update{\stackOnly}{ ( \evalExp{\counter + 1}{s_n} ) }{ \evalExp{ \locVar{i} } {s_n} }} $\\
%	  
%	  \comment{we conclude then }\\
%	  $\interpTwoLines{  \inter{\pc}{ \pc +1} }  { s'}$
%	  
%\Qed\\



We now establish a property of the correctness of the wp function  for an execution path. The following lemma states that if the calculated preconditions
of all the instructions in an execution path holds then either the execution terminates normally (executing a \return) or exceptionally, or 
another step can be made and the \fwpi \ of the next instruction holds.



\begin{lemma} \label{lemma1}
Let us have a program \Program{} and a method \methodd{} in \Program. 
%Assume we have a method \methodd \ with normal postcondition  $\methodd.\normalPost$ and exception function $\methodd.\excPostSpec$. 
For every state  
 $ \config{\heap_{0}}{\counterOnly_{0}}{\stackOnly_{0}}{\locVarOnly_{0}}{\pc_{0}}$ 
and state $\config{\heap_n}{\counterOnly_n}{\stackOnly_n}{\locVarOnly_n}{\pc_n} $ denoted respectively with $s_0$ and  $s_n$,
such that :
 \begin{itemize}
         \item $ \methodd.\body[0] : s_{0} \stateTransWeight{k}^{n} s_n$
         \item $ \methodd.\body[\pc_n] : s_n \stateTransWeight{k} s_{n+1}$
         \item $ \forall i, (\ 0 \leq i \leq n ) , \ \interp{\wpi{\ins{\pc_{i}} }{ \methodd } {  }}{ s_i } $  
	 \item all methods in \Program{} respect their specification at level \level{k-1}  
	 \item the verification conditions for \Program{} are valid formulas
        % \item    %$ \forall \mbox{ \rm \texttt{n}} : \MethodSet . \mbox{ \rm \texttt{n}}   \neq \methodd \ n$  is correct w.r.t. its specification
 \end{itemize}

then the folloing holds:
\begin{enumerate}
	\item if $\methodd.\body[\ins{\pc_n}] = \return$ and $s_{n+1} =\configFinalNorm{\heap_n}{\stackOnly_n( \counterOnly_n )} $ then $\interp{\methodd.\normalPost} {s_{n+1} } $ holds.  
	
        	\item if $\methodd.\body[\ins{\pc_n}] \neq \athrow  $ throws a not handled exception of type $\Exc$,
	 $ s_{n+1} = \configFinalExc{ \heap_{n+1}}{  \referenceOnly   }$, $\heap.\heapTypeOf(\referenceOnly) = \Exc  $ and  $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds.
	
	 \item if $\methodd.\body[\ins{\pc_n}] = \athrow $ throws a not handled exception of type $\Exc$,
	 	 $ s_{n+1} =\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)} $ and $\heap.\heapTypeOf(\stackOnly (\counterOnly) ) = \Exc  $ 
	 then  $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $  holds.


%	\item if $\ins{\pc_n}\neq \athrow  $ throws a not handled exception of type $\Exc$ \\ then
%	$\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds 
%	where  $\heap.\heapTypeOf(\referenceOnly) = \Exc  $ and  $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$.
%	
%	 \item if $\ins{\pc_n} = \athrow $ throws a not handled exception of type $\Exc$ \\
%	 then $\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $  holds
%	 where $\heap.\heapTypeOf(\stackOnly (\counterOnly) ) = \Exc  $ 
	
	
	\item else   $\interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{  } } { s_{n+1} } $  holds
\end{enumerate}
\end{lemma}

\textit{Proof :}
The proof is by case analysis on the execution relation $\execRel{}$  between the current instruction and the next instruction.
 We have three cases: the case when the next execution step does not enter a cycle (the next instruction is not a loop entry in the sense of Def.\ref{defLoop} )
the case when the current instruction is a loop end and the next instruction to be executed is a loop entry instruction (the execution step is $\execRel_l$ )
and the case when the current instruction is not a loop end and the next instruction is a loop entry instruction ( corresponds to the first iteration of a loop) 

  
\begin{description}
  \item [Case 1] the next instruction to be executed is not a loop entry instruction. 
           	Following Def. \ref{inter} of the function \interOnly \ in this case 
              we get $ \inter{\pc_n}{\pc_{n+1}} = \wpi{ \ins{\pc_{n+1} }}{\methodd}{}$. By initial hypothesis,
	       we have moreover that the weakest predicate for $\ins{\pc_{n}}$ is valid in 
	       state $s_n$, i.e.  $ \interp{\wpi{\ins{\pc_{n}} }{ \methodd }{} }{ s_n }$.
	      Thus by the previous lemma \ref{lemma0}  we know that 
	      the predicate $\inter{\pc_n}{\pc_{n+1}}$ holds in $s_{n+1}$, i.e. $\interp{\inter{\pc_n}{\pc_{n+1}} }{ s_{n+1} }$.
	      This actually means that the judgement 
	      $\interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{} }{ s_{n+1} }$	      holds.

 
  
\item [Case 2]
 $\ins{\pc_n} $ is not a loop end and the next instruction to be executed is a loop entry 
instruction at index $loopEntry $ in the array of bytecode instructions of the method \methodd{}.
 %(i.e. the execution step is of kind $\execRel^l$, see Def.\ref{defLoop}  ).
 Thus, there exists a natural number  $ i , 0 \le i < \methodd.\loopSpecTable.length   $   such that
 $ \methodd. \loopSpecTable[i].\posL = loopEntry $,  $ \methodd. \loopSpecTable[i].\invL = I $ and
   $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$.



 %\begin{equation*}\label{eq12} \tag{8.2.1}    

Because initial hypothesis we have that  $\interp{\wpi{\pc_n}{\methodd}{}}{s_n} $, from Lemma \ref{lemma0} we have
that  the intermediate predicate $\inter{\pc_n}{\pc_{n+1}}$ holds in state $s_{n+1}$, i.e. 
 $\interp{\inter{\pc_n}{\pc_{n+1}} }{s_{n+1}} $. 
From the  Def. \ref{inter} of the predicate \interOnly{}, we get that   
in the case for  an edge between a loop entry and a loop end $\inter{\pc_n}{\pc_{n+1}}$ is of the form:
     \begin{equation*}
                 \interp{  I \  \wedge
                                             \forall mod_i ,  i = 1..s \left( I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{} \right) 
                                 }  { s_{n+1}  }
\end{equation*}
  
We can get from the last formulation and the semantics of the universal quantification  that 
 \begin{equation*} 
\begin{array}{l}
                  \interp{I}   {s_{n+1} } \\
                              
                  \interp{ I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{} }
                                     {s_{n+1}  } \\
    \end{array} 
\end{equation*}
By modus ponens, this allows to conclude that $\wpi{\ins{\pc_{n+1}}}{\methodd}{} $ holds in state 
$s_{n+1} $

\item [Case 3]
Instruction $\ins{\pc_n} $ is an end of a cycle  and the next instruction to be executed is a loop entry 
instruction at index $loopEntry $, i.e.  $loopEntry = \pc_{n +1}$ % in the array of bytecode instructions of the method \methodd
 (i.e. the execution step is of kind $\execRel^l$ ).
 Thus, there exists a natural number  $ i , 0 \le i < \methodd.\loopSpecTable.length   $   such that
 $ \methodd. \loopSpecTable[i].\posL = loopEntry $,  $ \methodd. \loopSpecTable[i].\invL = I $ and
   $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$.
We consider the case when the current instruction is a sequential instruction. The cases when the current instruction 
is a jump instruction are similar. By initial hypothes we have that 
 $\interp{ \wpi{\ins{\pc_n} }{\methodd}{}}{s_n}$. 
From Def. \ref{inter}  for the case when the current instruction is a loop end and the next instruction is a loop entry, we get that the initial hypothesis
is equivalent to   
\begin{equation*} \label{eq12} \tag{8.3.1} 
 \interp{ I}{s_{n + 1}}  
\end{equation*} 
   From def. \ref{defLoop}, we  conclude that there is a prefix  $subP = \methodd.\body[0] \execRel^{*} \ins{loopEntry}$  of the current
 execution path which does not pass through $\ins{\pc_n}$. We can conclude that the transition between   $\ins{loopEntry}$ and its predecessor 
 $ \ins{k} $ ( which is at index $k$ in \methodd.\body)
	  in the path $subP$ is not a backedge. By hypothesis we know that 
           $ \forall i , 0 \le i \le  n, \interp{\wpi{\ins{\pc_i}}{\methodd}{}}{s_i}$.  From def.\ref{inter} and
	 lemma \ref{lemma0} we conclude 
          
   \begin{equation*} \label{eq13} \tag{8.3.2} 
         \exists k, 0 \le k \le n \Rightarrow 
         \interp{ \begin{array}{l}
	                                    I 
					    \wedge
                                           \forall mod_i ,  i = 1..s \left( \begin{array}{l } 
	                                                           I \Rightarrow 
	                                                           \wpi{\ins{loopEntry}}{\methodd}{} 
							      \end{array}\right)
				 \end{array} }{s_k} 
 \end{equation*} 

It also follows that the states $s_k$ and $s_{n+1}$ are the same except for the locations in the
 modifies list \modifL{} of the loop  $    s_k =^{\modifL} s_{n+1}   $
 because $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$  
 We obtain from  \eqref{eq13} by instantiating every location $mod_i$ in  
 by its value in $s_{n+1}$
 \begin{equation*} \label{eq14} \tag{8.3.3} 
 \interp { I \Rightarrow \wpi{\ins{loopEntry}}{\methodd}{}} {s_{n+1}}    
\end{equation*}

From \eqref{eq12} and \eqref{eq14} and  because $loopEntry = \pc_{n +1}$ we conclude that 
\begin{equation*} 	  \interp{ \wpi{\ins{\pc_{n+1}} }{\methodd}{} }{s_{n+1}} \end{equation*}
         

\end{description}

\Qed

We now show that starting execution of a method in a state where the \fwpi{}
 predicate for the entry instruction holds implies that the  
\fwpi{} for all the instructions in the execution path hold. 

\begin{lemma}[\fwpi \ precondition for method entry point holds initially ]\label{lemma3}
Let us have a program \Program{} and a method \methodd{} in \Program.
 Let us have states  $s_{0}$ and $s_n$ such that: 
\begin{itemize} 
     \item execution of method  \methodd{} starts  in state $s_{0}$ 
     \item  makes $n$ steps to reach the intermediate state $s_n$: $s_{0} \stateTransWeight{k}^{n} s_{n} $
     \item $\interp{ \wpi{0 } {\methodd}{}}{ s_{0}}$ holds
     \item all methods in \Program{} respect their specification at level \level{k-1}  
     \item the verification conditions for \Program{} are valid formulas
\end{itemize}  
 then the following holds
$$\forall i,  0 < i \le n, \  \interp{ \wpi{\pc_i} {\methodd}{ }}{ s_{i}} $$

\end{lemma}
Proof : Induction over the number of execution steps $n$
\begin{enumerate}
    \item\textit{ $s_{0} \stateTransWeight{k} s_{1}$. By initial hypothesis we have that  $\interp{ \wpi{0 } {\methodd}{}}{ s_{0}}$
             we can apply lemma \ref{lemma1}, we get that 
             $\interp{ \wpi{\ins{\pc_{1}}}{\methodd}{  } } { s_{1} }  $ and thus, the  case when one step is made from the initial state
             $s_0$  holds}   
    \item \textit{Induction step:   $s_{0} \stateTransWeight{k}^{n - 1} s_{n - 1}$ and \\
           $\forall i,  0 < i \le n - 1, \  \interp{ \wpi{\pc_i} {\methodd}{}}{ s_{i}} $
           and there can be made one step $s_{n- 1} \stateTransWeight{k} s_n$.  Lemma \ref{lemma1} \ can be applied and we get that
           $\numConclusion{1} \ \interp{ \wpi{\pc_n } {\methodd}{ } }{ s_{n}} $. 
	   From the induction hypothesis and \numConclusion{1} follows that 
	   $$\forall i,  0 < i \le n, \  \interp{ \wpi{\pc_i } {\methodd}{ }}{ s_{i}} $$ }
\end{enumerate}
\Qed \\

Having the last lemma we can  establish that if a method starts
execution in a state in which the \fwpi{} precondition  for the method entry instruction 
holds and the method terminates then the method postcondition holds in the method final state.

\begin{lemma}[\fwpi \ precondition for method entry point holds initially]\label{lemma2}
Let us have a program \Program{} and a method \methodd{} in program \Program.
For all states $s_0$ and $s_n$ such that   $\methodd : s_0  \stateTransTermWeight{k} s_n $
and let $\interp{ \wpi{} {\methodd}{0}}{ s_{0}}$ holds. Assume that
  all methods in \Program{} respect their specification at level \level{k-1} and 
the verification condition for \Program{} are valid formulas.
Let the program counter in state $s_n$ points to an instruction $\return $ or
 an instruction which throws an unhandled exception of type \mbox{\rm\texttt{Exc}}, then  the following holds:
\begin{itemize}
    \item if $\methodd.\body[\pc_{n-1}] = \return $     then $\interp{ \methodd.\normalPost}{s_{n}}$

    	\item if $\methodd.\body[\pc_{n-1}]$ throws a not handled exception of type $\Exc$  then  $\interp{\methodd.\excPostSpec( \Exc)}{ s_{n} } $ holds.
	

%    \item  if $\ins{\pc_n}$ throws a not handled exception of type \mbox{\rm\texttt{Exc}} then  $\interp{ \methodd.\excPostSpec(\mbox{\rm\texttt{Exc}}  )}{s_{n}}$
\end{itemize}
\end{lemma}
\textit{Proof:} 
%By hypothesis the execution of method \methodd \ always terminates, i.e. there exists $n$ steps such that
\textit{Let $ \ s_{0} \stateTransWeight{k}^{*} s_n $ and $\methodd.\body[\pc_n]$ is a \return \ or an instruction that throws a  not handled exception.
 Applying lemma \ref{lemma3}, we can get that $\forall i, 0 \le i < n , \ \interp{ \wpi{\pc_i } {\methodd}{ } }{ s_{i}}$. 
We apply lemma \ref{lemma1} for the case for a \return \ or instruction that throws an unhandled exception which allows to conclude that the current statement holds.
}\\
\Qed\\

Now, we establish under what conditions we can conclude that a method respects its specification at level \level{k}.
\begin{lemma}[method respects its specification at level \level{k}]\label{lemmaMethRespSpec}
Let us have a program \Program{} and a method \methodd{} in \Program.
If  all methods in \Program{} respect their specification at level  \level{k -1} and 
 the verification conditions for \Program{} are valid formulas
then \methodd{}  respects its specification at level \level{k} 
\end{lemma}
 The proof  follows directly from Lemma \ref{lemma2}. We are now ready to prove Theorem \ref{vcGenCorrect}.


\begin{vcGenCorrect1}
 If the verification conditions  of program \Program{} (see  subsection \ref{wp:vcMeth})
are valid then \Program{} is correct w.r.t. Def. \ref{defCorrectProgram}
\end{vcGenCorrect1}
\textit{Proof:}
We want to establish now  that if for every \methodd{}
 in every class \class{} in a program \Program{}  the respective verification conditions are valid then 
the \Program{} is correct as defined in Def. \ref{defCorrectProgram}.
 This, in particular, means that for all levels $\level{k} \ge 0 $ the program is correct in  level \level{k}.
We reason by induction on the level \level{k}. 
\begin{description} 
\item[base case \level{k} = 0]
 In this case, because we can not have an execution step at level \level{0}, we conclude that all methods at level  \level{0}
are correct
\item[induction step] Let us have that the program is correct at level $\level{k-1}$. 
In particular, this means that for every class \class{}, every method \methodd{} in \class{} is correct at level \level{k-1}.
We can apply Lemma \ref{lemmaMethRespSpec} to every single method  \methodd{} in \Program{}, 
 the induction hypothesis  and the initial hypothesis that  verification conditions  of \methodd{} are valid and we obtain that 
every method  \methodd{} is correct w.r.t. its specification at level \level{k}. This means that the program is correct at level k. 
\end{description}
From the base case and the inductive case, we can conclude that the program \Program{} is correct for every level \level{k} 
and thus, we have proven the statement.
 
\Qed







