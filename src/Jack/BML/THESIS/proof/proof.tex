\newtheorem{defCorrect}{Definition}[section]
%\newtheorem{lemma_1}{Lemma}[section] 
\newtheorem{lemma0}{Lemma}[section] % one step sequential execution
\newtheorem{lemma1}[lemma0]{Lemma} % progress
\newtheorem{lemma3}[lemma0]{Lemma} % progress
\newtheorem{lemma2}[lemma0]{Lemma} % if the wp holds of \methodd.\body[0] there exists n such that
% \pc_n = \return or  \ins{\pc_n }  throws a not handled exception E and 
%\pc_n = \return  then  in state_n holds post
% else in state_n holds the exceptional postcondition for E
\newtheorem{vcGenCorrect}[lemma0]{Theorem}

\newcommand{\state}[1]{ \tau_{#1} } 
\newcommand{\straightBraces}[1]{ \texttt{ (} #1 \texttt{ )} }
\newcommand{\tbc}{\textit{TBC}}


\section{Proof of Correctness } \label{proof}

The correctness of our verification  condition generator is established w.r.t.
to the operational semantics described in Section \ref{opSem}. We look only at
 partial correctness, i.e. we assume that programs always terminate and we assume that there are no recursive methods.

We first give a definition that a ``method is correct w.r.t its specification''

\begin{defCorrect}[A method is correct w.r.t. its specification] \label{defCorrect}
For every method \methodd \ with precondition \methodd.\pre, normal postcondition \methodd.\normalPost
and exceptional postcondition function \methodd.\excPostSpec, we say that \methodd \ respects its specification if 
for every two states $s_0$ and $s_1$ such that :
\begin{itemize}
      \item   $\methodd : s_0  \stateTransTerm s_1   $
      \item   $ \interp{\methodd.\pre }{ s_0 }$
\end{itemize}
Then if \methodd \ terminates normally then the normal postcondition holds in the final state $s_1 $:  $\interp{\methodd.\normalPost}{s_1}$. 
Otherwise, if  \methodd \ terminates on an exception \mbox{ \rm \texttt{Exc}} the exceptional postcondition holds in the poststate $s_1 $
$ \interp{\methodd.\excPostSpec(  \mbox{ \rm \texttt{Exc}} )}{s_1} $
\end{defCorrect}
 
 The next issue that is important for understanding our approach is that we follow the design by 
 contract paradigm \cite{M97oos}. This means that when verifying a method body, we assume that the
 rest of the methods respect their
 specification in the sense of the previuos definition \ref{defCorrect}.


% Once generated the verification conditions are proved with the first-order predicate logic rules. We denote that a formula $ f $ 
% has a proof in the empty context like this 
% $$ \vdash f $$

% The following lemma states
% that the proof rules preserve the meaning of predicates as defined in the previous section \ref{interpret}.   
% \begin{lemma_1}[Provability implies validity]
%      $$ \forall f , f \in \formulaBc,  \vdash f \ \Rightarrow \ \interp{f}{} $$
% \end{lemma_1}

First, we establish the correctness of the weakest precondition function for a single instruction: if the \fwpi \ (short for weakest precondition ) of an 
instruction holds in the prestate then in the poststate of the instruction the postcondition upon which the wp is caclulated holds. 



\begin{lemma0}[Single execution step correctness] \label{lemma0}
For every instruction $\ins{s}$, for every state $s_0 =\config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{s } $ and
initial state $s_{0} =\config{\heap_{0}  }{ 0 }{\lbrack \ \rbrack }{\locVarOnly }{ 0 } $ 
   of the execution of method \methodd \  if the following conditions hold: 
 \begin{itemize}
         \item $ \methodd.\body[0] : s_{0} \stateTrans^{*} s_n$
         \item $ \methodd.\body[s] : s_n \stateTrans s_{n+1}$
         \item $ \interp{\wpi{\ins{\pc_n}}{\methodd}{}}{s_n} $
	 %\item  $\ins{k} = next( \ins{s} ) $
         \item    $ \forall \mbox{ \rm \texttt{n}} : \MethodSet . \mbox{ \rm \texttt{n}}   \neq \methodd \ n$ is correct w.r.t. its specification
 \end{itemize}
  
  then : 
 \begin{itemize}
         \item if  $ \ins{\pc_n} \neq \return $ and the instruction does not terminate on exception,
	      $ s_{n+1} = \config{\heap_{n+1} }{\counterOnly_{n+1} }{ \stackOnly_{n+1}}{\locVarOnly_{n+1} }{ \pc_{n+1} }  $
	       then  $ \interp{\inter{\pc_n}{\pc_{n+1}}}{s_{n+1}}  $   holds 
        \item if  $ \ins{\pc_n} = \return $ then  $ \interp{\methodd.\normalPost}{s_{n+1}}  $   holds
	\item else if $ \ins{\pc_n } \neq \return $ and the instruction terminates on a not handled exception \mbox{ \rm\texttt{Exc }}, then
	      $ \interp{\methodd.\excPostSpec( \mbox{ \rm\texttt{Exc }} )}{ s_{n+1} }  $ 
	
  \end{itemize} 
\end{lemma0}
Proof :
The proof is by case analysis on the type of instruction that will be next executed. 
We are going to see only the proofs for the instructions \return , \load and \invoke, the other cases being the same
\begin{enumerate} 
		\item    $\ins{\pc_n}$ = \return 
		     $$ \begin{array}{l}
		    	\mbox{\rm\comment{by initial hypothesis }} \\
			\interp{\wpi{\return}{\pc_{n}}{\methodd}} {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }}  \\
			\mbox{\rm\comment{by definition the weakest precondition for \return } }\\
			 
                       \interp {\substitution{ \methodd.\normalPost }{ \result }{\stack{\topStack} }}  { \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } }  \\
			\mbox{\rm\comment{by the substitution property \ref{substRet}  }}\\
			 \iff \\
                          \interp { \normalPost} { \configFinalNorm{\heap_n  }
				                                   { \evalExp{ \stack{\topStack}}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } }
                         }\\
			 \mbox{\rm \comment{by definition of the evaluation function \mbox{ \rm \textit{eval}}  } }\\
			 \iff \\ 
				   \interp{ \normalPost} { \configFinalNorm{\heap_n  }  
							    { \stackOnly_n ( \counterOnly_n  )  } } 
			\end{array} $$
	\item   $\ins{\pc_n } = \load \ i $ 
	                  
			  $$ \begin{array}{l}
			  	\mbox{\rm\comment{by initial hypothesis }} \\
			 \interp{\wpi{\load \ i}{\methodd}{\pc_n  }}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }}$$ \\
			 \mbox{\rm\comment{definition of the wp function} } \\
			  \equiv \\ 
			   \interp{  \inter{\pc_n }{\pc_n  +1 } \begin{array}{l} \subst{\topStack}{\topStack + 1} \\
		                                                 \subst{\stack{\topStack + 1} } {\locVar{i} }
	                                        \end{array}}{ \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } 	\\
			\mbox{\rm\comment{applying the substitution properties \ref{substCntr} and \ref{substStack} }}\\
		
		       \iff \\ 
		       \interpTwoLines{\inter{\pc_n }{\pc_n  +1 }   }
                                  { \config{\heap_n }{\counterOnly_n  + 1}{ \update{\stackOnly_n }{\counterOnly_n  + 1 }{\locVarOnly_n (i) } }{\locVarOnly_n }{\pc_{n+1} } } \\
		    
		   
			\comment{from the operational semantics of the \load instruction in section \ref{opSem}} \\
			 \interp{  \inter{\pc_n }{\pc_n  +1 }  }{s_{n + 1}} \\
		  	 \comment{and the lemma holds in this case } 
			 \end{array}	$$
	\item  $\new  \ \clazz $ 
	        $$ \begin{array}{l}  
		      	\mbox{\rm\comment{by initial hypothesis }} \\ 
                         \interp{\wpi{\new \ \clazz }{\methodd}{\pc  }}{\config{\heap_n }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }} \\
			  \mbox{\rm\comment{definition of the wp function} } \\
			 \equiv \\  
		\numConclusion{1} \	\interpTwoLines{
		      \begin{array}{l}
			\forall \referenceOnly,  not \ \instances(\referenceOnly )\wedge \\
			 \phantom{\forall}       \referenceOnly \neq \Mynull \Rightarrow \\
                          %\phantom{\forall}      \typeof{\referenceOnly} = \type{\clazz} \Rightarrow \\ 
			\phantom{\forall} \phantom{\forall} \inter{i}{i+1} 
			\begin{array}{l} 
                               \subst{ \counter}{ \counter + 1 } \\
			       \subst{ \stack{ \counter + 1} }{\referenceOnly} \\
		               \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } \\
			       	\subst{ \typeof{\referenceOnly}}{ \clazz } 
		       \end{array} \end{array}} {\config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }} \\
		       \\
		       \mbox{\rm\comment{from the operational semantics of \new \ in section \ref{opSem}}} \\
		       \end{array}      $$
		   $$\begin{array}{l}
		      \numConclusion{2} s_{n+1} = \config{\heap_{n +1}}{\counterOnly_n  +1  }{\update{\stackOnly_n }{\counterOnly_n  +  1}{ \referenceOnly  } }{\locVarOnly_n  }{\pc_n  +1} \\
		       \\
		      \numConclusion{3} \newRef{\heap}{\clazz} = (\heap_{n+1},\referenceOnly' ) \\
		       \\
		       \mbox{\rm\comment{following Def. \ref{interpPred} instantiate \numConclusion{1} with \mbox{\rm\referenceOnly}$'$  }} \\
		       \numConclusion{4}  	 \interpTwoLines{\begin{array}{l}
			 not \ \instances(\referenceOnly' ) \wedge \\
			  \referenceOnly' \neq \Mynull \Rightarrow \\  
			  %\typeof{\referenceOnly'} = \type{\clazz} \Rightarrow \\ 
			\phantom{\forall}	\inter{i}{i+1} 
			\begin{array}{l} 
                               \subst{ \counter}{ \counter + 1 } \\
			       \subst{ \stack{ \counter + 1} }{\referenceOnly'} \\
		               \subst{ \fieldd} { \update{\fieldd} { \referenceOnly' }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } \\
			       	\subst{ \typeof{\referenceOnly}}{ \clazz } 
		       \end{array}\end{array} } {\config{\heap _n }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }} \\
		       \mbox{\rm\comment{ from     \numConclusion{3}   }} \\
		       \numConclusion{5} 
		       \interp{ \begin{array}{l}
			              not \ \instances(\referenceOnly' ) \wedge \\
				      \referenceOnly' \neq \Mynull \\
				      %\typeof{\referenceOnly'} = \type{\clazz} 
				\end{array}} { \config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }  } \\
		
		       \mbox{\rm\comment{ from     \numConclusion{4} and   \numConclusion{5} and Def. \ref{interpPred}  }} \\	  
                         \interpTwoLines{\inter{i}{i+1} 
			      \begin{array}{l} 
                                    \subst{ \counter}{ \counter + 1 } \\
			            \subst{ \stack{ \counter + 1} }{\referenceOnly'} \\
		                    \subst{ \fieldd} { \update{\fieldd} { \referenceOnly' }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } \\
                                    \subst{ \typeof{\referenceOnly}}{ \clazz } 
			    \end{array} }{ \config{\heap_n  }{\counterOnly_n  }{\stackOnly_n  }{\locVarOnly_n  }{\pc_n  }  } \\
		       
		       \mbox{\rm\textit{\{from lemmas \ref{substCntr},  \ref{substStack} and \ref{substHeap}, \ref{newHeap} }} \\
		       \mbox{\rm\textit{ and the operational semantics of the instruction \new \} }} \\  
		       \interp{ \inter{i}{i+1} }{s_{n+1}}
		\end{array}	$$
\item  $\ins{\pc } = \putfield   \ \fieldd $ \\

	        $$ \begin{array}{l}  
		      	\mbox{\rm\comment{by initial hypothesis }} \\ 
                         \interp{\wpi{\pc_n  \ \putfield   \ \fieldd }{\methodd}{}}{\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} \\
			  \mbox{\rm\comment{definition of the wp function} } \\
			 \equiv \\  
		    \numConclusion{1}	\interpTwoLines{ \stack{\counter } \ne \Mynull \Rightarrow \\
						 \Myspace \inter{i}{i+1}
                                                     \begin{array}{l}
                                                              \subst{ \counter }{  \counter -2 } \\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
						       \end{array} 
						        \\
							\wedge \\
							\stack{\counter } = \Mynull \Rightarrow   \methodd.\excPost( i, \NullPointerExc ) }
                       {\config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} \\
                  	\mbox{\rm \comment{ we get three cases }}
		    \end{array}	$$
                   \begin{enumerate}
		           \item the dereferenced reference on the stack top is \Mynull \ and an exception handler starting at 
                                 instruction $k$ exists for \NullPointerExc \  and $\ins{\pc_n} $ is in its scope   
			           $$ \begin{array}{l}   
				              \mbox{\rm\comment{thus, we get  the hypothesis   } } \\
				              \interp{ \stack{\counter } = \Mynull }{ \config{\heap_n }{\counterOnly_n}{\stackOnly_n }{\locVarOnly_n }{\pc_n }  } \\
					      \mbox{\rm\comment{ from the above conclusion and \numConclusion{1} we get   } } \\
					      \interp{ \methodd.\excPost( \pc_n , \NullPointerExc ) 
						      
						    }{ \config{\heap _n}{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } } \\
					    \mbox{\rm\textit{\{ from Def. \ref{wp:exc:defExcRuntime}  of the function $ \methodd.\excPost$ }} \\???
                                             \mbox{\rm\textit{ and the assumption that the exception is handled we get \} } } \\
				     
                    	\interpTwoLines{ \begin{array}{l} 
			\forall \referenceOnly,\\
			\Myspace \neg \ \instances(\referenceOnly) \wedge \\
			\Myspace \referenceOnly \neq \Mynull \Rightarrow	\\
                        \Myspace \Myspace  \inter{\pc_n}{\pc_{n+1}} \\
			\Myspace \Myspace		         \begin{array}{l}
					           \subst{\counter}{0} \\
						   \subst{\stack{0}}{\referenceOnly} \\
						   \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) } }_{{\small \forall \fieldd : \FieldSet, \ 
						   \subtype{\fieldd.\declaredIn}{ \mbox{ \rm \texttt{Exc}}} } }
				                 \end{array} 
                                          \end{array} } {\config{\heap_n  }{\counterOnly_n  }{\stackOnly_n }{\locVarOnly_n }{\pc_n }} \\
		       	\mbox{\rm\textit{\{ from lemmas \ref{substCntr},  \ref{substHeap}, \ref{substStack} and \ref{newHeap}}}\\
			\mbox{\rm\textit{ and the operational semantics of  \putfield \} }}\\
                        
				\interp{ \inter{\pc_n}{\pc_{n+1}}}{ s_{n+1}}
             \end{array}	$$
		 \item the reference on the stack top is \Mynull \ and and the exception thrown is not handled.
		       In this case, we obtain following the same way of reasoning as the previous case :
		       $$   \begin{array}{l}
		      \interpTwoLines{  \begin{array}{l} 
			\forall \referenceOnly,\\
			\Myspace \neg \ \instances(\referenceOnly) \wedge \\
			\Myspace \referenceOnly \neq \Mynull \Rightarrow	\\
                    	
			
			 \methodd.\excPostSpec( \NullPointerExc ) \\
			 \begin{array}{l}
		                \subst{\EXC }{\referenceOnly  }\\
			        \subst{ \fieldd}{ \update{\fieldd } { \referenceOnly }{\defaultValueOnly( \fieldd.\fieldType ) } }_{ {\small \forall \fieldd: \FieldSet, 
			        \subtype{\fieldd.\declaredIn}{ \mbox{ \rm \texttt{Exc}}} } }    \\
			   \end{array} 
		    \end{array}  }{ \config{\heap_n }{\counterOnly_n }{\stackOnly_n }{\locVarOnly_n }{\pc_n } }   \\  
		 	\mbox{\rm \textit{\{ from lemmas   \ref{substStack}, \ref{substHeap}, \ref{newHeap}  and}}\\
			\mbox{\rm \textit{ the operational semantics of \putfield \}}}\\
			\interp{  \methodd.\excPostSpec(\NullPointerExc  )}{s_{n+1}}		    
\end{array}	$$
                 \item the reference on the stack top is not \Mynull 


                   $$ \begin{array}{l}   
			 \mbox{\rm\comment{thus, we get  the hypothesis   } } \\
			 \interp{ \stack{\counter } \neq \Mynull }{ \config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{\pc }  } \\
			  \mbox{\rm\comment{ from the above conclusion and \numConclusion{1} we get   } } \\
			  \interpTwoLines{\inter{i}{i+1}
                                                     \begin{array}{l}
                                                              \subst{ \counter }{  \counter -2 } \\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
						       \end{array} }{\config{\heap }{\counterOnly }{\stackOnly }{\locVarOnly }{\pc }} \\
			 \mbox{\rm\textit{\{ applying lemmas \ref{substCntr} and \ref{substHeap}  and }}\\
			\mbox{\rm\textit{ of the operational semantics of \putfield \}} } \\
			\interp{ \inter{i}{i+1}}{s_{n+1}}			       
						       
	           \end{array}	$$

               
	   \end{enumerate}
\end{enumerate}





We now establish a property of the correctness of the wp function  for an execution path. The following lemma states that if the calculated preconditions
of all the instructions in an execution path holds then either the execution terminates normally (executing a \return) or exceptionally, or 
another step can be made and the \fwpi \ of the next instruction holds.



\begin{lemma1}[Progress] \label{lemma1}
Assume we have a method \methodd \ with normal postcondition  $\methodd.\normalPost$ and exception function $\methodd.\excPostSpec$. 
Assume that the  execution starts in state \\
 $ \config{\heap_{0}}{\counterOnly_{0}}{\stackOnly_{0}}{\locVarOnly_{0}}{\pc_{0}}$
and the there are made  n execution steps causing the transitive state transition \\
$ \config{\heap_0}{\counterOnly_0}{\stackOnly_0}{\locVarOnly_0}{\pc_0} \stateTrans^{n} \config{\heap_n}{\counterOnly_n}{\stackOnly_n}{\locVarOnly_n}{\pc_n} $.
Assume that \\
 $ \forall i, (\ 0 \leq i \leq n ) , \ \interp{\wpi{\ins{\pc_{i}} }{ \methodd } {  }}{ s_i } $  
holds then
\begin{enumerate}
	\item if $\ins{\pc_n} = \return$  then $\interp{\methodd.\normalPost} {\configFinalNorm{\heap_n}{\stackOnly_n( \counterOnly_n )}} $ holds.  
	
	\item if $\ins{\pc_n}\neq \athrow  $ throws a not handled exception of type $\Exc$ \\
	$\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n+1}}{  \referenceOnly   } } $ holds 
	where $\newRef{\heap_n}{\Exc} = (\heap_{n+1}, \referenceOnly )$.
	
	 \item if $\ins{\pc_n} = \athrow $ throws a not handled exception of type $\Exc$ \\
	$\interp{\methodd.\excPostSpec( \Exc)}{\configFinalExc{ \heap_{n}}{  \stackOnly (\counterOnly)   } } $ holds 
	
	
	\item else exists a state $s_{n+1}$ such that another execution step can be done 
	 $s_n  \stateTrans s_{n+1}$ and  $\interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{  } } { s_{n+1} } $  holds
\end{enumerate}
\end{lemma1}


Proof :
The proof is by case analysis on the type of instruction that will be next executed. 

 We consider three cases: the case when the next execution step doesnot enter a cycle (the next instruction is not a loop entry in the sense of Def.\ref{defLoop} )
the case when the current instruction is a loop end and the next instruction to be executed is a loop entry instruction (the execution step is $\execRel_l$ )
and the case when the current instruction is not a loop end and the next instruction is a loop entry instruction ( corresponds to the first iteration of a loop) 

  
\begin{enumerate}
  \item the next instruction to be executed is not a loop entry instruction. 
           $$ \begin{array}{l}
	      \mbox{\rm \comment{following Def. \ref{inter} of the function \interOnly \ in this case }}\\
              \numConclusion{1} \ \inter{\pc_n}{\pc_{n+1}} = \wpi{ \ins{\pc_{n+1} }}{\methodd}{}\\
	      \mbox{\rm \comment{ by initial hypothesis}} \\
	      \numConclusion{2} \ \interp{\wpi{\ins{\pc_{n}} }{ \methodd }{} }{ s_n }\\
	      \mbox{\rm \comment{from the previous lemma \ref{lemma0} and \numConclusion{2} , we know that}}\\
	      \numConclusion{3} \   \interp{\inter{\pc_n}{\pc_{n+1}} }{ s_{n+1} }\\
	      \mbox{\rm \comment{from \numConclusion{1} and  \numConclusion{3} }}\\
	      \interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{} }{ s_{n+1} }
	      \end{array}$$

 
  
\item $\ins{\pc_n} $ is not a loop end and the next instruction to be executed is a loop entry 
instruction at index $loopEntry $ in the array of bytecode instructions of the method \methodd
 (i.e. the execution step is of kind $\execRel^l$, see Def.\ref{defLoop}  ).
 Thus, there exists a natural number  $ i , 0 \le i < \methodd.\loopSpecTable.length   $   such that
 $ \methodd. \loopSpecTable[i].\posL = loopEntry $,  $ \methodd. \loopSpecTable[i].\invL = I $ and
   $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$.
We look only at the case when the current instruction is a \load  instruction\\
$$ \begin{array}{l}
\mbox{\rm\comment{by initial hypothesis}} \\
\interp{ \wpi{\pc_n \ \load \ i }{\methodd}{}}{s_n} \\
\mbox{\rm \comment{by defintion of  the wp function in section \ref{wpRules} of the previous chapter} } \\
 \interp{ \inter{\pc_n}{ \pc_n + 1} \begin{array}{l} 
                                              \subst{\counter}{\counter +1} \\
					      \subst{  \stack{ \counter  + 1}}{\locVar{j}} 
					\end{array}  }{s_n}  \\
 
\mbox{\rm \textit{\{by the definition  \ref{inter} for the case when}} \\
\mbox{\rm \textit{ the execution step is not a backedge but the target instruction is a loop entry \} } }\\

 % \interp{I\begin{array}{l} 
 %                                              \subst{\counter}{\counter +1} \\
 %					      \subst{  \stack{ \counter  + 1}}{\locVar{i}} 
 %					\end{array}   }{s_n} \\
 %					\\
     
                               \interpTwoLines{\begin{array}{l}

                                    I\begin{array}{l} 
                                              \subst{\counter}{\counter +1} \\
					      \subst{  \stack{ \counter  + 1}}{\locVar{i}} 
					\end{array} \\
					\wedge \\
                         \forall mod_i ,  i = 1..s ( I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{}) 
                                      \begin{array}{l} 
                                              \subst{\counter}{\counter +1} \\
					      \subst{  \stack{ \counter  + 1}}{\locVar{i}} 
					\end{array} 
					\end{array} 	
                         }{s_n} \\
		\mbox{\rm\comment{from lemmas \ref{substCntr} and \ref{substStack}} }	 \\
                         \iff \\
                 \interpTwoLines{ \begin{array}{l}
		                             I \  \wedge\\
                                             \forall mod_i ,  i = 1..s ( I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{}) 
                                      \end{array}} 
                                    {     s_n 
                                              \begin{array}{l}      
					                \subst{\counterOnly}{\evalExp{\counter + 1}{s_n} }\\
							\subst{\stackOnly} { \update{\stackOnly}{ ( \evalExp{\counter + 1}{s_n} ) }{ \evalExp{ \locVar{i} } {s_n} }}
							%\subst{\counterOnly}{\evalExp{\counter}{s_n} +1} \\
						                   %\update{\stackOnly}{\evalExp{\counter}{s_n}  + 1}{ \evalExp{ \locVar{i}}{s_n} }  
					\end{array}  
                                    } \\
%\end{array}$$

%$$ \begin{array}{l}
 \mbox{\rm\comment{from the Def. \ref{interpret}  of the evaluation function  }}\\				    
            \equiv \\
                 \interpTwoLines{ \begin{array}{l}
		                             I \  \wedge\\
                                             \forall mod_i ,  i = 1..s ( I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{}) 
                                      \end{array}} 
                                    {     s_n 
                                              \begin{array}{l}      
					                \subst{\counterOnly}{\counterOnly + 1} \\
							\subst{\stackOnly} { \update{\stackOnly}{\counterOnly + 1  }{  \locVarOnly(i)}  }
							%\subst{\counterOnly}{\evalExp{\counter}{s_n} +1} \\
						                   %\update{\stackOnly}{\evalExp{\counter}{s_n}  + 1}{ \evalExp{ \locVar{i}}{s_n} }  
					\end{array}  
                                    } \\
  %  \end{array} \\
 \mbox{\rm\comment{from the operational semantics of \load }}\\

 \interp{ 
\begin{array}{l}   I \  \wedge\\
                  \forall mod_i ,  i = 1..s ( I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{}) 
\end{array}}{s_{n+1}}  \\


\mbox{\rm \comment{we can get from the last formulation}}\\
  \numConclusion{1} \   \interp{I}   {s_{n+1} } \\
                              \\
                 \numConclusion{2}  \interp{ I \Rightarrow \wpi{\ins{\pc_{n+1}}}{\methodd}{} }
                                     {s_{n+1}  } \\
   % \end{array} 
\mbox{\rm \comment{ from \numConclusion{1}  and \numConclusion{2}  }}\\
  \interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{} }{s_{n+1}  }\\

\end{array} $$
\item $\ins{\pc_n} $ is an end of a cycle \ and the next instruction to be executed is a loop entry 
instruction at index $loopEntry $ in the array of bytecode instructions of the method \methodd
 (i.e. the execution step is of kind $\execRel^l$ ).
 Thus, there exists a natural number  $ i , 0 \le i < \methodd.\loopSpecTable.length   $   such that
 $ \methodd. \loopSpecTable[i].\posL = loopEntry $,  $ \methodd. \loopSpecTable[i].\invL = I $ and
   $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$.
We consider the case when the current instruction is a sequential instruction. The cases when the current instruction 
is a jump instruction are similar.   \\ 
		
\comment{by hypothesis we get} \\
 $$ \interp{ \wpi{\ins{\pc_n} }{\methodd}{}}{s_n}$$

\comment{ from Def. \ref{inter} and transformation over the above statement} 
$$\begin{array}{ll} \numConclusion{1} &  \interp{ I}{s_{n + 1}}  \end{array}$$
\comment{by hypothesis,  $loopEntry = \pc_{n +1}$.
         From def. \ref{defLoop}, we
         conclude that there is a prefix  $subP = \methodd.\body[0] \execRel^{*} \ins{loopEntry}$  of the current execution path which does not pass through
	 $\ins{\pc_n}$. We can conclude that the transition between   $\ins{loopEntry}$ and its predecessor  $ \ins{k} $ ( which is at index $k$ in \methodd.\body)
	  in the path $subP$ is not a backedge. By hypothesis we know that 
           $ \forall i , 0 \le i \le  n, \interp{\wpi{\ins{\pc_i}}{\methodd}{}}{s_i}$.  From def.\ref{inter} and
	 lemma \ref{lemma0} we conclude }
          
   $$  \numConclusion{2 } \  
        \begin{array}{l}   \exists k, 0 \le k \le n \Rightarrow \\
	
	 \\
 	 \Myspace \interpTwoLines{ \begin{array}{l}
	                                    I \\
					    \wedge
                                           \forall mod_i ,  i = 1..s ( \begin{array}{l } 
	                                                           I \Rightarrow \\
	                                                           \wpi{\ins{loopEntry}}{\methodd}{} 
							      \end{array})
				 \end{array} }{s_k}  \\
         \\  
 \numConclusion{3} \ 	 \Myspace    s_k =^{\modifL} s_{n+1} 
       \end{array}
    $$
   \comment{because $ \methodd. \loopSpecTable[i].\modifL =\{ mod_i, i = 1..s \}$  and    from \numConclusion{2} and  \numConclusion{3}     }
 $$  \numConclusion{4} \ \interp { I \Rightarrow \wpi{\ins{loopEntry}}{\methodd}{}} {s_{n+1}}    $$
 \comment{from \numConclusion{1} and  \numConclusion{4} }
   
 $$ \begin{array}{l} 
           \interp{ \wpi{\ins{loopEntry}}{\methodd}{}}{s_{n+1}} \\
	    \iff \\
	      \interp{ \wpi{\ins{\pc_{n+1}}}{\methodd}{} }{s_{n+1}} 
    \end{array}$$
         

\end{enumerate}

\Qed

\begin{lemma3}[\fwpi \ of method entry point instruction]\label{lemma3}
Assume we have a method \methodd. Assume that  execution of method  \methodd \ starts execution
 in state $s_{0}$ and $\interp{ \wpi{\methodd.\body[0] } {\methodd}{}}{ s_{0}}$ where 
and makes $n$ steps to reach state $s_n$: $s_{0} \stateTrans^{n} s_{n} $, then
  
$$\forall i,  0 < i \le n, \  \interp{ \wpi{\methodd.\body[\pc_i] } {\methodd}{ }}{ s_{i}} $$

\end{lemma3}
Proof : Induction over the number of execution steps $n$
\begin{enumerate}
    \item  $s_{0} \stateTrans s_{1}$. From the initial hypothesis   we can apply lemma \ref{lemma1}, we get that 
             $\interp{ \wpi{\ins{\pc_{1}}}{\methodd}{  } } { s_{1} }  $ and thus, the  case when one step is made from the initial state
             $s_0$  holds   
    \item Induction hypothesis:   $s_{0} \stateTrans^{n - 1} s_{n - 1}$ and \\
           $\forall i,  0 < i \le n - 1, \  \interp{ \wpi{\methodd.\body[\pc_i] } {\methodd}{}}{ s_{i}} $
           and there can be made one step $s_{n- 1} \stateTrans s_n$.  Lemma \ref{lemma1} can be applied and we get that
	    
           $\numConclusion{1} \ \interp{ \wpi{\methodd.\body[\pc_n] } {\methodd}{ } }{ s_{n}} $. 
	   From the induction hypothesis and \numConclusion{1} follows that 
	   $$\forall i,  0 < i \le n, \  \interp{ \wpi{\methodd.\body[\pc_i] } {\methodd}{ }}{ s_{i}} $$
            
\end{enumerate}



\begin{lemma2}[Validity of \fwpi \ for a method implies that postcondition holds]\label{lemma2}

Assume we have a method \methodd \ with normal postcondition  $\methodd.\normalPost$ and exception function $\methodd.\excPostSpec$. 

%Assume that every execution of the method \methodd \ terminates.
 Assume that  execution of methodd \methodd \ starts in state $_{0}$ 
and $\interp{ \wpi{\methodd.\body[0] } {\methodd}{0}}{ s_{0}}$
Then if the method \methodd \ terminates, i.e. there exists a  state $s_n$,  $\methodd : s_0  \stateTransTerm s_1   $ 
 such that $\ins{\pc_n} = \return $ or
 $\ins{\pc_n}$ throws an unhandled 
exception of type \mbox{\rm\texttt{Exc}} the following holds:
\begin{itemize}
    \item if $\ins{\pc_n} = \return $ then $\interp{ \methodd.\normalPost}{s_{n+1}}$
    \item  if $\ins{\pc_n}$ throws a not handled exception of type \texttt{Exc} then 
             $\interp{ \methodd.\excPostSpec(\mbox{\rm\texttt{Exc}}  )}{s_{n+1}}$
\end{itemize}
\end{lemma2}
Proof: 
%By hypothesis the execution of method \methodd \ always terminates, i.e. there exists $n$ steps such that
Let $ \ s_{0} \stateTrans^{*} s_n $ and $\methodd.\body[\pc_n]$ is a \return \ or an instruction that throws a  not handled exception.
 Applying lemma \ref{lemma3}, we can get that $  \interp{ \wpi{\methodd.\body[\pc_n] } {\methodd}{ } }{ s_{n}}$. We apply lemma \ref{lemma0}
for the case for a \return \ or instruction that throws an unhandled exception which allows to conclude that the current statement holds.



Now, we are ready to state the theorem which expresses the correctness of our verification condition generator
w.r.t. the operational semantics of our language
\begin{vcGenCorrect}\label{vcGenCorrect}
For any  method \methodd \  if the verification condition is valid:
$$ \validFormula{\methodd.\pre \Rightarrow \wpi{\method.\body[0]}{\methodd}{}} $$
 then \methodd \ is correct in the sense of the definition \ref{defCorrect}. 
\end{vcGenCorrect}
Proof: From lemma \ref{lemma2} and the initial hypothesis that the weakest precondition of the 
entry point holds we conclude that the method \methodd \ is correct
%of $ \methodd.\pre \Rightarrow \wpi{\method.\body[0]}{0}{\methodd} $ is done.
