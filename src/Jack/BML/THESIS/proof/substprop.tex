\newtheorem{substHeap}{Lemma}[section]
\newtheorem{newHeap}[substHeap]{Lemma}
\newtheorem{substStack}[substHeap]{Lemma}
\newtheorem{substCntr}[substHeap]{Lemma}
\newtheorem{substLv}[substHeap]{Lemma}
\newtheorem{substRet}[substHeap]{Lemma}


\newtheorem{valid}{Definition}[section]

\section{Relation between syntactic substitution and semantic evaluation}\label{substProp}

In this section, we will show what is the relation between the syntactic notion
of substitution and the semantic notion of evaluation. Particularly, we shall see that they commute.
As an intermediate execution state $ \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc } $ 
is composed from several elements, a heap \heap{}, the stack counter \counterOnly, the operand stack \stackOnly{} 
and the array of registers \locVarOnly, we shall state for each component a separate lemma.
In the following, we shall sketch the proof only of the first lemma, the other lemmas having a similar proof. 

Let us now look at the next formal statement.
It refers to the fact that if we substitute in a give expression $\expression_1$ 
the expression  \locVar{i} which represents the local variable at index i
 with another expression $\expression_2$ and evaluate the resulting expression in a state $s_1$
 we will get the same value if we evaluate   $\expression_1$  in the state 
$\update{s_1}{\locVarOnly(i) }{ \evalExp{ \expression_2 }{s_1}  }$.


\begin{substLv}[Update  a local variable]\label{substLv}
For any expressions $ \expression_1, \expression_2 $ 
if we have that the states $s_1$ and $s_2$ are such that
$ s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$, %$\evalExp{ \expression_2}{ s_1 } \in \Values $ and 
$ s_2 =   \config{\heap}{\counterOnly }{ \stackOnly }{\update{\locVarOnly}{i}{ \evalExp{ \expression_2}{ s_1 } }}{\pc }  $
 then 
the following holds:
\begin{enumerate}
      \item $\evalExp{\substitution{\expression_1}{ \locVar{i} }{ \expression_2 }}{ s_1 } = \evalExp{\expression_1}{s_2} $
      \item $\interp{\substitution{\psi}{ \locVar{i} }{ \expression_2 }}{ s_1 } \iff \interp{\psi}{s_2} $
\end{enumerate}
\end{substLv}
\textit{Proof} 
\begin{enumerate}
\item  we look at the first part of the lemma concerning expression evaluation. It is 
         by structural induction on the structure of $\expression_1$.  We look only at the simple case
      when $ \expression_1 = \locVar{i} $. The other cases proceed in a similar way. 
           \begin{longtable}{l} 
	      $\evalExp{ \locVar{i} \subst{\locVar{i}  }{\expression_2 }}{s_1} = $\\
	      \comment{apply substitution}\\
	      $\evalExp{\expression_2}{s_1}=$\\
	      \comment{ evaluation of local variables  and by the initial hypothesis for $s_2$ } \\ %by Def.\ref{interpExpr}
	       $\evalExp{\locVar{i}}{s_2}$\\
	   \end{longtable}
   


 \item second case of the lemma. It is by induction on the structure of the formula $\psi$. We sketch the case when 
          $ \psi = \exprWp_1 \  \predicates \  \exprWp_2 $
	    
	    \begin{longtable}{l} 
               $\interp{(\exprWp_1 \  \predicates \  \exprWp_2 )\subst{ \locVar{i} }{ \expression_2 }  }{s_1} =$ \\
	       \comment{apply substitution}\\
	       $\interp{\exprWp_1\subst{ \locVar{i} }{ \expression_2 }  \  \predicates \  \exprWp_2 \subst{ \locVar{i} }{ \expression_2 }  }{s_1} =$ \\
	       \comment{interpretation of formulas }\\
	        $\evalExp{\exprWp_1\subst{ \locVar{i} }{ \expression_2 } }{s_1}  \  \predicates \ \evalExp{ \exprWp_2 \subst{ \locVar{i} }{ \expression_2 }}x  {s_1} = $ \\
		\comment{from the first part of the lemma and the initial hypothesis for $s_2$ we get } \\
		 $\evalExp{\exprWp_1}{s_2}  \  \predicates \  \evalExp{\exprWp_2} {s_2} = $ \\
		 \comment{from definition of formula interpretation in a state}\\
		 $ \interp{\exprWp_1 \  \predicates \  \exprWp_2}{s_2}$
	     \end{longtable}
	
  
\end{enumerate}

\begin{substHeap}[Update of the heap]\label{substHeap}
For any expressions $ \expression_1, \expression_2, \expression_3 $ and any field \fieldd
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$,%$ \evalExp{\expression_2}{ s_1 } \in \Dom(\heap.\heapFields(\fieldd))$
 and \\
   $s_2 =  \config{ \update{\heap}{\fieldd }{\update{\fieldd}
                                                   {\evalExp{\expression_2}{ s_1 } }
                                                   {\evalExp{ \expression_3}{ s_1 } } } }
                                          {\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }   $  the following holds
\begin{enumerate}
  \item $ \evalExp{\substitution{\expression_1}{\fieldd}{ \update{ \fieldd  }{\expression_2}{\expression_3} }}{ s_1 } =  \evalExp{\expression_1}{ s_2  }  $
  \item $ \interp{\substitution{\psi}{\fieldd}{ \update{ \fieldd  }{\expression_2}{\expression_3} }}{ s_1 } \iff  \interp{\psi}{ s_2  }  $
\end{enumerate}
\end{substHeap}

 \begin{newHeap}[Update of the heap with a newly allocated object]\label{newHeap}
For any expressions $ \expression_1$  
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
  $s_2 =  \config{\heap'}{\counterOnly}{ \update{\stackOnly}{\counterOnly}{\evalExp{\referenceOnly}{s_1}} }{\locVarOnly}{\pc } $ where
 $  \newRef{\heap}{\clazz} = (\heap', \referenceOnly)   $  the following holds
\begin{enumerate}
  \item \[ \begin{array}{l}   \evalExp{\expression_1 %\begin{array}{l}
                             \subst{ \stack{\counter}}{ \referenceOnly} %\\
			     \lbrack  \fieldd \leftarrow \update{\fieldd } { \referenceOnly }{\defaultValueOnly( \fieldd.  \fieldType ) }  
                             \rbrack_{ \forall \fieldd: \FieldSet, \subtype{ \fieldd.\declaredIn}{ \clazz} }
                             %\end{array}
                             }{s_1} \\
			     = \\
                            \evalExp{\expression_1}{ s_2  } 
			     \end{array}  \]

     \item \[\begin{array}{l}  \interp{\psi %\begin{array}{l}
                              \subst{\stack{\counter}}{\referenceOnly }%\\
 			      \subst{\fieldd }{ \update{\fieldd } { \referenceOnly }{\defaultValueOnly( \fieldd.\fieldType)}} _{  \forall \fieldd: \FieldSet, \subtype{ \fieldd.\declaredIn}{ \clazz}   }
                             % \end{array}
                             }{s_1}\\
 			      \iff \\ 
 			     \interp{\psi}{s_2} 
 			     \end{array}  \]
 
 
 \end{enumerate}
 \end{newHeap}




%Proof : by structural induction on the structure of $\expression_1$ 
%\begin{enumerate}
%\item we consider the first case of the lemma 
%\begin{itemize}
%	  
 %    \item $\expression_1 = \stack{\counter} $
%      
%      $$
%	    \begin{array}{l}
%	          ( left ) \  \substitution{\stack{\counter}  }{ \stack{\counter} }{ \referenceOnly }    = \referenceOnly \\
%		  \Rightarrow \\
%		\numConclusion{1} \  \evalExp{\substitution {\stack{\counter}  }{ \referenceOnly }{ \expression_2 }}{ s_1 } =   \evalExp{\referenceOnly}{s_1} \\
%		  \\
%		  (right ) \  \evalExp{\locVar{i}}{s_2} = \\
%		  \mbox{\rm\comment{by Def.\ref{interpExpr} of the evaluation  for local variables  }} \\
%		\numConclusion{2} \  =  \evalExp{\expression_2}{s_1} \\
%		 \mbox{\rm\comment{from \numConclusion{1} \  and \numConclusion{2} \ we get that the lemma holds in this case  }}
%	    \end{array} 
%	   $$

%\end{itemize}
%%\item by structural induction over the structure of the formula $\psi$
%\end{enumerate}

\begin{substStack}[Update the stack]\label{substStack} 
For any expressions $ \expression_1, \expression_2, \expression_3 $ 
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ and 
  $s_2 = \config{\heap}{\counterOnly}{ \update{\stackOnly}
                                                                 {\evalExp{\expression_2}{ s_1 } }
                                                                 { \evalExp{\expression_3}{ s_1  } } }{\locVarOnly}{\pc }$ then
 the following holds:
\begin{enumerate}
      \item  $     \evalExp{\substitution{\expression_1}{\stack{\expression_2}}{\expression_3}}{s_1 } = 
      \evalExp{\expression_1}{s_2 }$
      \item  $     \interp{\substitution{\psi}{\stack{\expression_2}}{\expression_3}}{s_1 } \iff
      \interp{\psi}{s_2 }$
\end{enumerate}
\end{substStack}

\begin{substCntr}[Update the stack counter]\label{substCntr}
For any expressions $ \expression_1, \expression_2 $ 
if we have that the states $s_1$ and $s_2$ are such that
 $s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$, %$\evalExp{ \expression_2}{ s_1  } : \Myint$  and 
$s_2 =  \config{\heap}{\evalExp{ \expression_2}{ s_1  } }{ \stackOnly }{\locVarOnly}{\pc }  $ then 
the following holds:
\begin{enumerate}
      \item $\evalExp{\substitution{\expression_1}{ \counter }{ \expression_2 }}{ s_1 } = \evalExp{\expression_1}{s_2} $
      \item $\interp{\substitution{\psi}{ \counter }{ \expression_2 }}{ s_1 } \iff \interp{\psi}{s_2} $
\end{enumerate}
\end{substCntr} 




\begin{substRet}[Return value property]\label{substRet} 
For any expression $\expression_1$ and $\expression_2$,
for any two states $s_1$ and $s_2$  such that
$ s_1 =   \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$,%$\evalExp{\expression_2}{s_1} \in \Values $ and 
$ s_2 =   \configFinalNorm{\heap}{\evalExp{\expression_2}{s_1} } $ then 
the following holds:
\begin{enumerate}
      \item $\evalExp{\substitution{\expression_1}{ \result }{ \expression_2 }}{ s_1 } = \evalExp{\expression_1}{s_2} $
      \item $\interp{\substitution{\psi}{ \result}{ \expression_2 }}{ s_1 } \iff \interp{\psi}{s_2} $
\end{enumerate}
\end{substRet}




% In the following, we adopt a lighter notation for the update  configuration expressions of the form:

%  $$\substitution{ state }{ E }{ \interp{\exprWp}{ state  }  }   , \ E \in \{ \heap, \counterOnly, \stackOnly, \locVarOnly, \pc \} $$
% and instead, we write 
% $$\substitution{ state }{ E }{ \exprWp }$$


