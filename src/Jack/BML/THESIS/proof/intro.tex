%\section{Introduction}
 In the previous chapter \ref{wpGeneral}, we defined a verification
 condition generator for a Java bytecode like language. We used a weakest precondition
 to build the verification conditions. In this section, we will argue formally that the
 proposed verification condition generator is correct, or in other words that it is sufficient
 to prove the verification conditions generated over a bytecode program and its specification 
 for establishing that the program respects the specification. 

 In particular, we will prove the correctness of our methodology w.r.t. the operational semantics of our bytecode language
 given in chapter \ref{opSem}. The way in which the proof is done is standard. Note that the formalization
 of the operational semantics in terms of relation on states serves us to give a model for our assertion
 language. 

 Another point which deserves our attention, is that we will prove the partial correctness of our methodology, i.e.
 we suppose that our programs always terminate.

 We now proceed with the proof of the correctness of the weakest precondition calculus.
 First we will formulate what does it mean for a method to be correct. Then, we establish the correctness
of a single instruction (lemma \ref{lemma0}). The next step of the proof  is to establish that if all the steps
in an execution path establish the intermediate predicates then the execution can either proceed by establishing
the next weakest precondition predicate or will terminate in a state which respects the adequate postcondition.
  



