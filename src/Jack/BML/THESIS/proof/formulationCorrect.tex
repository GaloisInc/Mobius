\newtheorem{defCorrect}{Definition}[section]
\newtheorem{vcGenCorrect}{Theorem}[section]

\section{Formulation of the correctness statement}\label{proof:defineCorrect}

%The correctness of our verification  condition generator is established w.r.t.to the operational semantics described in Section \ref{opSem}.
In order to define what it means for the verification calculus to be correct we will need to 
 precise what does it mean that a  method respects its specification. As we have stated 
 before the intuition behind this notion is that if the method starts execution in a state 
 where its precondition  holds then if it terminates execution then its postcondition holds.
  
 As we want also to treat recursive methods, we use a standard technique which consists in  annotating the execution 
relation in  the operational semantics with weights. A weight  stands for  the maximal 
call depth in the execution of a  method. 
  Thus the operational semantics of a method invokation would be :
 
$$ \begin{array}{l}
              {\scriptsize \frac{\begin{array}{l} 
                        \lookup{\mbox{\rm meth}.\methodName}{ \mbox{\rm meth}.\args  }{\mbox{\rm meth}.\returnType }{\typeof{ \stackOnlyParam{ \counterOnly - \mbox{\rm meth}.\numArgs }} } = \mbox{\rm n} \\
	                        \stackOnlyParam{ \counterOnly - \mbox{\rm n}.\numArgs } \neq \Mynull   \\
	                      \mbox{\rm n}  :         \config{\heap}       
                                                       {0}
						       {\newStack }
                                                       {\lbrack \stackOnlyParam{ \counterOnly - \mbox{\rm n}.\numArgs },\ldots ,\stackOnlyParam{ \counterOnly} \rbrack }
						       {0} 
						       \stateTransTermWeight{k}
						       \configFinalNorm{\heap'}{\Res}\\
				                       \counterOnly' = \counterOnly - \methodd.\numArgs + 1 \\
						       \stackOnly' = \update{\stackOnly}{\counterOnly'}{\Res} \\
						       \pc' = \pc + 1
			         \end{array}  }	         
	         {\methodd \vdash \invoke \  \mbox{\rm meth} :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                        \stateTransWeight{k + 1}
					\config{\heap' }{\counterOnly'}{\stackOnly' }{\locVarOnly}{\pc'}} }
\end{array}$$

This definition is rather intuitive and means that if a method \methodd{}
 has a maximal call depth $k+1$ any method \mbox{\rm meth}  called in its body will have a maximal call depth $k$. For the other instructions the 
weight is just passed. This extension in the operational semantics will allow us to deal with recursive methods in our proof of correctness.


 
 Another condition involved in establishing a method correctness is that if it overrides a method from a super class
 of the class where it is declared  it must respect the specification of the method it overrides. Thus, we formulate method correctness as follows:

\begin{defCorrect}[A method respects its specification] \label{defCorrect}
For every method \methodd \ with precondition \methodd.\pre, normal postcondition \methodd.\normalPost
and exceptional postcondition function \methodd.\excPostSpec, we say that \methodd \ respects its specification if 
for every two states $s_0$ and $s_1$ such that :
\begin{itemize}
      
      \item   $\methodd : s_0  \stateTransTermWeight{k} s_1   $
      \item   $ \interp{\methodd.\pre }{ s_0 }$
\end{itemize}
Then if \methodd \ terminates normally then the normal postcondition holds in the final state $s_1 $:  $\interp{\methodd.\normalPost}{s_1}$. 
Otherwise, if  \methodd \ terminates on an exception \mbox{ \rm \texttt{Exc}} the exceptional postcondition holds in the poststate $s_1 $
$ \interp{\methodd.\excPostSpec(  \mbox{ \rm \texttt{Exc}} )}{s_1} $.
 Moreover, if method $\methodd$ overrides method \mbox{\rm\texttt{n}} then the specification of \methodd{} must be such that
 the precondition \mbox{\rm\texttt{n}}.$\pre$ of method  \mbox{\rm\texttt{n}} implies the precondition  $\methodd.\pre$ of method \methodd{}, i.e.
$\validFormula{\mbox{\rm\texttt{n}}.\pre \Rightarrow   \methodd.\pre}$  
and the postcondition 
$\methodd.\normalPost$ of \methodd{} implies the postcondition $\mbox{\rm\texttt{n}}.\normalPost$   of method \mbox{\rm\texttt{n}}, i.e. 
$\validFormula{\methodd.\normalPost \Rightarrow \mbox{\rm\texttt{n}}.\normalPost } $
 $\forall \mbox{\rm\texttt{Exc}} , \methodd{}.\excPostSpec(\mbox{\rm\texttt{Exc}}  )    \Rightarrow \mbox{\rm\texttt{n}}.\excPostSpec(\mbox{\rm\texttt{Exc}}  )$
\end{defCorrect}

% As we explained  earlier in Chapter \ref{assertLang}, Section \ref{assertLang:lang} the specification upon which the verification 
% of an overriding method is performed guarantees that the method respects automatically the specification of the overriden method.
% Thus, we shall not discuss in the following the behavioral subtyping as it holds trivially because of the way we construct specifications  for overriding methods.

Let us now see informally the correctness condition for the verification calculus. 
We would like to establish that if the verification conditions
generated for a method 
are valid 
and the precondition of the method holds in the initial state of the method 
then the postcondition of  the method holds in its final state if the method terminates. 
If, moreover a method overrides a method from the super class of the class where it is declared then there must be a covariant 
relation between its specification and the specification of the overriden method.
Formally, we want to establish the following statement:

\begin{vcGenCorrect}\label{vcGenCorrect}
For any  method \methodd \  if the verification conditions for a method described in subsection \ref{wp:vcMeth}
are valid, i.e. 
$$  \begin{array}{l}  \validFormula{\methodd.\pre \Rightarrow \wpi{\method.\body[0]}{\methodd}{}} \\

       \mbox{\rm\textit{if method \methodd{} overrides }} \mbox{\rm\texttt{n}} \ then \\
        
        \validFormula{\mbox{\rm\texttt{n}} . \pre \Rightarrow \methodd{}.\pre}\\
	\validFormula{ \methodd{}.\normalPost \Rightarrow \mbox{\rm\texttt{n}} .\normalPost}\\
	\validFormula{   \forall \mbox{\rm\texttt{Exc}} , \methodd{}.\excPostSpec(\mbox{\rm\texttt{Exc}}  )    \Rightarrow \mbox{\rm\texttt{n}}.\excPostSpec(\mbox{\rm\texttt{Exc}}  ) }
\end{array}
 $$


 then \methodd \ respects its specification in the sense of the Def. \ref{defCorrect}. 
\end{vcGenCorrect}

The main purpose of the current chapter is to establish this theorem. Before entering in technical part of the proof
we shall give an outline of the steps to be taken for establishing it.
