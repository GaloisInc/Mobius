\newtheorem{defCorrect}{Definition}[section]
\newtheorem{vcGenCorrect}{Theorem}[section]

\section{Formulation of the correctness statement}\label{proof:defineCorrect}

%The correctness of our verification  condition generator is established w.r.t.to the operational semantics described in Section \ref{opSem}.
In order to define what it means for the verification calculus to be correct we will need to 
 precise what does it mean that a  method respects its specification. As we have stated 
 before the intuition behind this notion is that if the method starts execution in a state 
 where its precondition  holds then if it terminates execution then its postcondition holds.
  
 As we want also to treat recursive calls, we use a technique  known in the literature \cite{Nipkow-MOD2001} which consists in  annotating the execution 
relation in  the operational semantics with levels. A level of execution  stands for  the maximal call depth in the execution of a  method. 
  Thus, the operational semantics of a method invokation in case of normal termination\footnote{we are not exhaustive here about all the possible rules of the 
operational semantics  for method invokation, but the other cases are similar}  would be :
 
$$ \begin{array}{l}
             \frac{\begin{array}{l} 
                        \lookup{\mbox{\rm meth}.\methodName}{ \mbox{\rm meth}.\args  }{\mbox{\rm meth}.\returnType }{
\heapTypeOf(\stackOnlyParam{ \counterOnly - \mbox{\rm meth}.\numArgs }) } = \mbox{\rm n} \\
	                        \stackOnlyParam{ \counterOnly - \mbox{\rm n}.\numArgs } \neq \Mynull   \\
	                      \mbox{\rm n}  :         \config{\heap}       
                                                       {0}
						       {\newStack }
                                                       {\lbrack \stackOnlyParam{ \counterOnly - \mbox{\rm n}.\numArgs },\ldots ,\stackOnlyParam{ \counterOnly} \rbrack }
						       {0} 
						       \stateTransTermWeight{k}
						       \configFinalNorm{\heap'}{\Res}\\
				                       \counterOnly' = \counterOnly - \methodd.\numArgs + 1 \\
						       \stackOnly' = \update{\stackOnly}{\counterOnly'}{\Res} \\
						       \pc' = \pc + 1
			         \end{array}  }	         
	         {\methodd \vdash \invoke \  \mbox{\rm meth} :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                        \stateTransWeight{k + 1}
					\config{\heap' }{\counterOnly'}{\stackOnly' }{\locVarOnly}{\pc'}} 
\end{array}$$

If a method invocation is at level \level{k} this means that the maximal call depth of the method is at most  \level{k-1}.
If a method invocation is at level \level{1} this means that the method execution does not perform any method calls.
Thus, a method invocation labeled with \level{0} does not exist. Moreover, if the invocation of  \methodd{}
 is at level \level{k+1} any method \mbox{\rm meth}  called in its body will have a level \level{k}. 
 For the other instructions the weight of the maximal call depth is just passed. The rules for the instructions different from 
method invocation have this general form: 
$$ \begin{array}{l}
              \frac{ i \neq \invoke \  \methodd \vdash  i: s_1 \stateTrans s_2 }{ \methodd \vdash s_1 \stateTransWeight{k} s_2 , \  \level{k} > 0}
\end{array}$$
 
We now first define what does it mean for a method to respect its specification at level \level{k}
\begin{defCorrect}[method respects its specification at level k] \label{defCorrectLevel}
For every method \methodd \ with precondition \methodd.\pre, normal postcondition \methodd.\normalPost{}
and exceptional postcondition function \methodd.\excPostSpec, we say that \methodd{} respects its specification at level \level{k} if 
for every two states $s_0$ and $s_1$ such that :
\begin{itemize}
      
      \item   $\methodd : s_0  \stateTransTermWeight{k} s_1   $
      \item   $ \interp{\methodd.\pre }{ s_0 }$
\end{itemize}
Then if \methodd{} terminates normally then the normal postcondition holds in the final state $s_1 $, i.e.  $\interp{\methodd.\normalPost}{s_1}$ holds. 
Otherwise, if  \methodd{}  terminates on an exception \mbox{ \rm \texttt{Exc}} the exceptional postcondition holds in the poststate $s_1 $, i.e.
$ \interp{\methodd.\excPostSpec(  \mbox{ \rm \texttt{Exc}} )}{s_1} $ holds.
 % Moreover, if method $\methodd$ overrides method \mbox{\rm\texttt{n}} then the specification of \methodd{} must be such that
 % the precondition \mbox{\rm\texttt{n}}.$\pre$ of method  \mbox{\rm\texttt{n}} implies the precondition  $\methodd.\pre$ of method \methodd{}, i.e.
 %$\validFormula{\mbox{\rm\texttt{n}}.\pre \Rightarrow   \methodd.\pre}$  
 %and the postcondition 
 %$\methodd.\normalPost$ of \methodd{} implies the postcondition $\mbox{\rm\texttt{n}}.\normalPost$   of method \mbox{\rm\texttt{n}}, i.e. 
 %$\validFormula{\methodd.\normalPost \Rightarrow \mbox{\rm\texttt{n}}.\normalPost } $
 % $\forall \mbox{\rm\texttt{Exc}} , \methodd{}.\excPostSpec(\mbox{\rm\texttt{Exc}}  )    \Rightarrow \mbox{\rm\texttt{n}}.\excPostSpec(\mbox{\rm\texttt{Exc}}  )$
\end{defCorrect}

Next, we give a definition for program correctness at level \level{k}. 

\begin{defCorrect}[program is correct at level \level{k}]\label{defCorrectProgramLevel}
A program is correct if for all classes \class{} in the program, every method \methodd{} in \class{}
respects its specification at level \level{k}.
\end{defCorrect}

%We give a more general definition for the method correctness which abstracts from the call levels.
%\begin{defCorrect}[A method respects its specification]\label{defCorrect}
%A method \methodd \ respects its specification if and only if 
%for all \level{k} where \level{k} $ \ge $ 0, method \methodd{} respects its specification at level \level{k}. 
%\end{defCorrect}


We generalize the definition for program correctness w.r.t. the level \level{k}. 

\begin{defCorrect}[program is correct]\label{defCorrectProgram}
A program is correct
if for all levels $\level{k} \ge 0 $ the program is correct at level \level{k}.
\end{defCorrect}


% As we explained  earlier in Chapter \ref{assertLang}, Section \ref{assertLang:lang} the specification upon which the verification 
% of an overriding method is performed guarantees that the method respects automatically the specification of the overriden method.
% Thus, we shall not discuss in the following the behavioral subtyping as it holds trivially because of the way we construct specifications  for overriding methods.

Let us now see informally the correctness condition for the verification calculus. 
We would like to establish that if the verification conditions
generated for all methods in a program are valid then we can conlcude that the program is correct. 
%are valid 
%and the precondition of the method holds in the initial state of the method 
%then the postcondition of  the method holds in its final state if the method terminates. 
%If, moreover a method overrides a method from the super class of the class where it is declared then there must be a covariant 
%relation between its specification and the specification of the overriden method.
We formulate this as a the theorem:
\begin{vcGenCorrect}[Verification condition generator is correct]\label{vcGenCorrect}
If the verification conditions  for all  methods in a program \Program{}  (see  subsection \ref{wp:vcMeth} )
are valid then \Program{} is correct w.r.t. Def. \ref{defCorrectProgram}
%$$  \begin{array}{l}  \validFormula{\methodd.\pre \Rightarrow \wpi{\method.\body[0]}{\methodd}{}} \\
%       \mbox{\rm\textit{if method \methodd{} overrides }} \mbox{\rm\texttt{n}} \ then \\
%        
% %       \validFormula{\mbox{\rm\texttt{n}} . \pre \Rightarrow \methodd{}.\pre}\\
%	\validFormula{ \methodd{}.\normalPost \Rightarrow \mbox{\rm\texttt{n}} .\normalPost}\\
%	\validFormula{   \forall \mbox{\rm\texttt{Exc}} , \methodd{}.\excPostSpec(\mbox{\rm\texttt{Exc}}  )    \Rightarrow \mbox{\rm\texttt{n}}.\excPostSpec(\mbox{\rm\texttt{Exc}}  ) }
%\end{array}
% $$

\end{vcGenCorrect}

The main purpose of the current chapter is to establish this theorem. Before entering in technical part of the proof
we shall give an outline of the steps to be taken for establishing it.


