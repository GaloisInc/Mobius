 %\newcommand{\isFieldOfOnly}{\mbox{ \rm \textit{isFieldOf}} \ }
 % \newcommand{\isFieldOf}[2]{\mbox{ \rm \textit{isFieldOf}}(#1, #2) }

 \section{Classes, fields and methods}\label{clazz}
 Java programs are a set of classes. As the JVM says \textit{`` A class declaration specifies a new reference type and provides its implementation. \ldots
 The body of a class declares members (fields and methods), static initializers, and constructors.''}
 In our formalization, classes are encoded  with the data structure $\ClassSet$,  fields with $\FieldSet$ and
 methods are encoded with $\MethodSet$ data structure. 
 We define a domain for class names \ClassName, for field names \FieldName{} and for method names \MethodName{} respectively.

 An object of type \ClassSet \ is a tuple with the following components: list of field objects (\fields), which are declared in this class,
 list of the methods declared in the class (\methods), the name of the class (\className)   and the super class of the class (\superClass).
 All classes, except the special class \Object, have a unique direct super class. Formally, a class of our bytecode language 
 has the following structure:


 $$ \begin{array}{l}
          %\forall  \clazz : \ClassSet , \\
         \ClassSet = \left\{\begin{array}{ll} \fields    & :    list \ \FieldSet \\
                                          \methods    & :    list \ \MethodSet\\
					  \className  & :   \ClassName \\
					  \superClass & :   \ClassSet \cup \{ \bottom \}
                    \end{array} \right\}
   \end{array} $$

 A field object is a tuple that contains the unique field id (\fieldName) and a field type (\fieldType) and
 the class where it is declared (\declaredIn):  
 $$ \begin{array}{l}
         \FieldSet = \left\{\begin{array}{ll}   
		                               \fieldName  &  : \FieldName;\\
                                               \fieldType   &  : \JavaType; \\
					       \declaredIn  &  : \ClassSet \cup \{ \bottom \}
                     \end{array} \right\}
   \end{array} $$
  From the above definition, we can notice that the field \declaredIn \ may have a value $\bottom$. This is because we model 
  the length of a reference pointing to an array object as an element from the set \FieldSet. Because the length of 
  an array is not declared in any class, 
  we assign to its attribute \declaredIn \ the value $\bottom$.  
  The special field which stands for the array length  
 (the name of the object and its field  \fieldName \ have the same name ) is the following:
 $$  \length =  \left\{\begin{array}{ll} \fieldName & = length;\\
			                 \fieldType  & = int; \\
					 \declaredIn & = \bottom
                     \end{array} \right\}$$

 There are other possible approaches for modeling the array length. For instance,
 the array length can be part of the array reference. We consider that both of the choices are equivalent.
 However, the current formalization follows closely our implementation  of the verification condition 
 generator which encodes in this way array length which is necessary if we want to do a proof of correctness of the implementation.

% We assume that for any two different fields $\fieldd_1$ and $\fieldd_2$ their names are different : 
% $$\fieldd_1 \neq \fieldd_2 \Rightarrow \fieldd_1.fieldName \neq  \fieldd_2.fieldName  $$

 A method has a unique method id (\methodName), a return type (\retType),
 a list containing the formal parameter types(\args), 
 the number of its formal parameters (\numArgs),
 list of bytecode instructions representing its body (\body),
% and the entry point instruction of the method (\entryPoint)
% (the instruction at which every execution of the method starts), 
 the exception handler table (\excHandlerTable) and the list of exceptions
 (\exceptions) that the method may throw. Finally, the structure also contains information 
 about the class where the method is declared(\declaredIn). 

 $$ \begin{array}{l} % \forall \methodd: \MethodSet, \\
                     \MethodSet  = \left\{\begin{array}{ll}  \methodName & :\MethodName \\
						             \retType & :\JavaType\\
							     \args &  : list \  \JavaType \\
							     \numArgs & : nat \\
							     \body &  : list \ \bcIns \\
							     %\entryPoint  &  : \bcIns \\
							     \excHandlerTable & : list \ \ExcHandler \\
							     \exceptions & : list \ \ClassSet_{exc}\\
							     \declaredIn  &  : \ClassSet
                                     \end{array}  \right\}
     \end{array} $$
  
 We assume that for every method \methodd \ the entry point is the first instruction in the list of instructions 
 of which the method body consists, i.e. $ \methodd.\entryPoint =\methodd.\body[0]$.

 An object of type \ExcHandler \ contains information about the region in the method body that it protects, i.e. the start
 position (\pcStart) of the region and the end position (\pcEnd), about the exception it protects from (\exc),
 as well as what position in the method body the exception handler starts (\pcHandler) at.


 $$ \begin{array}{l}  
                 \ExcHandler = \left\{\begin{array}{ll} \pcStart & : nat \\
						          \pcEnd & : nat \\
							  \pcHandler &  : nat \\
							  \exc & : \ClassSet_{exc} 
                                        \end{array}  \right\}
     \end{array} $$
   We require that \pcStart, \pcEnd \ and \pcHandler \ fields in any exception handler attribute \methodd.\excHandlerTable \ for any method \methodd \
   are valid indexes in the list  of instructions of the method body  \methodd.\body :
 
$$ \begin{array}{l}  \forall \methodd: \MethodSet,  \\
                      \forall i:nat, 0 \le i <  \methodd.\excHandlerTable.length,  \\
                            \Myspace 0 \le \methodd.\excHandlerTable[i].\pcEnd <  \methodd.\body.length \wedge  \\
			    \Myspace 0 \le \methodd.\excHandlerTable[i].\pcStart <  \methodd.\body.length  \wedge \\
			    \Myspace 0 \le \methodd.\excHandlerTable[i].\pcHandler <  \methodd.\body.length  
    \end{array}
 $$


 
% For getting the value of any of the attributes in a class, method or field object we use the notation \textit{ name of the object . name of the attribute }
  
