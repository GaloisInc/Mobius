\index{\HeapSet}
\index{\heap}
\index{\heapArrays}
\index{\heapArrays} 
\index{\heapTypeOf}

 \subsection{Modeling the object heap} \label{heap}
 An important issue for the modeling of an object oriented programming language and its operational semantics
 is the memory heap. The heap is the
 runtime data area from which memory  for all class instances and arrays is allocated. Whenever a new instance
 is allocated, the JVM returns a reference value that points to the newly created object. 
 We introduce a record type \HeapSet \ which models the memory heap. We do not take into account 
 garbage collection and thus, we assume that heap objects has an infinite memory space. 
 
 In our modeling, a heap consists of the following components:
 \begin{itemize}
       \item a component  named \heapFields \ which is a partial function that maps field
             structures (of type \FieldSet \ introduced in subsection \ref{clazz} ) into partial functions from references (\AllRefs)
	     into values (\Values).  
 

       \item  a component \heapArrays \ which maps the components of arrays  into their values

       \item  a component  \heapLocs  \ which stands for the  list of references that the heap has allocated  
              
       \item  a component \heapTypeOf   \ is a partial function  which maps references to their dynamic type 
 \end{itemize}


 Formally, the data type \HeapSet \ has the following structure:



  $$ \begin{array}{l}
         \forall  \heap : \HeapSet , \\
         \heap = \left\{\begin{array}{ll}  \heapFields  &  : \FieldSet \rightharpoonup (  \RefValues \rightharpoonup \Values) \\
                                           \heapArrays  &  : \RefValuesArr * nat \rightharpoonup \Values \\
					   \heapLocs    &  : list \ \RefValues \\
					   \heapTypeOf  &  : \RefValues \rightharpoonup \AllRefs
                    \end{array} \right\}
   \end{array} $$


 Another possibility is to model the heap as partial function from locations to objects where objects contain a function from 
 fields to values. Both formalizations are equivalent, still we have chosen this model as it follows closely the
 verification condition generator implementation.

 In the following, we are interested only in  heap objects \heap \ for which the components
 \heap.\heapFields \ and \heap.\heapArrays \ are functions defined only for references from the proper
 type, i.e. well-typed and which are in the list of references of the heap \heap.\heapLocs, i.e. well-defined: 

% \ as well as that if a field function
% returns a reference value then this reference value is once again in \heap.\heapLocs :
 $$\begin{array}{ll}
          \forall  \fieldd : \FieldSet, \forall \referenceOnly \in \RefValues, &  \referenceOnly \in \Dom( \heap.\heapFields(\fieldd)) \Rightarrow \\
	  &  \referenceOnly  \in \heap.\heapLocs  \wedge \\
	  & \subtype{ \heap.\heapTypeOf(\referenceOnly ) }{\fieldd.\declaredIn} \\
	  \wedge &  \\
	  \forall \referenceOnly \in  \RefValuesArr, &  (\referenceOnly  , i ) \in \Dom (\heap.\heapArrays) \Rightarrow \\
	  &  \referenceOnly  \in  \heap.\heapLocs \wedge \\
	  & 0 \leq i < \heap.\heapFields( \length)( \referenceOnly)  
	 
   \end{array}
  $$

% Also, we assume that the heap must contain well formed values. By this, we mean that the heap  maps any field object \todo{is this restriction ok? }
% \fieldd : \FieldSet \ which has a reference  type (i.e. the component \fieldd.\fieldType \ contains a reference type  )  
%into a function which may only return references which are already defined in the heap. The same condition is required for array references whose elements
%are references, i.e. the value of an array elements is either a reference defined in the heap or \Mynull. The next formalization expresses the restriction for field 
%functions : 

% $$\begin{array}{ll}
%          \forall  \fieldd : \FieldSet, & \forall \referenceOnly \in \RefValues, \\ 
%          & \fieldd.\fieldType \in \AllRefs  \wedge \\
%	  & \referenceOnly  \in  \Range( \heap.\heapFields(\fieldd))  \Rightarrow \\
%	  & \Myspace  \referenceOnly \in \heap.\heapLocs \vee \referenceOnly = \Mynull \\	  
%   \end{array}
%  $$
 



 % We define an operation \addNewLocationOnly \  which adds a new reference to the list of references in a heap.
 % The only change that the operation will cause to the heap \heap \ is to add
 % a new reference $\referenceOnly$ to the list of references of the heap \heap.\heapLocs:   

 % $$ \addNewLocationOnly : \HeapSet *  \AllRefs   \rightarrow \HeapSet $$

 % Formally, the operation is defined as follows: 
 % $$ \begin{array}{l}
 %           \addNewLocation{\heap}{\referenceOnly} = \heap' \iff^{def} \\
 %	      \\
 %   	      \referenceOnly \notin \heap.\heapLocs   \\ 
 % %	      \heap'.\heapLocs = \referenceOnly \assocList \heap.\heapLocs \wedge \\ 
 %	      \heap.\heapFields = \heap'.\heapFields \wedge \\
 %	      \heap.\heapArrays = \heap'.\heapArrays \wedge \\
 %	     
 %    \end{array}$$ 



 If a new object of class $\clazz$ is created in the memory,
 a fresh reference value $\referenceOnly$ different from \Mynull{}  which points to the newly created object is added in the heap \heap \ 
 and all the values of the field functions that correspond to the fields in class $\clazz$ 
 are updated for the new reference with the default values for their corresponding types.
 The function which for a heap \heap \ and a class type \clazz \ returns the same heap but with a fresh reference of
 type \clazz \ has the following name and signature:
 $$ \newRefOnly :  \heap \rightarrow \reff \rightarrow  \heap * \Ref $$

 The formalization of the resulting heap and the new reference is the following:



 $$  \begin{array}{l}
            \newRef{\heap}{\clazz} = (\heap',\referenceOnly )     \iff^{def} \\
	    \\
	    \referenceOnly \neq \Mynull \wedge \\ 
	    \referenceOnly \notin \heap.\heapLocs \wedge   \\ 
	    \heap'.\heapLocs = \referenceOnly \assocList \heap.\heapLocs \wedge \\ 
	    \heap'.\heapTypeOf := \update{ \heap.\heapTypeOf}{ \referenceOnly}{\clazz}  \wedge \\ 
            \begin{array}{ll}
	           \forall  \fieldd : \FieldSet, & \instanceFlds{\fieldd}{\clazz} \Rightarrow \\
                                                 & \Myspace \heap'.\heapFields := 
			                           \update{\heap'.\heapFields}{\fieldd}{\update{\fieldd}{\referenceOnly}{ \defaultValue{\fieldd.\fieldType }}} \wedge \\
			                             
                                                
      \end{array}
	  
     \end{array} $$

In the above definition, we use the function \instanceFldsOnly, which for a given field \fieldd \ and \clazz \ returns true if \fieldd \ is
an instance field of \clazz: 

$$
 \instanceFldsOnly : \FieldSet   \rightarrow \ClassSet \rightarrow bool 
$$

$$
 \begin{array}{l}
       \instanceFlds{\fieldd}{\clazz } = \\
       \left\{\begin{array}{ll}
                    true  & \fieldd.\declaredIn = \clazz \\
		    false & \clazz = \Object \wedge \fieldd.\declaredIn \neq \Object \\
		    \instanceFlds{\fieldd}{\clazz.\superClass} & else
       \end{array}\right.
 \end{array}
$$


Identically, when allocating a new object of array type whose elements are of type \anyType \ and length $l$, we obtain 
a new heap object  $\newArrRef{\heap}{\anyType \lbrack \ \rbrack  }{l} $ which is defined similarly to the previous case: 
$$ \newArrRefOnly :  \heap \rightarrow  \reffArr \rightarrow  \heap * refArr $$

 $$  \begin{array}{l}
            \newArrRef{\heap}{\anyType\lbrack \ \rbrack}{l} = (\heap', \referenceOnly)      \iff^{def} \\
	    \\
	    \referenceOnly \neq \Mynull \wedge \\ 
	    \referenceOnly \notin \heap.\heapLocs \wedge   \\ 
	    \heap'.\heapLocs = \referenceOnly \assocList \heap.\heapLocs \wedge \\ 
	    \heap'.\heapTypeOf :=  \update{ \heap.\heapTypeOf}{ \referenceOnly}{\anyType\lbrack \ \rbrack  }  \wedge \\ 
            \heap'.\heapFields :=  \update{\heap'.\heapFields}{\length}{\update{\length}{ \referenceOnly}{ l }} \wedge  \\
	    \forall i, 0 \le i < l  \Rightarrow   \heap'.\heapArrays :=
            \update{\heap'.\heapArrays}{(\referenceOnly , i)}{ \defaultValue{\anyType }  } \\
	     
     \end{array} $$



In the following, we adopt few more naming conventions which do not create any ambiguity.
 Getting the function corresponding to a field \fieldd in a heap \heap \ :
$ \heap . \heapFields ( \fieldd)$ is replaced  with $ \heap  ( \fieldd)$ for the sake of simplicity.
 
The same abbreviation is done for access of an element in an  array object referenced by the reference 
 \referenceOnly at index $i$ in the heap \heap. Thus, the usual denotation:
$ \heap . \heapArrays (\referenceOnly, i )$ becomes $ \heap(\referenceOnly, i )$.
 
 
% The list of references of the resulting heap $\newRef{\heap}{\clazz}$ and the heap \heap
% has the following property:

% $$  \intersect{\getLocations{\heap}}{\newRef{\heap}{\clazz}} =  \lbrack \Ref{\clazz} \rbrack $$



 
   Whenever the  field $\fieldd$ for the object pointed by reference
 $\referenceOnly$ is updated  with the value \textit{val},
 the component \heap.\heapFields \ is updated:
 $$ \heap.\heapFields := \update{\heap.\heapFields}{\fieldd}{\update{\heap.\heapFields(\fieldd)}{\referenceOnly}{val}} $$  
 In the following, for the sake of clarity, we will use another lighter notation for a field update which do not imply any ambiguities:
 $$ 
  \update{\heap}{\fieldd}{\update{\fieldd}{\referenceOnly}{val}} 
 $$ 



 If in the heap \heap \ 
 the $i^{th}$ component in the array referenced by $\referenceOnly$ is updated with the new value \textit{val},
 this results in assigning a new value of the component \heap.\heapArrays:
 $$\heap.\heapArrays := \update{\heap.\heapArrays}{(\referenceOnly , i)}{val} $$ 
 In the following, for the sake of clarity, we will use another lighter notation for an update of an array component
 which do not imply any ambiguities:
 $$ 
  \update{\heap}{(\referenceOnly , i) }{val} 
 $$ 

 
 

