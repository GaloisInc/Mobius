

 \subsection{Modeling the Object Heap} \label{heap}
 An important issue for the modelization of an object oriented programming language and its operational semantics
 is the garbage collected memory heap. As the JVM specification states, the heap is the
 runtime data area from which memory  for all class instances and arrays is allocated. Whenever a new instance
 is allocated, the JVM returns a reference value that points to the newly created object. 
 We introduce a record type \HeapSet \ which models the memory heap. We do not take into account 
 garbage collection and thus, we assume that heap objects has an infinite space memory. 
 
 In our modelization, a heap consists of the following components:
 \begin{itemize}
       \item a component  named \heapFields \ which is a partial function that maps field
             structures (of type \FieldSet \ introduced in subsection \ref{clazz} ) into partial functions from references (\AllRefs)
	     into values (\Values).  
 

       \item  a component \heapArrays \ which maps the components of arrays  into their values

       \item  a component  \heapLocs  \ which stands for the  list of references that the heap has allocated  
              
       \item  a component \heapTypeOf   \ is a partial function  which maps references to their dynamic type 
 \end{itemize}


 Formally, the data type \HeapSet \ has the following structure:



  $$ \begin{array}{l}
         \forall  \heap : \HeapSet , \\
         \heap = \left\{\begin{array}{ll}  \heapFields  &  : \FieldSet \rightharpoonup (  \RefValues \rightharpoonup \Values) \\
                                           \heapArrays  &  : \RefValuesArr * nat \rightharpoonup \Values \\
					   \heapLocs    &  : list \ \RefValues \\
					   \heapTypeOf  &  : \RefValues \rightharpoonup \AllRefs
                    \end{array} \right\}
   \end{array} $$


 Another possibility is to model the heap as partial function from locations to objects where objects contain a function from 
 fields to values. Both formalizations are equivalent, still we have chosen this model as it follows closely our implementation
 of the verification condition generator.

 A heap object \heap \ must assure that the value of the components \heap.\heapFields \ and \heap.\heapArrays \
 are functions which are defined only for references from the proper
 type and which are in the list of references of the heap \heap.\heapLocs:
 $$\begin{array}{ll}
          \forall  \fieldd : \FieldSet, \forall \referenceOnly: \clazz', &  \InDom{ \heap.\heapFields(\fieldd)}{\referenceOnly } \Rightarrow \\
	  & \isInList{\referenceOnly}{ \getLocations{\heap}} \wedge \\
	  & \fieldd.\declaredIn = \clazz \wedge \\
	  & \subtype{\clazz'}{\clazz} \\
	  \wedge &  \\
	  \forall \referenceOnly : T \lbrack \ \rbrack, &  \InDom{ \heap.\heapArrays}{(\referenceOnly  , i )} \Rightarrow \\
	  & \isInList{\heap.\heapLocs}{  \referenceOnly }\wedge \\
	  & 0 \leq i < \heap.\heapFields( \length)( \referenceOnly)  
	 
   \end{array}
  $$



 
% The function $\intersectOnly$ takes two lists $l1$ and $l2$ and returns a list of
% their common elements:
% $$\intersectOnly : list \ \AllRefs *  list \ \AllRefs \rightarrow  list \ \AllRefs   $$


 %The function \getFreshRefOnly returns a reference of type \texttt{C} which is not in the list $l$
 %\ 
 %$$\getFreshRefOnly: list \ \AllRefs  * \JavaClass \rightarrow \AllRefs $$

 %and which has the following property for every list of references $l$ and class type $C$:

 %$$ \getFreshRef{l}{C} = \Ref{C} \Rightarrow \isInList{l}{\Ref{C}} = \mbox{ \rm \textit{false}} $$

 We define an operation \addNewLocationOnly \  which add a new reference to the list of references in a heap.
 The only change that the operation will cause to the heap \heap \ is to add
 a new reference $\referenceOnly$ to the list of references of the heap \heap.\heapLocs:   

 $$ \addNewLocationOnly : \HeapSet *  \AllRefs   \rightarrow \HeapSet $$

 Formally, the operation is defined as follows: 
 $$ \begin{array}{l}
           \addNewLocation{\heap}{\referenceOnly} = \heap' \iff^{def} \\
	      \\
              \heap.\heapLocs = l \wedge \\
   	      \isInList{l}{\referenceOnly} = \mbox{ \rm \textit{false}} \wedge \\
	      \heap'.\heapLocs = \addInList{l}{\referenceOnly}  \wedge \\ 
	      \heap.\heapFields = \heap'.\heapFields \wedge \\
	      \heap.\heapArrays = \heap'.\heapArrays \wedge \\
	      % \heap.\heapTypeOf = \heap'.\heapTypeOf
	   %   \begin{array}{l}
            %  %        \forall \fieldd : \FieldSet, \ \forall \referenceOnly : \clazz,  \\
            %                \Myspace \isInList{l}{\mbox{ \rm \texttt{r}}} = \mbox{ \rm \textit{true}}  \wedge \\
             %               \Myspace \instanceFlds{\fieldd}{   \heapTypeOf( \referenceOnly )} \Rightarrow \\
	 % 		  \Myspace (\heap.\heapFields ( \fieldd  ))( \referenceOnly ) = (\heap'.\heapFields( \fieldd ))(\referenceOnly) \\
              %        \wedge  \\
	      %        \forall \referenceOnly  : \reffArr,  \\
              %              \Myspace  \isInList{l}{\referenceOnly} = \mbox{ \rm \textit{true}}  \wedge \\
               %             \Myspace \forall i, 0 \leq i  < \heap.\heapFields(\length)(\referenceOnly) \Rightarrow \\
                %            \Myspace \heap.\heapArrays(\referenceOnly, i ) = \heap'.\heapArrays(\referenceOnly, i  )
               %  \end{array} 
    \end{array}$$ 

In the above definition, we use the function \instanceFldsOnly, which for a given field \fieldd \ and \clazz \ returns true if \fieldd \ is
an instance field of \clazz: 

$$
 \instanceFldsOnly : \FieldSet   \rightarrow \ClassSet \rightarrow bool 
$$

$$
 \begin{array}{l}
       \instanceFlds{\fieldd}{\clazz } = \\
       \left\{\begin{array}{ll}
                    true  & \fieldd.\declaredIn = \clazz \\
		    false & \clazz = \Object \wedge \fieldd.\declaredIn \neq \Object \\
		    \instanceFlds{\fieldd}{\clazz.\superClass} & else
       \end{array}\right.
 \end{array}
$$



 If a new object of class $\clazz$ is created in the memory,
 a fresh reference $\referenceOnly$  which points to the newly created object is added in the heap \heap \ 
 and all the values of the field functions that correspond to the fields in class $\clazz$ 
 are updated for the new reference with the default values for their corresponding types.
 The function which for a heap \heap and a class type \clazz returns the same heap but with a fresh reference of
 type \clazz \ has the following name and signature:
 $$ \newRefOnly :  \heap \rightarrow \reff \rightarrow  \heap * ref $$

 The formalization of the resulting heap and the new reference is the following:



 $$  \begin{array}{l}
            \newRef{\heap}{\clazz} = (\heap',\referenceOnly )     \iff^{def} \\
	    \\
	    \addNewLocation{\heap}{\referenceOnly } = \heap' \wedge \\
	    
            \left\{\begin{array}{ll}
	           \forall  \fieldd : \FieldSet, &\instanceFlds{\fieldd}{\clazz} \Rightarrow \\
                                                 & \heap'.\heapFields := 
			                           \update{\heap'.\heapFields}{\fieldd}{\update{\fieldd}{\referenceOnly}{ \defaultValue{\fieldd.\fieldType }}}\\
			                        & \heap.\heapTypeOf( \referenceOnly) = \clazz 
                                                
      \end{array}\right\}
	  
     \end{array} $$




Identically, when allocating a new object of array type whose elements are of type \anyType \ and length $l$, we obtain 
a new heap object  $\newArrRef{\heap}{\anyType \lbrack \ \rbrack  }{l} $ which is defined similarly to the previous case: 
$$ \newArrRefOnly :  \heap \rightarrow  \reffArr \rightarrow  \heap * refArr $$

 $$  \begin{array}{l}
            \newArrRef{\heap}{\anyType\lbrack \ \rbrack}{l} = (\heap', \referenceOnly)      \iff^{def} \\
	    \\
	    \addNewLocation{\heap}{\referenceOnly} = \heap' \wedge \\
            \heap'.\heapFields :=  \update{\heap'.\heapFields}{\length}{\update{\length}{ \referenceOnly}{ l }} \wedge  \\
	    \forall i, 0 \geq i < l  \Rightarrow   \heap'.\heapArrays :=
            \update{\heap'.\heapArrays}{(\referenceOnly , i)}{ \defaultValue{\anyType }  } \\
            \heap. \heapTypeOf(\referenceOnly ) = \anyType\lbrack \ \rbrack
                            
     \end{array} $$



In the following, we adopt few more naming convention which do not create any ambiguity.
 Getting the function corresponding to a field \fieldd in a heap \heap \ :
$ \heap . \heapFields ( \fieldd)$ is replaced  with $ \heap  ( \fieldd)$ for the sake of simplicity.
 
The same abreviation is done for access of an element in an  array object referenced by the reference 
 \referenceOnly at index $i$ in the heap \heap. Thus, the usual denotation:
$ \heap . \heapArrays (\referenceOnly, i )$ becomes $ \heap(\referenceOnly, i )$.
 
 
% The list of references of the resulting heap $\newRef{\heap}{\clazz}$ and the heap \heap
% has the following property:

% $$  \intersect{\getLocations{\heap}}{\newRef{\heap}{\clazz}} =  \lbrack \Ref{\clazz} \rbrack $$



 
   Whenever the  field $\fieldd$ for the object pointed by reference
 $\referenceOnly$ is updated  with the value \textit{val},
 the component \heap.\heapFields \ is updated:
 $$ \heap.\heapFields := \update{\heap.\heapFields}{\fieldd}{\update{\heap.\heapFields(\fieldd)}{\referenceOnly}{val}} $$  
 In the following for the sake of clarity, we will use another lighter notation for a field update which do not imply any ambiguities:
 $$ 
  \update{\heap}{\fieldd}{\update{\fieldd}{\referenceOnly}{val}} 
 $$ 



 If in the heap \heap \ 
 the $i^{th}$ component in the array referenced by $\referenceOnly$ is updated with the new value \textit{val},
 this results in assigning a new value of the component \heap.\heapArrays:
 $$\heap.\heapArrays := \update{\heap.\heapArrays}{(\referenceOnly , i)}{val} $$ 
 In the following, for the sake of clarity, we will use another lighter notation for an update of an array component
 which do not imply any ambiguities:
 $$ 
  \update{\heap}{(\referenceOnly , i) }{val} 
 $$ 

 
 

