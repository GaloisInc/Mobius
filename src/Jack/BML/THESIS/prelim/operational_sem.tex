
\newtheorem{StateTransition}{Definition}[section]
\newtheorem{transClosStateTrans0}[StateTransition]{Definition}
\newtheorem{transClosStateTrans1}[StateTransition]{Definition}



\section{Bytecode Language and its Operational Semantics} \label{opSem}
 The bytecode language that we introduce here corresponds to a representative subset of the Java bytecode language. 
 In particular, it supports object manipulation and creation, method invokation, as well as exception throwing and handling.
 In fig. \ref{opSem:bclang}, we give the list of instructions that constitute our bytecode
 language.
 
 \begin{figure}[h] 
      $$  \begin{array}{lll}
             \bcIns ::= & \ifCond & \\
	                & \mid \goto  & \\ 
			& \mid \return  &\\ 
			& \mid \arithOp  & \\ 
			& \mid \load & \\ 
			& \mid \store & \\
			& \mid \push & \\
			& \mid \pop & \\
			& \mid \dup & \\
			& \mid \iinc & \\
			& \mid \new & \\
			& \mid \newarray &  \\ 	
			& \mid \putfield  & \\
			& \mid \getfield  & \\
			& \mid \arrstore &  \\
			& \mid \arrload  & \\
			& \mid \arraylength  & \\
			& \mid \instanceof  & \\
			& \mid \checkcast &  \\
			& \mid \athrow  & \\
			& \mid \invoke  & \\
		%	& \mid \jsr  & \\
		%	& \mid \ret  & \\
	\end{array}$$
        \caption{Bytecode Language instructions }
        \label{opSem:bclang}
  \end{figure}  
 	 
 Note that the instruction \arithOp stands for any arithmetic instruction in the list  \instr{add}, \instr{sub}, \instr{mult}, 
 \instr{and}, \instr{or}, \instr{xor} , \instr{ishr}, \instr{ishl}, \instr{div}, \instr{rem} ).
 


% We introduce two special value for the program counter $\botNorm$ and  $\botExc$. 
% The program counter \pc is set to $\bottom^{norm}$ whenever the method execution 
% terminates normally, i.e. the execution reaches a \return instruction. 
% On the other hand \pc receives the value $\bottom^{exc}$ if an instruction is
% executed which terminates with an uncaught exception.
% The key word \result \ is a special variable that stores the value that the current method returns.  
% \todo{say more about exceptions: exception table, how the exception handler is searched in a separate section may be}
 
%The function \excIndex{ind}{ExcType} returns either the index of the exception handler that protects the instruction at index \texttt{ind} from exception 
% type  \texttt{ExcType}, or $\bottom^{exc}$ if such a handler does not exist:

% $$
% \excIndex{\mbox{ \rm ind} }{ \mbox{ \rm ExcType} } = 
%\left\{ \begin{array}{ll}
%   ind^{ExcType} & \mbox{ \rm if an exception handler for ExcType exists  } \\
%   \bottom &    \mbox{ \rm else } 
% \end{array}\right.
% $$

 We define the operational semantics of a single Java instruction in terms of
 relation between the instruction and the state configurations
 before and after its execution.

 \begin{StateTransition}[State Transition] \label{stateTrans} 
 If an instruction \bcIns in the body of method \methodd \ starts execution in a state with configuration  
 $\config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{ \pc}$ and
  terminates execution in state with configuration  $\config{ \heap'}{\counterOnly'}{\stackOnly'}{\locVarOnly'}{\pc'}$ we denote this by

  $$  {\scriptsize \methodd \vdash \bcIns : \config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{ \pc }   \stateTrans \config{ \heap'}{\counterOnly'}{\stackOnly'}{\locVarOnly'}{\pc'} } $$
 \end{StateTransition}

 We also define how the execution of a list of instructions change the state configuration in  which their execution starts.
 

 \begin{transClosStateTrans0}[Transitive closure of a method state transition relation]\label{stateTransit}
 If  the method \methodd \  starts execution in a state $\config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}$ with \methodd.\body[0] \  
 and there exists  a transitive state transition  to the state $\config{ \heap'}{\counterOnly'}{\stackOnly'}{\locVarOnly'}{\pc'}$ we denote this with:
$$\config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} \stateTrans^{*} \config{ \heap'}{\counterOnly'}{\stackOnly'}{\locVarOnly'}{\pc'}  $$ 
\end{transClosStateTrans0}

 \begin{transClosStateTrans1}[Termination  of method execution] \label{stateTransClos}
   If  the method \methodd \  starts execution in a state $\config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}$   with \methodd.\body[0] 
   and there is a transitive state transition to  $\config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{k}$ 
    such that the instruction \methodd.\body[k] is either a \return \ instruction or an 
    instruction which terminates execution with an uncaught exception and the configuration after its execution is 
    $\configFinal{ \heap'}{\locVarOnly'}{\Final}$ then   we denote this  with: 
    $$ {\scriptsize \methodd \vdash \methodd.\body: \config{ \heap}{\counterOnly}{\stackOnly}{\locVarOnly}{ \pc } \stateTransTerm \configFinal{ \heap'}{\locVarOnly'}{\Final} }$$
 \end{transClosStateTrans1}
 



 We first give the operational semantics of a method execution. The execution of method \methodd 
 is the execution of its body upto reaching a final state configuration:
 
 $$
 {\scriptsize  \frac{\begin{array}{l}
          \methodd \vdash  \methodd.\body :  
	                    \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}  \stateTrans^{*} \configFinal{\heap'}{\locVarOnly'}{\Final}\\
	\end{array}	 
       }
       {\methodd :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		    \stateTransTerm
                   \configFinal{\heap'}{\locVarOnly'} {\Final} }}$$ \\


 

   
 Next, we define the operational semantics of every instruction. The operational semantics
 of an instruction states how the execution of an instruction affects the program state configuration 
 in terms of state configuration transitions defined in the previous subsection \ref{def}.
 Note that we do not model the method frame stack of the JVM which is not needed for our purposes. 

\begin{itemize}
       \item Control transfer instructions \\\\

        \begin{enumerate}
            \item Conditional jumps : \ifCond


        $$ 
           {\scriptsize \frac{ \mbox{ \rm \texttt{ cond}}( \stackOnlyParam{\counterOnly}, \stackOnlyParam{\counterOnly - 1}) } 			       		               
                      {\method \vdash \ifCond \ n : \config{\heap }{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}
		                      \stateTrans 
				      \config{\heap}{\counterOnly - 2}{\stackOnly}{\locVarOnly}{n}} 
            }    $$
		$$ {\scriptsize
                 \frac{  not (\mbox{ \rm \texttt{ cond}}( \stackOnlyParam{\counterOnly}, \stackOnlyParam{\counterOnly - 1})) }		                             
                     {\methodd \vdash \ifCond \ n : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                    \stateTrans 
                                    \config{\heap}{\counterOnly - 2}{\stackOnly}{\locVarOnly}{\pc + 1}} }
           $$
            

	    The condition \texttt{cond} = $\{ =, \neq, \le, <, >, \ge \} $ is applied to the stack top  \stackOnlyParam{\counterOnly} and the element below the stack top
	     \stackOnlyParam{\counterOnly -1}which must be of type \Myint. If the condition is true then the control is transfered to the instruction
	    at index \texttt{n}, otherwise the control continues at the instruction following the current instruction. The top two elements \stackOnlyParam{\counterOnly} and
            \stackOnlyParam{\counterOnly - 1}  of the stack top are popped from the operand stack.
 
        \item Unconditional jumps: \goto \\
            $${\scriptsize \frac{  }
	            {\methodd \vdash \goto \ n: \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                    \stateTrans 
                                    \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{ n}} }$$
				    
   
             Transfers control to the instruction at position \textit{n}.


      \item \return
        $$ {\scriptsize \frac{ } 
            {\methodd \vdash \return :\config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                    \stateTrans 
                                    \configFinalNorm{\heap}{\locVarOnly}{\stackOnlyParam{\counterOnly}}}   }  $$

	    The instruction causes the normal termination of the execution of the current method \methodd.
	    The instruction does not affect changes on the heap \heap and the return result is contained in
	    the stack top element \stackOnlyParam{\counterOnly}
      \end{enumerate}

  \item Arithmetic operations 	
        
	   $${\scriptsize \frac{ 
	   \begin{array}{l}
	   \counterOnly' = \counterOnly - 1 \\
	   \stackOnly' = \update{\stackOnly} {\counterOnly-1}{\stackOnlyParam{\counterOnly} \ \rm{op} \ \stackOnlyParam{\counterOnly-1}} \\
	   \pc' = \pc + 1
	   \end{array}}
		   {\method \vdash  \op :\config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		          \stateTrans 
                          \config{\heap}{\counterOnly'}{\stackOnly' }{\locVarOnly}{\pc'} } } $$ 
		 
 
       Pops the values which are on the stack top \stackOnlyParam{\counterOnly}  and \stackOnlyParam{\counterOnly - 1}  at the position below and applies the arithmetic operation \texttt{op}
       on them. The stack counter is decremented and  the resulting  value on the stack top \stackOnlyParam{\counterOnly - 1} \ \rm{op} \ \stackOnlyParam{\counterOnly} is pushed on the stack
       top  \stackOnlyParam{\counterOnly - 1}. 
	\todo{case for arithmetic instructions that throw exception }

  \item Load Store instructions

      \begin{enumerate}
    
	\item \load
	$${\scriptsize \frac{ \begin{array}{l}
	                \counterOnly' = \counterOnly + 1\\
			\stackOnly' = \update{\stackOnly}{\counterOnly +  1}{ \locVarOnly(i) } \\
			\pc' = \pc + 1
	          \end{array}
	    } 
	    {\method \vdash \load \ \mbox{ \rm i}  : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		  \stateTrans 
                  \config{\heap}{\counterOnly'}{\stackOnly'}{\locVarOnly}{\pc'}  } } $$ 
            The instruction increments the stack counter  \counterOnly and pushes
	    the content of the local variable $\locVar{i}$ on the stack top \stackOnlyParam{\counterOnly + 1}
	    
        \item \store
        $$ {\scriptsize \frac{  \begin{array}{l}
	                \counterOnly' = \counterOnly- 1\\
			\locVarOnly' =	\update{\locVarOnly}{ \mbox{ \rm i} } { \stackOnlyParam{\counterOnly}} \\
			\pc' = \pc + 1
	          \end{array} }
                {\method \vdash  \store \ \mbox{ \rm i} :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		  \stateTrans 
                  \config{\heap}{\counterOnly'}{\stackOnly }{\locVarOnly' }{\pc'} } } $$ 

	     Pops the stack top element \stackOnlyParam{\counterOnly}  and stores it into local variable $\locVar{\mbox{ \rm i}}$ and  decrements the stack counter 
	     \counterOnly  
	
        \item  \instr{iinc}

                $${\scriptsize  \frac{ \begin{array}{l}	               
			\locVarOnly' =  \update{\locVarOnly}{\mbox{ \rm i} }{ \locVar{\mbox{ \rm i} } + 1}\\
			\pc' = \pc + 1
	          \end{array} } 
	        {\method \vdash \instr{iinc } \ \mbox{ \rm i}  :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		  \stateTrans 
                  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly' }{\pc'}  }  } $$ 
            Increments the value of the local variable $\locVar{i}$ 
	
	\item \push
	       $${\scriptsize \frac{\begin{array}{l}
	                \counterOnly' = \counterOnly + 1\\
			\stackOnly' = \update{\stackOnly}{\counterOnly +  1}{\mbox{ \rm i}  }\\
			\pc' = \pc + 1
	          \end{array}  } 
	        {\method \vdash \instr{push} \ \mbox{ \rm i}  :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                                  \stateTrans  
						  \config{\heap}{\counterOnly + 1}{\stackOnly' }
						  {\locVarOnly}
						  {\pc'}  } } $$
     
      \item \instr{pop} 
       $${\scriptsize \frac{ } 
	        {\method \vdash \instr{pop}   :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                                  \stateTrans  
						  \config{\heap}{\counterOnly + 1}{\stackOnly}
						  {\locVarOnly}
						  {\pc + 1}  } } $$
    \end{enumerate}


   \item Object creation and manipulation 

     \begin{enumerate}

      \item \new \texttt{Cl}
            $${\scriptsize \frac{\begin{array}{l}
			(\heap',\referenceOnly) = \newRef{\heap}{\clazz} \\ 
			\counterOnly' = \counterOnly + 1\\
			\stackOnly' = \update{\stackOnly}{\counterOnly +  1}{ \referenceOnly  } \\
			\pc' = \pc + 1
	          \end{array}}
              {\method \vdash \new \ \clazz :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		               \stateTrans  
			       \config{\heap'}
			              {\counterOnly'}
				      {\stackOnly' }
				      {\locVarOnly}
				      {\pc'}  } } $$
	      
	      A new fresh location $\referenceOnly$ is added in the memory heap \heap \ of type \\
               \clazz, the  stack counter \counterOnly is incremented.
	      The reference $\referenceOnly$ is put on the stack top \stackOnlyParam{\counterOnly + 1}. 
	


	\item \putfield  
           
	   $${\scriptsize \frac{ \begin{array}{l}
	               \stackOnlyParam{\counterOnly - 1} \neq \Mynull   \\
                       %\left\{\begin{array}{l}
		              \heap' = \update{\heap}{\fieldd }{\update{\fieldd}{\stackOnlyParam{\counterOnly - 1}}{\stackOnlyParam{\counterOnly }}} \\
			      \counterOnly' = \counterOnly - 2 \\
			      \pc' = \pc + 1
	               %\end{array}\right. \\
		      \end{array}   
		   }
                   { \methodd \vdash  \putfield \ \fieldd:  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
                                               \stateTrans  
					       \config{\heap'}{\counterOnly'}{\stackOnly}{\locVarOnly}{\pc'} } } $$   

		     
	    
           $${\scriptsize \frac{ \begin{array}{l}
	                 \stackOnlyParam{\counterOnly - 1} = \Mynull   \\
		         \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \NullPointerExc, \methodd.\excHandlerTable ) =  \configVar			                  \end{array}
                      }
		      {\methodd \vdash  \putfield \ \fieldd:  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
					          \stateTrans  
						  \configVar }} $$
						        
        The top value contained on the stack top \stackOnlyParam{\counterOnly} and the reference contained in \stackOnlyParam{\counterOnly - 1} 
	are popped from the operand stack. If \stackOnlyParam{\counterOnly - 1} is not \Mynull \footnote{here we assume that the code has passed successfully the bytecode verification procedure and thus,
	for instance, \stackOnlyParam{\counterOnly - 1} contains certainly a reference        of type \texttt{C}  } , the value of its field 
	\texttt{f} for the object  is updated 
	with the value\stackOnlyParam{\counterOnly} and the counter \counterOnly is decremented.
	If the reference in \stackOnlyParam{\counterOnly - 1} is \Mynull then a \NullPointerExc~ is thrown
          
        \item \getfield  
        	  
         $$ {\scriptsize \frac{ \begin{array}{l}
                               \stackOnlyParam{\counterOnly} \neq \Mynull \\
	                       %\left\{\begin{array}{l}             
			             \stackOnly' =  \update{\stackOnly}{\counterOnly}{ \heap(\fieldd)(\stackOnlyParam{\counterOnly} ) }\\
			             \pc' = \pc + 1
	                       %\end{array}\right.
	             \end{array}
                 }   
		 {\methodd \vdash  \getfield \ \fieldd  :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
						 \stateTrans  
						 \config{\heap}{\counterOnly}{\stackOnly'}{\locVarOnly}{\pc'}} } $$
			


        $${\scriptsize  \frac{ \begin{array}{l}
	                      \stackOnlyParam{\counterOnly} = \Mynull \\
			       \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \NullPointerExc, \methodd.\excHandlerTable ) =  \configVar                              \end{array}}
		  {\methodd \vdash  \getfield \ \fieldd  :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
						 \stateTrans  
						 \configVar} }$$
	 
	The top stack element \stackOnlyParam{\counterOnly}  is popped from the stack. If \stackOnlyParam{\counterOnly} is not \Mynull the value of the field \texttt{f}
	in the object referenced by the reference contained in \stackOnlyParam{\counterOnly}, is fetched and pushed onto the operand stack \stackOnlyParam{\counterOnly}.
        If \stackOnlyParam{\counterOnly} is \Mynull then a \texttt{NullPointerExc} is thrown, i.e. the stack counter is set to 0, a new object of type
	\texttt{NullPointerExc} is created in the memory heap store \heap and a reference to it $\Ref{NullPointerExc}$ is pushed onto the operand stack					 
			
        \item  \newarray  \ \anyType \\
	        $${\scriptsize \frac{\begin{array}{l}
		               \stackOnlyParam{\counterOnly} \geq 0  \\
			        %\left\{\begin{array}{l}
			                    (\heap',\referenceOnly ) = \newArrRef{\heap}{type}{\stackOnlyParam{\counterOnly}}\\
					    \counterOnly' = \counterOnly + 1\\
					    \stackOnly' = \update{\stackOnly}{\counterOnly +  1}{\referenceOnly } \\
					    \pc' = \pc + 1
			               % \end{array}\right.
			       \end{array}  }
                {\methodd \vdash  \newarray \ \anyType :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		               \stateTrans  
			       \config{\heap'}
			              {\counterOnly'}
				      {\stackOnly' }
				      {\locVarOnly}
				      {\pc'}  } } $$

	  
	        $${\scriptsize \frac{\begin{array}{l}
		               \stackOnlyParam{\counterOnly} < 0 \\
			       \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \NegativeArraySizeExc,\methodd.\excHandlerTable ) =  \configVar                	        \end{array}  }
                {\methodd \vdash  \newarray \ \anyType :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
			                      \stateTrans  
					      \configVar } } $$
	  
	A new array whose components are of type \anyType \ and whose length is the stack top value is allocated on the heap.
	The array elements are initialised to the default value of  \anyType \ and a reference to it is put on the stack top. 
	In case the stack top is less than 0, then \NegativeArraySizeExc is thrown 

     
        \item \arrstore


      
	 $${\scriptsize \frac{ \begin{array}{l} 
	             \stackOnlyParam{\counterOnly - 2} \neq \Mynull  \\
		     0 \leq \stackOnlyParam{\counterOnly - 1  } < \length( \stackOnlyParam{\counterOnly - 2} )   \\
                     \heap' = \update{\heap}{( \stackOnlyParam{\counterOnly - 2},\stackOnlyParam{\counterOnly - 1} ) }{ \stackOnlyParam{\counterOnly}} \\
		     \counterOnly' = \counterOnly - 3 \\
		     \pc'  =  \pc + 1
		\end{array}}
		{\methodd \vdash  \arrstore \ :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
						 \stateTrans  
						 \config{\heap'}{\counterOnly'}{\stackOnly}{\locVarOnly}{\pc'}} } $$


       $${\scriptsize \frac{ \begin{array}{l}
	                      \stackOnlyParam{\counterOnly - 2} = \Mynull \\
			      \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} , \NullPointerExc,\methodd.\excHandlerTable ) =  \configVar  \\  
		   \end{array}}
		 {\methodd \vdash  \arrstore \ :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
			                         \stateTrans  
						 \configVar } } $$ 
        $${\scriptsize \frac{ \begin{array}{l} 
                                \stackOnlyParam{\counterOnly - 2} \neq \Mynull  \\
			  	( \stackOnlyParam{\counterOnly - 1} < 0 	\vee  \\
			       \stackOnlyParam{\counterOnly - 1} \geq \length (  \stackOnlyParam{\counterOnly - 2 }  ) ) \Rightarrow \\
			        \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \ArrIndexOutOfBoundExc ,\methodd.\excHandlerTable ) =  \configVar 
		    \end{array}}
		 {\methodd \vdash  \arrstore \ :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
			                         \stateTrans  
						 \configVar } } $$ 
	%Stores a value \stackOnlyParam{\counterOnly} \ at index \stackOnlyParam{\counterOnly - 1} \ in  the array component \stackOnlyParam{\counterOnly - 2}. 
	The three top stack elements \stackOnlyParam{\counterOnly}, \stackOnlyParam{\counterOnly - 1} \  and \stackOnlyParam{\counterOnly - 2} 
	are popped from the operand stack. The type value contained in \stackOnlyParam{\counterOnly} must be assignment 
	compatible\todo{say what assignment compatible is} with the type
	of the elements of the array reference contained in \stackOnlyParam{\counterOnly - 2},  \stackOnlyParam{\counterOnly - 1} \  must be of type int. 

	The value \stackOnlyParam{\counterOnly} \ is stored in the component at index \stackOnlyParam{\counterOnly - 1} \  of the array  in  \stackOnlyParam{\counterOnly - 2}.
	If \stackOnlyParam{\counterOnly - 2} \ is \Mynull a \NullPointerExc is thrown. If \stackOnlyParam{\counterOnly - 1}  \  is not in the bounds of the array 
	in \stackOnlyParam{\counterOnly - 2}  \ an \ArrIndexOutOfBoundExc exception is thrown. If \stackOnlyParam{\counterOnly} \ is not assignment 
	compatible with the type of the components of the array, then \ArrStoreExc  is thrown 

					 						 
\todo{one more case of exceptional termination if it terminates on an exception }


	\item \arrload       
	      
	     $${\scriptsize \frac{ \begin{array}{l}  \stackOnlyParam{\counterOnly - 1} \neq \Mynull  \ \\
					 \stackOnlyParam{\counterOnly} \geq 0   \\
					 \stackOnlyParam{\counterOnly} < \length (  \stackOnlyParam{\counterOnly - 1}  )  \\
			       			       %\left\{\begin{array}{l}
			                     \counterOnly' = \counterOnly - 1\\
					     \stackOnly' = \update{\stackOnly}{\counterOnly - 1} {  \heap(\stackOnlyParam{ \counterOnly -1 }{\stackOnlyParam{ \counterOnly} } ) } \\
					     \pc'  =  \pc + 1
			        %      \end{array} \right.
			 \end{array}}
			  {\methodd \vdash  \arrload \ :       \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
						 \stateTrans  
						 \config{\heap}{\counterOnly'}{\stackOnly'}{\locVarOnly}{\pc'}} } $$
						 

	  $${\scriptsize \frac{ \begin{array}{l}
	                      \stackOnlyParam{\counterOnly - 1} = \Mynull   \\
			      \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} , \NullPointerExc,\methodd.\excHandlerTable ) =  \configVar  \\  
		 \end{array}}
		 {\methodd \vdash  \arrload \ :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
			                         \stateTrans  
						 \configVar } } $$

                $$  {\scriptsize \frac{ \begin{array}{l}   
			      \stackOnlyParam{\counterOnly - 1} \neq \Mynull  \\
			      ( \stackOnlyParam{\counterOnly} < 0 	\vee  \\
			       \stackOnlyParam{\counterOnly} \geq \length (  \stackOnlyParam{\counterOnly - 1}  ) )   \\
			        \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \ArrIndexOutOfBoundExc ,\methodd.\excHandlerTable ) =  \configVar  
		    \end{array}}
		 {\methodd \vdash  \arrload \ :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
			                         \stateTrans  
						 \configVar } } $$					 						 
			
	       
	 

               Loads a value from an array. The top stack element \stackOnlyParam{\counterOnly} and the element below it \stackOnlyParam{\counterOnly -1 }
	       are popped from the operand stack.  \stackOnlyParam{\counterOnly} must be of type \Myint. The value in \stackOnlyParam{\counterOnly -1 } must be 
               of type \reff \ whose components are of type \textrm{type}. The value in the component of the array  \texttt{arrRef} 
	       at index \texttt{ind} is retrieved and pushed onto the operand stack.
	       If \stackOnlyParam{\counterOnly -1 } contains the value \Mynull a \NullPointerExc is thrown. If \stackOnlyParam{\counterOnly}  is
	       not in the bounds of the array object referenced by \stackOnlyParam{\counterOnly -1 }  a \ArrIndexOutOfBoundExc is thrown


    \item \arraylength
          $${\scriptsize \frac{ \begin{array}{l}
			   \stackOnlyParam{ \counterOnly } \neq \Mynull  \\
			    %\left\{\begin{array}{l}
			          \heap' = \heap \\ 
				  \counterOnly'= \counterOnly \\
				  \stackOnly'= \update{\stackOnly}{\counterOnly}{ \heap(\length)( {\stackOnlyParam{\counterOnly} } )  } \\ 
				  \pc' = \pc+ 1
                          % \end{array}\right.      
		    \end{array}
	        }
	        {\methodd \vdash \arraylength :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                  \stateTrans  
				  \config{\heap'}{\counterOnly'}{\stackOnly'}{\locVarOnly}{\pc'} } } $$
		     
	 

	  $$ {\scriptsize	 \frac{ \begin{array}{l}
			       \stackOnlyParam{ \counterOnly } = \Mynull    \\
			        \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \NullPointerExc ,\methodd.\excHandlerTable ) =  \configVar  
			\end{array}
		      }
		      {\methodd \vdash \arraylength : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                                      \stateTrans  
						      \configVar} } $$
	The stack top element is popped from the stack. It must be a 
	reference that points to an array. If the stack top element \stackOnlyParam{\counterOnly} is not \Mynull  the length of the array  
	\length{\stackOnlyParam{\counterOnly} } is fetched and pushed on the stack.
	If the stack top element \stackOnlyParam{\counterOnly} is \Mynull then a \NullPointerExc is thrown.


	\item \instanceof
	      $${\scriptsize \frac{ \begin{array}{l}
                            \subtype{\heap.\heapTypeOf(\stackOnlyParam{\counterOnly})}{\clazz}  \\	
		           % \begin{array}{l}    
			          \stackOnly' = \update{\stackOnly}{\counterOnly}{1}   \\
                 		  \pc' =  \pc +1 
		           % \end{array}
			\end{array} 
	              }
                      {\instanceof  \ \clazz : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                                   \stateTrans  
						   \config{\heap}{\counterOnly}{\stackOnly'}{\locVarOnly}{\pc'}} } $$
              
	      $$
	{\scriptsize	\frac{ \begin{array}{l}
                             not( \subtype{ \heap.\heapTypeOf( \stackOnlyParam{\counterOnly} ) }{\clazz}) \vee \stackOnlyParam{\counterOnly} = \Mynull  \\
			       %   \begin{array}{l}
			                \stackOnly' = \update{\stackOnly}{\counterOnly}{0}   \\
					\pc' =  \pc +1 
			  %    \end{array}
		        \end{array} }
		     {\methodd \vdash \instanceof  \ \tt{C} : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                                   \stateTrans  
						   \config{\heap}{\counterOnly}{\stackOnly'}{\locVarOnly}{\pc'}}}  $$
		
	      
	      The stack top is popped from the stack. If it is of subtype \clazz or
	      is \Mynull, then the   \texttt{1} is pushed on the stack, otherwise \texttt{0}. 
         
       	\item \checkcast
          $${\scriptsize \frac{\begin{array}{l}
		               \subtype{\heap.\heapTypeOf( \stackOnlyParam{\counterOnly})}{\clazz }   \vee \stackOnlyParam{\counterOnly} = \Mynull  \\
			      \pc' =  \pc  +1 
		 \end{array}}
		  {\methodd \vdash \checkcast \ \clazz :     \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                             \stateTrans  
					     \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc'}} }
	  $$	      
	  $${\scriptsize \frac{\begin{array}{l}	
			       not(\subtype{\heap.\heapTypeOf(  \stackOnlyParam{\counterOnly} ) }{\clazz} )  \\
			       \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \ClassCastExc,\methodd.\excHandlerTable ) =  \configVar                                              \end{array}}
		  {\methodd \vdash \checkcast \ \clazz :     \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                             \stateTrans  
					     \configVar} }  $$



	   The stack top is popped from the stack. If it is not of subtype \clazz \ an exception of type \ClassCastExc is thrown.

	 
   \end{enumerate}

   \item Throw exception instruction. \athrow
            $${\scriptsize \frac{ \begin{array}{l}	 
		             \stackOnlyParam{\counterOnly} \neq \Mynull   \\
			     \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc},typeof( \stackOnlyParam{\counterOnly} )  ,\methodd.\excHandlerTable ) =  \configVar
		    \end{array}	     
	      }
              {\methodd \vdash \athrow :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                         \stateTrans  
					 \configVar} } $$

	     $${\scriptsize \frac{ \begin{array}{l}	 
	                     \stackOnlyParam{\counterOnly}  = \Mynull   \\
			     \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \NullPointerExc  ,\methodd.\excHandlerTable ) =  \configVar
      		    \end{array}	     
	      }
              {\methodd \vdash \athrow :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                         \stateTrans  
					  \configVar} } $$ 				 

           The stack top element  must be a reference of an object of type \\ \Throwable. 
	  If there is a handler that protects this bytecode instruction from the exception thrown, the control is transfered
	  to the instruction at which the exception handler starts\footnote{for every method the ExceptionHandler
	  table describes the corresponding exception handler by the limits of the 
	  region it protects, the Exception that it catches, and the instruction at which it starts}.
	  If the object on the stack top is \Mynull, a \NullPointerExc \ is thrown. 

 \item Method Invokation. \invoke \footnote{ only the case when  the invoked method returns a value}
      
         $$ {\scriptsize \frac{\begin{array}{l} \stackOnlyParam{ \counterOnly - meth.\numArgs } \neq \Mynull   \\
	                         meth : %\begin{array}{l} 
			                        \config{\heap}       
                                                       {0}
						       {\newStack }
                                                       {\lbrack \stackOnlyParam{ \counterOnly - meth.\numArgs },\ldots ,\stackOnlyParam{ \counterOnly} \rbrack }
						       {0} 
						         \stateTransTerm 
							 \configFinalNorm{\heap'}{\locVarOnly'}{\Res}\\
				                %\end{array}  
                                                   \\
						   \counterOnly' = \counterOnly - \methodd.\numArgs + 1 \\
						   \stackOnly' = \update{\stackOnly}{\counterOnly'}{\Res} \\
						   \pc' = \pc + 1
			         \end{array} 	      
	         }	         
	         {\methodd \vdash \invoke \  meth :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                        \stateTrans  
					\config{\heap' }{\counterOnly'}{\stackOnly' }{\locVarOnly}{\pc'}} } $$
	  
	  $${\scriptsize \frac{\begin{array}{l}
	                        \stackOnlyParam{ \counterOnly - meth.\numArgs } \neq \Mynull   \\
	                         meth: %\begin{array}{l} 
			                        \config{\heap}       
                                                       {0}
						       {\newStack }
                                                       {\lbrack \stackOnlyParam{ \counterOnly - meth.\numArgs },\ldots ,\stackOnlyParam{ \counterOnly} \rbrack }
						       {0} 
						         \stateTransTerm 
						       \configFinalExc{\heap'}{\locVarOnly'}{\Exc}\\
				           %\end{array} \\
					   \Rightarrow \\
					  \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, typeof(\Exc)  ,\methodd.\excHandlerTable ) =  \configVar
	         \end{array} 	      
	         }	         
	         {\methodd \vdash \invoke \  meth :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                        \stateTrans  
					\configVar} } $$


	  $${\scriptsize \frac{\begin{array}{l}
	                         \stackOnlyParam{ \counterOnly - meth.\numArgs } = \Mynull   \\ 
				 \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc},\NullPointerExc,\methodd.\excHandlerTable ) =  \configVar
	         \end{array} 	      
	         }	         
	         {\methodd \vdash \invoke \  meth :  \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
		                        \stateTrans  
					\configVar} } $$					
	  

	 The first top $meth.\numArgs$ \ elements in the operand stack \stackOnly \ are popped from the operand stack. If 
         \stackOnlyParam{ \counterOnly - meth.\numArgs } is not \Mynull, the invoked method is executed on the object   \stackOnlyParam{ \counterOnly - meth.\numArgs } 
	 and where the first \numArgs + 1 elements of the list of its of local variables is initialised with \\
         \stackOnlyParam{ \counterOnly - meth.\numArgs } \ldots \stackOnlyParam{\counterOnly}. In case that the execution of method $meth$
	 terminates normally, the return value \Res \  of its execution is stored on the operand stack of the invoker. 
	 If the execution of of method $meth$ terminates because of an exception \Exc, then the exception handler of the invoker is searched for
	 a handler that can handle the exception. In case the object  \stackOnlyParam{ \counterOnly - meth.\numArgs } \  on which the  method $meth$ must be 
	 called is \Mynull, a \NullPointerExc is thrown.  			




% \item Subroutines
%    \begin{enumerate}
%          \item \jsr
% 	         $$\frac{ \begin{array}{l}
% 		                 \pc' =  \pc  + \it{ind} \\
% 				 pushJsr(\pc + 1)
%                            \end{array}  
% 		        } 
% 		     {\jsr \ \it{ind} : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
% 		                        \stateTrans  
% 					\config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc'}}$$
% 	 \item  \ret
% 	        $$\frac{  \pc' =  getJsr() 
% 		          } 
% 			  {\ret : \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} 
% 		                        \stateTrans  
% 					\config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc'}}$$
%    \end{enumerate}

\end{itemize}


