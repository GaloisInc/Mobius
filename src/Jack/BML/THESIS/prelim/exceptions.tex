\section{Throwing and handling exceptions}\label{opSem:exc}

As the JVM specification states \textit{exception are thrown if a program violates the semantic constraints of the Java programming language,
 the Java virtual machine signals this error to the program as an exception. An example of such a violation is an 
attempt to index outside the bounds of an array. The Java programming language specifies that an exception will be thrown when
 semantic constraints are violated and will cause a nonlocal transfer of control from the point where the exception occurred to
 a point that can be specified by the programmer. An exception is said to be thrown from the point where it occurred and is said to be
 caught at the point to which control is transferred. A method invocation that completes because an exception causes transfer of
 control to a point outside the method is said to complete abruptly. Programs can also throw exceptions explicitly, using throw statements \ldots }

Our language supports an exception handling mechanism similar to the JVM one.
 More particularly, it supports  Runtime exceptions: 
 \begin{itemize}
   \item \NullPointerExc \ thrown if a null pointer is dereferenced
   \item \NegativeArraySizeExc \ thrown if an array is accessed out of its bounds
   \item \ArrIndexOutOfBoundExc \ thrown if an array is accessed out of its bounds
   \item \ArithExc \ thrown if a division by zero is done
   \item \ClassCastExc \ thrown if an object reference is cast to to an incompatible type
   \item \ArrStoreExc \ thrown if an object is tried to be stored in an array and the object is of incompatible type with type of the  array elements
\end{itemize}

The language also supports programming exceptions. Those exceptions are forced by the programmer, by a special bytecode 
intruction as we shall see later in the coming section. 

 The modelization of the exception handling mechanism involves several auxiliary functions. 
 The function \getStateAfterExc \ deals with bytecode instructions that may throw runtime exceptions.
 This function applies only to instructions which are not a method invokation neither the special instruction
 by which the program can throw explicitely an exception.
 The function returns the state  configuration after the current instruction during the execution of \methodd \ throws a runtime exception
 of type $\mbox{\rm\texttt{E}}$. If the  method \methodd \ has an  exception handler which can handle  exceptions of type
 $\mbox{\rm\texttt{E}}$ thrown at the index of the current  instruction,
 the execution will proceed and thus, the state is an intermediate state configuration.
 If the method \methodd \ does not have an exception handler for dealing with exceptions of type $\mbox{\rm\texttt{E}}$ 
 at the current index, the execution of \methodd \ terminates exceptionally and the current instruction
 causes the method exceptional termination. Note also that the heap is changed as a new instance of the corresponding exceptional 
 type is created:

 
 $$\begin{array}{l}
          \getStateAfterExc : \SetConfigInterm * \excType * \ExcHandler[] \rightarrow \SetConfigInterm \cup \SetConfigFinalExc  \\
	  \\
	  \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, \mbox{\rm\texttt{E}},  \excHH[] ) = \\
          \left\{\begin{array}{ll}
	        \config{\heap'}{0}{\update{\stackOnly}{0}{\referenceOnly}}{\locVarOnly}{\pcHandler} & \begin{array}{l}  
                                                                                                           \mbox{\rm if \ \findExcHandler{\mbox{\rm\texttt{E}}}{\pc}{\excHH[]}} \\
													   =\pcHandler 
												      \end{array}	   
													   \\
		& \\
		\configFinalExc{\heap'}{\referenceOnly} & \begin{array}{l}     
		                                                             \mbox{\rm  if \ \findExcHandler{\mbox{\rm\texttt{E}}}{\pc}{\excHH[]} } \\
		                                                             = \bottom  
		                                                        \end{array}
	  \end{array}\right.\\
	  \\
        \mbox{\rm where }\\
	(\heap', \referenceOnly )= \newRef{\heap}{\mbox{\rm\texttt{E}}}
    \end{array}
 $$
 




 If an exception $\mbox{\rm\texttt{E}}$ is thrown by instruction at position $i$ while executing the method \methodd,
 the exception handler table  \methodd.\excHandlerTable \ will be searched for the first exception handler that can handle the exception. 
 The search is done by the function \findExcHandlerOnly. If there is found
 such a handler the function returns the index of the instruction at which the exception handler starts, otherwise it returns $\bottom$:
 $$ \begin{array}{l}
        \findExcHandlerOnly : \excType * nat * \ExcHandler[] \rightarrow nat \\
	\\
	\findExcHandler{ \mbox{ \rm \texttt{E}} }{\pc}{\excHH[]} = \\
	 \left\{\begin{array}{ll}
	     \excHH[m].\pcHandler & \begin{array}{l}
	          		         if  \  hExc \neq emptySet \\
					 where \  m = min( hExc ) 
			            \end{array}	 \\
			   & \\
	     \bottom &  else %hExc = emptySet
	 \end{array}\right. \\
\\ 
 \rm{where } \\  
  hExc = \{ k  \mid  \begin{array}{l} 
                        \excHH[k] = (\pcStart,\pcEnd,\pcHandler, \mbox{\rm\texttt{E}}' ) \wedge  \\
                        \pcStart \leq \pc < \pcEnd \wedge \\
			 \subtype{\mbox{\rm\texttt{E}}}{\mbox{\rm\texttt{E}}'} 
                    \end{array} \}
   \end{array}	  
 $$
