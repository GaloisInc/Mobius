\section{Throwing and handling exceptions}

As the JVM specification states \textit{exception are thrown if a program violates the semantic constraints of the Java programming language,
 the Java virtual machine signals this error to the program as an exception. An example of such a violation is an 
attempt to index outside the bounds of an array. The Java programming language specifies that an exception will be thrown when
 semantic constraints are violated and will cause a nonlocal transfer of control from the point where the exception occurred to
 a point that can be specified by the programmer. An exception is said to be thrown from the point where it occurred and is said to be
 caught at the point to which control is transferred. A method invocation that completes because an exception causes transfer of
 control to a point outside the method is said to complete abruptly. Programs can also throw exceptions explicitly, using throw statements \ldots }

Our language supports also an exception handling mechanism similar to the JVM one.
 More particularly, it supports Runtime exceptions: 
 \begin{itemize}
   \item \NullPointerExc \ thrown if a null pointer is dereferenced
   \item \NegativeArraySizeExc \ thrown if an array is accessed out of its bounds
   \item \ArrIndexOutOfBoundExc \ thrown if an array is accessed out of its bounds
   \item \ArithExc \ thrown if a division by zero is done
   \item \ClassCastExc \ thrown if an object reference is cast to to an incompatible type
   \item \ArrStoreExc \ thrown if an object is tried to be stored in an array and the object is of incompatible type with type of the  array elements
\end{itemize}

The language also supports programming exceptions. Those exceptions are forced by the programmer, by a special intruction.

We have several functions which model the exception handling mechanism. 
 The function \getStateAfterExc \ deals with bytecode instructions that may throw exceptions. The function returns the state 
 configuration after the current instruction during the execution of \methodd \ throws an exception of type $E$. If the  method
 \methodd \ has an  exception handler which can handle  exceptions of type $E$ thrown at the index of the current  instruction,
 the execution is not stuck and thus, the state configuration is an intermediate state configuration.
 If the method \methodd \ does not have an exception handler for dealing with exceptions of type $E$ 
 at the current index, the execution of \methodd \ terminates exceptionally and the current instruction
 causes the method exceptional termination:

 
 $$\begin{array}{l}
          \getStateAfterExc : \SetConfigInterm * \excType * \ExcHandler[] \rightarrow \SetConfigInterm \cup \SetConfigFinalExc  \\
	  \\
	  \getStateAfterExc( \config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc}, E, \pc, \excHH[] ) = \\
          \left\{\begin{array}{ll}
	        \config{\heap'}{0}{\update{\stackOnly}{0}{\referenceOnly}}{\locVarOnly}{\pcHandler} & \begin{array}{l}  
                                                                                                           \mbox{\rm if \ \findExcHandler{E}{\pc}{\excHH[]}} \\
													   =\pcHandler 
												      \end{array}	   
													   \\
		& \\
		\configFinalExc{\heap'}{\locVarOnly}{\referenceOnly} & \begin{array}{l}     
		                                                             \mbox{\rm  if \ \findExcHandler{E}{\pc}{\excHH[]} } \\
		                                                             = \bottom  
		                                                        \end{array}
	  \end{array}\right.\\
	  \\
        \mbox{\rm where }\\
	(\heap', \referenceOnly )= \newRef{\heap}{E}
    \end{array}
 $$

 If an exception $E$ is thrown by instruction at position $i$ while executing the method \methodd,
 the exception handler table  \methodd.\excHandlerTable \ will be searched for the first exception handler that can handle the exception. 
 The search is done by the function \findExcHandlerOnly. If there is found
 such a handler the function returns the index of the instruction at which the exception handler starts, otherwise it returns $\bottom$:
 $$ \begin{array}{l}
        \findExcHandlerOnly : \excType * nat * \ExcHandler[] \rightarrow nat \\
	\\
	\findExcHandler{ \mbox{ \rm \texttt{E}} }{\pc}{\excHH[]} = \\
	 \left\{\begin{array}{ll}
	     \excHH[m].\pcHandler & \begin{array}{l}
	          		          hExc \neq emptySet \Rightarrow
					  min( hExc ) = m
			            \end{array}	 \\
			   & \\
	     \bottom &  hExc = emptySet
	 \end{array}\right. \\
\\ 
 \rm{where } \\  
  hExc = \{ k  \mid  \begin{array}{l} 
                        \excHH[k] = (\pcStart,\pcEnd,\pcHandler, E' ) \wedge  \\
                        \pcStart \leq \pc < \pcEnd \wedge \\
			 \subtype{E}{E'} 
                    \end{array} \}
   \end{array}	  
 $$
