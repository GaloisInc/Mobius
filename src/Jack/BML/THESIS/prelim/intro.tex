

In this chapter, we  shall turn our attention to a bytecode language and  
  and its operational semantics. The bytecode  language will be used all along the thesis and more particularly
  later in Chapter \ref{wpGeneral} for the definition of the verification condition generator.
 We define the operational semantics of  the bytecode language   as a relation between the initial and final states of 
 instruction execution.
 The operational semantics will be used 
 for establishing  the soundness of the verification procedure.
 As our verification procedure is tailored to Java bytecode 
 the bytecode language introduced hereafter is close to the 
 Java Virtual Machine  language \cite{VMSpec}(JVM for short). 
 
% supported features
In particular, \textbf{the features supported} by our bytecode language are 
\begin{description} 
   \item  [arithmetic operations] like multiplication, division, addition and subtraction. 

   \item  [stack manipulation] Similarly to the JVM  our abstract machine is stack based, i.e. instructions
          get their arguments from the operand stack and push their result on the  operand stack.

   \item  [method invocation] In the following, we consider only  non void methods. 
          We restrict our modeling for the sake of simplicity without losing any specific feature of the Java language.
          
   \item  [object manipulation and creation] 
          Java supports all the facilities for object creation and manipulation.
	  This is an important aspect of the Java language as it is completely object oriented.
	  Thus, we support field access and update as well as object creation. Note that we also 
	  support arrays with the corresponding facilities for creation, access and update. 

   \item  [exception throwing and handling] Our bytecode language supports runtime and programmatic exceptions as the JVM does.
	  An example for a situation where a runtime exception is thrown is a null object dereference.  Programmatic exceptions
	  are forced by the programmer with a special instruction in the program text.
   
   \item  [classes and class inheritance] Like in the JVM language, our bytecode language supports  a tree class hierarchy in which every class 
          has a super class except the class \texttt{Object} which is the root of the class hierarchy.

   \item  [integer type] The unique basic type which is supported is the integer type.
          This is not so unrealistic as the JVM
	  treats the other integral types e.g. byte and short like the integer type. 
	  JVM actually supports only few instructions 
          for dealing in a special way with the array of byte and short.
	  
\end{description} 
 

% what is not supported?
 Our bytecode language omits some of the features of Java. Let us see which ones exactly and why.

\textbf{The features not supported} by our bytecode language are 
\begin{description} 
   \item[void methods]  Note that the current formalization can be extended to void methods without major difficulties.
         However, in our implementation 
         we treat void methods.

   \item [static fields and methods] Static data is shared between all the instances of the class
         where it is declared.  We can extend our formalization to deal with static fields and methods,
	 however it would have made the presentation heavier without gaining new feature from the JVM bytecode language. 
	 Once again, static methods are supported in the implementation of the verification condition generator.

   \item [static initialization] This part of the JVM is discarded as its formal understanding is difficult and complex.
         Static initialization is a good candidate for a future work. 

   \item [subroutines] Subroutines in Java is a piece of code inside a method which must be executed 
         after another, no matter how the first terminate execution. 
	 They correspond to the construction \texttt{try\{ \} finally \{ \} } in the Java language.
	 Subroutines are a controversy point 
	 in the JVM because on one hand they complicate a lot the bytecode verification algorithm in Java and second,
	 slow the JVM execution because of the way they are implemented. While the standard compilation of  \texttt{try\{ \} finally \{ \} }
	 is with special instructions, the most recent Java compilers inline the subroutine 
	 code which results more efficient for the bytecode verifier as well as for the code execution. 
	 In the implementation of our verification calculus we also inline subroutines and in this way we omit the special bytecode constructs
	 for subroutines in our bytecode language. 
	
  
  \item [errors] The exception mechanism in Java is provided with two kind of exceptions: exceptions from which 
        a reasonable application may recover. i.e. handle the exception and exceptions which cannot be recovered. This last group
	of exceptions in Java are called JVM errors. JVM errors are  thrown typically when the proper functioning of the JVM cannot 
	continue. 
	The cause might be an error  on loading, linking, initialization time of a class or on execution time because of deficiency in the JVM resource, e.g.
	stack, memory overflow.
	For instance, during the resolution of a field name may terminate on \texttt{NoSuchFieldError} if 
	such a field is not found. Another example is the \texttt{MemoryOverflowError} thrown when no more memory is available.
	Note that such errors is not always clear how to express in our program logic presented later in the thesis. This is because, 
	the logic is more related with the functional properties of the program while the JVM errors are related more to the physical
	state of the JVM. Thus, we omit here this aspect of the JVM.
	 

   \item [interface types] These are reference types whose methods are not implemented and whose variables are constants.
         Such interface types are then implemented by classes and allow that a class get more than one behavior.
	 A class may implement several interfaces. 
	 The class must give an implementation for every method declared in any interface that it implements.
	 If a class implements an interface then every object which has as type the class is also of the interface type.
	 Interfaces  are the cause of  problems in the bytecode verifier as the type hierarchy is no more a lattice in the 
	 presence of interface types and thus,
	 the least common super type of two types is not unique.
	 However, in the current thesis we do not deal with bytecode verification but 
	 we will be interested in the program functional behavior. For instance, if a method overrides a method
	 from the super class or implements a method from an interface, our objective will be to establish that the method
	 respects the specification of the method it overrides or implements. In this sense, super classes or interfaces
	 are treated similarly in our verification tool.
  
	 Moreover, considering interfaces would have complicated the current formalization 
	 without gaining more new features of Java. 
	 For instance, in the presence of interfaces, we should have extended 
	 the subtyping relation. 

   \item [arithmetic overflow] The arithmetic in Java is  bounded. This means that if the result of an 
         arithmetic operation exceeds (is below) the largest integer (the smallest)  the operation will
	 result in overflow. The arithmetic proposed here is infinite. We could have designed the arithmetic
	 operations such that they take into account the arithmetic overflow. 
	 However, we consider that for the purposes of the present thesis this is not necessary and will 
	 complicate the presentation without bringing any particular feature of the bytecode. 
	 

   \item [64 bit arithmetic]  We do not consider  
	  long values as their treatment is similar to the integer arithmetic.
	  However, it is true that the formalization and manipulation of the long type can be more complicated as
	  long values are stored in two adjacent registers but it is feasible to extend the current formalization 
	  to deal with long values.

   \item [floating point arithmetic] We omit this data in our bytecode language for the following reasons.
	 There is no support for floating point data by automated tools.  
	 For instance, the automatic theorem prover Simplify which interfaces our verification tool
	 lacks support for floating point data, see  \cite{ESC2000LNS}. 
	 Although larger and more complicated than integral data, formalization of floating point arithmetic is possible. 
	 For example, the specification of IEEE  \cite{DRT03GLF} for floating point
	 arithmetic as well as a proof for its consistency  is done in the interactive
	 theorem prover Coq. 
	 However, including floating point data would not
	 bring any interesting part of Java but would rather turn more complicated
	 and less understandable the formalizations in the current document.
	  
         
 \end{description}

 Now that we have seen the general outlines of our language,
 in the rest of this chapter we shall proceed with a more detailed description.

 %our operational semantics 
 % In what follows, we give a big step operational semantics of the bytecode language whose major difference with most of the formalizations
 % of the JVM is that it abstracts from the method frame stack.  However, this semantics
 % is sufficient for our purposes which are to prove the correctness of our verification calculus.  


  
 The rest of this chapter is organized as follows:
 subsection \ref{notation} gives some particular notations that will be used from now on along the thesis,
 subsection \ref{clazz} introduces the structures classes, fields and methods  used in the virtual machine, 
 subsection \ref{types} gives the type system which is supported by the bytecode language,
 subsection \ref{def} introduces the notion of state configuration,
 subsection \ref{heap} gives the modeling of the memory heap,
 subsection \ref{opSem:JVM} is a discussion about our choice for operational semantics,
 subsection \ref{opSem} gives the operational semantics of our language 
 and finally we conclude with subsection \ref{relWork}  which is an overview of existing formalizations of the JVM semantics.
.

