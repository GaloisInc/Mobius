
 The purpose of this chaprter is to introduce the fundamental concepts of the
 present thesis. In particular, we present a bytecode language 
 and its operational semantics. Those concepts will be used later in Chapter \ref{wpGeneral}
 for the definition of the verification
 procedure as well as for establishing 
 its correctnes w.r.t. the operational semantics
 given in this section. As our verification procedure is tailored to Java bytecode 
 the bytecode language introduced hereafter is close to the Java Virtual Machine 
 language \cite{VMSpec}(JVM for short). However, it abstracts from some of the JVM language
 features while supporting others. Thus, we concentrate on the 
the most important features of the JVM. In the following, we look closer at what are the characteristic of our bytecode language. 

% supported features
\textbf{The features supported} by our bytecode language are 
\begin{itemize} 
   \item  arithmetic operations like multiplication, division, addition and substruction. 

   \item  stack manipulation. Similarly to the JVM  our abstract machine is stack based, i.e. instructions
          get their arguments from the operand stack and push their result on the  operand stack.

   \item  method invokation. In the following, we consider only  non void methods. 
          We restrict our modelization for the sake of simplicity without losing any specific feature of the Java language.
         
   \item  object manipulation and creation. We support field access and update as well as object creation. 

   \item  exception throwing and handling. Our bytecode language supports runtime and programmatic exceptions as the JVM does.
	  An example for a situation where a runtime exception is thrown is a null object dereference.  
   
   \item  classes and class inheritance. Like in the JVM language, our bytecode language supports  a tree class hierarchy in which every class 
          has a super class except the class \texttt{Object} which is the root of the class hieararchy.

   \item  the unique basic type which is supported is the integer type.
          This is not so unrealistic as the JVM supports only few instructions 
          for dealing with the other integral types, like byte and short. However, it is true that
	  the formalization of the long type and manipulation of long values can be more complicated because
	  of the fact that long values are stored in two adjacent registers. For our purposes, we do not consider  that 
	  long values represent an interesting case and we discard them.
	  
\end{itemize} 
 
% what is not supported?


 Our bytecode language omits some of the features of Java, in order to concentrate on the features listed above.

\textbf{The features not supported} by our bytecode language are 
\begin{itemize} 
   \item void methods. Note that the current formalization can be extended to void methods without major difficulties.

   \item static fields and methods. Static data is shared between all the instances of the class
         where it is declared.  We can extend our formalization to deal with static fields and methods,
	 however it would have made the presentation heavier without gaining new feature from the JVM bytecode language  

   \item static initialization. This part of the JVM is discarded as its formal understanding is difficult and complex.
         Static initialization is a good candidate for a future work \todo{J. Kiniry}

   \item subroutines. The basic reason that our bytecode language does not support subroutines is that 
         in the implementation of our bytecode verification condition generator we inline them and thus, there is no need
	 of supporting them on bytecode level.

   \item interface types. These are reference types whose methods are not implemented and whose variables are constants.
         Such interface types are then implemented by classes and allow that a class get more than one behavior.
	 A class may implement several interfaces. 
	 The class must give an implementation for every method declared in any interface that it implements.
	 If a class implements an interface then every object which has as type the class is also of the interface type.
	 Interfaces  are the cause of  problems in the bytecode verifier as the type hierarchy is no more a lattice in the 
	 presence of interface types and thus,
	 the least common super type of two types is not unique.
	 However, in the current thesis we do not deal with bytecode verification but 
	 we will be interested in the program functional behaviour. For instance, if a method overrides a method
	 from the super class or implements a method from an interface, our objective will be to establish that the method
	 respects the specification of the method it overrides or implements. In this sense, super classes or interfaces
	 are treated similarly in our verification tool.
  
	 Moreover, considering interfaces would have complicated the current formalization 
	 without gaining more new features of Java. 
	 For instance, in the presence of interfaces, we should have extended 
	 the subtyping relation. 


   \item floating point arithmetic. We omit this data in our bytecode language for the following reasons.
	 There is no support for floating point data by automated tools.  
	 For instance, the automatic theorem prover Simplify which interfaces our verification tool
	 lacks support for floating point data, see  \cite{ESC2000LNS}. 
	 Although larger and more complicated than integral data, formalization of floating point arithmetic is possible. 
	 For example, the specification of IEEE \todo{reference} for floating point
	 arithmetic as well as a proof for its consistency  is done in the interactive
	 theorem prover Coq. 
	 However, including floating point data would not
	 bring any interesting part of Java but would rather turn more complicated
	 and less understandable the formalizations in this thesis.
	  
	  
	 
	 
   
         
 \end{itemize}

 

 %our operational semantics 
 In what follows, we give a big step operational semantics of the bytecode language whose major difference with most of the formalizations
 of the JVM is that it abstracts from the method frame stack. This is different from most of the existing formalization of the JVM (or JVM like languages),
 which use usually a small step semantics. However, this semantics
 is sufficient for our purposes which are to prove the correctness of our verification calculus.  


  
 The rest of this chapter is organized as follows:
 subsection \ref{opSem:JVM} is a discussion about our choice for operational semantics,
 subsection \ref{relWork} is an overview of existing formalisations of the JVM semantics,
 subsection \ref{notation} gives some particular notations that will be used from now on along the thesis,
 subsection \ref{clazz} introduces the structures classes, fields and methods  used in the virtual machine, 
 subsection \ref{types} gives the type system which is supported by the bytecode language,
 subsection \ref{def} introduces the notion of state configuration,
 subsection \ref{heap} gives the modelisation of the memory heap,
 subsection \ref{opSem} gives the operational semantics of our language.

