
%\newtheorem{StateSubst}[StateTransition]{State after assignment}
\newtheorem{StateProp0}{Substitution Property for Expressions}
\newtheorem{StateProp1}[StateProp0]{Substitution Property for Formulas} % lemme
\newtheorem{UpdateStateSem}[StateProp0]{Definition}
%\newtheorem{FieldAtState}[StateTransition]{Interpretation of field functions in a state}
%\newtheorem{StateSatisfiesProp}[StateTransition]{Predicate holds in a state}


\newtheorem{AtState}{Definition}


\newtheorem{FormulaInterp}[AtState]{Definition}
\newtheorem{StateProp2}[AtState]{Substitution Property for Field Functions } %lemme


\section{State configuration}\label{def}
 In this section, we introduce the notion of program state.
 A state configuration \SetConfigs models the program state in particular execution
 program point by specifying what is the memory heap in the state, the stack and the stack counter, the values of the
 local variables of the currently executed method  and what is the instruction which is executed next. Note that, as we stated before our 
 semantics ignores the method call stack and so, state configurations also omit the call frames stack. 
 
 We define two kinds of state configurations:
 $$\SetConfigs = \SetConfigInterm \cup \SetConfigFinal$$
 The set $\SetConfigInterm$ consists of method intermediate state configurations, which stand for an 
 \textit{intermediate state} in which the execution of the current method is not finished i.e.
 there is still another instruction of the method body to be executed.  
 The configuration $\config{\heap}{\counterOnly}{\stackOnly}{\locVarOnly}{\pc} \in \SetConfigInterm$ has the following elements:
               \begin{itemize}
                     \item the function \heap : \HeapSet \ which stands for the heap in the state configuration
	   
	             \item \counterOnly is a variable that contains a natural number which stands for the number of
		     elements in the operand stack.  

		     \item \stackOnly is a partial function from natural numbers to values  which  stands for 
		     the operand stack.

	             \item \locVarOnly \ is a partial function from natural numbers to values which stands for
		     the array of local variables of a method.
		     Thus,  for an index \texttt{i} it returns the value $\locVar{i}$ which is stored at that 
		     index of the array of local variables
	
	            \item \pc \ stands for the program counter and contains the index of the instruction to be executed in the current state
	        \end{itemize}


 The elements of the set $\SetConfigFinal$ are the final states, states in which the current method execution is terminated and consists of 
 normal termination states ($\SetConfigFinalNorm$) and exceptional termination states ($\SetConfigFinalExc$):
 $$\SetConfigFinal =  \SetConfigFinalNorm   \cup \SetConfigFinalExc $$ 
 
 A method may terminate either normally (by reaching a return instruction) or exceptionally (by throwing an exception).
 
 \begin{itemize}
        \item  $\configFinalNorm{\heap}{\Res} \in \SetConfigFinalNorm $ which describes a \textit{normal final state}, i.e.
	       the method execution terminates normally. The normal termination configuration has the following components :
               \begin{itemize}
                      \item the function \heap : \HeapSet \ which reflects what is the heap state after the method terminated
		      
		      \item \Res \ stands for the return value  of the method
	       \end{itemize}

	\item  $\configFinalExc{\heap}{\Exc} \in \SetConfigFinalExc $ which stands for an 
               \textit{exceptional final state} of a method,
	       i.e. the method terminates by throwing an exception. The exceptional configuration has the following components:
               \begin{itemize}
                      \item the heap \heap 
		      %\item \locVarOnly \ is the array of local variables of a method
		      \item \Exc \ is a reference to the uncaught exception that caused the method termination
               \end{itemize}

 \end{itemize}
  
 When an element of a state configuration $\config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc}$ is updated 
 we use the notation: 
 $$ \substitution{\configVar}{ E}{ V}   , \ E \in \{ \heap, \counterOnly, \stackOnly, \locVarOnly, \pc \} $$   
 We will denote with $\configFinal{\heap}{\Final}$ for any configuration which belongs to the set  $\SetConfigFinal$. 
 Later on in this chapter, we define in terms of state configuration transition relation the operational semantics of
 our bytecode programming language.
 In the following, we focus in more detail on the heap modelization and the operand stack. 
