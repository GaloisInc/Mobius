\section{Example}\label{wp:example}
In the following, we  shall see what are the resulting preconditions 
that the \fwpi{} will calculate for the instructions in the bytecode from the program in Fig. \ref{wp:example:sum}.



Fig.\ref{wp:example:sumVC} shows the weakest preconditions for some of the instructions in the bytecode of the method  \lstinline!sum!.
In the figure, the line before every instruction gives the calculated weakest precondition of the instruction.
 Thus, the weakest precondition of the instruction  \return \ at line 74 states that before the instruction is executed the stack top element
\stack{\counter}  must  contain the sum  of the natural numbers smaller than the local variable \locVar{1}. This precondition is calculated from the method postcondition 
which is given in curly brackets at line 75.



The instruction preceding the \return{}
instruction is a conditional branch which may jump to instruction at line 44 (or at position 5 in the bytecode array). 
This instruction has as precondition a predicate which reflects the two possible choices after it: if the element below
the stack top \stack{\counter -1} is smaller than the stack top element \stack{\counter} then the precondition P5 of
the instruction at line 44 must hold, otherwise the precondition Pre13 of the instruction at line 74 holds. 
For every instruction which does not targets a loop entry instruction the precondition is calculated from the precondition of its
 successor instructions. The special cases are the instructions at lines 37 and 56 which point to the loop entry instruction
 at line 61. As described earlier we can see that the resulting precondition of the instruction at line 56 is calculated upon the loop invariant.
The precondition of the instruction at line 37 is calculated also upon the loop invariant but also confirms that the invariant implies
the precondition of the loop entry instruction.

Finally, we can remark that the  verification condition for the method \lstinline!Pre ==> Pre0! is valid.






\begin{figure}
{\scriptsize
\begin{lstlisting}[frame=trbl]
{Pre: reg(1) >= 0}
{Pre0:= 
 0>=0 && 0<=reg(1)&& 0==0*(0-1)/2
 && 
 forall reg(3), reg(2)
    reg(3)>=0 &&reg(3)<=reg(1)&&reg(2)==reg(3)*(reg(3)-1)/2
       ==> reg(3)<reg(1) ==> Pre5 
       &&
       reg(3)>= reg(1) ==>  Pre13}
0 const 0

{0>=0 && 0<=reg(1)&& st(cntr)==0*(0-1)/2
 && 
 forall reg(3), reg(2)
    reg(3)>=0 &&reg(3)<=reg(1)&&reg(2)==reg(3)*(reg(3)-1)/2
       ==> reg(3)<reg(1) ==> Pre5 
       &&
       reg(3)>= reg(1) ==>  Pre13}
1 store 2

{0>=0 && 0<=reg(1)&& reg(2)==0*(0-1)/2
 && 
 forall reg(3), reg(2)
    reg(3)>=0 &&reg(3)<=reg(1)&&reg(2)==reg(3)*(reg(3)-1)/2
       ==> reg(3)<reg(1) ==> Pre5 
       &&
       reg(3)>= reg(1) ==>  Pre13}
2 const 0

{st(cntr)>=0 && st(cntr)<=reg(1)&&reg(2)==st(cntr)*(st(cntr)+1)/2
 && 
 forall reg(3),reg(2), 
    reg(3)>=0&&reg(3)<=reg(1)&&reg(2)==reg(3)*(reg(3)-1)/2==> 
       reg(3)<reg(1) ==> Pre5  && reg(3)>= reg(1) ==> Pre13}
3 store 3

{I && forall reg(2),reg(3) (I ==> Pre10) }
4 goto 10

{Pre5:=
 reg(3)+1>=0&&reg(3)+1<=reg(1)&&reg(2)+reg(3)==(reg(3)+1)*(reg(3))/2}
5 load 2

{reg(3)+1>=0&&reg(3)+1<=reg(1)&&st(cntr)+reg(3)==(reg(3)+1)*(reg(3))/2}
6 load 3

{reg(3)+1>=0&&reg(3)+1<=reg(1)&&
 st(cntr-1)+st(cntr)==(reg(3)+1)*(reg(3))/2}
7 add

{reg(3)+1>=0&&reg(3)+1<=reg(1)&&
 st(cntr)==(reg(3)+1)*(reg(3))/2}
8 store 2

{reg(3)+1>=0&&reg(3)+1<=reg(1)&&
 reg(2)==(reg(3)+1)*(reg(3))/2}
9 iinc 3 //LOOP END

{Pre10 := reg(3)<reg(1) ==> Pre5 
          &&
          reg(3)>= reg(1) ==>  Pre13}
10 load 3 //LOOP ENTRY

{st(cntr)<reg(1)==>Pre5 
 &&
st(cntr)>=reg(1)==>Pre13}
11 load 1

{st(cntr - 1) < st(cntr) ==> Pre5 
 &&
 st(cntr - 1) >= st(cntr) ==>  Pre13}
12 if_icmplt 5 

{Pre13:= st(cntr) ==reg(1)*(reg(1)+1)/2}
13 return
{Post: \result==reg(1)*(reg(1)+1)/2}
\end{lstlisting} }
\caption{\sc weakest precondition predicates for the instructions of the   bytecode of method \lstinline!sum!}
\label{wp:example:sumVC}
\end{figure}







