\subsection{Rules for single instruction} \label{wp:singleInstr}
 In the following, we give the definition of the weakest precondition function for every instruction.


\begin{itemize}	
\item Control transfer instructions
\begin{enumerate}
 \item unconditional jumps, $i = \goto \  n  $ \\
  $$\begin{array}{l} \wpi{}{\methodd}{i} =   \inter{i}{n}  \end{array} $$
  The rule says that an unconditional jump does not modify the program state and thus, the postcondition and the precondition of this instruction
  are the same

\item conditional jumps,  $i = \ifCond \  n  $
  $$ \begin{array}{l}
          \wpi{ }{\methodd}{i} =\\
	   \begin{array}{l} 
                   \stack{\counter} \  \rel \ \stack{\counter - 1}  \Rightarrow  \inter{i}{n}\subst{\counter}{ \counter - 2 } \\
			 \wedge  \\
		  \neg ( \stack{\counter} \ \rel \ \stack{\counter - 1} )  \Rightarrow \inter{i}{i+1}\subst{\counter}{\counter - 2} 
           \end{array}
  \end{array}$$
   In case of a conditional jump, the weakest precondition depends on if  the condition of the jump is satisfied
   by the two stack top elements. %Note, that the instruction does not modify the program state except for the stack counter.
   If the condition of the instruction evaluates to true then the predicate between the current instruction and
   the instruction at index $n$ must hold  where the stack counter is decremented with 2 $\inter{i}{n}\subst{\counter}{ \counter - 2} $ 
   If the condition evaluates to false then the predicate between the current instruction and its next instruction holds where once again the stack counter
   is decremented with two $ \inter{i}{i+1}\subst{\counter}{\counter - 2} $. 

 \item return,  $i = \return $
 
 $$\wpi{}{i}{\methodd}  = \methodd.\normalPost \subst{ \result }{\stack{\counter}}$$
 As the instruction \return \ marks the end of the execution path, we require that its postcondition is the normal method postcondition \normalPost.
 Thus, the weakest precondition of the instruction is \normalPost \ where the specification variable \result \  is substituted with the stack top
 element.

\end{enumerate}


%\item subroutines\\
%Subroutines are treated by inlining, thus every the precondition of every jsr instruction depends on the subroutine code which is executed after it.
%\begin{enumerate}

%\item $ \wpi{\instr{jsr \ n}}{i}{\excPost}{\normalPost} =  \inter{i}{n} $\\

%\item$ \wpi{\instr{ret \ n}}{i}{\excPost}{\normalPost} =  \inter{i}{k} $
%for any instruction $\ins{k}$ which follows a \texttt{jsr} instruction, that jumps to the subroutine ending with $\ins{i}$
%\end{enumerate}

\item the skip instruction, $i = \nop$ 
      $$ \begin{array}{l}
                          \wpi{}{ \methodd }{i} = 
			  \inter{i}{i+1}
                    \end{array} $$
 
\item  load and store instructions

	\begin{enumerate}
		\item load a local variable on the operand stack, $i = \load \  \mbox{ \rm j} $ \\
		 $$ \begin{array}{l}
                          \wpi{}{ \methodd }{i} =  \\
			  \inter{i}{i+1} \subst{\counter}{\counter +1}  \subst{  \stack{ \counter  + 1}}{\locVar{j}} 
					
                    \end{array} $$ 
                
                The weakest precondition of the instruction then is the predicate that must hold between the current instruction
                and its successor, but where the stack counter is incremented and the stack top is substituted with $\locVar{\mbox{ \rm j}}$.
                For instance, if we have that the predicate $\inter{i}{i+1} $ is equal to $ \stack{counter} == 3$ then we get that the precondition of
                instruction is $\locVar{\mbox{\rm j}} == 3$:               
		$$
		\begin{array}{l}
		    \{  \locVar{\mbox{\rm j}} == 3 \} \\
		     i:  \load  \ \mbox{\rm j} \\
                     \{ \stack{\counter} == 3 \} \\
                     i+1: \ldots 
		 \end{array}
		$$
 		
		\item store the stack top element in a local variable $ i= \store \ \mbox{\rm j} $	 \\	 
		$$ \begin{array}{l}
                          \wpi{  } { \methodd}{i}  =   \\ 
		\inter{i}{i+1}
                                    \subst{\counter}{\counter   - 1} 
				    \subst{\locVar{\mbox{\rm j}} }{\stack{ \counter}}  
			       
                   \end{array} $$ \\
		  
		  Contrary to the previous instruction, the instruction $\store \ \mbox{\rm j}$ will take the stack top element
		  and will store its contents in the local variable $\locVar{\mbox{ \rm j}}$.

		\item push an integer constant on the operand stack $ i= \push \  \mbox{\rm j} $ \\
			$$\begin{array}{l}
                          \wpi{  }  {\methodd} {i} =   \\
			  \inter{i}{i+1}
                                    \subst{\counter}{ \counter   + 1}
                                    \subst{\stack{ \counter +1 }}{ \mbox{ \rm j }}
			         		
			\end{array} $$ \\
		   The predicate that holds after the instruction holds in the prestate of the instruction but where the stack counter \counter \
		   is incremented and the constant \mbox{ \rm j } is stored in the stack top element
	
		\item incrementing a local variable $ i = \iinc \   \mbox{ \rm j}$
				$$ \begin{array}{l}
                                          \wpi{ } {i} {\methodd}   =  \\
				          \inter{i}{i+1} \subst{ \locVar{  j} }{  \locVar{\mbox{ \rm j}} + 1 } 
                                   \end{array}$$
		  
	\end{enumerate}
	
\item arithmetic instructions
	\begin{enumerate}
		\item instructions that cannot  cause exception throwing   $ i \in \{  \instr{add}, \instr{sub}, \instr{mult}, 
				\instr{and}, \instr{or}, \instr{xor} , \instr{ishr}, \instr{ishl}\}$
				$$ \begin{array}{l} 
                                          \wpi{}{\methodd} {i}    =  \\
					  \inter{i}{i+1}
                                          
                                                \subst{\counter}{\counter   - 1} 
                                                \subst{ \stack{\counter - 1} } {  \stack{\counter}   \texttt{op} \ \stack{\counter -1} }
				          
                                     \end{array} $$

				We illustrate this rule with an example. Let us have  the arithmetic instruction  \instr{add} at index $i$ such that the predicate
				$\inter{i}{i+1} \equiv \stack{\counter } \geq 0 $. In this case, applying the rule we get that the weakest precondition 
				is $\stack{\counter - 1} +  \stack{\counter } \geq 0$ :
				
				$$
				\begin{array}{l}
				 \{ \stack{\counter - 1} +  \stack{\counter } \geq 0 \}   \\
				   i : \instr{add} \\
				   \{ \stack{\counter } \geq 0 \} 
				 \end{array}
				$$
				
						
		\item instructions that may throw exceptions $i =  \{\instr{rem}, \instr{div} \}$
				$$ \begin{array}{l}
                                         \wpi{}{\methodd}{i}   = \\
					 \begin{array}{l}
				                \stack{\counter} \neq \Mynull \Rightarrow \\
						\Myspace  \inter{i}{i+1}
                                                                               \subst{\counter}{ \counter   - 1}
						                               \subst{\stack{\counter - 1}} { \stack{\counter} \ \texttt{op}  \ \stack{\counter -1}} 
                                                                         
					\\
					        \wedge \\				
					
						\stack{\counter} = \Mynull \Rightarrow 	\methodd.\excPost(i, \ArithExc)             
                               	\end{array} 
				 \end{array}$$
	\end{enumerate}

\item  object creation and manipulation 
	\begin{enumerate}
		\item create a new object, $ i = \new  \ \class $ \\
		$$ \begin{array}{l}
                         \wpi{} {\methodd}{i}  =  \\
		 
		    \forall \freshVar,\\
                    \left(\begin{array}{l}  \neg \ \instances(\freshVar) \wedge
		     \typeof{\freshVar} = \clazz \wedge
		    \freshVar \neq \Mynull  \Rightarrow \\
		     %   \Myspace \typeof{\freshVar} <: \class  \Rightarrow	\\
		      
			                 \Myspace   %\Myspace     
					
                                    \inter{i}{i+1} \begin{array}{l}
		                                   \subst{ \counter}{ \counter + 1 } \\
						   \subst{ \stack{ \counter + 1} }{\freshVar} \\
						   \subst{ \fieldd} { \update{\fieldd} { \freshVar }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \fieldd}}^{{\small \subtype{\fieldd.\declaredIn}{  \class}} } \\
				%\subst{ \typeof{\freshVar}}{ \clazz } 
		       \end{array} 
                  \end{array} \right)
              \end{array}$$
		  The postcondition of the instruction \new{} is the intermediate predicate $\inter{i}{i+1}$. The weakest precondition 
		  of the instruction says that for any reference $\freshVar$ 
		  if $\freshVar$ is not an instance reference  in the state before the execution of the instryction and whose type is \class{}  then
		  the precondition is the same predicate but in which the stack
		  counter is incremented and \freshVar{}  is pushed on the stack top. The fields for the 
		  \freshVar{} have the default value of their type which is expressed through series of substitutions ${\small \subtype{\fieldd.\declaredIn}{  \class}}  $. 
	
		
		\item array creation, $  i =\newarray  \ \anyType $
	
				 $$\begin{array}{l}
                                         \wpi{ } {\methodd}{i}  =  \\
			\forall \referenceOnly,\\
                        \left(\begin{array}{l}    not \ \instances(\referenceOnly) \wedge \\
			   \referenceOnly \neq \Mynull \wedge 
			   \typeof{\referenceOnly} = \type{\anyType[ ]} \wedge 
			  \stack{\counter} \ge 0 \Rightarrow  \\
					 \Myspace     \Myspace  \inter{i}{i+1} \\
                                           \Myspace      \Myspace \begin{array}{l}        
						        \subst{\stack{\counter} }{ \referenceOnly } \\
							\subst{ \arrayAccessOnly }{ \update{\arrayAccessOnly}
                                                                                           {(\referenceOnly, j ) }
                                                                                         {\defaultValue{\anyType} } }_{ { \small \forall j , 0 \leq  j < \stack{\counter} } } \\
                                                          \subst{\length}{\update{\length}{\referenceOnly}{\stack{\counter} } }     
						   \end{array} \\
							\wedge \\
						\stack{\counter} < 0 \Rightarrow    \methodd.\excPost( i, \NegativeArraySizeExc) \\
                         \end{array}\right)
                                    \end{array} $$
		  Here, the rule for array creation is similar to the rule for object creation.
		  However, creation of an array might terminate exceptionally in case the length of the array stored 
		  in the stack top element \stack{\counter} is smaller than $0$. In this case, function $\methodd.\excPost$ will search for the corresponding postcondition 
		  of the instruction at position $i$ and the exception \NegativeArraySizeExc
		
			\item field access  $ i = \getfield  \ \fieldd  $\\
				 $$ 	\begin{array}{l} \wpi{} {\methodd}{i}  =  \\
				 		\stack{\counter } \ne \Mynull \Rightarrow 
						      \inter{i}{i+1}\subst{\stack{\counter }}{\fieldd ( \stack{\counter } ) } \\
									 \wedge \\
						\stack{\counter } = \Mynull \Rightarrow \methodd.\excPost( i, \NullPointerExc) 
					\end{array} 
					$$
			  The instruction for accessing a field value takes as postcondition the predicate that must hold between it and its next instruction
			  $\inter{i}{i+1}$.  This instruction may terminate normally or on an exception.
			  In case the stack top element is not \Mynull, the precondition of \getfield \ is its postcondition where the stack 
			  top element is substituted by the field access expression $\fieldd ( \stack{\counter }$.
			  If the stack top element is \Mynull, then the instruction will terminate on  a \NullPointerExc \ exception. In this case the precondition
			  of the instruction is the predicate returned by the function $\methodd.\excPost$ for position $i$ in the bytecode and exception \NullPointerExc
			  
			\item  field update $ i = \putfield  \ \fieldd$\\
			$$\begin{array}{l}
                                  \wpi{  } {\methodd}{i}  =  \\
				 		\stack{\counter } \ne \Mynull \Rightarrow 
						 \inter{i}{i+1}
                                                     
                                                              \subst{ \counter }{  \counter -2 }
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
						       
						        \\
							\wedge \\
							\stack{\counter } = \Mynull \Rightarrow   \methodd.\excPost( i, \NullPointerExc ) \\
					  \end{array} 
					$$
			                
			                This instruction  also may terminate normally or exceptionally. The termination depends on the value of the stack 
					top element in the prestate of the instruction. If the top stack element is not \Mynull \ then in the precondition
					of the instruction $\inter{i}{i+1}$ must hold where the stack counter is decremented with two elements and
					the \fieldd object is substituted with an updated version $\update{\fieldd}{ \stack{\counter - 2}}{  \stack{\counter  -1} } $.
				
					For example, let us have the instruction \putfield \ \fieldd in method \methodd. Its normal postcondition is
					$ \inter{i}{i+1} \equiv \fieldd( \locVar{1})  \neq \Mynull $. Assume that \methodd \ does not have exception
					handler for \NullPointerExc \ exception for the region in which the \putfield \ instruction. Let the exceptional postcondition
					of \methodd \ for \NullPointerExc \ be \Myfalse, i.e. \methodd.\excPostSpec(\NullPointerExc ) = \Myfalse.
					If all these conditions hold, the function \fwpi \ will return for the \putfield \ instruction the following formula : 
					 
					$$\begin{array}{l}
					 \stack{\counter} \ne  \Mynull \Rightarrow  (\fieldd( \locVar{1})  \neq \Mynull  )
					          %\begin{array}{l} 
					                     \subst{ \counter }{  \counter -2 } %\\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter } } }
                                             	  \\%\end{array} \\
                                           \wedge \\
					   \stack{\counter } = \Mynull \Rightarrow \Myfalse
					  \end{array} 
					$$
					After applying the substitution following the rules 
					described in Section \ref{subst}, we obtain that the precondition is 
					$$\begin{array}{l}
					 \stack{\counter} \ne  \Mynull \Rightarrow  \update{\fieldd}{ \stack{\counter - 1} }{\stack{\counter} }( \locVar{1})  \neq \Mynull \\
                                          \wedge \\
					  \stack{\counter } = \Mynull \Rightarrow \Myfalse
					\end{array} 
					$$
					
					Finally, we give the instruction \putfield its postcondition and the respective weakest precondition:
					$$ \begin{array}{l}
					  \{ \begin{array}{l}
					           \stack{\counter} \ne  \Mynull \Rightarrow 
                                                   \update{\fieldd}{ \stack{\counter - 1} }{\stack{\counter} }( \locVar{1})  \neq \Mynull \}  \\
					           \wedge \\
						   \stack{\counter } = \Mynull \Rightarrow \Myfalse
					        \end{array}  \}\\
					  i: \putfield  \ \fieldd\\
					  \{\fieldd( \locVar{1})  \neq \Mynull \} \\
					  i+1: \ldots 
					\end{array}
					$$
					
					\item access the length of an array $i = \arraylength$
					$$\begin{array}{l}
					        \wpi{ } {\methodd}{i}  =  \\
					 				\stack{\counter } \ne \Mynull \Rightarrow
									 \inter{i}{i+1}
									 \subst{ \stack{\counter } }{ \length(\stack{\counter } )  } \\
									 \wedge \\
								\stack{\counter } = \Mynull \Rightarrow  \methodd.\excPost( i, \NullPointerExc) \\
					  \end{array} $$
					  The semantics of \arraylength is that it takes the stack top element which must be an array reference
					  and puts on the operand stack the length of the array referenced by this reference. This instruction
					  may terminate either normally or exceptionally. The termination depends on if the stack top element is 
					  \Mynull \ or not. In case $\stack{\counter} \neq \Mynull$ the predicate  $\inter{i}{i+1}$ must hold where
					  the stack top element is substituted with its length. The case when a \NullPointerExc is thrown is similar
					  to the previous cases with exceptional termination
					  
					  
					\item checkcast $ i = \checkcast  \ \clazz$
						$$ \begin{array}{l} 
						\wpi{ } {\methodd}{i}  = \\
							\typeof{\stack{\counter}}  \subtypeSpec  \clazz \vee  \stack{\counter} = \Mynull \Rightarrow 
							        \inter{i}{i+1}\\
							
							 \wedge \\
							
							\neg(  \typeof{\stack{\counter}} \subtypeSpec  \clazz  ) \Rightarrow  
							 \methodd.\excPost( i, \ClassCastExc) \\
						\end{array}$$  
					  The instruction checks if the stack top element can be cast to the class \clazz. 
					  Two termination of the instruction  are possible. If the stack top element \stack{\counter} is of type 
					  which is a subtype of class \clazz \  or is \Mynull \ then the predicate $ \inter{i}{i+1} $ holds in the prestate.
					  Otherwise, if   \stack{\counter} is not of type which is a subtype of class \clazz, the instruction terminates
					  on \ClassCastExc \ and the predicate returned by $\methodd.\excPost$ for the position $i$ and exception \ClassCastExc  \
					  must hold 
					  
						\item instanceof $i = \instanceof \  \clazz  $
						$$ \begin{array}{l}
                                                    \wpi{} {\methodd}{i}  = \\
							 \typeof{ \stack{\counter}} \subtypeSpec \clazz  \Rightarrow 
								 \inter{i}{i+1} \subst{ \stack{\counter } } {  1  } \\
									 \wedge \\
							\neg (  \typeof{\stack{\counter}} \subtypeSpec  \clazz  )  \vee  \stack{\counter} = \Mynull \Rightarrow 
							   \inter{i}{i+1} \subst{  \stack{\counter } }{ 0 } \\	  
						\end{array} 	$$
						  This instruction, depending on if the stack top element can be cast to the class type \clazz \ pushes on the stack 
						  top either 0 or 1.
						  Thus, the rule is almost the same as the previous instruction \checkcast.
					
	\end{enumerate}
%	\item Stack management
%		         \begin{itemize}
%						 \item pop  \\
%	  							$\wpi{\instr{pop}} {\methodd}{i}  =  \inter{i}{i+1}[ \counter \leftarrow \counter -1]$ \\
%%	  					\item dup \\
%	  							$$
%	  							\begin{array}{l}\wpi{\instr{dup}} {\methodd}{i}  =  \inter{i}{i+1}[ \counter \leftarrow \counter + 1] \\
%	  							\Myspace \Myspace \Myspace \Myspace \Myspace   [ \stack{\counter + 1} \leftarrow  \stack{\counter}]
%	  							 \end{array}
%	  							 $$
%	 				 	\item swap 
%	 				 			$\wpi{\instr{swap}} {\methodd}{i}  =  $ \\
%	 				 			$$ 
%	 				 			\begin{array}{l}
%	 				 					\inter{i}{i+1}[  \stack{\counter} \leftarrow var ] \\
%	 				 						\Myspace \Myspace \Myspace [  \stack{\counter + 1} \leftarrow  \stack{\counter}  ] \\
%	 				 						\Myspace \Myspace \Myspace [  var  \leftarrow  \stack{\counter + 1}  ] \\
%	 				 			\end{array}
%	 				 			$$ \\
%\end{itemize} 
	 		\item method invocation  (only the case for non void instance method is given).
			$i =\invoke  \   \mbox{\rm\texttt{n} } $ 
	 				$$\begin{array}{l}
								 \wpi{ } {\methodd}{i}  =   \\
	 				 	 \mbox{\rm\texttt{n} } .\pre\subst{\locVar{s}}{ \stack{\counter + s -\methodd.\numArgs}}_{s = 0}^{ \mbox{\rm\texttt{n} }  .\numArgs }  \\ \\
	 				 			\wedge \\\\
								
	 				 			       \forall res,  m_i ( m_i \in \mbox{\rm\texttt{n} } .\modif )   \\
           %( mod \in \mbox{\rm\texttt{n} } .\modif ), \forall res (  \\ 
         \left( \begin{array}{l}
	 				 				      \mbox{\rm\texttt{n} } .\normalPost %\begin{array}{l}
									\subst{\result}{  res } %\\
									%\subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} } .\modif.length }
									%\subst{\old{\ast}}{\ast}	 
									\subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } .\numArgs} }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }                                                                                                	%\end{array}  
                                                                   \Rightarrow \\ 
										      
										      \inter{i}{i+1 } %\begin{array}{l}
										                                   \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs}
														   \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ res }																%	\end{array}																									
	 				 			 	\end{array}\right)  \\\\
	 				 			\wedge_{j = 0 }^{\mbox{\rm\texttt{n} } .\exceptions.length -1} \\ \\
	 				 			%\forall \tt{e_m} ( m =1 .. k  )

            	\wedge


	 	 \findExcHandler{ \mbox{\rm\texttt{n} }.\exceptions[j] }{i}{\methodd.\excHandlerTable} = \bottom \Rightarrow \\  
					  \forall e, m_i ( m_i \in \mbox{\rm\texttt{n} } .\modif ),  \\
					 \left( \begin{array}{l}
                                                 \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j]) \subst{\EXC }{e } %\subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} }  .\modif.length }  %\subst{\old{\ast}}{\ast}  \Rightarrow \\ 
                                                  \methodd.\getExcPost (i,   \methodd.\exceptions[j] )\subst{\EXC }{e } %\subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} } .\modif.length }      \\
						 
						 \end{array}\right)	
                                                                        \\

 \wedge \\

		     (\findExcHandler{ \mbox{\rm\texttt{m} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = k    \Rightarrow \\ 
                    \forall e , m_i ( m_i \in \mbox{\rm\texttt{n} } .\modif ), \\
                              \left( \begin{array}{l}
						 \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j]) \subst{\EXC }{e } 	%\subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} } .\modif.length } %\subst{\old{\ast}}{\ast} )
 \Rightarrow \\ 
                                                  \inter{i}{k} %\begin{array}{l}
						                                           \subst{\counter}{0} 
                                                                                           \subst{\stack{0} }{e }  
											   \subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} } .\modif.length} %\subst{\old{\ast}}{\ast} )
						                                        %\end{array}
        
							
	 				 		\end{array}  \right) 

                                     \end{array}$$	 		
	 			
						Let us look in detail what is the meaning of the weakest precondition for method invokation.
						Because we are following a contract based approach 
						the caller, i.e. the current method  \methodd \ must establish several facts.
						First, we require that 
						the precondition \mbox{\rm\texttt{n}}.\pre \ of the invoked method \mbox{\rm\texttt{n}}  \ holds where the formal 
						parameters are correctly initialized with the
						first \mbox{\rm\texttt{n}}.\numArgs \ elements from the operand stack.
						
						Second, we get a logical statement which guarantees the correctness of the method invokation
						in case of normal termination.
						On the other hand, its postcondition \mbox{\rm\texttt{n}}.\normalPost \ is assumed to hold and thus, we want to establish that 
						under the assumption that \methodd.\normalPost{}  holds \ with \result{} substituted with a fresh bound variable $ res$
						and correctly initialized formal parameters
						is true we want to establish that the predicate \inter{i}{i+1 } \
						holds . This implication is quantified over the locations \mbox{\rm\texttt{n}}.\modif \ that a method may modify.
						We denote the quantification with $ m_i ( m_i \in \mbox{\rm\texttt{n} } .\modif ) $ to say that we quantify over the locations 
						which are in the modifies list.
						%This is done by quantifying over the bound variables $\boundVar_1 \ldots \boundVar_{\mbox{\rm\texttt{n} }  .\modif.length}$.
						%Note also that in the postcondition of the invoked method, 
						%we substitute old expressions of the form $\old{\expression}$  with $\expression$. This is done via the series of substitutions
						%denoted with  $ \subst{\old{\ast}}{\ast}  $.
						%  This is actually, because the old expressions in the postcondition of the
					%	invoked method refer not to the same state to which the old expressions in $\inter{i}{i+1}$ refer.
						%This substitution must be done carefully in order not to bind them to the quantification over the 
						% variables in   \mbox{\rm\texttt{n} } .\modif, in particular it must be done after the substitution 
					%	$ \subst{\mbox{\rm\texttt{n} } .\modif[i]}{  \boundVar_i }_{i=0}^{ \mbox{\rm\texttt{n} } .\modif.length}$.						
						The third part of the rule deals with the exceptional termination of the method invokation.
						In this case, if the invoked method \texttt{n} terminates on any exception which belongs to the array of 
						exceptions \texttt{n}.\exceptions{} that \texttt{n} may throw. Two cases are considered - either the thrown
						exception can be handled by \methodd{} or not. If the thrown exception  \texttt{Exc} can not be handled
						by the method \methodd \
						(i.e. $\findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}
						{\methodd.\excHandlerTable} = \bottom $) then if the exceptional postcondition predicate
						$ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ of \texttt{n} holds
						then  	$ \methodd.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ for any value of the thrown exception
						object. 
						In case the thrown  exception\texttt{Exc} is handled by \methodd, i.e. \\
						$ \findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec 
						  ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = k $   then if 
						the exceptional postcondition $ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ 
						of \texttt{n} holds then the intermediate predicate $\inter{i}{k}$ 
						that must hold after $\ins{i}$ and before   $\ins{k}$ must hold once again for any value
						of thrown exception. 
						
						
						
						
						
					
\item throw exception instruction, $ i =\athrow $
				
							$$ \begin{array}{l}
							          \wpi{} {\methodd}{i}  = \\
								    \stack{\counter} = \Mynull \Rightarrow  \methodd.\excPost( i, \NullPointerExc) \\
								     \wedge \\
							          \stack{\counter} \neq \Mynull \Rightarrow 
								    \begin{array}{l}  
								       \forall  \mbox{\rm\texttt{Exc}}, \left(
								        \typeof{\stack{\counter}} <: \mbox{\rm\texttt{Exc}}   \Rightarrow 
								         \methodd.\getExcPost( i, \mbox{\rm\texttt{Exc}}    )\subst{ \EXC }{\stack{\counter}  } \right)
								       % \wedge \\
								       % \forall n, 0 \le n < \methodd.\excHandlerTable.length,  \\  
								       % \typeof{\stack{\counter}} <: \methodd. \excHandlerTable[n].\exc \Rightarrow \\
								       % \Myspace   \methodd.\getExcPost(i,\excHandlerTable[n].\exc  ) 
								                     
								    \end{array} 
							   \end{array}
							$$ \\
						The thrown object is on the top of the stack \stack{\counter}.
						If the stack top object \stack{\counter} \ is \Mynull, then the instruction \athrow{}  terminates on an exception
						\NullPointerExc \ where the predicate returned by the function $ \methodd.\excPost( i, \NullPointerExc)$ must hold.
						The case when  the thrown object is not \Mynull{}  should consider all the possible exceptions that
						might be thrown by the current instruction. This is because we do not know the type of the thrown object which is
						on the stack top.
						The part of the \fwpi \ when the thrown object on the stack top  \stack{\counter} \ is not \Mynull \ considers all the possible types
						of the exception thrown. In any of 
						
						%Thus, the rule takes into account the case when the exception thrown is a not handled exception,
						%	i.e. the type    of \stack{\counter} is a subtype of any  of the exceptions \methodd.\exceptions \ that might be thrown
						%	by the current method \methodd. Thus, if  \athrow \ instruction throws a not handled exception \texttt{Exc} 
						%	then  the exceptional postcondition for  \texttt{Exc} must hold where the special exception variable \EXC \ 
						%	is substituted for the stack counter \stack{\counter}. 
 						%	The \fwpi \ considers also the case when the thrown exception object  might be handled by any of the
						%	exception handlers \methodd.\excHandlerTable \ of method \ \methodd. 
						%	In that case, once again the rule takes into account all the possible exception handler types as the type of the
						%	thrown exception is unknown.
						
	 		\end{itemize}


