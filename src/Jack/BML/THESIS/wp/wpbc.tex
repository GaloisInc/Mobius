 






\section{Weakest precondition calculus} \label{wpRules}

In what follows, we assume that the bytecode has passed the bytecode verifier, thus it is well typed and well structured. Actually, our calculus is concerned only
with functional properties of programs leaving the problem of code well structuredness and welltypedness to the bytecode verification techniques 








%\subsection{Rules for single instruction}
The weakest precondition predicate transformer function which for any instruction of the Java sequential fragment
determines the predicate that must hold in the prestate of the instruction has the following signature:

$$ \fwpi :   (nat,\bcIns)  \longrightarrow   \MethodSet   \longrightarrow \predWp $$
The function \fwpi \ takes two arguments : 
the second argument is the method \methodd \ to which the  instruction belongs
and  the first argument is  the instruction (for instance  \putfield) along with its position in \methodd.
%and finally the position of the instruction in the body of  \methodd.

The function \fwpi \  returns a predicate $\wpi{ins}{\methodd}{pos}$ such that  if it holds in the prestate of the method \methodd \  and if the
\methodd \ terminates normally then the normal postcondition \methodd.\normalPost \ holds when  \methodd \ terminates execution, otherwise if \methodd \ terminates on an exception
  \mbox{ \rm \texttt{Exc}} the exceptional postcondition  $ \methodd.\excPost( \mbox{ \rm \texttt{Exc}} )$ holds. 
Thus, the \fwpi \ function takes into account both normal and exceptional program termination. Note however, that \fwpi \ deals only with partial correctness, i.e.
 it does not guarantee program termination.

In order to define the \fwpi \ function, we will need two other notions.
 The first one is a function which will determine the predicate between two instructions that are in execution relation as defined in Def. \ref{defEdge}. 
Note that this is not necessary for structured programs. However, for unstructured programs with loops annotated with invariants and frame conditions,
this is a necessary step.  The definition of the intermediate predicate is given in the next subsection \ref{wp:interPred}.
We will also see how the weakest precondition is defined in presence of exceptions. This is done in subsection \ref{wp:interExc}.
\input{wp/intermPred.tex}
\input{wp/excPred.tex} 





\subsection{Rules for single instruction}
 In the following, we give the definition of the weakest precondition function for every instruction.


\begin{itemize}	
\item Control transfer instructions
\begin{enumerate}
 \item unconditional jumps \\
  $$\begin{array}{l} \wpi{\goto \  n }{\methodd}{i} =   \inter{i}{n}  \end{array} $$
  The rule says that an unconditional jump does not modify the program state and thus, the postcondition and the precondition of this instruction
  are the same

\item conditional jumps
  $$ \begin{array}{l}
          \wpi{ \ifCond  \  n }{\methodd}{i} =\\
	   \begin{array}{l} 
                  \mbox{ \rm \texttt{ cond}} ( \stack{\counter}, \stack{\counter - 1} ) \Rightarrow \\
                  \Myspace \inter{i}{n}\subst{\counter}{ \counter - 2 } \\
			 \wedge  \\
		  not(\mbox{ \rm \texttt{ cond}})( \stack{\counter},\stack{\counter - 1} ))  \Rightarrow \\
		  \Myspace \inter{i}{i+1}\subst{\counter}{\counter - 2} 
           \end{array}
  \end{array}$$
   In case of a conditional jump, the weakest precondition depends on if  the condition of the jump is satisfied
   by the two stack top elements. %Note, that the instruction does not modify the program state except for the stack counter.
   If the condition of the instruction evaluates to true then the predicate between the current instruction and
   the instruction at index $n$ must hold  where the stack counter is decremented with 2 $\inter{i}{n}\subst{\counter}{ \counter - 2} $ 
   If the condition evaluates to false then the predicate between the current instruction and its next instruction holds where once again the stack counter
   is decremented with two $ \inter{i}{i+1}\subst{\counter}{\counter - 2} $. 

 \item return 
 
 $$\wpi{\return}{i}{\methodd}  = \methodd.\normalPost \subst{ \result }{\stack{\counter}}$$
 As the instruction \return \ marks the end of the execution path, we require that its postcondition is the normal method postcondition \normalPost.
 Thus, the weakest precondition of the instruction is \normalPost \ where the specification variable \result \  is substituted with the stack top
 element.

\end{enumerate}


%\item subroutines\\
%Subroutines are treated by inlining, thus every the precondition of every jsr instruction depends on the subroutine code which is executed after it.
%\begin{enumerate}

%\item $ \wpi{\instr{jsr \ n}}{i}{\excPost}{\normalPost} =  \inter{i}{n} $\\

%\item$ \wpi{\instr{ret \ n}}{i}{\excPost}{\normalPost} =  \inter{i}{k} $
%for any instruction $\ins{k}$ which follows a \texttt{jsr} instruction, that jumps to the subroutine ending with $\ins{i}$
%\end{enumerate}


\item  load and store instructions
	\begin{enumerate}
		\item load a local variable on the operand stack \\
		 $$ \begin{array}{l}
                          \wpi{\load \  \mbox{ \rm j}}{ \methodd }{i} =  \\
			  \inter{i}{i+1}\begin{array}{l} 
                                              \subst{\counter}{\counter +1} \\
					      \subst{  \stack{ \counter  + 1}}{\locVar{j}} 
					\end{array}
                    \end{array} $$ 
                
                The weakest precondition of the instruction then is the predicate that must hold between the current instruction
                and its successor, but where the stack counter is incremented and the stack top is substituted with $\locVar{j}$.
                For instance, if we have that the predicate $\inter{i}{i+1} $ is equal to $ \stack{counter} == 3$ then we get that the precondition of
                instruction is $\locVar{j} == 3$:               
		$$
		\begin{array}{l}
		    \{  \locVar{j} == 3 \} \\
		     i:  \load  \ \mbox{ \rm j} \\
                     \{ \stack{\counter} == 3 \} \\
                     i+1: \ldots 
		 \end{array}
		$$
 		
		\item store the stack top element in a local variable	 \\	 
		$$ \begin{array}{l}
                          \wpi{\store \ \mbox{ \rm j} } { \methodd}{i}  =   \\ 
		\inter{i}{i+1}\begin{array}{l} 
                                    \subst{\counter}{\counter   - 1} \\
				    \subst{\locVar{j} }{\stack{ \counter}}  
			       \end{array}
                   \end{array} $$ \\
		  
		  Contrary to the previous instruction, the instruction $\store \ \mbox{\rm j}$ will take the stack top element
		  and will store its contents in the local variable $\locVar{j}$.

		\item push an integer constant on the operand stack  \\
			$$\begin{array}{l}
                          \wpi{\push  \  \mbox{ \rm j} }  {\methodd} {i} =   \\
			  \inter{i}{i+1}\begin{array}{l}  
                                    \subst{\counter}{ \counter   + 1} \\ 
                                    \subst{\stack{ \counter +1 }}{ \mbox{ \rm j }}
			         \end{array}			
			\end{array} $$ \\
		   The predicate that holds after the instruction holds in the prestate of the instruction but where the stack counter \counter \
		   is incremented and the constant \mbox{ \rm j } is stored in the stack top element
	
		\item incrementing a local variable 
				$$ \begin{array}{l}
                                          \wpi{\iinc \   \mbox{ \rm j} } {i} {\methodd}   =  \\
				          \inter{i}{i+1} \subst{ \locVar{  j} }{  \locVar{j} + 1 } 
                                   \end{array}$$
		  
	\end{enumerate}
	
\item arithmetic instructions
	\begin{enumerate}
		\item instructions that cannot  cause exception throwing    (\texttt{arithOp} =  \instr{add}, \instr{sub}, \instr{mult}, 
				\instr{and}, \instr{or}, \instr{xor} , \instr{ishr}, \instr{ishl},     )\\
				$$ \begin{array}{l} 
                                          \wpi{\arithOp }{\methodd} {i}    =  \\
					  \inter{i}{i+1}
                                          \begin{array}{l}
                                                \subst{\counter}{\counter   - 1} \\
                                                \subst{ \stack{\counter - 1} } {  \stack{\counter}   \texttt{op} \ \stack{\counter -1} }
				          \end{array}
                                     \end{array} $$

				We illustrate this rule with an example. Let us have  the arithmetic instruction  \instr{add} at index $i$ such that the predicate
				$\inter{i}{i+1} \equiv \stack{\counter } \geq 0 $. In this case, applying the rule we get that the weakest precondition 
				is $\stack{\counter - 1} +  \stack{\counter } \geq 0$ :
				
				$$
				\begin{array}{l}
				 \{ \stack{\counter - 1} +  \stack{\counter } \geq 0 \}   \\
				   i : \instr{add} \\
				   \{ \stack{\counter } \geq 0 \} 
				 \end{array}
				$$
				
						
		\item instructions that may throw exceptions ( \texttt{arithOp} =  \instr{rem}, \instr{div} )\\
				$$ \begin{array}{l}
                                         \wpi{\instr{arithOp } }{\methodd}{i}   = \\
					 \begin{array}{l}
				                \stack{\counter} \neq \Mynull \Rightarrow \\
						\Myspace  \inter{i}{i+1} \begin{array}{l}
                                                                               \subst{\counter}{ \counter   - 1} \\
						                               \subst{\stack{\counter - 1}} { \stack{\counter} \ \texttt{op}  \ \stack{\counter -1}} 
                                                                          \end{array}\\
						\\
					        \wedge \\				
						\\
						\stack{\counter} = \Mynull \Rightarrow 	\methodd.\excPost(i, \NullPointerExc)             
                               	\end{array} 
				 \end{array}$$
	\end{enumerate}

\item  object creation and manipulation 
	\begin{enumerate}
		\item create a new object \\
		$$ \begin{array}{l}
                         \wpi{\instr{new  \ \clazz }} {\methodd}{i}  =  \\
		 
		    \forall \referenceOnly,\\
                      \Myspace    not \ \instances(\referenceOnly) \wedge \\
		      \Myspace \referenceOnly \neq \Mynull \Rightarrow	\\
		      % \Myspace  \typeof{\referenceOnly} = \type{\clazz} \Rightarrow	\\
			                 \Myspace   \Myspace     
					 \begin{array}{l}   \inter{i}{i+1} \\
		                                   \subst{ \counter}{ \counter + 1 } \\
						   \subst{ \stack{ \counter + 1} }{\referenceOnly} \\
						   \subst{ \fieldd} { \update{\fieldd} { \referenceOnly }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \clazz}} } \\
				\subst{ \typeof{\referenceOnly}}{ \clazz } \\		   
		       \end{array}
              \end{array}$$
		  The postcondition of the instruction \new \ is the intermediate predicate $\inter{i}{i+1}$. The weakest precondition 
		  of the instruction says that for any reference $\referenceOnly$ 
		  if $\referenceOnly$ was not instantiated in the initial state of the execution of \methodd \ then
		  the precondition is the same predicate but in which the stack
		  counter is incremented and \referenceOnly  \ is pushed on the stack top  where the fields for the 
		  \referenceOnly \ are initialized with their default values 
	
		
		\item array creation 
	
				 $$\begin{array}{l}
                                         \wpi{\newarray  \ \anyType } {\methodd}{i}  =  \\
			\forall \referenceOnly,\\
                        \Myspace    not \ \instances(\referenceOnly) \wedge \\
			 \Myspace \referenceOnly \neq \Mynull \wedge \\
			% \Myspace \typeof{\referenceOnly} =\type{\anyType[ ]}
			 	\Myspace \stack{\counter} \ge 0 \Rightarrow  \\
					 \Myspace     \Myspace  \inter{i}{i+1} \\
                                           \Myspace      \Myspace \begin{array}{l}        
						        \subst{\stack{\counter} }{ \referenceOnly } \\
							\subst{ \arrayAccessOnly }{ \update{\arrayAccessOnly}
                                                                                           {(\referenceOnly, j ) }
                                                                                         {\defaultValue{\anyType} } }_{ { \small \forall j , 0 \leq  j < \stack{\counter} } } \\
                                                          \subst{\length}{\update{\length}{\referenceOnly}{\stack{\counter} } }     
						   \end{array} \\
							\wedge \\
						\stack{\counter} < 0 \Rightarrow    \methodd.\excPost( i, \NegativeArraySizeExc) \\
                                    \end{array} $$
		  Here, the rule for array creation is similar to the rule for object creation.
		  However, creation of an array might terminate exceptionally in case the length of the array stored 
		  in the stack top element \stack{\counter} is smaller than $0$. In this case, function $\methodd.\excPost$ will search for the corresponding postcondition 
		  of the instruction at position $i$ and the exception \NegativeArraySizeExc
		
			\item field access  \\
				 $$ 	\begin{array}{l} \wpi{\getfield  \ \fieldd } {\methodd}{i}  =  \\
				 		\stack{\counter } \ne \Mynull \Rightarrow \\
						      \Myspace	\inter{i}{i+1}[ \stack{\counter } \leftarrow \fieldd ( \stack{\counter } ) ] \\
									 \wedge \\
						\stack{\counter } = \Mynull \Rightarrow \methodd.\excPost( i, \NullPointerExc) 
					\end{array} 
					$$
			  The instruction for accessing a field value takes as postcondition the predicate that must hold between it and its next instruction
			  $\inter{i}{i+1}$.  This instruction may terminate normally or on an exception.
			  In case the stack top element is not \Mynull, the precondition of \getfield \ is its postcondition where the stack 
			  top element is substituted by the field access expression $\fieldd ( \stack{\counter }$.
			  If the stack top element is \Mynull, then the instruction will terminate on  a \NullPointerExc \ exception. In this case the precondition
			  of the instruction is the predicate returned by the function $\methodd.\excPost$ for position $i$ in the bytecode and exception \NullPointerExc
			  
			\item  field update \\
			$$\begin{array}{l}
                                  \wpi{\putfield  \ \fieldd } {\methodd}{i}  =  \\
				 		\stack{\counter } \ne \Mynull \Rightarrow \\
						 \Myspace \inter{i}{i+1}
                                                     \begin{array}{l}
                                                              \subst{ \counter }{  \counter -2 } \\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
						       \end{array} 
						        \\
							\wedge \\
							\stack{\counter } = \Mynull \Rightarrow   \methodd.\excPost( i, \NullPointerExc ) \\
					  \end{array} 
					$$
			                
			                This instruction  also may terminate normally or exceptionally. The termination depends on the value of the stack 
					top element in the prestate of the instruction. If the top stack element is not \Mynull \ then in the precondition
					of the instruction $\inter{i}{i+1}$ must hold where the stack counter is decremented with two elements and
					the \fieldd object is substituted with an updated version $\update{\fieldd}{ \stack{\counter - 2}}{  \stack{\counter  -1} } $
				
					For example, let us have the instruction \putfield \ \fieldd in method \methodd. Its normal postcondition is
					$ \inter{i}{i+1} \equiv \fieldd( \locVar{1})  \neq \Mynull $. Assume that \methodd \ does not have exception
					handler for \NullPointerExc \ exception for the region in which the \putfield \ instruction. Let the exceptional postcondition
					of \methodd \ for \NullPointerExc \ be \Myfalse, i.e. \methodd.\excPostSpec(\NullPointerExc ) = \Myfalse
					If all these conditions hold, the function \fwpi \ will return for the \putfield \ instruction the following formula : 
					 
					$$\begin{array}{l}
					 \stack{\counter} \ne  \Mynull \Rightarrow \\ 
					  	 \Myspace (\fieldd( \locVar{1})  \neq \Mynull  )
					          \begin{array}{l} 
					                     \subst{ \counter }{  \counter -2 } \\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter } } }
                                             	  \end{array} \\
                                           \wedge \\
					   \stack{\counter } = \Mynull \Rightarrow \Myfalse
					  \end{array} 
					$$
					After applying the substitution following the rules 
					described in Section \ref{subst}, we obtain that the precondition is 
					$$\begin{array}{l}
					 \stack{\counter} \ne  \Mynull \Rightarrow \\  
                                                \Myspace  \update{\fieldd}{ \stack{\counter - 1} }{\stack{\counter} }( \locVar{1})  \neq \Mynull \\
                                          \wedge \\
					  \stack{\counter } = \Mynull \Rightarrow \Myfalse
					\end{array} 
					$$
					
					Finally, we give the instruction \putfield its postcondition and the respective weakest precondition:
					$$ \begin{array}{l}
					  \{ \begin{array}{l}
					           \stack{\counter} \ne  \Mynull \Rightarrow \\  
                                                   \update{\fieldd}{ \stack{\counter - 1} }{\stack{\counter} }( \locVar{1})  \neq \Mynull \}  \\
					           \wedge \\
						   \stack{\counter } = \Mynull \Rightarrow \Myfalse
					        \end{array}  \}\\
					  i: \putfield  \ \fieldd\\
					  \{\fieldd( \locVar{1})  \neq \Mynull \} \\
					  i+1: \ldots 
					\end{array}
					$$
					
					\item access the length of an array 
					$$\begin{array}{l}
					        \wpi{\arraylength } {\methodd}{i}  =  \\
					 				\stack{\counter } \ne \Mynull \Rightarrow \\
									\Myspace \inter{i}{i+1}
									 \subst{ \stack{\counter } }{ \length(\stack{\counter } )  } \\
									 \wedge \\
								\stack{\counter } = \Mynull \Rightarrow  \methodd.\excPost( i, \NullPointerExc) \\
					  \end{array} $$
					  The semantics of \arraylength is that it takes the stack top element which must be an array reference
					  and puts on the operand stack the length of the array referenced by this reference. This instruction
					  may terminate either normally or exceptionally. The termination depends on if the stack top element is 
					  \Mynull \ or not. In case $\stack{\counter} \neq \Mynull$ the predicate  $\inter{i}{i+1}$ must hold where
					  the stack top element is substituted with its length. The case when a \NullPointerExc is thrown is similar
					  to the previous cases with exceptional termination
					  
					  
					\item checkcast 
						$$ \begin{array}{l} 
						\wpi{\checkcast  \ \clazz } {\methodd}{i}  = \\
							\typeof{\stack{\counter}}  \subtypeSpec  \clazz \vee  \stack{\counter} = \Mynull \Rightarrow \\
							     	\Myspace   \inter{i}{i+1}\\
							
							 \wedge \\
							
							not(  \typeof{\stack{\counter}} \subtypeSpec  \clazz  ) \Rightarrow  
							 \methodd.\excPost( i, \ClassCastExc) \\
						\end{array}$$  
					  The instruction checks if the stack top element can be cast to the class \clazz. 
					  Two termination of the instruction  are possible. If the stack top element \stack{\counter} is of type 
					  which is a subtype of class \clazz \  or is \Mynull \ then the predicate $ \inter{i}{i+1} $ holds in the prestate.
					  Otherwise, if   \stack{\counter} is not of type which is a subtype of class \clazz, the instruction terminates
					  on \ClassCastExc \ and the predicate returned by $\methodd.\excPost$ for the position $i$ and exception \ClassCastExc  \
					  must hold 
					  
						\item instanceof
						$$ \begin{array}{l}
                                                    \wpi{\instanceof \  \clazz } {\methodd}{i}  = \\
							 \typeof{ \stack{\counter}} \subtypeSpec \clazz  \Rightarrow \\
								\Myspace  	 \inter{i}{i+1} \subst{ \stack{\counter } } {  1  } \\
									 \wedge \\
								not(  \typeof{\stack{\counter}} \subtypeSpec  \clazz  )  \vee  \stack{\counter} = \Mynull \Rightarrow \\
								\Myspace   \inter{i}{i+1} \subst{  \stack{\counter } }{ 0 } \\	  
						\end{array} 	$$
						  This instruction, depending on if the stack top element can be cast to the class type \clazz \ pushes on the stack 
						  top either 0 or 1.
						  Thus, the rule is almost the same as the previous instruction \checkcast.
					
	\end{enumerate}
%	\item Stack management
%		         \begin{itemize}
%						 \item pop  \\
%	  							$\wpi{\instr{pop}} {\methodd}{i}  =  \inter{i}{i+1}[ \counter \leftarrow \counter -1]$ \\
%%	  					\item dup \\
%	  							$$
%	  							\begin{array}{l}\wpi{\instr{dup}} {\methodd}{i}  =  \inter{i}{i+1}[ \counter \leftarrow \counter + 1] \\
%	  							\Myspace \Myspace \Myspace \Myspace \Myspace   [ \stack{\counter + 1} \leftarrow  \stack{\counter}]
%	  							 \end{array}
%	  							 $$
%	 				 	\item swap 
%	 				 			$\wpi{\instr{swap}} {\methodd}{i}  =  $ \\
%	 				 			$$ 
%	 				 			\begin{array}{l}
%	 				 					\inter{i}{i+1}[  \stack{\counter} \leftarrow var ] \\
%	 				 						\Myspace \Myspace \Myspace [  \stack{\counter + 1} \leftarrow  \stack{\counter}  ] \\
%	 				 						\Myspace \Myspace \Myspace [  var  \leftarrow  \stack{\counter + 1}  ] \\
%	 				 			\end{array}
%	 				 			$$ \\
%\end{itemize} 
	 		\item method invocation  (only the case for non void instance method is given). 
	 				 			$$\begin{array}{l}
								 \wpi{\invoke  \   \mbox{\rm\texttt{n} } } {\methodd}{i}  =   \\
	 				 	 \mbox{\rm\texttt{n} } .\pre[ \locVar{s} \leftarrow \stack{\counter + s -\methodd.\numArgs}]_{s = 0}^{ \mbox{\rm\texttt{n} }  .\numArgs }  \\ \\
	 				 			\wedge \\\\
								\begin{array}{l}
	 				 			       \forall  mod ,  ( mod \in \mbox{\rm\texttt{n} } .\modif ), \forall freshVar (  \\ 
	 				 				              \Myspace \mbox{\rm\texttt{n} } .\normalPost \begin{array}{l}
									               \subst{\result}{  freshVar } \\
											\subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } }.\numArgs }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }                                                                                                	\end{array}  \Rightarrow \\ 
										      \\
										      \Myspace  \Myspace  \inter{i}{i+1 } \begin{array}{l}
										                                   \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs}\\
														   \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ freshVar }																	\end{array}																									
	 				 			 )	\end{array}  \\\\
	 				 			\wedge_{j = 0 }^{\mbox{\rm\texttt{n} } .\exceptions.length -1} \\ \\
	 				 			%\forall \tt{e_m} ( m =1 .. k  )
							\begin{array}{l}
	 				 		\forall  mod ,  ( mod \in \mbox{\rm\texttt{n} } .\modif ), \\
	 				 		\Myspace (\findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = \bottom \Rightarrow \\  
					 \Myspace \forall \bound_i (  \\ 
						 \Myspace \Myspace \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j]) \subst{\EXC }{\bound_i } \Rightarrow \\ 
                                                 \Myspace\Myspace\Myspace  \methodd.\excPost(i,   \methodd.\exceptions[j] )\subst{\EXC }{\bound_i }    ) ) \\
						 \Myspace \wedge \\
						 \Myspace (\findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = k    \Rightarrow \\ 
 \Myspace \forall \bound_i (  \\ 
						 \Myspace \Myspace \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j]) \subst{\EXC }{\bound_i } \Rightarrow \\ 
                                                 \Myspace\Myspace\Myspace  \inter{i}{k}\begin{array}{l}
						                                           \subst{\counter}{0} \\
                                                                                           \subst{\stack{0} }{\bound_i }  
						                                        \end{array}) )
							
	 				 		\end{array}
							\end{array}
	 				 			$$ 
	 			

						Let us look in detail what is the meaning of the weakest precondition for method invokation.
						Because we are following a contract based approach 
						the caller, i.e. the current method must establish several facts.
						First, we require that 
						the precondition \methodd.\pre \ of the invoked method \methodd \ holds where the formal 
						parameters are correctly initialized with the
						first \methodd.\numArgs \ elements from the operand stack.
						
						Second, we get a logical statement which guarantees the correctness of the method invokation
						in case of normal termination.
						On the other hand, its postcondition  \methodd.\normalPost \ is assumed to hold and thus, we want to establish that 
						under the assumption that \methodd.\normalPost \  holds \ with \result \ substituted with a fresh bound variable $ \bound_i$
						and correctly initialized formal parameters
						is true we want to establish that the predicate   \inter{i}{i+1 } \
						holds . This implication is quantified over the locations  \method.\modif \ that a method may modify
						and the variable $ \bound_i$ which stands for the result that the invoked method \methodd \ returns.  
						
						The third part of the rule deals with the exceptional termination of the method invokation.
						In this case, if the invoked method \texttt{n} terminates on any exception which belongs to the array of 
						exceptions \texttt{n}.\exceptions \ that \texttt{n} may throw. Two cases are considered - either the thrown
						exception can be handled by \methodd \ or not. If the thrown exception  \texttt{Exc} can not be handled
						by the method \methodd \
						(i.e. $\findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}
						{\methodd.\excHandlerTable} = \bottom $) then if the exceptional postcondition predicate
						$ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ of \texttt{n} holds
						then  	$ \methodd.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ for any value of the thrown exception
						object. 
						In case the thrown  exception\texttt{Exc} is handled by \methodd, i.e. \\
						$ \findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec 
						  ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = k $   then if 
						the exceptional postcondition $ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ 
						of \texttt{n} holds then the intermediate predicate $\inter{i}{k}$ 
						that must hold after $\ins{i}$ and before   $\ins{k}$ must hold once again for any value
						of thrown exception. 
						
						
						
						
						
					
\item throw exception instruction \\
				
							$$ \begin{array}{l}
							          \wpi{\instr{athrow }} {\methodd}{i}  = \\
								    \stack{\counter} = \Mynull \Rightarrow  \methodd.\excPost( i, \NullPointerExc) \\  
								     \wedge \\
							          \stack{\counter} \neq \Mynull \Rightarrow \\
								    \begin{array}{l}  
								      \forall n, 0 \le n < \methodd. \exceptions.length \\  
								      \typeof{\stack{\counter}} <:  \methodd.\exceptions[n] \Rightarrow \\
								      \Myspace \methodd.\excPostSpec( \methodd.\exceptions[n]  )\subst{ \EXC }{\stack{\counter}  } \\
								      \wedge \\
								      \forall n, 0 \le n < \methodd.\excHandlerTable.length \\  
								      \typeof{\stack{\counter}} <: \methodd. \excHandlerTable[n].\exc \Rightarrow \\
								      \Myspace  \inter{i}{\methodd. \excHH[n].\pcHandler}
								                     
								    \end{array} 
							   \end{array}
							$$ \\
						The thrown object is on the top of the stack \stack{\counter}.
						If the stack top object \stack{\counter} \ is \Mynull, then the instruction \athrow will terminate on an exception
						\NullPointerExc \ where the predicate returned by the function $ \methodd.\excPost$ must hold.
						The case when  the thrown object is not \Mynull \  should consider all the possible exceptions that
						might be thrown by the current instruction. This is because we do not know the type of the thrown object which is
						on the stack top. Thus, the rule takes into account the case when the exception thrown is a not handled exception,
						i.e. the type    of \stack{\counter} is a subtype of any  of the exceptions \methodd.\exceptions \ that might be thrown
						by the current method \methodd. Thus, if  \athrow \ instruction throws a not handled exception \texttt{Exc} 
						then  the exceptional postcondition for  \texttt{Exc} must hold where the special exception variable \EXC \ 
						is substituted for the stack counter \stack{\counter}. 
 						The \fwpi \ considers also the case when the thrown exception object  might be handled by any of the
						exception handlers \methodd.\excHandlerTable \ of method \ \methodd. 
						In that case, once again the rule takes into account all the possible exception handler types as the type of the
						thrown exception is unknown.
						
	 		\end{itemize}
Supposing the execution of a method always terminates, the verification condition for a method \methodd \ with a
 precondition $\methodd.\pre$ is defined in the following way:
$$ \methodd.\pre \Rightarrow \wpi{\method.\body[0]}{\methodd}{0}$$





