 






\section{Weakest precondition calculus} \label{wpRules}


%\subsection{Rules for single instruction}
The weakest precondition predicate transformer function which for any instruction of the Java sequential fragment
determines the predicate that must hold in the prestate of the instruction has the following signature:

$$ \fwpi :   (int,\bcIns)  \longrightarrow   \MethodSet   \longrightarrow \predWp $$
The function \fwpi \ takes two arguments : 
the second argument is the method \methodd \ to which the  instruction belongs
and  the first argument is  the instruction (for instance  \putfield) along with its position in \methodd.
%and finally the position of the instruction in the body of  \methodd.

Let us first see what is the desired meaning of \fwpi.
Particularly, we would like that the function \fwpi{}  returns a predicate $\wpi{ins}{\methodd}{pos}$
such that  if it holds in the prestate of the method \methodd \  and if the
\methodd{} terminates normally then the normal postcondition \methodd.\normalPost \ holds when 
\methodd{} terminates execution, otherwise if \methodd \ terminates on an exception
\mbox{ \rm \texttt{Exc}} the exceptional postcondition  $\methodd.\excPostSpec(\mbox{ \rm \texttt{Exc}})$ holds where the function \excPostSpec{} was
introduced in Section \ref{methExtend}. Thus, the \fwpi \ function takes into account both normal and exceptional
program termination. Note however, that \fwpi{} deals only with partial correctness, i.e. it does not 
guarantee program termination. In the next Chapter \ref{proofGeneral}, we shall formally argument that \fwpi{} has this semantics.
 
 In the following, we will give an intuition to the way in which we have defined our verification condition generator.
 Consider the example in Fig. \ref{wp:example:sum} which 
 shows both the source code and the bytecode of a method which calculates the sum of all the natural numbers
 smaller or equal to the parameter \lstinline!k!. The source and bytecode are annotated, the first one in JML and the latter in BML.
 However, the bytecode annotations are actually stored separately from the bytecode instructions as we have described in Section \ref{methExtend}
 but we have put them explicitely in the bytecode at the point where they must hold for the sake of clarity. 
 Note that in what follows we will name the loop invariant $I$.
 We have also marked the instructions which are identified as loop start and end
 according to Def.\ref{defEdge} in Chapter \ref{opSem}, Section \ref{prelim:ctrFlow}. 

  
\begin{figure}[ht!]
\begin{center}
\begin{minipage}[c]{\linewidth} 
\begin{minipage}[c]{.63\linewidth}
\scriptsize{
\begin{lstlisting}[frame=trbl]
//@requires reg(1)>=0
0 const 0
1 store 2
2 const 0
3 store 3
4 goto 10
5 load 2
6 load 3
7 add
8 store 2
9 iinc 3 //LOOP END
//@loop_modifies reg(2),reg(3)
//@loop_invariant I := 
//@               reg(3)>=0 &&
//@               reg(3)<=reg(1)&&
//@               reg(2)==reg(3)*(reg(3)-1)/2
10 load 3 //LOOP ENTRY 
11 load 1
12 if_icmplt 5 
13 return
//@ensures \result==
           reg(1)*(reg(1)+1)/2
\end{lstlisting}} 
\end{minipage}


%\hfill
\begin{minipage}[c]{.63\linewidth} 
\scriptsize{
\begin{lstlisting}[frame=trbl]
//@requires k >= 0 ;
//@ensures \result == k*(k+1)/2;
public void m(int k){
  int sum = 0;
  //@loop_modifies sum, i;
  //@loop_invariant i >= 0 
  && i <=k && sum == i*(i-1)/2;
  for (int i = 0;i < k;i++){
    sum = sum + i;
  } 
}
\end{lstlisting} }
\end{minipage}
\end{minipage}
\end{center}
\caption{\sc  bytecode of method \lstinline!sum! and its specification }
\label{wp:example:sum}
\end{figure}


 It is worth first to note that because the bytecode is not structured we cannot define
 the weakest precondition in the same way in which a predicate transformer for structured
 languages is defined.  We will rather  define the predicate transformer for an instructions to depend on
 the instructions which may follow it during an execution:  
$$\fwpi( j ) = \bigwedge_k  C_k \Rightarrow S_k(\fwpi( k )) , where  \ j \execRel k $$
$C_k$ stands for some condition to be filled in order that after the instruction at index $j$ executes the instruction at index $k$.
 In most of the cases the condition $C_k$  is \Mytrue{} except for conditional jumps or when the instruction  $j$ throws an exception.
$S_k$ stands for a function which might be the identity function or apply substitutions over its argument.

Thus the weakest precondition for the instruction at index 12 (in the bytecode version) which is a conditional jump  
of the program will be:
$$ \begin{array}{ll} \fwpi( 12 )  = & 
                      \stack{\counter - 1} < \stack{\counter} \Rightarrow   \fwpi(13) \subst{\counter}{\counter - 2} \\
                      &\wedge \\
		      &\stack{\counter - 1} >= \stack{\counter} \Rightarrow   \fwpi(5)\subst{\counter}{\counter - 2}, \\
		      & where \ 12 \execRel 13, 12 \execRel 5
   \end{array}
		      $$

Let us see now what  we would expect about the result of   the function \fwpi{} when applied to the instructions
that have as successor the loop entry instruction at index 10. For instance, we can look at the instruction
at index 9 which is marked in the figure as the end of the loop. 
As we said earlier we have inlined annotations in the bytecode at the places where they must hold. Thus after the execution
of the instruction at index 9  the loop invariant must hold. It follows then that for a loop end instruction 
we will rather require that the \fwpi{} function takes into account the corresponding loop invariant:
$$ \begin{array}{ll} \fwpi( 9 )  = &
                    I \subst{\locVar{3}}{\locVar{3} + 1}, \\
		     & where \ 9 \execRel^l 10 
		     \end{array}$$


The situation is  similar  for the instruction at index 4 which jumps to the loop entry instruction at index 10. 
The semantics of the invariant requires that  in between instructions 4 and 10 first the invariant must hold
and second,  whatever are the values
of the program variables that might be modified by the loop, the invariant should imply the precondition of the loop entry instruction at 10.
 Thus we would like that  the function \fwpi{} gives us something like: 
   $$\begin{array}{ll} \fwpi( 4 ) =& 
                    I \\
		    &\wedge \\
		    &\forall \locVar{2}, \locVar{3},  I  \Rightarrow \fwpi(10), \\
			&    where \ 4 \execRel 10 \ \wedge 10 \ is \ a \ loop \ entry   
      \end{array}
                 $$
% May be it is here the place to discuss   why we   quantify over the values of the
% modified variables in the loop. The  reason for this is that we can thus properly
%initialize the non modified variables in verification conditions. This makes the set of 
%%the provable verification conditions larger than in the case we would have not done this.  
%In the following, we shall assume that the modifies clauses in specifications
%are correct although we verify it in our verification condition generator.

The example shows that the function \fwpi{} depends  on the semantics of the instruction 
for which it calculates a precondition and also on the execution relation it has with its successors.
In order to define the function \fwpi{} we will use an intermediate function which shall decide 
what is the postcondition of an instruction  upon the execution relation with its successors. This function 
is introduced in the next subsection \ref{wp:interPred}.
 
We will also see how the weakest precondition is defined in the presence of exceptions in subsection \ref{wp:Exc}.
\input{wp/intermPred.tex}
\input{wp/excPred.tex} 



\subsection{Rules for single instruction} \label{wp:singleInstr}
 In the following, we give the definition of the weakest precondition function for every instruction.


\begin{itemize}	
\item Control transfer instructions
\begin{enumerate}
 \item unconditional jumps \\
  $$\begin{array}{l} \wpi{\goto \  n }{\methodd}{i} =   \inter{i}{n}  \end{array} $$
  The rule says that an unconditional jump does not modify the program state and thus, the postcondition and the precondition of this instruction
  are the same

\item conditional jumps
  $$ \begin{array}{l}
          \wpi{ \ifCond  \  n }{\methodd}{i} =\\
	   \begin{array}{l} 
                  \mbox{ \rm \texttt{ cond}} ( \stack{\counter}, \stack{\counter - 1} ) \Rightarrow \\
                  \Myspace \inter{i}{n}\subst{\counter}{ \counter - 2 } \\
			 \wedge  \\
		  not(\mbox{ \rm \texttt{ cond}})( \stack{\counter},\stack{\counter - 1} ))  \Rightarrow \\
		  \Myspace \inter{i}{i+1}\subst{\counter}{\counter - 2} 
           \end{array}
  \end{array}$$
   In case of a conditional jump, the weakest precondition depends on if  the condition of the jump is satisfied
   by the two stack top elements. %Note, that the instruction does not modify the program state except for the stack counter.
   If the condition of the instruction evaluates to true then the predicate between the current instruction and
   the instruction at index $n$ must hold  where the stack counter is decremented with 2 $\inter{i}{n}\subst{\counter}{ \counter - 2} $ 
   If the condition evaluates to false then the predicate between the current instruction and its next instruction holds where once again the stack counter
   is decremented with two $ \inter{i}{i+1}\subst{\counter}{\counter - 2} $. 

 \item return 
 
 $$\wpi{\return}{i}{\methodd}  = \methodd.\normalPost \subst{ \result }{\stack{\counter}}$$
 As the instruction \return \ marks the end of the execution path, we require that its postcondition is the normal method postcondition \normalPost.
 Thus, the weakest precondition of the instruction is \normalPost \ where the specification variable \result \  is substituted with the stack top
 element.

\end{enumerate}


%\item subroutines\\
%Subroutines are treated by inlining, thus every the precondition of every jsr instruction depends on the subroutine code which is executed after it.
%\begin{enumerate}

%\item $ \wpi{\instr{jsr \ n}}{i}{\excPost}{\normalPost} =  \inter{i}{n} $\\

%\item$ \wpi{\instr{ret \ n}}{i}{\excPost}{\normalPost} =  \inter{i}{k} $
%for any instruction $\ins{k}$ which follows a \texttt{jsr} instruction, that jumps to the subroutine ending with $\ins{i}$
%\end{enumerate}


\item  load and store instructions
	\begin{enumerate}
		\item load a local variable on the operand stack \\
		 $$ \begin{array}{l}
                          \wpi{\load \  \mbox{ \rm j}}{ \methodd }{i} =  \\
			  \inter{i}{i+1}\begin{array}{l} 
                                              \subst{\counter}{\counter +1} \\
					      \subst{  \stack{ \counter  + 1}}{\locVar{j}} 
					\end{array}
                    \end{array} $$ 
                
                The weakest precondition of the instruction then is the predicate that must hold between the current instruction
                and its successor, but where the stack counter is incremented and the stack top is substituted with $\locVar{j}$.
                For instance, if we have that the predicate $\inter{i}{i+1} $ is equal to $ \stack{counter} == 3$ then we get that the precondition of
                instruction is $\locVar{j} == 3$:               
		$$
		\begin{array}{l}
		    \{  \locVar{j} == 3 \} \\
		     i:  \load  \ \mbox{ \rm j} \\
                     \{ \stack{\counter} == 3 \} \\
                     i+1: \ldots 
		 \end{array}
		$$
 		
		\item store the stack top element in a local variable	 \\	 
		$$ \begin{array}{l}
                          \wpi{\store \ \mbox{ \rm j} } { \methodd}{i}  =   \\ 
		\inter{i}{i+1}\begin{array}{l} 
                                    \subst{\counter}{\counter   - 1} \\
				    \subst{\locVar{j} }{\stack{ \counter}}  
			       \end{array}
                   \end{array} $$ \\
		  
		  Contrary to the previous instruction, the instruction $\store \ \mbox{\rm j}$ will take the stack top element
		  and will store its contents in the local variable $\locVar{j}$.

		\item push an integer constant on the operand stack  \\
			$$\begin{array}{l}
                          \wpi{\push  \  \mbox{ \rm j} }  {\methodd} {i} =   \\
			  \inter{i}{i+1}\begin{array}{l}  
                                    \subst{\counter}{ \counter   + 1} \\ 
                                    \subst{\stack{ \counter +1 }}{ \mbox{ \rm j }}
			         \end{array}			
			\end{array} $$ \\
		   The predicate that holds after the instruction holds in the prestate of the instruction but where the stack counter \counter \
		   is incremented and the constant \mbox{ \rm j } is stored in the stack top element
	
		\item incrementing a local variable 
				$$ \begin{array}{l}
                                          \wpi{\iinc \   \mbox{ \rm j} } {i} {\methodd}   =  \\
				          \inter{i}{i+1} \subst{ \locVar{  j} }{  \locVar{j} + 1 } 
                                   \end{array}$$
		  
	\end{enumerate}
	
\item arithmetic instructions
	\begin{enumerate}
		\item instructions that cannot  cause exception throwing    (\texttt{arithOp} =  \instr{add}, \instr{sub}, \instr{mult}, 
				\instr{and}, \instr{or}, \instr{xor} , \instr{ishr}, \instr{ishl},     )\\
				$$ \begin{array}{l} 
                                          \wpi{\arithOp }{\methodd} {i}    =  \\
					  \inter{i}{i+1}
                                          \begin{array}{l}
                                                \subst{\counter}{\counter   - 1} \\
                                                \subst{ \stack{\counter - 1} } {  \stack{\counter}   \texttt{op} \ \stack{\counter -1} }
				          \end{array}
                                     \end{array} $$

				We illustrate this rule with an example. Let us have  the arithmetic instruction  \instr{add} at index $i$ such that the predicate
				$\inter{i}{i+1} \equiv \stack{\counter } \geq 0 $. In this case, applying the rule we get that the weakest precondition 
				is $\stack{\counter - 1} +  \stack{\counter } \geq 0$ :
				
				$$
				\begin{array}{l}
				 \{ \stack{\counter - 1} +  \stack{\counter } \geq 0 \}   \\
				   i : \instr{add} \\
				   \{ \stack{\counter } \geq 0 \} 
				 \end{array}
				$$
				
						
		\item instructions that may throw exceptions ( \texttt{arithOp} =  \instr{rem}, \instr{div} )\\
				$$ \begin{array}{l}
                                         \wpi{\instr{arithOp } }{\methodd}{i}   = \\
					 \begin{array}{l}
				                \stack{\counter} \neq \Mynull \Rightarrow \\
						\Myspace  \inter{i}{i+1} \begin{array}{l}
                                                                               \subst{\counter}{ \counter   - 1} \\
						                               \subst{\stack{\counter - 1}} { \stack{\counter} \ \texttt{op}  \ \stack{\counter -1}} 
                                                                          \end{array}\\
						\\
					        \wedge \\				
						\\
						\stack{\counter} = \Mynull \Rightarrow 	\methodd.\excPost(i, \NullPointerExc)             
                               	\end{array} 
				 \end{array}$$
	\end{enumerate}

\item  object creation and manipulation 
	\begin{enumerate}
		\item create a new object \\
		$$ \begin{array}{l}
                         \wpi{\new  \ \class } {\methodd}{i}  =  \\
		 
		    \forall \freshVar,\\
                      \Myspace    \neg \ \instances(\freshVar) \wedge \\
		      \Myspace \freshVar \neq \Mynull  \\
		        \Myspace \typeof{\freshVar} <: \class  \Rightarrow	\\
		      
			                 \Myspace   \Myspace     
					 \begin{array}{l}   \inter{i}{i+1} \\
		                                   \subst{ \counter}{ \counter + 1 } \\
						   \subst{ \stack{ \counter + 1} }{\freshVar} \\
						   \subst{ \fieldd} { \update{\fieldd} { \freshVar }{\defaultValue{ \fieldd.  \fieldType } } }_{{\small \forall \fieldd: \FieldSet. \subtype{\fieldd.\declaredIn}{  \class}} } \\
			%	\subst{ \typeof{\referenceOnly}}{ \clazz } \\		   
		       \end{array}
              \end{array}$$
		  The postcondition of the instruction \new{} is the intermediate predicate $\inter{i}{i+1}$. The weakest precondition 
		  of the instruction says that for any reference $\freshVar$ 
		  if $\freshVar$ is not an instance reference  in the initial state of the execution of \methodd \ then
		  the precondition is the same predicate but in which the stack
		  counter is incremented and \freshVar  \ is pushed on the stack top  where the fields for the 
		  \freshVar \ have the default value of their type. 
	
		
		\item array creation 
	
				 $$\begin{array}{l}
                                         \wpi{\newarray  \ \anyType } {\methodd}{i}  =  \\
			\forall \referenceOnly,\\
                        \Myspace    not \ \instances(\referenceOnly) \wedge \\
			 \Myspace \referenceOnly \neq \Mynull \wedge \\
			\Myspace \typeof{\referenceOnly} = \type{\anyType[ ]} \wedge \\
			 	\Myspace \stack{\counter} \ge 0 \Rightarrow  \\
					 \Myspace     \Myspace  \inter{i}{i+1} \\
                                           \Myspace      \Myspace \begin{array}{l}        
						        \subst{\stack{\counter} }{ \referenceOnly } \\
							\subst{ \arrayAccessOnly }{ \update{\arrayAccessOnly}
                                                                                           {(\referenceOnly, j ) }
                                                                                         {\defaultValue{\anyType} } }_{ { \small \forall j , 0 \leq  j < \stack{\counter} } } \\
                                                          \subst{\length}{\update{\length}{\referenceOnly}{\stack{\counter} } }     
						   \end{array} \\
							\wedge \\
						\stack{\counter} < 0 \Rightarrow    \methodd.\excPost( i, \NegativeArraySizeExc) \\
                                    \end{array} $$
		  Here, the rule for array creation is similar to the rule for object creation.
		  However, creation of an array might terminate exceptionally in case the length of the array stored 
		  in the stack top element \stack{\counter} is smaller than $0$. In this case, function $\methodd.\excPost$ will search for the corresponding postcondition 
		  of the instruction at position $i$ and the exception \NegativeArraySizeExc
		
			\item field access  \\
				 $$ 	\begin{array}{l} \wpi{\getfield  \ \fieldd } {\methodd}{i}  =  \\
				 		\stack{\counter } \ne \Mynull \Rightarrow \\
						      \Myspace	\inter{i}{i+1}[ \stack{\counter } \leftarrow \fieldd ( \stack{\counter } ) ] \\
									 \wedge \\
						\stack{\counter } = \Mynull \Rightarrow \methodd.\excPost( i, \NullPointerExc) 
					\end{array} 
					$$
			  The instruction for accessing a field value takes as postcondition the predicate that must hold between it and its next instruction
			  $\inter{i}{i+1}$.  This instruction may terminate normally or on an exception.
			  In case the stack top element is not \Mynull, the precondition of \getfield \ is its postcondition where the stack 
			  top element is substituted by the field access expression $\fieldd ( \stack{\counter }$.
			  If the stack top element is \Mynull, then the instruction will terminate on  a \NullPointerExc \ exception. In this case the precondition
			  of the instruction is the predicate returned by the function $\methodd.\excPost$ for position $i$ in the bytecode and exception \NullPointerExc
			  
			\item  field update \\
			$$\begin{array}{l}
                                  \wpi{\putfield  \ \fieldd } {\methodd}{i}  =  \\
				 		\stack{\counter } \ne \Mynull \Rightarrow \\
						 \Myspace \inter{i}{i+1}
                                                     \begin{array}{l}
                                                              \subst{ \counter }{  \counter -2 } \\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter} } }
						       \end{array} 
						        \\
							\wedge \\
							\stack{\counter } = \Mynull \Rightarrow   \methodd.\excPost( i, \NullPointerExc ) \\
					  \end{array} 
					$$
			                
			                This instruction  also may terminate normally or exceptionally. The termination depends on the value of the stack 
					top element in the prestate of the instruction. If the top stack element is not \Mynull \ then in the precondition
					of the instruction $\inter{i}{i+1}$ must hold where the stack counter is decremented with two elements and
					the \fieldd object is substituted with an updated version $\update{\fieldd}{ \stack{\counter - 2}}{  \stack{\counter  -1} } $
				
					For example, let us have the instruction \putfield \ \fieldd in method \methodd. Its normal postcondition is
					$ \inter{i}{i+1} \equiv \fieldd( \locVar{1})  \neq \Mynull $. Assume that \methodd \ does not have exception
					handler for \NullPointerExc \ exception for the region in which the \putfield \ instruction. Let the exceptional postcondition
					of \methodd \ for \NullPointerExc \ be \Myfalse, i.e. \methodd.\excPostSpec(\NullPointerExc ) = \Myfalse
					If all these conditions hold, the function \fwpi \ will return for the \putfield \ instruction the following formula : 
					 
					$$\begin{array}{l}
					 \stack{\counter} \ne  \Mynull \Rightarrow \\ 
					  	 \Myspace (\fieldd( \locVar{1})  \neq \Mynull  )
					          \begin{array}{l} 
					                     \subst{ \counter }{  \counter -2 } \\
							     \subst{  \fieldd}{ \update{\fieldd}{ \stack{\counter - 1}}{  \stack{\counter } } }
                                             	  \end{array} \\
                                           \wedge \\
					   \stack{\counter } = \Mynull \Rightarrow \Myfalse
					  \end{array} 
					$$
					After applying the substitution following the rules 
					described in Section \ref{subst}, we obtain that the precondition is 
					$$\begin{array}{l}
					 \stack{\counter} \ne  \Mynull \Rightarrow \\  
                                                \Myspace  \update{\fieldd}{ \stack{\counter - 1} }{\stack{\counter} }( \locVar{1})  \neq \Mynull \\
                                          \wedge \\
					  \stack{\counter } = \Mynull \Rightarrow \Myfalse
					\end{array} 
					$$
					
					Finally, we give the instruction \putfield its postcondition and the respective weakest precondition:
					$$ \begin{array}{l}
					  \{ \begin{array}{l}
					           \stack{\counter} \ne  \Mynull \Rightarrow \\  
                                                   \update{\fieldd}{ \stack{\counter - 1} }{\stack{\counter} }( \locVar{1})  \neq \Mynull \}  \\
					           \wedge \\
						   \stack{\counter } = \Mynull \Rightarrow \Myfalse
					        \end{array}  \}\\
					  i: \putfield  \ \fieldd\\
					  \{\fieldd( \locVar{1})  \neq \Mynull \} \\
					  i+1: \ldots 
					\end{array}
					$$
					
					\item access the length of an array 
					$$\begin{array}{l}
					        \wpi{\arraylength } {\methodd}{i}  =  \\
					 				\stack{\counter } \ne \Mynull \Rightarrow \\
									\Myspace \inter{i}{i+1}
									 \subst{ \stack{\counter } }{ \length(\stack{\counter } )  } \\
									 \wedge \\
								\stack{\counter } = \Mynull \Rightarrow  \methodd.\excPost( i, \NullPointerExc) \\
					  \end{array} $$
					  The semantics of \arraylength is that it takes the stack top element which must be an array reference
					  and puts on the operand stack the length of the array referenced by this reference. This instruction
					  may terminate either normally or exceptionally. The termination depends on if the stack top element is 
					  \Mynull \ or not. In case $\stack{\counter} \neq \Mynull$ the predicate  $\inter{i}{i+1}$ must hold where
					  the stack top element is substituted with its length. The case when a \NullPointerExc is thrown is similar
					  to the previous cases with exceptional termination
					  
					  
					\item checkcast 
						$$ \begin{array}{l} 
						\wpi{\checkcast  \ \clazz } {\methodd}{i}  = \\
							\typeof{\stack{\counter}}  \subtypeSpec  \clazz \vee  \stack{\counter} = \Mynull \Rightarrow \\
							     	\Myspace   \inter{i}{i+1}\\
							
							 \wedge \\
							
							not(  \typeof{\stack{\counter}} \subtypeSpec  \clazz  ) \Rightarrow  
							 \methodd.\excPost( i, \ClassCastExc) \\
						\end{array}$$  
					  The instruction checks if the stack top element can be cast to the class \clazz. 
					  Two termination of the instruction  are possible. If the stack top element \stack{\counter} is of type 
					  which is a subtype of class \clazz \  or is \Mynull \ then the predicate $ \inter{i}{i+1} $ holds in the prestate.
					  Otherwise, if   \stack{\counter} is not of type which is a subtype of class \clazz, the instruction terminates
					  on \ClassCastExc \ and the predicate returned by $\methodd.\excPost$ for the position $i$ and exception \ClassCastExc  \
					  must hold 
					  
						\item instanceof
						$$ \begin{array}{l}
                                                    \wpi{\instanceof \  \clazz } {\methodd}{i}  = \\
							 \typeof{ \stack{\counter}} \subtypeSpec \clazz  \Rightarrow \\
								\Myspace  	 \inter{i}{i+1} \subst{ \stack{\counter } } {  1  } \\
									 \wedge \\
								not(  \typeof{\stack{\counter}} \subtypeSpec  \clazz  )  \vee  \stack{\counter} = \Mynull \Rightarrow \\
								\Myspace   \inter{i}{i+1} \subst{  \stack{\counter } }{ 0 } \\	  
						\end{array} 	$$
						  This instruction, depending on if the stack top element can be cast to the class type \clazz \ pushes on the stack 
						  top either 0 or 1.
						  Thus, the rule is almost the same as the previous instruction \checkcast.
					
	\end{enumerate}
%	\item Stack management
%		         \begin{itemize}
%						 \item pop  \\
%	  							$\wpi{\instr{pop}} {\methodd}{i}  =  \inter{i}{i+1}[ \counter \leftarrow \counter -1]$ \\
%%	  					\item dup \\
%	  							$$
%	  							\begin{array}{l}\wpi{\instr{dup}} {\methodd}{i}  =  \inter{i}{i+1}[ \counter \leftarrow \counter + 1] \\
%	  							\Myspace \Myspace \Myspace \Myspace \Myspace   [ \stack{\counter + 1} \leftarrow  \stack{\counter}]
%	  							 \end{array}
%	  							 $$
%	 				 	\item swap 
%	 				 			$\wpi{\instr{swap}} {\methodd}{i}  =  $ \\
%	 				 			$$ 
%	 				 			\begin{array}{l}
%	 				 					\inter{i}{i+1}[  \stack{\counter} \leftarrow var ] \\
%	 				 						\Myspace \Myspace \Myspace [  \stack{\counter + 1} \leftarrow  \stack{\counter}  ] \\
%	 				 						\Myspace \Myspace \Myspace [  var  \leftarrow  \stack{\counter + 1}  ] \\
%	 				 			\end{array}
%	 				 			$$ \\
%\end{itemize} 
	 		\item method invocation  (only the case for non void instance method is given). 
	 				 			$$\begin{array}{l}
								 \wpi{\invoke  \   \mbox{\rm\texttt{n} } } {\methodd}{i}  =   \\
	 				 	 \mbox{\rm\texttt{n} } .\pre[ \locVar{s} \leftarrow \stack{\counter + s -\methodd.\numArgs}]_{s = 0}^{ \mbox{\rm\texttt{n} }  .\numArgs }  \\ \\
	 				 			\wedge \\\\
								\begin{array}{l}
	 				 			       \forall  mod ,  ( mod \in \mbox{\rm\texttt{n} } .\modif ), \forall freshVar (  \\ 
	 				 				              \Myspace \mbox{\rm\texttt{n} } .\normalPost \begin{array}{l}
									               \subst{\result}{  freshVar } \\
											\subst{ \locVar{s}}{\stack{\counter + s - \mbox{\rm\texttt{n} } }.\numArgs }_{s = 0}^
{ \mbox{\rm\texttt{n} }. \numArgs }                                                                                                	\end{array}  \Rightarrow \\ 
										      \\
										      \Myspace  \Myspace  \inter{i}{i+1 } \begin{array}{l}
										                                   \subst{\counter}{ \counter - \mbox{\rm\texttt{n} } .\numArgs}\\
														   \subst{ \stack{\counter -  \mbox{\rm\texttt{n} } .\numArgs  }}{ freshVar }																	\end{array}																									
	 				 			 )	\end{array}  \\\\
	 				 			\wedge_{j = 0 }^{\mbox{\rm\texttt{n} } .\exceptions.length -1} \\ \\
	 				 			%\forall \tt{e_m} ( m =1 .. k  )
							\begin{array}{l}
	 				 		\forall  mod ,  ( mod \in \mbox{\rm\texttt{n} } .\modif ), \\



	 		\Myspace (\findExcHandler{ \mbox{\rm\texttt{n} }.\exceptions[j] }{i}{\methodd.\excHandlerTable} = \bottom \Rightarrow \\  
					 \Myspace \forall \bound (  \\ 
						 \Myspace \Myspace \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j]) \subst{\EXC }{\bound } \Rightarrow \\ 
                                                 \Myspace\Myspace\Myspace  \methodd.\getExcPost (i,   \methodd.\exceptions[j] )\subst{\EXC }{\bound }    ) ) \\
						 \Myspace \wedge \\
						 \Myspace (\findExcHandler{ \mbox{\rm\texttt{m} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = k    \Rightarrow \\ 
 \Myspace \forall \bound (  \\ 
						 \Myspace \Myspace \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j]) \subst{\EXC }{\bound } \Rightarrow \\ 
                                                 \Myspace\Myspace\Myspace  \inter{i}{k} \begin{array}{l}
						                                           \subst{\counter}{0} \\
                                                                                           \subst{\stack{0} }{\bound }  
						                                        \end{array}) )
							
	 				 		\end{array}
							\end{array}
	 				 			$$ 
	 			

						Let us look in detail what is the meaning of the weakest precondition for method invokation.
						Because we are following a contract based approach 
						the caller, i.e. the current method  \methodd \ must establish several facts.
						First, we require that 
						the precondition \mbox{\rm\texttt{n}}.\pre \ of the invoked method \mbox{\rm\texttt{n}}  \ holds where the formal 
						parameters are correctly initialized with the
						first \mbox{\rm\texttt{n}}.\numArgs \ elements from the operand stack.
						
						Second, we get a logical statement which guarantees the correctness of the method invokation
						in case of normal termination.
						On the other hand, its postcondition \mbox{\rm\texttt{n}}.\normalPost \ is assumed to hold and thus, we want to establish that 
						under the assumption that \methodd.\normalPost{}  holds \ with \result{} substituted with a fresh bound variable $ \bound$
						and correctly initialized formal parameters
						is true we want to establish that the predicate \inter{i}{i+1 } \
						holds . This implication is quantified over the locations \mbox{\rm\texttt{n}}.\modif \ that a method may modify
						and the variable $ \bound$ which stands for the result that the invoked method \mbox{\rm\texttt{n}} \ returns.  
						
						The third part of the rule deals with the exceptional termination of the method invokation.
						In this case, if the invoked method \texttt{n} terminates on any exception which belongs to the array of 
						exceptions \texttt{n}.\exceptions{} that \texttt{n} may throw. Two cases are considered - either the thrown
						exception can be handled by \methodd{} or not. If the thrown exception  \texttt{Exc} can not be handled
						by the method \methodd \
						(i.e. $\findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}
						{\methodd.\excHandlerTable} = \bottom $) then if the exceptional postcondition predicate
						$ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ of \texttt{n} holds
						then  	$ \methodd.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ for any value of the thrown exception
						object. 
						In case the thrown  exception\texttt{Exc} is handled by \methodd, i.e. \\
						$ \findExcHandler{ \mbox{\rm\texttt{n} }.\excPostSpec 
						  ( \mbox{\rm\texttt{n} }.\exceptions[j])  }{i}{\methodd.\excHandlerTable} = k $   then if 
						the exceptional postcondition $ \mbox{\rm\texttt{n} }.\excPostSpec ( \mbox{\rm\texttt{Exc} })  $ 
						of \texttt{n} holds then the intermediate predicate $\inter{i}{k}$ 
						that must hold after $\ins{i}$ and before   $\ins{k}$ must hold once again for any value
						of thrown exception. 
						
						
						
						
						
					
\item throw exception instruction \\
				
							$$ \begin{array}{l}
							          \wpi{\instr{athrow }} {\methodd}{i}  = \\
								    \stack{\counter} = \Mynull \Rightarrow  \methodd.\getExcPost( i, \NullPointerExc) \\  
								     \wedge \\
							          \stack{\counter} \neq \Mynull \Rightarrow \\
								    \begin{array}{l}  
								       \forall  \mbox{\rm\texttt{Exc}}, \\  
								        \typeof{\stack{\counter}} <: \mbox{\rm\texttt{Exc}}   \Rightarrow \\
								        \Myspace \methodd.\getExcPost( i, \mbox{\rm\texttt{Exc}}    )\subst{ \EXC }{\stack{\counter}  } 
								       % \wedge \\
								       % \forall n, 0 \le n < \methodd.\excHandlerTable.length,  \\  
								       % \typeof{\stack{\counter}} <: \methodd. \excHandlerTable[n].\exc \Rightarrow \\
								       % \Myspace   \methodd.\getExcPost(i,\excHandlerTable[n].\exc  ) 
								                     
								    \end{array} 
							   \end{array}
							$$ \\
						The thrown object is on the top of the stack \stack{\counter}.
						If the stack top object \stack{\counter} \ is \Mynull, then the instruction \athrow will terminate on an exception
						\NullPointerExc \ where the predicate returned by the function $ \methodd.\excPost$ must hold.
						The case when  the thrown object is not \Mynull \  should consider all the possible exceptions that
						might be thrown by the current instruction. This is because we do not know the type of the thrown object which is
						on the stack top.
						The part of the \fwpi \ when the thrown object on the stack top  \stack{\counter} \ is not \Mynull \ considers all the possible types
						of the exception thrown. In any of 
						
						%Thus, the rule takes into account the case when the exception thrown is a not handled exception,
						%	i.e. the type    of \stack{\counter} is a subtype of any  of the exceptions \methodd.\exceptions \ that might be thrown
						%	by the current method \methodd. Thus, if  \athrow \ instruction throws a not handled exception \texttt{Exc} 
						%	then  the exceptional postcondition for  \texttt{Exc} must hold where the special exception variable \EXC \ 
						%	is substituted for the stack counter \stack{\counter}. 
 						%	The \fwpi \ considers also the case when the thrown exception object  might be handled by any of the
						%	exception handlers \methodd.\excHandlerTable \ of method \ \methodd. 
						%	In that case, once again the rule takes into account all the possible exception handler types as the type of the
						%	thrown exception is unknown.
						
	 		\end{itemize}
Supposing the execution of a method always terminates, the verification condition for a method \methodd \ with a
 precondition $\methodd.\pre$ is defined in the following way:
$$ \methodd.\pre \Rightarrow \wpi{\method.\body[0]}{\methodd}{0}$$





