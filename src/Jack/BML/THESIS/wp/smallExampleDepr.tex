\section{Example}\label{wp:example}
In the following, we  shall see what are the resulting preconditions 
that the \fwpi{} will calculate for the instructions in the bytecode from the program in Fig. \ref{wp:example:sum}.








\begin{figure}
\begin{lstlisting}[frame=trbl]
//@ ensures \result == i*i; 
public int square( int i ) { 
  int sqr  = 0;
  if ( i < 0) {
    i = -i;
  }
  //@ loop_modifies s, sqr;
  //@ loop_invariant (0 <= s) && (s <= i) && sqr == s*s ;
  for (int s = 0 ; s < i; s++ ) {
    sqr = sqr + 2*s + 1;
  }
  return sqr;
}

\end{lstlisting} 
\caption{\sc Java method which calculates the square of its input  }
\label{wp:example:sqrSrc}
\end{figure}


\begin{figure}
\begin{minipage}[t]{32mm}
\begin{lstlisting}[frame=trbl]
0  const 0
1  store 2
2  load 1
3  if\_ge 7 
4  load 1
5  neg
6  store 1
7  const 0
8  store 3
9  goto 19 
10 load 2
11 const 2
12 load 3
13 mul
14 add
15 const 1
16 add
17 store 2
18 iinc 3
//loop start
19 load 3 
20 load 1
21 if\_icmplt 10
22 load 2
23 return
\end{lstlisting} 
\end{minipage}

\phantom{aaaaa}

\begin{minipage}[t]{20mm}
$$\begin{array}{l}
 \mbox{\rm\lstinline!square!}. \normalPost = \result == \locVar{1}* \locVar{1} \\ 
 \mbox{\rm\lstinline!square!}.\loopSpecTable =  \\
        \left\{  \begin{array}{l}  \posL   = 19 \\\\
                          \invL   =\begin{array}{l} 
                                     0 <= \locVar{3}  \wedge \\
				     \locVar{3}<= \locVar{1}   \wedge \\
                                    \locVar{2} = \locVar{3} *\locVar{3}
                                   \end{array}\\ \\
	                  \modifL =  \locVar{3}, \locVar{2}\\
			  \end{array}\right.
         \end{array}$$
\end{minipage}
\caption{\sc  bytecode of method \lstinline!square! and its specification }
\label{wp:example:sqrBc}
\end{figure}
Fig.\ref{wp:example:sqrBcVc} shows the weakest preconditions for some of the instructions in the bytecode of the method  \lstinline!square!.
In the figure, the line before every instruction gives the calculated weakest precondition of the instruction in the execution path which reaches the end 
of the method. Thus, the weakest precondition of the instruction  \return \ at line 28 states that before the instruction is executed the stack top element
\stack{\counter}  must  contain the square of the local variable \locVar{1}. Note that this precondition is calculated from the method postcondition 
which is given in curly brackets at line 38.
The instruction before the \return \ instruction has as precondition that the local variable \locVar{2} must be equal to the square of \locVar{1}.
 The instruction \ifCond \ at line 24  has as weakest precondition that   if the stack element below the stack top element \stack{\counter - 1}
 is not smaller than    \stack{\counter } then  \locVar{2} == \locVar{1}*\locVar{1}. Note that we give only a part of the precondition of this instruction for the sake
of clarity. In particular, we give the precondition which must hold if the condition is not true, or in other words the precondition of the \ifCond \ instruction for the execution path which goes to the end of the method. 
The  case which deserves more attention is the instruction \goto \ at line 14 which jumps to the loop entry instruction at line 21. 
As  discussed in Section \ref{wp:interPred}, the weakest precondition of this \goto consists in the specified loop invariant and the a formula
which states that the invariant implies the precondition of the loop entry.  

Another point to notice is that the instruction at line 19 which is a loop end instruction w.r.t. Def \ref{defLoop} has as precondition the loop invariant where the 
\locVar{3} is incremented.

\begin{figure}
\begin{lstlisting}[frame=trbl]
...
// invariant initialization
{   0 <= lv(3) && 
    lv(3) <= lv(1) && 
    lv(2) = lv(3) * lv(3) } 
// invariant implies the loop postcondition 
{ forall lv(3), forall lv(2),
    0 <= lv(3) && 
    lv(3) <= lv(1) && 
    lv(2) = lv(3) * lv(3) &&
    not(lv(3) < lv(1))==> 
       lv(2) = old(lv(1)) * old(lv(1)) }
9  goto 19

...

{  0 <= lv(3) + 1 && 
    lv(3) + 1 <= lv(1) && 
    lv(2) = (lv(3) + 1) * ( lv(3) + 1) } 
18 iinc 3

{ not (lv(3) < lv(1)) ==>lv(2) == lv(1)*lv(1) }
19 load 3 //loop start

{ not (st(cntr) < lv(1))==>lv(2)==lv(1)*lv(1) }
20 load 1

{not ( st(cntr - 1)<st(cntr))==>lv(2) == lv(1)*lv(1)}
21 if icmplt 10

{lv(2) == lv(1)*lv(1)   }
22 load 2

{st(cntr) == lv(1)*lv(1) }
23 return

{ \result == lv(1)*lv(1) }
\end{lstlisting} 
\caption{\sc  bytecode of method \lstinline!square! and weakest preconditions for  a fragment of the execution path which reaches the method end}
\label{wp:example:sqrBcVc}
\end{figure}


