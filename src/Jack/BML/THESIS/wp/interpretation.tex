

\newtheorem{interpExpr}{Definition}[subsection]
\newtheorem{interpTypeExpr}[interpExpr]{Definition} 
\newtheorem{interpPred}[interpExpr]{Definition}
\newtheorem{valid}[interpExpr]{Definition}

\subsection{Interpretation }\label{interpret}

We discuss the evaluation of expressions and interpretation of predicates  in a particular program state configuration.
Thus, we first define a function for expression evaluation, as well as a function which for a given state and predicate returns the interpretation
of the given predicate in the given state. 
The function $eval$ will evaluate expressions in a given state:
$$
eval : \expressionsWp \rightarrow \SetConfigs \rightarrow \Values \cup \JavaType
$$




\begin{interpExpr}[Evaluation of expressions] \label{interpExpr} 
The evaluation in a state \\
$s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$  or $s = \configFinal{\heap}{\locVarOnly}{\Final }$  of an expression $\expressionsWp$
 is denoted with $\evalExp{\expressionsWp}{s}$  and is defined inductively on the grammar of expressions $\expressionsWp$ \  as follows:
 
$$
\begin{array}{l}
\evalExp{ v  }{s } = v\\
  where \  v \in \  \Myint   \ \vee  \  v \in  \RefValues \\
\\
 \evalExp{\fieldd(\expressionsWp ) }{s} = \\
 = \heap(\fieldd) (\evalExp{ \expressionsWp}{ s } ) \\
\\

 \evalExp{\update{\fieldd}{\expressionsWp_1}{\expressionsWp_2}(\expressionsWp_3)}{ s } = \\
=  \update{\heap}{\fieldd }{\update{\fieldd}{  \evalExp{\expressionsWp_1}{s } }{ \evalExp{\expressionsWp_2}{s }  }} (\fieldd)
                                            (  \evalExp{\expressionsWp_3}{ s } ) \\
 \\


 \evalExp{\arrayAccess{\expressionsWp_1} {\expressionsWp_2}  }{ s } = \\

 = \heap (\evalExp{ \expressionsWp_1}{ s } ,\evalExp{ \expressionsWp_2}{ s } )   \\
\\

 \evalExp{ \update{ \arrayAccessOnly}{ (\expressionsWp_1 , \expressionsWp_2)}{ \expressionsWp_3} (\expressionsWp_4,\expressionsWp_5)  } { s } = \\
 = \update{\heap}{ ( \evalExp{\expressionsWp_1}{s } ,  \evalExp{\expressionsWp_2}{s } ) }  
                 { \evalExp{\expressionsWp_3}{s }}
                 ( \evalExp{\expressionsWp_4}{s } ,  \evalExp{\expressionsWp_5}{ s  } ) \\
\\
 \evalExp{ \locVar{i} } { s } = \locVarOnly(i) \\
\\

 \evalExp{\expressionsWp_1 \ \op \ \expressionsWp_2   } { s } =   \evalExp{\expressionsWp_1}{s} \op  \evalExp{\expressionsWp_2}{s}  \\

\\
\evalExp{ \typeof{\expressionsWp}}{s } = \\
\left\{\begin{array}{ll}
      \Myint                                           & \evalExp{\expressionsWp}{s} \in \Myint \\
      \heap. \heapTypeOf(\evalExp{\expressionsWp}{s} ) & else \\
	   
\end{array}\right. \\

\\ 
\evalExp{ \elemtype{\expressionsWp}}{s } = \\  
\left\{\begin{array}{ll}
            \mbox{ \rm \texttt{T} }  & if \   \heap. \heapTypeOf(\evalExp{\expressionsWp}{s} ) = \mbox{ \rm \texttt{T[ ] } } 
\end{array}\right. \\					    
\\

\evalExp{ \TYPE }{s } = \mbox{ \rm \texttt{java.lang.Class}} 
\end{array}
$$

The evaluation of stack expressions can be done only in intermediate state configurations $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ :
$$
\begin{array}{ll}
 \evalExp{ \counter   } { s } = \counterOnly \\
\\

 \evalExp{ \stack{ \expressionsWp}   } { s } = \stackOnly ( \evalExp{\expressionsWp}{s} ) \\
\\

\end{array}
$$
The evaluation of the following expressions can be done only in a final state $s = \configFinal{\heap}{\locVarOnly}{\Final }$:
$$
\begin{array}{ll}
\evalExp{ \result }{s } = \Res  & where \ s=  \configFinalNorm{\heap}{\locVarOnly}{\Res} \\
\evalExp{ \EXC }{s } = \Exc  & where \ s=  \configFinalExc{\heap}{\locVarOnly}{\Exc}
\end{array}
$$
  

\end{interpExpr}



 
The relation $\vDash$ that we define next, gives a meaning to the formulas from our
 assertion language $\predWp$.
%$$ \vDash :  \SetConfigs *  \predWp  $$
 
\begin{interpPred}[Interpretation of predicates] \label{interpPred} 
The interpretation $ s \vDash \predWp$ of a predicate $\predWp$ in a state configuration $s$ is defined inductively as follows:
$$
\begin{array}{l}
\interp{\true}{s} \  is \ true \ in \ any \ state \ s \\
\\
\interp{\false}{s} \ is \ false \ in \ any \ state \ s \\
\\

\interp{\predWp_1  \wedge  \predWp_2 }{s} \ iff \ \interp{\predWp_1}{s} \ and \ \interp{\predWp_2}{s}  \\
\\

\interp{\predWp_1  \vee  \predWp_2 }{s} \ iff \ \interp{\predWp_1}{s} \ or \ \interp{\predWp_2}{s}  \\
\\
\interp{\predWp_1  \Rightarrow  \predWp_2 }{s} \ iff \ if \ \interp{\predWp_1}{s} \ then \ \interp{\predWp_2}{s}  \\
\\
\interp{\predWp_1  \iff \predWp_2 }{s} \ iff \  \interp{\predWp_1}{s} \ if \ and \ only \ if  \ \interp{\predWp_2}{s}  \\
\\
\interp{\forall x : T .  \predWp(x)   }{s} \ iff \ forall \ value \ \mbox{ \rm \textbf{v}} \ of \  type \  T \ \interp{\predWp(\mbox{ \rm \textbf{v}})}{s}  \\
\\

\interp{\exists x : T .  \predWp(x)   }{s} \ iff \ a \ value \ \mbox{ \rm \textbf{v}} \ of \  type \  T \ exists \ such \ that \ \interp{\predWp(\mbox{ \rm \textbf{v}})}{s}  \\
\\
\interp{\exprWp_1 \  \predicates \  \exprWp_2 }{s} \ iff \begin{array}{l}
                                                              \evalExp{\exprWp_1 }{s} \neq \bottom \wedge \\
							       \evalExp{\exprWp_2 }{s}\neq \bottom \wedge \\
                                                             \evalExp{\exprWp_1 }{s} \evalRel{\predicates }  \evalExp{\exprWp_2 }{s} \ is  \ true
							     \end{array}
\end{array}
$$   
\end{interpPred}
