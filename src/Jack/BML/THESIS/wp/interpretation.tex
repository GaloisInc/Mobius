

\newtheorem{interpExpr}{Definition}[subsection]
\newtheorem{interpTypeExpr}[interpExpr]{Definition} 
\newtheorem{interpPred}[interpExpr]{Definition}


\subsection{Interpretation }\label{interpret}

We discuss the evaluation of expressions and interpretation of predicates  in a particular program state configuration.
Thus, we first define a function for expression evaluation, as well as a function which for a given state and predicate returns the interpretation
of the given predicate in the given state. 
The function $eval$ which evaluates expressions in a state has the following signature:
$$
eval : \expressionsWp \rightarrow \SetConfigs  \rightarrow \SetConfigs  \rightarrow \Values \cup \JavaType \cup \bottom
$$
Note that the evaluation function takes as arguments an expression ($\expressionsWp$ ) of the assertion language presented in the previuos Section 
\ref{exprLang}, the current state as well as the initial state of the current method and returns a value as defined in Section \ref{types}.
%The function $eval$ associates a value to expressions from  \expressionsWp  \  if they have a value in the state.
%For instance, a reference which is not in the domain of the  



\begin{interpExpr}[Evaluation of expressions] \label{interpExpr} 
The evaluation in a state \\
$s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$  or $s = \configFinal{\heap}{\locVarOnly}{\Final }$  of an expression $\expressionsWp$
w.r.t. an initial state $ s_{init} = \config{\heap_{init}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $  s.t. 
$s_{init} \stateTrans^{*} s $ 
is denoted with $\evalExp{\expressionsWp}{s}$  and is defined inductively on the grammar of expressions $\expressionsWp$ \  as follows:
 
$$
\begin{array}{l}
\evalExp{ v  }{s } = v\\
  where \  v \in \  \Myint   \ \vee  \  v \in  \RefValues \\
\\
 \evalExp{\fieldd(\exprWp ) }{s} = \\
 = \heap(\fieldd) (\evalExp{ \exprWp}{ s } ) \\
\\

 \evalExp{\update{\fieldd}{\exprWp_1}{\exprWp_2}(\exprWp_3)}{ s } = \\
=  \update{\heap}{\fieldd }{\update{\fieldd}{  \evalExp{\exprWp_1}{s } }{ \evalExp{\exprWp_2}{s }  }} (\fieldd)
                                            (  \evalExp{\exprWp_3}{ s } ) \\
 \\


 \evalExp{\arrayAccess{\exprWp_1} {\exprWp_2}  }{ s } = \\

 = \heap (\evalExp{ \exprWp_1}{ s } ,\evalExp{ \exprWp_2}{ s } )   \\
\\

 \evalExp{ \update{ \arrayAccessOnly}{ (\exprWp_1 , \exprWp_2)}{ \exprWp_3} (\exprWp_4,\exprWp_5)  } { s } = \\
 = \update{\heap}{ ( \evalExp{\exprWp_1}{s } ,  \evalExp{\exprWp_2}{s } ) }  
                 { \evalExp{\exprWp_3}{s }}\\
                 \Myspace ( \evalExp{\exprWp_4}{s } ,  \evalExp{\exprWp_5}{ s  } ) \\
\\
 \evalExp{ \locVar{i} } { s } = \locVarOnly(i) 
\end{array}$$

$$\begin{array}{l}
 \evalExp{ \old{\exprWp} } { s } =\evalExp{ \exprWp }{  s_{init}} \\
\\ 
 \evalExp{\exprWp_1 \ \op \ \exprWp_2   } { s } =   \evalExp{\exprWp_1}{s} \op  \evalExp{\exprWp_2}{s}  \\

\\
\evalExp{ \typeof{\exprWp}}{s } = \\
\left\{\begin{array}{ll}
      \Myint                                           & \evalExp{\exprWp}{s} \in \Myint \\
      \heap. \heapTypeOf(\evalExp{\exprWp}{s} ) & else \\
	   
\end{array}\right. \\

\\ 
\evalExp{ \elemtype{\exprWp}}{s } = \\  
\left\{\begin{array}{ll}
            \mbox{ \rm \texttt{T} }  & if \   \heap. \heapTypeOf(\evalExp{\exprWp}{s} ) = \mbox{ \rm \texttt{T[ ] } } 
\end{array}\right. \\					    
\\

\evalExp{ \TYPE }{s } = \mbox{ \rm \texttt{java.lang.Class}} 
\end{array}
$$

The evaluation of stack expressions can be done only in intermediate state configurations $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ :
$$
\begin{array}{ll}
 \evalExp{ \counter   } { s } = \counterOnly \\
\\

 \evalExp{ \stack{ \exprWp}   } { s } = \stackOnly ( \evalExp{\exprWp}{s} ) \\
\\

\end{array}
$$
The evaluation of the following expressions can be done only in a final state $s = \configFinal{\heap}{\locVarOnly}{\Final }$:
$$
\begin{array}{ll}
\evalExp{ \result }{s } = \Res  & where \ s=  \configFinalNorm{\heap}{\locVarOnly}{\Res} \\
\evalExp{ \EXC }{s } = \Exc  & where \ s=  \configFinalExc{\heap}{\locVarOnly}{\Exc}
\end{array}
$$
  

\end{interpExpr}



 
The relation $\vDash$ that we define next, gives a meaning to the formulas from our
 assertion language $\predWp$.
%$$ \vDash :  \SetConfigs *  \predWp  $$
 
\begin{interpPred}[Interpretation of predicates] \label{interpPred} 
The interpretation $ s \vDash \predWp$ of a predicate $\predWp$ in a state configuration $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ 
w.r.t. an initial state  $ s_{init} = \config{\heap_{init}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $ s.t. 
$s_{init} \stateTrans^{*} s $   is defined inductively as follows:
$$
\begin{array}{l}
\interp{\true}{s} \  is \ true \ in \ any \ state \ s \\
\\
\interp{\false}{s} \ is \ false \ in \ any \ state \ s \\
\\

\interp{\predWp_1  \wedge  \predWp_2 }{s} \ iff \ \interp{\predWp_1}{s} \ and \ \interp{\predWp_2}{s}  \\
\\

\interp{\predWp_1  \vee  \predWp_2 }{s} \ iff \ \interp{\predWp_1}{s} \ or \ \interp{\predWp_2}{s}  \\
\\
\interp{\predWp_1  \Rightarrow  \predWp_2 }{s} \ iff \ if \ \interp{\predWp_1}{s} \ then \ \interp{\predWp_2}{s}  \\
\\
\interp{\predWp_1  \iff \predWp_2 }{s} \ iff \  \interp{\predWp_1}{s} \ if \ and \ only \ if  \ \interp{\predWp_2}{s}  \\
\\
\interp{\forall x : T .  \predWp(x)   }{s} \ iff \ forall \ value \ \mbox{ \rm \textbf{v}} \ of \  type \  T \ \interp{\predWp(\mbox{ \rm \textbf{v}})}{s}  \\
\\

\interp{\exists x : T .  \predWp(x)   }{s} \ iff \ a \ value \ \mbox{ \rm \textbf{v}} \ of \  type \  T \ exists \ such \ that \ \interp{\predWp(\mbox{ \rm \textbf{v}})}{s}  \\
\\
\interp{\exprWp_1 \  \predicates \  \exprWp_2 }{s} \ iff \begin{array}{l}
                                                              \evalExp{\exprWp_1 }{s} \neq \bottom \wedge \\
							       \evalExp{\exprWp_2 }{s}\neq \bottom \wedge \\
                                                             \evalExp{\exprWp_1 }{s} \evalRel{\predicates }  \evalExp{\exprWp_2 }{s} \ is  \ true

							     \end{array} \\
\\

\interp{\instances(\referenceOnly) }{s}, where \ \referenceOnly \in \RefValues \ iff \    \isInList{\referenceOnly }{ \getLocations{\heap_{init}}}  
\end{array}
$$   
\end{interpPred}
