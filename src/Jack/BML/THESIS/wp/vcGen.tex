\newtheorem{thmVC}{Definition}[section]

\subsection{Verification conditions} \label{wp:vcMeth}
Let us see now how with the help of the \wpName{} we can express 
formulas whose validity implies the correctness of a program in our language.
We shall express program correctness in terms of correctness of
methods declared in the classes of a program. 
In particular, the verification conditions  for a program  is the set of 
 the verification conditions for all the classes in \Program{}.
The verification conditions for a class are the verification conditions for
all methods declared in a class. 
Method correctness is understood 
as the compliance between the specified method contract (pre and
postconditions) and method implementation. 
Moreover, if a method in a class overrides a method declared in a super type
the correctness of the overriding method requires that it behaves as the
method it overrides. 

Thus, in the following, we take a closer look at
 the formulas that concern method correctness.

\subsubsection{Method implementation respects method contract}
Supposing the execution of a method always terminates, the verification condition which expresses the fact that 
 a method \methodd{}  respects its specification 
states that the specified method precondition  \methodd.\pre{} implies the
 predicate \wpi{}{\methodd}{0}  calculated over the body of
 \methodd{}. Moreover,  we have few more assumptions concerning the register (local) variables
 which store the receiver object and the method parameters. Those assumptions
 actually reflect properly the semantics of our programming language. Thus the
 verification condition  will be as shown in the following: % Fig. \ref{vc:impl}. 
%\begin{frameit}
\begin{thmVC}\label{wp:vc:impl}The verification condition which expresses that a method \methodd{}
  respects its specification precondition \methodd.\pre{}, postcondition
  \methodd.\normalPost{} and exceptional postcondition function   \methodd.\excPostSpec{} is:

 $$ \methodd.\pre  \wedge \locVar{0} \wedge \instances( \locVar{0} ) \wedge
\neq \Mynull   
\wedge \instancesLocVars(\methodd )  \wedge \subTypesLocVars(\methodd )   \Rightarrow
 \wpi{}{\methodd}{0} $$
\end{thmVC}
%\caption{Verification condition for that method implementation respects method
%specification}\label{vc:impl}
%\end{frameit}
As we can see, the verification condition assumes not only the specified
 method precondition but also  that the local variable
\locVar{0} which stores the current object is not \Mynull{} and that it
 contains a reference to an object in the heap. Actually, this is
 a natural condition as because of the semantics of our language
 method may be executed only on a non null reference which belongs to the
 current heap. Next, we also take as  a hypothesis the formula  \instancesLocVars{} which is
parameterized by the method \methodd{} and   which stands stands for:

$$ \instancesLocVars(\methodd  )  =  \forall i.
 1 \le i \le \methodd.\numArgs,  \methodd. \args[i] <: \Object \Rightarrow  \instances( \locVar{i} )
  \vee \locVar{i} = \Mynull
$$

Thus we constrain the values of the local variables which are of reference
type( i.e. are of type which is a subtype  of the root class \Object{} of all
reference types) to be either a reference to an object allocated in the
heap or \Mynull. This is also in correspondence with the semantics of the
language, which manipulates either references which are in the domain
of the heap or are \Mynull.

The next formula in the assumption of the verification condition is
\instancesLocVars{} also parameterized with \methodd{} which stands for the
following:

$$ \subTypesLocVars (\methodd)  =  \forall i.
 0 \le i \le \methodd.\numArgs,  \typeof{\locVar{i}} <: \methodd. \args[i]
$$

Thus we assume that any local variable $\locVar{i}, 0 \le i \le \methodd.\numArgs$ 
 (including the local variable \locVar{0} which stores reference to the current
object) is assumed to be with the expected type $\locVar{i} <: \methodd. \args[i]$  with which it is declared.

Consider for instance, the simple method which assigns the value 3
to a field \fieldd{} of the receiver object stored in the method register
\locVar{1}.  
\begin{lstlisting}[frame=trbl]
A {
 int (*@ \fieldd @*);

//@ requires (*@  \Mytrue  @*)
//@ ensures  (*@ $\fieldAccess{\locVar{0}}{ \fieldd} = 3 $ @*)
//@ exsures (Exception ) (*@ \Myfalse @*)
 m (  )
  load 0
  const 3 
  putfield (*@ \fieldd @*)
  return
} 
\end{lstlisting}

This method respects its specification as in its body it assigns the value 3
to the field \fieldd{} of the current object. Its verification condition is:  
$$  \begin{array}{l} (\Mytrue  \wedge \locVar{0} \neq \Mynull   \wedge
  \instancesLocVars{} \wedge \subTypesLocVars  ) \Rightarrow\\   
  \begin{array}{l}
 \locVar{0} \neq \Mynull \Rightarrow \fieldAccess{\locVar{0}}{\update{
  \fieldd}{\locVar{0} } {3}} = 3 \\ 
  \wedge \\
\locVar{0} = \Mynull \Rightarrow \Myfalse 
\end{array}  \end{array}
  $$
We can see that the verification condition also holds. The first conjunct in it
 corresponds to a normal termination of the method 
and holds because the left hand side of the equality simplifies to 3. The
second conjunct concerns the exceptional termination of the method (in case the
dereferenced object by the instruction \putfield{} is  \Mynull). This case
also holds because of the contradiction of in the hypothesis where \locVar{0}
is both  equal and different from \Mynull.


\subsubsection{Behavioral subtyping}
As we said above, in an object oriented language with subclassing and 
method overriding, the notion of method correctness 
must also include the fact that the behavior of an overriding 
 method conforms with the semantics of the method it overrides.


We illustrate the importance of this issue by the following example: 
\begin{lstlisting}[frame=trbl]
A {
//@ requires Pre1;
//@ ensures  Post1;
int m ( ){...}
}

B extends A{  
//@ requires Pre1;
//@ ensures  Post1;
 m ( ){...}
}

C {
 n(A a) {
 int a.m();
 }
}
\end{lstlisting}

 In the example,  the class \lstinline!B! extends the class  
 \lstinline!A!   and overrides the method \lstinline!m!. The last part of the
 example shows a method \lstinline!n! declared in class 
 \lstinline!C! which makes a call to  \lstinline!m! over the method parameter
  \lstinline!a!  declared with static type the class \lstinline!A!.  If we had
 to verify this method call, as we saw in the previous section we would use
 the specification of method \lstinline!m! declared in \lstinline!A!, i.e. the
 precondition \lstinline!Pre1! and the postcondition  \lstinline!Post1!.
 Unfortunately, this is not sufficient to establish the correctness of the
 method \lstinline!n! as the dynamic type of the parameter  \lstinline!a!
 might be  \lstinline!B! and we do not have any guarantee that the overriden
 method and its specification makes the verification condition for method
 \lstinline!n! valid. 

 One way to cope with this situation is  to generate verification conditions
 at every method call site
 for all the methods and their specifications that  override the called method (methods with the
 same signature declared in the subclasses of the static type of the object over
 which the method call is done) respect. But this solution is not modular as
 it requires to reverify the whole program every time a new subclass extension
 is made in the program. Such approach is taken in \cite{AP98LFT}.

 We adopt here an alternative solution which  consists in the following.
If a method \methodd{} declared in a class \lstinline!B! overrides 
 method   \lstinline!A! from the super
 class \texttt{B} of \texttt{A}, the specification of method \methodd{} must conform with the specification of method   \mbox{\rm\texttt{n}}:
  This is expressed by the two  conditions ( contravariant and covariant) over their pre and postconditions:
        \begin{itemize}
           \item the precondition of the  overriden method \mbox{\rm\texttt{n}} must  imply
                 the precondition of the overriding method
                 \methodd{}. Intuitively, this means that where the overriden
                 method is called the overriding method can be also called.
           \item the postcondition of the overriding method  \methodd{}  must imply 
                 the postcondition of the overriden method \mbox{\rm\texttt{n}}. This  must be true for normal postcondition and
                 every  exceptional postcondition case. This
                 means that the overriding method guarantees stronger
                 properties than the overriden method 
        \end{itemize}


%Fig. \ \ref{vc:subty} shpws
In the next, we  show the  conditions for establishing the
 correctness of a method \methodd{} if method \methodd{}  overrides method \mbox{\rm\texttt{n}}:
\begin{thmVC}\label{wp:vc:subt}{Verification conditions for correct subtyping}
The verification condition which express that a method \methodd{} which overrides
method   \mbox{\rm\texttt{n}} is a behavioral subtype is given in the following:

%\begin{figure}
%\begin{frameit}


$$ 
  \begin{array}{l} 
          \forall  \boundVar_0,  \ldots , \boundVar_{\mbox{\rm\texttt{n}}.\numArgs },\\
      \left(  \begin{array}{l}  \left( \begin{array}{l}
          \mbox{\rm\texttt{n}}.\pre \wedge  
          \locVar{0} \neq \Mynull \wedge
          \instances(\locVar{0}) \wedge\\
          \instancesLocVars(\mbox{\rm\texttt{n}} )  \wedge 
          \subTypesLocVars(\mbox{\rm\texttt{n}} ) 
            \end{array}\right) %\subst{\locVar{i} }{ \boundVar_i}_{i=0}^{\mbox{\rm\texttt{n}}.\numArgs }
            \Rightarrow %\\
          \methodd{}.\pre  \end{array}\right) \subst{\locVar{i} }{ \boundVar_i}_{i=0}^{\mbox{\rm\texttt{n}}.\numArgs }  
\\\\
 

         \forall \boundVar, \boundVar_0,  \ldots ,\boundVar_{\mbox{\rm\texttt{n}}.\numArgs },\\
           \left(  \begin{array}{l}  \left( \begin{array}{l}
             
             \methodd{}.\normalPost \subst{\result}{\boundVar} \wedge  
             \boundVar <: \mbox{\rm\texttt{n}}.\retType \wedge\\
             \locVar{0} \neq \Mynull \wedge
             \instances(\locVar{0}) \wedge\\
             \instancesLocVars(\mbox{\rm\texttt{n}} ) \wedge
             \subTypesLocVars(\mbox{\rm\texttt{n}} ) \wedge\\
             \instances(\locVar{0})  \end{array}\right)
       \Rightarrow \mbox{\rm\texttt{n}}.\normalPost \subst{\result}{\boundVar}
        \end{array}\right)\subst{\locVar{i} }{ \boundVar_i}_{i=0}^{\mbox{\rm\texttt{n}}.\numArgs }
          

 \\\\

          \forall \boundVar, \boundVar_0,  \ldots ,\boundVar_{\mbox{\rm\texttt{n}}.\numArgs },\\
        \left( \begin{array}{l} 
           \left( \begin{array}{l} 
           \methodd{}.\excPostSpec(\mbox{\rm\texttt{Exc}}  ) \subst{\EXC}{\boundVar}  \wedge  \\ 
           \instances(\boundVar) \wedge \\
           \boundVar <: \mbox{\rm\texttt{Exc}} \wedge\\
           \locVar{0} \neq \Mynull \wedge\\
           \instances(\locVar{0}) \wedge\\
           \instancesLocVars \wedge 
           \subTypesLocVars\\
          \end{array}\right)
          \Rightarrow
          \mbox{\rm\texttt{n}}.\excPostSpec(\mbox{\rm\texttt{Exc}}) \subst{\EXC}{\boundVar}  \end{array}\right)\subst{\locVar{i} }{ \boundVar_i}_{i=0}^{\mbox{\rm\texttt{n}}.\numArgs } 
          \\ \\
          where \ \mbox{\rm\texttt{Exc}} \in \mbox{\rm\texttt{n}}.\exceptions
   \end{array}
$$
\end{thmVC}
%\caption{Verification conditions for behavioral subtyping}\label{vc:subty}
%\end{frameit}
%\end{figure}
As in the verfication conditions conditions concerning  only method
specification above, they all use additional assumption concerning the types
and values of the local variables. As explained above, the first condition expresses the fact that
the precondition of the overriding method is stronger than the precondition it
overrides. This is the so called contravariant rule. Note that the implication
 must hold for any valid value of the local variables  (i.e. for those of reference type they must be valid references in the heap and moreover, the receiver
of the call  must be not \Mynull)
 
The second  condition expresses the fact that the normal postcondition of the
 overriding method is stronger than than the postcondition specified in the
  method it overrides. We quantify over the postcondition result as well as the values of the local variables including the receiver
 of the method call \locVar{0}.
 The third formula represents a series of
  formulas which show that the postcondition for any exceptional outcome of
  the overriding method on any exception type \texttt{Exc} declared in   \mbox{\rm\texttt{n}}.\exceptions
 must respect the condition of the overriden method.  Similarly, we want that the implication holds for any
 values of the local variables and of the exception object which of the expected exception type \texttt{Exc}. 

Note that here, because we do not treat \oldOnly{} expressions, the verification condition is simple w.r.t. 
verification conditions which might take into account the initial state.
 The latter involves a modelisation of the heap which expresses the relation between the initial and final states of a method execution. 
A detailed explanation for how to construct such verification conditions may refer to  \cite{CP03VTO}.

