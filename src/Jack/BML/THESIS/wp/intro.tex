\newtheorem{defLoop}{Definition}[section] 
\newtheorem{defInter}[defLoop]{Definition}
\newtheorem{defExc}[defLoop]{Definition}
\newtheorem{defInv}[defLoop]{Definition}
\newtheorem{defModif}[defLoop]{Definition}

\newtheorem{propPath}{Lemma}[section]

This section describes a Hoare style verification condition generator for bytecode based on a weakest precondition predicate transformer function.
 
% motivations
A natural question is to ask what are the motivations behind building a bytecode verification condition generator (vcGen for short)
while a considerable list of tools for source code verification exists.
We consider that today's software industry requires more and more guarantees about software security especially when
mobile computing becomes a reality. Thus in mobile code scenarios, performing verification on source code of untrusted executable
 unit requires a trust in the compiler but which is not always reasonable. On the other hand,
 type based verification used for example, in the Java bytecode verifier could not deal with complex functional or security
 properties which is the case for a verification condition generator.   
%technical
The vcGen is tailored to the bytecode language introduced in Section \ref{opSem} and thus, it deals
with stack manipulation, object creation and manipulation, field access and update, as well as exception throwing and handling.

%related work
Bytecode verification has become lately quite fashionable, thus several works exist on bytecode verification. Section \ref{relWorkWp}
is an overview of the existing work in the domain.



%what is different w.r.t source
Performing Hoare style logic verification over an unstructured program like bytecode programs has few particularities which
verification of structured programs lacks. For example loops on source level correspond to a syntactic structure in the source language and thus, identifying
a loop in a source program is not difficult.  However, this is not the case for unstructured programs. 
As we saw in the previous section \ref{bcsl}, our approach consists in compiling source specification into
bytecode specification. When compiling a loop invariant, we need to know where exactly in the bytecode the invariant must hold.
Section \ref{prelim} introduces the notion of a loop in an unstructured program.

% definition of the wp
As we stated earlier, our verification condition generator is based on a weakest precondition (wp) calculus. As we shall see in Section  \ref{wpRules}
a wp function for bytecode is similar to a wp function for source code. However, a logic tailored to stack based bytecode should take into account 
particular bytecode features as for example the operand stack.

% proof of correctness
%An important question is the correctness of our methodology, i.e. what guarantees that if the verification procedure succeeds on a program then 
%the program respects  for real the property that we verified for. A skatch of the proof of correctness is presented in Section \ref{proof}
% w.r.t. the operational semantics of our bytecode language introduced in Section \ref{opSem}. 
 





 
