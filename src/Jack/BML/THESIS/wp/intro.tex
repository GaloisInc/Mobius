
This section describes a Hoare style verification condition generator for bytecode based on a weakest precondition predicate transformer function.
 

%technical
The vcGen is tailored to the bytecode language introduced in Section \ref{opSem} and thus, it deals
with stack manipulation, object creation and manipulation, field access and update, as well as exception throwing and handling.
Different ways of generating verification conditions exist. The verification condition
 generator presented  propagates the weakest precondition and exploits the information 
about the modified locations by methods and loops. 
%In Section \ref{wp:discussionVC}, we discuss the existing approaches and motivate the choices done here.

% definition of the wp
In Section \ref{assertLang}, we discuss the assertion language which the  formalization of 
the verification condition generator manipulates. The assertion language consists of a subset of the BML language 
extended with few new constructs.
In Section \ref{methExtend}, we show the data structures which encode the specification. 
In Section  \ref{wpRules}, we focus on the verification calculus.
As we stated earlier, our verification condition generator is based on a weakest precondition (wp) calculus.
 However, a logic tailored to stack based bytecode should take into account 
particular bytecode features as for example the operand stack. Another particularity of the verification condition calculus 
is the propagation of verification conditions up to the program point similar to the definition of the weakest precondition calculus
for the Java-like  source language in Chapter \ref{javaVerif}. To do this, we define the  weakest precondition predicate transformer
in terms of two mutually recursive functions. 
The first one calculates the precondition of instructions over an intermediate predicate which should hold 
in between the current instruction and 
its successor. A predicate which must hold between an instruction and its successor 
depends on the precondition of the successor and the execution relation between the two instructions, namely 
it depends on if the successor is a loop entry or not.
Section \ref{wp:example} gives an example for how the verification condition generator works.
Finally, section \ref{relWorkWp} is an overview of the existing work in the domain.
% proof of correctness
%An important question is the correctness of our methodology, i.e. what guarantees that if the verification procedure succeeds on a program then 
%the program respects  for real the property that we verified for. A skatch of the proof of correctness is presented in Section \ref{proof}
% w.r.t. the operational semantics of our bytecode language introduced in Section \ref{opSem}. 
 





 
