
\subsection{Intermediate predicates} \label{wp:interPred}
In this subsection, we define the function $\interOnly$ which for two instructions that may execute one
after another in a control flow graph  of  method \methodd \ determines the predicate $\inter{j}{k}$ which must hold in between them.
The function has the signature:
$$ \interOnly: int \longrightarrow int  \longrightarrow \MethodSet \longrightarrow \predWp $$ 


 The predicate $\inter{j}{k}$ will be used for determining the weakest predicate that must hold in the poststate of the instruction
 $\ins{j}$ in the execution path where  \ins{j} is followed by the instruction $\ins{k}$.
 This predicate depends on the execution relation between the two instructions $\ins{j}$ and $\ins{k}$.
 Recall that  we introduced the notion of execution  relation between two instructions  in Chapter \ref{opSem},
 Section \ref{prelim:ctrFlow}. %There we define the notion of an edge between  a loop entry and loop end instruction and we mark it with $\execRel^l$.


 % different on source level and a motivation for doing so
 %Note that this is not necessary for structured programs as loops correspond to program structures and thus are well identified.
 % However, for unstructured programs with loops annotated with invariants and frame conditions,
 %this is a necessary step. 

\begin{defInter}[Intermediate predicate between two instructions ]\label{inter} 
Assume that $\ins{j} \execRel \ins{k}$. The predicate $\inter{j}{k}$ must hold after the execution of $\ins{j}$ and before the execution of 
$\ins{k}$ and is defined as follows:
\begin{itemize}
\item if $\ins{k}$ is a loop entry instruction,  $\ins{j} \execRel^l \ins{k}$ and  $ \methodd.\loopSpecTable[s].\posL = k $
then the corresponding loop invariant  must hold:
$$
\inter{j}{k} \equiv  \methodd.\loopSpecTable[s].\invL
$$


\item else if $\ins{k}$  is a loop entry  and  $ \methodd.\loopSpecTable[s].\posL = k $ 
then the corresponding loop invariant $ \methodd.\loopSpecTable[s].\invL$  must hold before $\ins{k}$ is executed, 
i.e. after the execution of $\ins{j}$. We also require that \\
$\methodd.\loopSpecTable[s].\invL$ implies the weakest precondition of the loop entry instruction. 
The implication is quantified over the locations $ \methodd.\loopSpecTable[s].\modifL $ that may be modified in the loop body:

$$\begin{array}{l} \inter{j}{k} \equiv \\ \begin{array}{l}
          \methodd.\loopSpecTable[s].\invL \ \wedge \\
          \forall i , i = 1.. \methodd.\loopSpecTable[s].\modifL.length ,\\
          \forall  \methodd.\loopSpecTable[s].\modifL[i], (\\
	  \phantom{ \methodd.\loopSpecTable[s] }  \methodd.\loopSpecTable[s].\invL \Rightarrow \\
	  \phantom{ \methodd.\loopSpecTable[s]  \methodd.\loopSpecTable[s] } \wpi{ }{ \methodd }{k} ) 
 \end{array}
 \end{array}  $$

\item else 

$$\inter{j}{k} \equiv \wpi{ }{\methodd}{k}$$
\end{itemize}
\end{defInter}
