\newtheorem{defInter}{Definition}[subsection]
\subsection{Intermediate predicates} \label{wp:interPred}
In this subsection, we define the function $\interOnly$ which for two instructions that may execute one
after another in a control flow graph  of  method \methodd \ determines the predicate $\inter{j}{k}$ which must hold in between them.
The function has the signature:
$$ \interOnly: int \longrightarrow int  \longrightarrow \MethodSet \longrightarrow \predWp $$ 


 The predicate $\inter{j}{k}$ will be used for determining the weakest predicate that must hold in the poststate of the instruction
 $\ins{j}$ in the execution path where  \ins{j} is followed by the instruction $\ins{k}$.
 This predicate depends on the execution relation between the two instructions $\ins{j}$ and $\ins{k}$.
 The function \interOnly{} allows to generate correct verification conditions for loops. For this,  \inter{} does a case analysis 
 over the relation $\execRel{}$ (introduced  in Chapter \ref{opSem}, Section \ref{prelim:ctrFlow} ) between the current instruction and its successor.
 If the relation is a $\execRel^{l}$, i.e. the next instruction is a loop entry instruction and the current is a loop end
( as defined in Def.\ref{defLoop}) 
 then the predicate that must hold in between the current instruction and the next one is the loop invariant associated to the loop entry.
The rest of the cases are two. In case that the next instruction is a loop entry then two conditions must hold in between it and the
current instruction. First, the invariant must hold there and second, the invariant must imply the weakest predicate of the loop entry instruction.
\todo{???CONTINUE HERE}
For the last case, when the next instruction is not a loop entry, we get that the predicate that must hold between the current instruction 
and the successor instruction is the weakest precondition of the successor.  

 % different on source level and a motivation for doing so
 %Note that this is not necessary for structured programs as loops correspond to program structures and thus are well identified.
 % However, for unstructured programs with loops annotated with invariants and frame conditions,
 %this is a necessary step. 

\begin{defInter}[Intermediate predicate between two instructions ]\label{inter} 
Assume that instructions $\ins{j} $ and $\ins{k}$ may execute one after another, i.e. $\ins{j} \execRel \ins{k}$. 
The predicate $\inter{j}{k}$ must hold after the execution of $\ins{j}$ and before the execution of 
$\ins{k}$ and is defined as follows:
\begin{itemize}
\item if $\ins{k}$ is a loop entry and \ins{j}  is a loop end, i.e. $\ins{j} \execRel^l \ins{k}$ then there exists
an index $s$ in the loop specification table  \methodd.\loopSpecTable{} such that  $ \methodd.\loopSpecTable[s].\posL = k $
then the corresponding loop invariant  must hold:
$$
\inter{j}{k} \equiv  \methodd.\loopSpecTable[s].\invL
$$


\item else if $\ins{k}$  is a loop entry then there exists
an index $s$ in the loop specification table  \methodd.\loopSpecTable{} such that $ \methodd.\loopSpecTable[s].\posL = k $ 
and the corresponding loop invariant $ \methodd.\loopSpecTable[s].\invL$  must hold before $\ins{k}$ is executed, 
i.e. after the execution of $\ins{j}$. We also require that \\
$\methodd.\loopSpecTable[s].\invL$ implies the weakest precondition of the loop entry instruction. 
The implication is quantified over the locations $ \methodd.\loopSpecTable[s].\modifL $ that may be modified in the loop body:

$$\begin{array}{l} \inter{j}{k} \equiv \\ \begin{array}{l}
          \methodd.\loopSpecTable[s].\invL \ \wedge \\
          \forall i , i = 1.. \methodd.\loopSpecTable[s].\modifL.length ,\\
          \forall  \methodd.\loopSpecTable[s].\modifL[i], (\\
	  \phantom{ \methodd.\loopSpecTable[s] }  \methodd.\loopSpecTable[s].\invL \Rightarrow \\
	  \phantom{ \methodd.\loopSpecTable[s]  \methodd.\loopSpecTable[s] } \wpi{ }{ \methodd }{k} ) 
 \end{array}
 \end{array}  $$

\item else 

$$\inter{j}{k} \equiv \wpi{ }{\methodd}{k}$$
\end{itemize}
\end{defInter}
