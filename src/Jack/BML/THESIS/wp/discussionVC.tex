\section{Discussion}\label{wp:discussionVC}


Before getting into more technical details, we would first like
to outline the general features of our verification condition
generator. 


% features of the verification condition generator here
Our verification condition generator has the following features :

\begin{description}
  \item [based on a weakest precondition predicate transformer] 
      % forward and backward generation
        The weakest precondition generates a precondition predicate starting 
	from the end of the program with a specified postcondition and ``goes '' in a backward
	direction to the entry point instruction of the program. 
	
	There is an alternative for generating
	verification condition  which works in a forward direction called a strongest postcondition
	predicate transformer. However, strongest postcondition tends to generate large formulas which is less practical than the more concise
	formulae generated by the  weakest precondition calculus.
	% what are the bad features of the SP
	Next, it generates existential quantification for every assignment expression in a program which
	are not easily treated by automatic theorem provers. \todo{???} 
	For more detailed information on strongest postcondition calculus the reader may refer to  \cite{WPCDS}.
 
  \item [works directly on bytecode] 
        %alternative
        Another possible approach is to generate verification conditions over a guarded command language program.
	A guarded command language is a small programming language with few program constructs but which are 
	sufficiently expressive to encode a rich programming language. 
	If a guarded command language is used in the verification procedure this would mean 
	a stage where  bytecode programs are transformed in guarded command language programs.
	Using guarded command language as an intermediate representation of programs
	is useful because the verification condition generator can interface and can be extended to interface 
	easily several programming languages. 
	Such an intermediate representation is used in the extended static checker
	ESC/java (\cite{escjava}) and Spec\# (\cite{BLS04sp}). 
	
	However, we consider that a guarded command language 
	is not completely suitable for a PCC architecture.
	More particularly, we consider that proving the transformation algorithm from a programming language to a 
	guarded command language could be not trivial and thus, we prefer to keep a verification condition generator 
	which works directly on bytecode programs. 

	% First, the transformation is usually a complex procedure which needs
	% 		computational resources. This could be a problem, if the verification procedure is done on a
	% 	a device with limitted resources. Second, proving the transformation correct is not trivial.
 	% We consider that performing the verification procedure directly over the original bytecode program avoids the aformentioned problems.

  
   \item [propagates verification conditions up to the program entry instruction]
         This means that the underlying weakest precondition calculus will discharge the verification 
	 conditions only when it has reached the program entry point. 

         For this feature we also have an alternative solution. The latter consists in
	 that verification conditions are discharged immediately when an assertion (e.g. loop invariant)
	 is reached by the verifiction condition generator as is done in the seminal paper of Floyd \cite{F67amp}
	 (see also the definition of the verification condition in \cite{gta05:fast}).
	 These verification conditions (in the case of a weakest precondition predicate transformer) state in case of a loop invariant
	 that the loop invariant implies the postcondition of the loop if the loop condition is not true and that the invariant implies the weakest precondition 
	 of the loop body if the loop condition holds.

	 Although, generating in this way verification conditions is simpler 
	 than our approach it needs much stronger invariants in order that they get provable.In particular, the specification 
	 required for this alternative approach may increase the size of the program considerably which could not be always admissible,
	 for instance if the program and its specification must be sent via the network.
	 Another shortcoming is that writing or inferring these stronger invariants
	 may be difficult. \todo{relie avec la transformation Benjamin}
	 

  \item [deals only with functional properties] 
        We assume that programs are well-typed i.e. that programs
	have passed successfully the bytecode verification. By well-typed program we mean that  every
	instruction in the program starts execution in a  state where for instance, the method operand
	stack contains the right number and values of the right type
	and where the heap is well typed. Our 
	verification condition generator does not generate such kind of type constraints over 
	the bytecode instructions.
	
	In fact, we could have  designed a logic for checking also for well - typedness as 
	is done in the work of Benton \cite{B04tlsj}.

	However, we consider that this problem is well-understood
	with type checking algorithms and we prefer to concentrate on the functional aspect of programs. 
	We shall not enter  here in the details of the bytecode verification algorithms
	because, as we have already seen in Section \ref{relWork}, the field has been profoundly studied
	and the curious reader may refer to the existing literature (e.g. \cite{Ljbc}). 
	
       %what does it mean well - typed?
	%Let us see what we mean exactly by well-typed programs.
 
	
	
\end{description}







