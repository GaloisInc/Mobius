\section{Discussion}\label{wp:discussionVC}


In this section, we make an overview of the different ways for generating verification conditions. 
Next, we shall see how we argument our design decisions of the verification condition
 generator presented here. 

% features of the verification condition generator here
Our verification condition generator has the following features :

\begin{itemize}
  \item it is based on a weakest precondition predicate transformer \\
      % forward and backward generation
    The weakest precondition generates a precondition predicate starting 
    from the end of the program with a specified postcondition and ``goes '' in a backward
    direction to the entry point of the program. There is an alternative for generating
    verification condition  which works in a forward direction called a strongest postcondition
    predicate transformer. However, strongest postcondition tends to generate large formulas which is less practical than the more concise
    formulae generated by the  weakest precondition calculus.
    % what are the bad features of the SP
    Next, it generates existential quantification for every assignment expression in a program which
    are not easily treated by automatic theorem provers. \todo{???} 
    For more detailed information on strongest postcondition calculus the reader may refer to  \cite{WPCDS}.
 


  \item it works directly on the bytecode \\
        %alternative
        Another possible approach is to generate verification conditions over a guarded command language program.
	This in particular would mean that the verification procedure would have one more stage where
	the bytecode programs is transformed in a program in a guarder command language.
	A guarded command language is useful for an interactive verification and is the case for the extended static checker
	ESC/java (\cite{escjava}) and Spec\# (\cite{BLS04sp}). The reason for this is that its representation is close to the semantics of the original
	program and thus is understandable by programmers.
	
	However, we consider that a guarded command language is impractical for our purposes for
	several reasons.
	First, the transformation is usually a complex procedure which needs
	computational resources. This could be a problem, if the verification procedure is done on a
	small device with limitted resources. Second, proving the transformation correct is not trivial.
	We consider that performing the verification procedure directly over the original bytecode program
	avoids the aformentioned problems.

  
   \item it propagates the verification conditions up to the program entry instruction \\
         For this feature we also have an alternative solution. An alternative is that verification
	 conditions are discharged immediately when a loop entry is reached by the verifiction condition generator (see \todo{Benjamin, Tamara}).
	 These verification conditions (in the case of a weakest precondition predicate calculus) state that the loop 
	 invariant implies the postcondition of the loop if the loop condition is not true and that the invariant implies the weakest precondition 
	 of the loop body if the loop condition holds. Although, this verification condition generator is simpler than our approach it needs
	 much stronger invariants than the verification condition generator proposed here. In particular, the specification 
	 required for this alternative approach may increase the size of the program considerably which will be not desirable if for instance 
	 the program and its specification must be sent via the network.
\end{itemize}







