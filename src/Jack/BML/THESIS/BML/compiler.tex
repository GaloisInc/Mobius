

\section{Compiling JML into BML}\label{BCSLcompile}

%This section explains how JML specifications are compiled into bytecode level specifications and how they are inserted into the bytecode. 

We now turn to explaining how JML specifications are compiled into user defined attributes for Java class files.
As we shall see, the compilation consists of several phases where in the final phase 
 The JVMS allows to add to the class file user specific information(\cite{VMSpec}, ch.4.7.1). This is done by defining user specific attributes
  (their structure is predefined by JVMS).
Thus the ``JML compiler'' \footnote{Gary Leavens also calls his tool jmlc JML compiler, which transforms jml into runtime checks and thus generates input for the jmlrac tool  } compiles the JML source specification into user defined attributes. The compilation process has the following stages:
\begin{enumerate}
\item Compilation of the Java source file \\
  This can be done by any Java compiler that supplies for every method in the generated class file 
the \textbf{Line\_Number\_Table} \\ 
and \textbf{Local\_Variable\_Table}  attributes. The presence in the Java class file format of 
these attribute is optional \cite{VMSpec}, yet almost all standard non optimizing compilers can generate these data. 
The \textbf{Line\_Number\_Table} describes the link between the source line and the bytecode of a method.  
The \textbf{Local\_Variable\_Table} describes the local variables that appear in a method. 
Those attributes are important for the next phase of the JML compilation.

\item Desugaring of the JML specification \\
      BML supports less specification clauses than JML for the sake of keeping compact the class file format.
      In particular BML does not support heavy weight behaviour specification clauses or nested specification, neither an incomplete
      method specification(see  \cite{JMLRefMan}).
      Thus, a step in the compilation of JML specification into BML specification is the desugaring of the JML heavy weight
      behaviours and the expanding of a light - weight non complete specification into its full default format.
      This corresponds to the standard JML desugaring as described  in \cite{RT03djml}
      For instance, a Java method which has two normal behaviours is given in Fig. \ref{JmlSpec}. 
      Its desugared form corresponds to the method given in Fig. \ref{bcSpec}

\begin{figure}
\begin{verbatim}
class C {
   int a ;

   invariant a > 0; 
   historyConstraint  old(a) >= a;

   /*@ public_behaviour
     @ requires a > b;
     @ modifies a;
     @ ensures  a == \old(a) - b;  
     @
     @ also
     @ requires a <= b;
     @ ensures  a == \old(a);
     @*/
     public void decrease(int b) {
        if ( a > b) {
           a = a - b;
        }
     }
}
\end{verbatim}
\caption{\sc An example for a method with two normal behaviours specified in JML} \label{JmlSpec}
\end{figure}

\item Linking with source data structures \\
      When the JML specification is desugared, we are ready for the linking and resolving phases.
      In this stage, the JML specification gets into an intermediate format in which 
      the identifiers are resolved to data structures standing for the data that it represents. For instance, 
      consider once again the example in Fig. \ref{JmlSpec} and particularly, let's look at the first specification
      case of method {\verb m }  whose precondition { \verb a > b }  contains the identifier {\verb a }. In the linking phase, this identifier
      is resolved to the field  named {\verb a } which is declared in the same class as shown in the figure. 
      Also in this precondition, the identifier {\verb b } which is resolved to the parameter of method  {\verb m }.



      
\item Compilation of the JML specification into BML \\
   In this stage, the desugared JML specification from the source file is compiled into BML specification.
The Java and JML source identifiers are linked with their identifiers on bytecode level, namely with the corresponding indexes either from the constant pool or the array of 
local variables described in the \textbf{Local\_Variable\_Table} attribute. If, in the JML specification a field
identifier appears for which no constant pool (cp) index exists, it is added in the constant pool and the identifier in question
is compiled to the new cp index. It is also in this phase that the specification parts like the loop invariants and the assertions which should hold at a certain point in the source program must be associated to the respective program point on bytecode level. The specification
is compiled in binary form using tags in the standard way. The compilation of an expression is a tag followed by the compilation of its subexpressions. 


Another important issue in this stage of the JML compilation is how the type differences on source and bytecode level are treated. 
By type differences we refer to the fact that the JVM (Java Virtual Machine) does not provide direct support for integral types 
like byte, short, char, neither for boolean. Those types are rather encoded as integers in the bytecode. Concretely, this means that 
if a Java source variable has a boolean type it will be compiled to a variable with
an integer type. For instance, in the example for the method 
\texttt{isElem} and its specification in Fig.\ref{replaceSrc} the postcondition states the equality between the JML expression  
\result \ and a predicate. This is correct as the method \texttt{isElem} in the Java source is declared with return type boolean  and thus,
 the expression \result \ has type boolean. 
Still, the bytecode resulting from the compilation of the method  \texttt{isElem} returns a value of type integer. This means that the JML compiler has to 
``make more effort'' than simply compiling the left and right side of the equality in the postcondition, otherwise its compilation will not make sense as 
it will not be well typed. Actually, if the JML specification contains program boolean expressions that the Java compiler will compile to bytecode expression
 with an integer type, the JML compiler will also compile them in integer expressions and will transform the specification condition in equivalent 
one\footnote{when generating proof obligations we add for every source boolean expression an assumption that it
 must be equal to 0 or 1. Actually, a reasonable compiler will encode boolean values in this way}.  

Finally, the compilation of the postcondition of method \texttt{isElem} is given in Fig. \ref{postCompile}. From the postcondition compilation,
 one can see that the expression \result \ has integer type and the equality between the boolean expressions in the postcondition in Fig.\ref{replaceSrc} is
 compiled into logical equivalence. The example also 
shows that local variables and  fields are respectively linked to the index of the register table for the method and to the corresponding 
index of the constant pool table 
(\#19 is the compilation of the field name \texttt{list} and $\locVar{1}$ stands for the method parameter \texttt{obj}). 

\begin{figure}[t]
 $$\begin{array}{l}
         \result = 1 \\
          \\ 
         \iff \\ 
         \exists    \bound\_{\mbox{\rm \textsf{0}}}, 
           \biggl(\begin{array}{l} \ 0 \leq  \bound\_{\mbox{\rm \textsf{0}}} \wedge\\ 
             \bound\_{\mbox{\rm \textsf{0}}} < len(\#19(\locVar{0})) \wedge \\
             \arrayAccess{\#19(\locVar{0})}{\bound\_{\mbox{\rm \textsf{0}}} } = \locVar{1} 
         \end{array} \biggr) 
   \end{array}
$$
\caption{\sc The compilation of the postcondition in Fig. \ref{replaceSrc}}
\label{postCompile}
\end{figure}





\item Encoding BML specification  into user defined attributes\\
 Method specifications, class invariants, loop invariants are newly defined attributes in the class file.
 For example, the specifications of all the loops in a method are compiled to a unique method attribute whose syntax is
 given in Fig.~\ref{loopAttribute}. This attribute is an array of data structures each describing a single loop from the method source code.
 Also for each loop in the source code there must be a corresponding element in the array. 
More precisely, every element contains information about the instruction where the loop starts as specified in the
\textbf{Line\_Number\_Table}, the locations that can be modified in a loop iteration, 
 the invariant associated to this loop and the decreasing expression in case of total correctness, 
%For the full specification of the compiler see~\cite{JML2BCSpec}.
\end{enumerate}

\begin{figure}[t]
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{index}: The index in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described

\item \textbf{modifies[]}: The array of locations that may be modified

\item \textbf{invariant }: The predicate that is the loop invariant. It is a compilation of the JML formula in the low level specification language

\item \textbf{decreases}: The expression which decreases at every loop iteration
\end{itemize}
\caption{\sc Structure of the Loop Attribute}
\label{loopAttribute}
%\end{frameit}
\end{figure}

The JML compiler does not depend on any specific Java compiler, but it requires the presence of a debugging information,
namely the presence of the \textbf{Line\_Number\_Table} attribute for the correct compilation of inter method
 specification, i.e. loops and assertions. We think that this is an acceptable restriction as few bytecode programs even handwritten are not reducible.
 The most problematic part of the compilation is to identify which source loop corresponds to which bytecode loop in the control flow
 graph. To do this, we assume that the control flow graph is reducible (see~\cite{ARUCom1986}), i.e. there are no
 jumps from outside a loop inside it; graph reducibility allows to establish the same order between loops in the
 bytecode and source code level and to compile the invariants to the correct places in the bytecode.


%\todo{limitations : registers that are used with two different types in the method bytecode}
