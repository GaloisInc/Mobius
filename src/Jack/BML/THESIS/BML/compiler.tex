


\section{Compiling JML into BML}\label{BCSLcompile}

%This section explains how JML specifications are compiled into bytecode level specifications and how they are inserted into the bytecode. 

In this section, we turn to the \JMLtoBML \ compiler.
As we shall see, the compilation consists of several phases, namely compiling the Java source file, 
preprocessing of the JML specification, resolution
and linking of names, locating the position of intra --- method specification, processing of boolean expressions and 
finally encoding the BML specification in user defined class file attributes.  (their structure is predefined by JVMS).
In the following, we look in details at the phases of the compilation process:
\begin{enumerate}
\item Compilation of the Java source file \\
  This can be done by any Java compiler that supplies for every method in the generated class file 
  the \textbf{Line\_Number\_Table} \\ 
  and \textbf{Local\_Variable\_Table}  attributes. 
  % The presence in the Java class file format of 
  % these attribute is optional \cite{VMSpec}, yet almost all standard non optimizing compilers can generate these data. 
 %  The \textbf{Line\_Number\_Table} describes the link between the source line and the bytecode of a method.  
 %  The \textbf{Local\_Variable\_Table} describes the local variables that appear in a method. 
   Those attributes are important for the next phases of the JML compilation.

\item Compilation of Ghost field declarations \\
      JML specification is invisible by the 
      Java compilers. Thus Java compilers omit the compilation of ghost variables declaration.
      That is why it is the responsibility of the \JMLtoBML \  compiler to do this work. 
      For instance, the compilation of the declaration of the ghost variable from
      Fig. \ref{bml:ghost} is given in Fig.\ref{bml:compiler:ghost} which shows the data structure \textbf{Ghost\_field\_Attribute}
      in which the information about the field
      \texttt{TRANS} is encoded in the class file format. 
      Note that,  the constant pool indexes \textbf{\#18} and \textbf{\#19}  which contain its description were not in the constant
      pool table of the class file \texttt{Transaction.class} before running the \JMLtoBML \ compiler on it. 
\begin{figure}[ht!]
\begin{frameit}
\textbf{     
\begin{tabbing}
 Gho\=st\_field\_Attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= access\_flag 10;\\
\> \> name\_ index = \#18; \\
\> \> descriptor\_index = \#19 \\
\> \} ghost[1];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{access\_flag}: The kind of access that is allowed to the field

\item \textbf{name\_index}:  The index in the constant pool which contains information about the source name of the field

\item \textbf{descriptor\_index}: The index in the constant pool which contains information about the name of the field type  
\end{itemize}


\caption{\sc Compilation of ghost variable declaration}
\label{bml:compiler:ghost}
\end{frameit}
\end{figure}

\item Desugaring of the JML specification \\
      %BML supports less specification clauses than JML for the sake of keeping compact the class file format.
     % In particular BML does not support heavy weight behaviour specification clauses or nested specification, neither an incomplete
     % method specification(see  \cite{JMLRefMan}).
      % Thus, a step in the compilation of JML specification into BML specification is the desugaring of the JML heavy weight
      The phase consists in converting the JML method heavy-weight behaviors and the light - weight non complete
      specification into BML specification cases.
      It corresponds to part of the standard JML desugaring as described  in \cite{RT03djml}.
      For instance, the BML compiler will produce from the specification in Fig.\ref{bml:heavySp} the BML specification 
      given in Fig.\ref{bml:heavySpBML} 
      



\item Linking with source data structures \\
      When the JML specification is desugared, we are ready for the linking and resolving phases.
      In this stage, the JML specification gets into an intermediate format in which 
      the identifiers are resolved to their corresponding data structures in the class file.
      The Java and JML source identifiers are linked with their identifiers on bytecode level, 
      namely with the corresponding indexes either from the constant pool or the array of 
      local variables described in the \textbf{Local\_Variable\_Table} attribute. 

      For instance, consider once again the example in Fig. \ref{bml:heavySp} and more particularly  the first specification
      case of method \texttt{divide}  whose precondition \texttt{ b > 0 }  contains the method parameter identifier \texttt{b}.
      In the linking phase, the identifier \texttt{b} is resolved to the local variable $\locVar{1}$  in the array of
      local variables for the method \texttt{divide}.
      We have a similar situation with the postcondition \texttt{ a == \old{a} / b }  which mentions also the field \texttt{a} of the current object.
      The field name \texttt{a} is compiled to the index in the class constant pool  which describes the constant field reference.
      The result of the linking process is in Fig.\ref{bml:heavySpBML}.

      % how ghost fields are compiled
      If, in the JML specification a field
      identifier appears for which no constant pool index exists, it is added in the constant pool and the identifier in question
      is compiled to the new constant pool index. This happens when declarations of JML ghost fields are compiled. 
     

  





      

\item Locating the points for the intra ---method specification \\

      In this phase the specification parts like the loop invariants and the assertions
      which should hold at a certain point in the source program must be associated to the
      respective program point in the bytecode. For this, the 
      \textbf{Line\_Number\_Table} attribute is used. The \textbf{Line\_Number\_Table} attribute
      describes the correspondence between the Java source line and the instructions of its respective bytecode.
      In particular, for every line in the Java source code the   \textbf{Line\_Number\_Table}  specifies the index 
      of the beginning of the basic block\footnote{a basic block is a sequence of instructions which does not contain jumps except
	may be for the last instruction and neither contains target of jumps except for the first instruction. 
	This notion comes from the compiler community and 
	more information on this one can find at \cite{ARUCom1986}} in the bytecode which corresponds to the source line. 
      Note however, that a source line may correspond to more than one instruction in the \textbf{Line\_Number\_Table}. 
     
      This poses problems for  identifying loop entry instruction of a loop in the bytecode
      which corresponds to a particular loop in the source  code. % which is important for the
     % compilation of the JML loop invariants (as we should know exactly where they must hold in the bytecode). 
       For instance, for method \texttt{replace} in
      the Java source example in Fig. \ref{replaceSrc} the java compiler will  produce two lines in the 
       \textbf{Line\_Number\_Table} which correspond to the source line \textbf{17}  as shown in Fig. \ref{bml:compiler:loopEntry}.
       The problem is that none of the basic blocks determined by instructions  \textbf{2} and  \textbf{18} contain the loop entry instruction of the compilation
       of the loop at line \textbf{17} in Fig. \ref{replaceSrc}. Actually, the loop entry instruction in the bytecode in 
       Fig. \ref{bml:loopBML} (remember that this is the compilation in bytecode of the Java source in Fig. \ref{replaceSrc}) which corresponds to the 
       in the bytecode is at index \textbf{19}.
  
       Thus for identifying  loop entry instruction   corresponding to a particular loop in the source code, we use an heuristics.  
       It consists in looking for the first bytecode loop entry instruction starting from one of the \textbf{start\_pc} indexes 
       (if there is more than one) corresponding to the start
       line of the source loop in the \textbf{Line\_Number\_Table}. 
       The algorithm works under the assumption that the control flow graph of the method bytecode is reducible.
       This assumption  guarantees that the first loop entry instruction found starting the search 
       from  an index in the  \textbf{Line\_Number\_Table} corresponding to the first line of a source loop
       will be the loop entry corresponding to this source loop.
       However, we do not have a formal argumentation for this algorithm because it depends on the particular implementation of the compiler.
       From our experiments, the heuristic works successfully for the Java Sun non optimizing compiler.
 
\begin{figure}[t]
\begin{frameit}
\textbf{Line\_Number\_Table} 
\textbf{     
\begin{tabbing}
start\_pc \= line \\
\ldots \> \\
2 \> 17 \\
18  \> 17 \\
\end{tabbing}
}

\caption{\textbf{Line\_Number\_Table}  {\sc for the method } \texttt{replace} {\sc in Fig.  \ref{replaceSrc}  } }
\label{bml:compiler:loopEntry}
\end{frameit}
\end{figure} \todo{une presentation tres laide }

      
      
\item Compilation of the JML boolean expressions into BML \\
      
     

Another important issue in this stage of the JML compilation is how the type differences on source and bytecode level are treated. 
By type differences we refer to the fact that the JVM (Java Virtual Machine) does not provide direct support for integral types 
like byte, short, char, neither for boolean. Those types are rather encoded as integers in the bytecode. Concretely, this means that 
if a Java source variable has a boolean type it will be compiled to a variable with
an integer type.


 For instance, in the example for the method 
\texttt{replace} and its specification in Fig.\ref{replaceSrc} the postcondition states the equality between the JML expression  
\result \ and a predicate. This is correct as the method \texttt{replace} in the Java source is declared with return type boolean  and thus,
 the expression \result \ has type boolean. 
Still, the bytecode resulting from the compilation of the method  \texttt{replace} returns a value of type integer. This means that the JML compiler has to 
``make more effort'' than simply compiling the left and right side of the equality in the postcondition, otherwise its compilation will not make sense as 
it will not be well typed. Actually, if the JML specification contains program boolean expressions that the Java compiler will compile to bytecode expression
 with an integer type, the JML compiler will also compile them in integer expressions and will transform the specification condition in equivalent 
one\footnote{when generating proof obligations we add for every source boolean expression an assumption that it
 must be equal to 0 or 1. A reasonable compiler would encode boolean values in a similar way}.  

Finally, the compilation of the postcondition of method \texttt{replace} is given in Fig. \ref{postCompile}. From the postcondition compilation,
 one can see that the expression \result \ has integer type and the equality between the boolean expressions in the postcondition in Fig.\ref{replaceSrc} is
 compiled into logical equivalence. 
% The example also 
% shows that local variables and  fields are respectively linked to the index of the register table for the method and to the corresponding 
% index of the constant pool table 
% (\#19 is the compilation of the field name \texttt{list} and $\locVar{1}$ stands for the method parameter \texttt{obj}). 

\begin{figure}[t]
\begin{frameit}
 $$\begin{array}{l}
         \result = 1 \\
          \\ 
         \iff \\ 
         \exists    \bound\_{\mbox{\rm \textsf{0}}}, 
           \biggl(\begin{array}{l} \ 0 \leq  \bound\_{\mbox{\rm \textsf{0}}} \wedge\\ 
             \bound\_{\mbox{\rm \textsf{0}}} < len(\#19(\locVar{0})) \wedge \\
             \arrayAccess{\#19(\locVar{0})}{\bound\_{\mbox{\rm \textsf{0}}} } = \locVar{1} 
         \end{array} \biggr) 
   \end{array}
$$
\caption{\sc The compilation of the postcondition in Fig. \ref{replaceSrc}}
\label{postCompile}
\end{frameit}
\end{figure}





\item Encoding BML specification  into user defined class attributes\\
  The specification expression and predicates
  are compiled in binary form using tags in the standard way. The compilation of an expression is a tag followed by the compilation of its subexpressions. 
    
 Method specifications, class invariants, loop invariants are newly defined attributes in the class file.
 For example, the specifications of all the loops in a method are compiled to a unique method attribute whose syntax is
 given in Fig.~\ref{loopAttribute}. This attribute is an array of data structures each describing a single loop from the method source code.
From the figure, we notice that every element describing the specification for a particular loop contains the index of the corresponding loop
entry instruction \textbf{index}, the loop modifies clause (\textbf{modifies}),
the loop invariant (\textbf{invariant}), an expression which guarantees termination (\textbf{decreases}).


\end{enumerate}

\begin{figure}[t]
\begin{frameit}
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> ...\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\begin{itemize}
\item \textbf{index}: The index in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described

\item \textbf{modifies[]}: The array of locations that may be modified

\item \textbf{invariant }: The predicate that is the loop invariant. It is a compilation of the JML formula in the low level specification language

\item \textbf{decreases}: The expression which decreases at every loop iteration
\end{itemize}
\caption{\sc Structure of the Loop Attribute}
\label{loopAttribute}
\end{frameit}
\end{figure}

% The JML compiler does not depend on any specific Java compiler, but it requires the presence of a debugging information,
%namely the presence of the \textbf{Line\_Number\_Table} attribute for the correct compilation of inter method
% specification, i.e. loops and assertions. We think that this is an acceptable restriction as few bytecode programs even handwritten are not reducible.
% The most problematic part of the compilation is to identify which source loop corresponds to which bytecode loop in the control flow
% graph.
%  To do this, we assume that the control flow graph is reducible (see~\cite{ARUCom1986}), i.e. there are no
% jumps from outside a loop inside it; graph reducibility allows to establish the same order between loops in the
% bytecode and source code level and to compile the invariants to the correct places in the bytecode.
% \todo{put it elsewhere}

%\todo{limitations : registers that are used with two different types in the method bytecode}
