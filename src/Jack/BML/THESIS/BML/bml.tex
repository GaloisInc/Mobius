

% CHANGED - the example o compilation of loop specification

\newtheorem{bml}{Definition}[section]

\section{The subset of JML supported in BML} \label{BCSLgrammar}


BML corresponds to a representative subset of JML and is expressive enough for most purposes including the description of non trivial functional and 
 security properties. The following Section \ref{bml:notation} gives the notation conventions adopted here and 
Section  \ref{BCSL} gives the formal grammar of  BML as well as an informal description of its semantics. 

\subsection{Notation convention}\label{bml:notation}


\begin{itemize}
     \item Nonterminals are written with a \nonterminal font
     \item Terminals are written with a \terminal font
    % \item Keywords are writtem with a \keyWord font
     \item brackets  $\lbrack \ \rbrack $ surround optional text.
\end{itemize}


\subsection{BML Grammar}\label{BCSL}

%\begin{bml}[Formal grammar of BML]\label{BCSL} 
$$\begin{array}{ll}
     \Constants   & ::= \intLiteral  \mid \signedInt  \mid \Mynull \mid \ident  \\
     & \\

     \signedInt & ::= + \nonZeroDigit  \lbrack \digits \rbrack  \mid  - \nonZeroDigit  \lbrack \digits \rbrack \\

     & \\
     \intLiteral & ::= \digit \mid \nonZeroDigit  \lbrack \digits \rbrack \\

     & \\ 
     \digits & ::=  \digit  \lbrack \digits \rbrack \\

     & \\
     
     \digit & ::=  \mbox{\rm\textbf{0}} \mid \nonZeroDigit \\
     
     & \\

     \nonZeroDigit &::= \mbox{\rm\textbf{1}}  \mid \ldots \mid \mbox{\rm\textbf{9}}   \\
     
     & \\
     
     \ident & ::= \# \ \intLiteral \\    
     
     & \\
 
     \boundVar & ::= \ \bound\_\intLiteral \\ 

     & \\
    % \RefValuesSpec    & ::=  Ref \mid \Mynull \\
    & \\
    \expression      & ::= \Constants \\
                     &  \mid \locVar{ \digits } \\ 
       	             &  \mid \fieldAccess{\expression}{\ident} \\
		     &  \mid \ident \\
		  %  &  \mid  \update{\fieldd}{ \expression}{\expression}(\expression) \\
		     &  \mid \arrayAccess{\expression} {\expression} \\	   
		 %   &  \mid \update{ \arrayAccessOnly}{ (\expression , \expression)}{ \expression} (\expression,\expression) \\	
		     &  \mid \expression \ \op \ \expression   \\
		     &  \mid \counter \\
		     &  \mid \stack{ \expression} \\
                     &  \mid \old{ \expression  } \\
                     &  \mid \EXC    \\
		     &  \mid \result \\
		     &  \mid \boundVar \\
		     &  \mid \typeof{ \expression} \\
                     &  \mid \type{\ident} \\
                     &  \mid \elemtype{\expression  }\\
		     &  \mid \TYPE\\  
  & \\
 \op & ::=  \plus \mid \minus \mid \mult \mid \divis \mid  \modulo \\
 

    & \\
 \predicates & ::=  \  = \mid  \neq \mid \leq \mid \le \mid \geq \mid > \mid \subtypeSpec    \\
  & \\
 \formulaBc & ::= 
            \expression \ \predicates \  \expression   \\
	  & \mid  \true \\
	  & \mid  \false  \\	
          & \mid not \ \formulaBc  \\
	  & \mid \formulaBc  \wedge  \formulaBc \\
	  & \mid \formulaBc \vee  \formulaBc \\
	  & \mid \formulaBc  \Rightarrow \formulaBc \\
          & \mid \formulaBc \iff  \formulaBc \\
	  & \mid \forall \ \boundVar , \formulaBc\\
	  & \mid \exists \ \boundVar  , \formulaBc	 \\
    & \\
  \ClassSpec & ::=  \ClassInv \ \formulaBc  \\
                 & \mid \ClassHistoryConstr  \ \formulaBc   \\
                 & \mid \declare \ \ghost \ \ident \ \ident \\ 

    & \\
  \intraMethodSpec & ::=  \begin{array}{l}  \atIndex \ nat; \\
		                            \intraSpec ; 
			  \end{array}\\
&\\
\intraSpec & ::=  \loopSpec \\ 
             & \mid \assert \ \formulaBc  \\                      
	     & \mid \set \ \expression \  \expression \\
& \\
\loopSpec  & ::=  \begin{array}{l}  
                        \loopInv \  \formulaBc; \\ 
			\loopMod \ list; \\ 
                        \loopDecreases \ \expression; 
	         \end{array}\\
    \end{array}$$


$$\begin{array}{ll} 
 %   & \\ 
  \MethodSpec & ::= \specCase \\     
                    & \mid  \specCase \ \also \ \MethodSpec \\

 & \\
  \specCase & ::=    \{| \\
                    & \phantom{aaa} \begin{array}{l}  
                              \requires  \ \formulaBc; \\
                                 \modifies  \ list \   \modifiesLoc;  \\
				 \ensures \ \formulaBc; \\
				 \exsuresList\\
				 
		     \end{array}  \\
                    &\phantom{aaa} |\} \\
 & \\ 
 \exsuresList & ::=   [ ] \mid  \exsures \ ( \ident )  \ \formulaBc  ; \exsuresList  \\
 & \\
  \modifiesLoc & ::=  \fieldAccess{\expression}{\ident} \\
                    & \mid \locVar{i} \\ 
                    & \mid \arrayAccessMod{\expression}{\specIndex}\\
		    & \mid \everything \\
		    & \mid \nothing \\
              
 & \\
 \specIndex & ::= \all \mid i_1 .. i_2 \mid i  \\
            
%\end{array}                
%$$

%$$ 
%\begin{array}{ll}    
 
       & \\
       \bmlKeyWords & ::= \requires \\
                       & \mid \ensures \\
		       & \mid \modifies \\
		       & \mid \assert \\
		       & \mid \set \\
		       & \mid \exsures \\
		       & \mid  \also \\
		       & \mid  \ClassInv \\
		       & \mid \ClassHistoryConstr \\
		       & \mid \atIndex \\ 
		       & \mid \loopInv \\
		       & \mid \loopDecreases \\
		       & \mid \loopMod \\
		       & \mid \jmlKey{$\backslash$ typeof} \\
		       & \mid \jmlKey{$\backslash$ elemtype}\\
		       & \mid \TYPE\\
		       & \mid \result 
\end{array}
$$


\subsection{Syntax and semantics of BML}

In the following, we will discuss informally the semantics of the syntax structures of BML.
Note that most of them are identical with construction from JML. In the following, we will concentrate more on
 the specific features of BML and will just briefly comment the BML features which it inherits from JML like preconditions 
and which we have not mentioned already\footnote{because we have already discussed  in Section \ref{BCSLprelim}
 the JML constructs for pre and postconditions, loop invariants, operators like \jmlKey{old}, \result, etc. we would not 
return to them anymore as their semantics is exactly the same as the one of JML}.  


\subsubsection{BML expressions}
Among the common features of BML and JML are the following expressions:
field access expressions $\fieldAccess{ \expression}{\ident}$, array access  
($\arrayAccess{\expression^1} {\expression^2} $),  arithmetic expressions
($\expression \ \op \ \expression$ ). Like JML, BML may talk about expression types.
As the BML grammar shows,  $ \typeof{\expression}$  denotes the dynamic type of the expression $\expression$, 
 $ \type{ \ident } $  is the class  described at index $\ident$ in the constant pool of the corresponding class file.
The construction $\elemtype{\expression}$ denotes the type of the elements of the array $\expression$,
and \TYPE, like in JML, stands for the Java type \texttt{java.lang.Class}. 

A difference between JML and BML expressions is the syntax of identifiers, i.e. the syntax
for local variables, method parameters, field and class identifiers. In JML, all these constructs
 are represented syntactically by their names in the Java source file. This is not the case in BML.

 We first look at the syntax of method local variables and parameters.
 The class file format stores information for them in the array of local variables.
 That is why, both method parameters and local variables are represented in BML 
 with the construct  $\locVar{i}$ which refers to the local variable in the array of local
 variables of a method at index $i$. Note that the \texttt{this} expression in BML is encoded
 as $\locVar{0}$. This is because the reference to the current object is stored at index 0 in the array of local variables.

 
 Field and class identifiers in BML are encoded by the respective number in the constant pool table of the class file.
 For instance, the syntax of field access expressions  in BML is $\fieldAccess{\expression}{\ident}$ which 
 stands for the value in the field at index $\ident$ in the class constant pool of the class 
 for the reference denoted by the expression  $ \expression $. 

 The BML grammar defines the syntax of identifiers differently from their usual syntax.
 Particularly, in BML those are positive numbers preceded by the symbol \# while usually
 the syntax of identifiers is a chain of characters which always starts with a letter. 
 The reason for this choice in BML  is that identifiers in BML are indexes in the constant
 pool table of the corresponding class.     

 Fig.\ref{bml:heavySpecBML} gives the bytecode as well as the BML specification
 of the code presented in   Fig.\ref{bml:heavySp}. As we can see, the names of the local variables, field and class names  
 are compiled as described above.
 For instance, at line 2 we can see the precondition of the specification case.
 It talks about $\locVar{1}$ which is the element in the array of local variables
 of the method which corresponds to the unique method parameter. 

About the syntax of class names,  after the
 \exsures \ clause at line 5 follows a BML identifier (\#25) enclosed in parenthesis.
 This is the constant pool index at which the Java exception  type \texttt{java.lang.Exception} is declared.
 
\begin{figure}
\begin{lstlisting}[frame=trbl]

   ...

1. //@ {| 
2. //@  requires lv(1) > 0;
3. //@  modifies lv(0).#19;
4. //@  ensures  lv(0).#19 == \old( lv(0).#19 ) / lv(1);
5. //@  exsures  ( #25 ) false;  
6. //@ |}
7. //@ also 
8. //@ {|
9. //@  requires lv(1) == 0;
10.//@  modifies \nothing;
11.//@  ensures false;
12.//@  exsures ( #26 ) lv(0).#19  == \old(lv(0).#19);
13.//@ |}
   public void divide(int lv(1)) 
      0 aload 0
      1 dup
      2 getfield #19 // instance field a
      3 iload 1
      4 idiv
      5 putfield #19 // instance field a
      6 return
\end{lstlisting}
\caption{\sc An example for a heavy weight specification in BML} \label{bml:heavySpBML}
\end{figure}

%\begin{itemize}
%      \item  constants with the nonterminal 
%             $\Constants$. 
%             A constant is either a signed or unsigned integer, or an identier.  
%             Integers are defined in a standard way. Identifiers correspond 
%	     to indexes in the constant pool of a Java class and are always prefixed by the symbol $\#$. 
%             
%      \item  $\locVar{i}$ a local variable in the array of local variables of a method at index $i$.
%             Note that the array of local variables of a method in a class file
%             is the list containing both the formal parameters of the method and
%	     the variables declared locally in the method.
%             
%             
%      \item  field access expressions where $\fieldAccess{ \expression}{\ident}$ stands for accessing the field which 
%             is at index $\ident$ in the class constant pool of the class 
%             for the reference denoted by the expression  $ \expression $. 
%	      	    
%               
 %     \item  array access expression where $\arrayAccess{\expression^1} {\expression^2} $ stands for an access to the element at index $ \expression^2$ 
%             in the array denoted by the expression $ \expression^1$. This corresponds to the Java notation $\expression^1[\expression^2 ]  $ 
%             
%              
%      \item  $\expression \ \op \ \expression$ stands for the usual arithmetic operations 
%%             where $\op$ ranges over the standard  arithmetic operations $ + , - , * , div ,  rem $ 
%
%   
%      \item $\old{\expression}$  denotes the value of $\expression$ in the initial state of a method.
%            This expression makes sense in the postcondition of a
%            method and thus, allows that the postcondition predicate relate to the initial value of expressions.
%
%      \item $\EXC$ is a special specification identifier which denotes the thrown exception object in
%            exceptional postconditions
% \end{itemize}
%
A particular feature of BML is that it supports stack expressions which do not have a counterpart in JML.
These expressions are related to
 the way in which the virtual machine works, i.e. we refer to the stack and the stack counter.
Because intermediate calculations are done by using the stack, often we will need stack expressions in order to characterise the states before and after an instruction
execution. Stack expressions are represented in BML as follows:
\begin{itemize}
      \item  $\counter$ represents the stack counter.
      \item  $\stack{ \expression}$ stands for the element in the operand stack at position $\expression$.   
             For instance, the element below the stack top is represented with $\stack{\counter - 1}$ 
             % Differently from the JML, our bytecode specification language has to take into 
             % account the operand stack and its counter. 
	     Note that those expressions may appear in predicates that refer to intermediate instructions in the bytecode. 
	   
 \end{itemize}


%Finally, type expressions are given by the nonterminal $\typeExp$. 
%Note that all of these expressions have their analogue in JML and have the following meaning:
%\begin{itemize}
%   \item  $ \typeof{\expression}$  denotes the dynamic type of the expression $\expression$ 
%
%%      \item $ \type{ \ident } $  denotes the class  described at index $\ident$ in the constant pool of the corresponding class file
% 
%      \item $\elemtype{\expression}$ denotes the type of the elements of the array $\expression$
%      \item \TYPE.  This keyword stands for the Java type \texttt{java.lang.Class}\footnote{In the Java Application Programming Interface (API), 
%            instances of the class \texttt{java.lang.Class} represent Java classes, interfaces or basic types}. Notice that expressions
%	    $ \typeof{\expression}$, $\type{\ident}$ and $\elemtype{ \expression }$ are of type \TYPE.     
%
% \end{itemize}

\subsubsection{BML predicates}
 The properties that our bytecode language can express are from first order predicate logic. The formal grammar of the predicates is
 given by the nonterminal $\formulaBc$. From the formal syntax, we can notice that BML supports the standard logical connectors
 $\wedge, \vee, \Rightarrow $, existential $\exists$ and universal quantification $\forall$ as well as standard relation between
 the  expressions of our language like $\neq, = , \leq, \le \ldots$  
 

\subsubsection{Class Specification}
 The nonterminal  \ClassSpec \ in the BML grammar defines syntax constructs for the
 support of class specification. Note that these specification features exist in JML
 and have exactly the same semantics. 
 However, we give a brief description of the syntax. 
 Class invariants are introduced by the terminal
 \ClassInv, history constraints are introduced by the terminal \ClassHistoryConstr. 
 BML allows the declaration of specification variables which are not visible by
 the JVM. Their syntax in the grammar is $\declare \ \ghost \ \ident  \ \ident$. 
 These variables do not change the program behaviour although they might be
 assigned to as we shall see later in this section.

%\todo{HERRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRE} 
%Class specifications refer to properties that must hold in every visible state of a class. Thus, we have
%two kind of properties concerning classes: 
%\begin{itemize}
%      \item \ClassInv. Class invariants are predicates that must hold in every visible state of a class.
%                       This means that they must hold at the beginning and end of every method as well as whenever a method is called.
%      \item \ClassHistoryConstr. 
%      \item  $\declare \ \ghost \ \ident  \ \ident$ declares a special specification variable which we call ghost variable.
%             These variables do not change the program behaviour although they might be assigned to as we shall see later in this section.
%	     Ghost variables are used only for specification purposes and  are not ``seen'' by the Java Virtual Machine.   
%\end{itemize}
 


\subsubsection{Inter --- method specification}

 In this subsection, we will focus on the method specification which is visible by the other methods in the program
 or in other words the method pre, post and frame conditions. 
 The syntax of those constructs is given by the nonterminal
 \MethodSpec. As their meaning is exactly the same as in JML which we have already discussed
  in Section \ref{BCSLprelim} dedicated to JML, we shall not spend more lines here on those.

 The part of the method specification which deserves more attention 
 is the syntax of heavy weight method specification. 
 In Section \ref{BCSLprelim}, we saw that JML supports syntactic sugar for
 the definition of the normal and exceptional behavior of a method. 
 The syntax BML does not
 support these syntactic constructs but rather supports their desugared version
 (see \cite{RT03djml} for a detailed specification of the JML desugaring process).
 A specification in BML may declare several method specification cases using.
 The syntactic structure of a specification case is defined by the nonterminal \specCase.
 We illustrate this by the example in Fig. \ref{bml:heavySpBML}.
% which gives the specification in BML of the method \texttt{divide} from Fig. \ref{bml:heavySp}.
 In the example, we can see that in BML the keywords \jmlKey{normal\_behavior} and \jmlKey{normal\_behavior} are not used. 
 On the contrary, the specification cases now explicitely declare their behavior. 
 The first specification case (the first bunch of specification enclosed in $\{|$ $ |\}$  ) corresponds to the
 \jmlKey{normal\_behavior} specification case in the code from Fig. \ref{bml:heavySp}.
 It states that the method always terminates normally
 and thus, the exceptional postcondition is declared \false \ for any exceptional termination.
 The second specification case in Fig.\ref{bml:heavySpBML}  corresponds to the \jmlKey{exceptional\_behavior} case of the source code
 specification in Fig.\ref{bml:heavySp}. It also specifies explicitely the expected behavior of the method, i.e. the method postcondition
 is declared to be \false. 
 



  
 

%\subsubsection{Method specification case}
%A specification case \specCase \  consists of the following specification units:
%
% \begin{itemize}
%      \item $\requires \ \formulaBc$ which represent the   precondition of the specification case. If such a clause is not explicitely written
%            in the specification, then the default precondition  \Mytrue \ is implicite
%      \item $\ensures \ \formulaBc$   which stands for the normal postcondition of the method in case the precondition held in the prestate.
%%            In case this clause is not written in the specification explicitely, then the default postcondition   \Mytrue \  must hold.
 %     \item $\modifies \ list \ \modifiesLoc $   which is the frame condition of the specification case and denotes the 
%            the locations that may be modified by the method if the precondition of this specification case holds in the prestate.
%	    This in particular means that a location that is not mentioned in the \modifies \  clause may be modified. 
%	    If the modifies clause is omitted, then the default modifies specification is \modifies \ \everything
%      \item \exsuresList \  is the list of the exceptional postconditions that should hold in this specification case. In particular,
 %           every element in the list of exceptional postconditions has the following structure 
%	    $ \exsures \ ( \ident )  $ $\ \formulaBc$. 
%	    Note that  at index $\ident$  there is a constant which stands for some exception class  $\mbox{\rm\texttt{Exc}}$.
%	    The semantics of such a specification expression is that if the method 
%	    containing the exceptional postcondition terminates on an exception of type   $\mbox{\rm\texttt{Exc}}$
%	    then the predicate denoted by $\formulaBc$ must hold in the poststate. Note that the list of exceptional postcondition may be empty.
%	    Also the list of exceptional postconditions might not be complete w.r.t. exceptions that may be thrown  by the method.
%	    In both cases, for every
%	    exception that might be thrown by the method for which no explicite exceptional postcondition is given,
%	     we take the default exceptional postcondition
%	    \Myfalse
%\end{itemize}
%\todo{give the bytecode version of the example with heavy weight specification}






\subsubsection{Intra --- method specification}
As we can see from the formal  grammar in subsection \ref{BCSL}, BML allows to specify a property that must hold at 
particular program point inside a method body. The nonterminal which describes the grammar of assertions is
 \intraMethodSpec.  
 Note that every intra --- method specification, i.e. loop specification or assertion at particular program point
 contains information about the point in the method body at which it refers.
 In the following, we give the meaning of the syntactic constructs of the intra---method specification: 

\begin{itemize}
  \item $\atIndex \ nat$ specifies the index of the instruction which identifies the instruction
        to which the specification refers. 
  \item  $\intraSpec$ specifies the property that must hold in  every  state that reaches the instruction at the index  specified by $ \atIndex \ nat$.
         We allow the following local assertions:  
	 
\begin{itemize}
  \item  \loopSpec \ gives the specification of a loop. It has the following syntax: 
          \begin{itemize}
	     \item $\loopInv \  \formulaBc $  where $  \formulaBc $ is   the property that must hold  whenever the corresponding
	           loop entry instruction is reached during execution
             \item $\loopMod \ list \ loc$  is the list of locations modified in the loop. This means that at the borders
	           of every iteration (beginning and end), all the expressions not mentioned in the loop frame condition must have
		   the same value.  
             \item $ \loopDecreases \ \expression $ specifies the expression $\expression $ which guarantees loop termination. 
	           The values of   $\expression $ must be from a well founded set (usually from $\Myint$ type ) and the values
		    of   $\expression $ should decrease at every iteration 
            \end{itemize}

  \item  $  \assert \ \formulaBc $ specifies the predicate $\formulaBc $ that must hold at the corresponding position in the bytecode

  \item  $ \set \ \expression \  \expression $ is a special expression that allows to set the value of a specification ghost variable. This means
         that the first argument must denote a reference to a ghost variable, while the second expression is the new value that this 
	 ghost variable is assigned to. \todo{what about assigning nonghost value to a ghost field of reference type}
\end{itemize}
\end{itemize}

\subsubsection{Frame conditions} 
BML supports frame conditions for methods and loops. These have exactly the same semantics as in JML. 
The nonterminal that defines the syntax for frameconditions is 
We look now what are the syntax constructs that may appear in the frame condition:

%As we already saw, method or loop specifications  might declare the locations that are modified 
%by the method / loop. We use the same syntax in both of the cases where the modified expressions for methods or loops are
% specified with $  \modifies  \ list \   \modifiesLoc;$. The semantics of such a specification clause is that 
%all the locations that are not mentioned in the $\modifies$ list must be unchanged.
The syntax of the expressions that might be modified by a method is determined by the nonterminal
$  \modifiesLoc$. We now look more closely what a modified expression can be:
\begin{itemize}
      \item  $ \fieldAccess{\expression}{\ident} $ states that the method / loop modifies the value of the field at index $\ident$ 
             in the constant pool for the reference denoted by  $\expression$ 
      \item $\locVar{i}$ states that the local variable may modified by a loop. Note that this kind of modified
            expression makes sense only for expressions modified in a loop.
	    Indeed, a modification of a local variable does not make sense for a method frame condition, 
	    as methods in Java are called by value, and
	    thus, a method can not cause a modification of a local variable that is observable from the outside of the method.
	    
      \item  $\arrayAccessMod{\expression}{\specIndex}$ states that the components at the indexes specified by $\specIndex$ in
            the array denoted by $\expression$ may be modified. The indexes of the array components that may be modified $\specIndex$
	    have the following syntax:
	    \begin{itemize}
	          \item $i$ is the index of the component at index $i$. For instance, \\
		        $\arrayAccessMod{\expression}{i}$ means that the array component at index $i$ might be modified.
	          \item \all \ specifies that all the components of the array may be modified, i.e. the expression 
		         $\arrayAccessMod{\expression}{\all}$ means that any element in the array may potentially be modified.
                       % $$ \forall \ i ,   0  \le i < \length(\expression ) \Rightarrow \arrayAccessMod{\expression}{i }$$
		       
		  \item $ i_1 .. i_2$ specifies the interval of array components between the index $i_1$  and $i_2$.  
		        %Thus, the modified expression  $\arrayAccessMod{\expression}{i_1 .. i_2}$ is a syntactic sugar for 
			%  $$ \forall \ i ,  i_1 \leq i \wedge  i \leq i_2 \Rightarrow \arrayAccessMod{\expression}{i }$$
			 
	    \end{itemize}

      \item $\everything $ states that every location might be modified by the method / loop
      \item $\nothing$ states that no location might be modified by a method / loop
\end{itemize}
