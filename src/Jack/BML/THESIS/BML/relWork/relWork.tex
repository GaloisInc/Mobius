

\section{Related work}\label{bml:relWork}

The idea of introducing annotations in the bytecode is actually not so recent.  
For instance, the possibility to check a property at run-time, using the \texttt{assert}
 construct, has been long adopted in the C programming language and recently also in Java (Java
1.5, see \cite[\S 14.10]{JLS}). Checking runtime simple assertions,
 as for instance that a reference is not  null is certainly very useful as it
 allows for detecting bugs early in the development process.    
But  in the presence of mobile code, the need for more
 powerful specification mechanisms on the executable or interpreted code arises. Moreover, it  represents an interest  
 for software audit which does not trust the compiler. Another reason to 
 consider a rich specification bytecode language  is the verification of programs which
 are written directly in bytecode. 

Although verification of bytecode programs has started to attract 
the scientific interest,  not too much work has been done in
the direction of bytecode specification. Several logics have been developed to reason about
bytecode but none of them discusses the issue about a formalism for expressing program properties.
For instance, in~\cite{BannwartMueller05} Bannwart \& M\"uller propose a general purpose Hoare style bytecode logic
 which is proved correct and complete. They also show how to compile Hoare style derivations 
from the source language into Hoare style derivations over bytecode in order to cope with complex properties in a PCC scenarios.
 However, they do not introduce a formalism into which to
 express those program properties. Within the MRG project~\cite{AspinallEtAl:TPHOLs2004}, a resource aware logic is designed for Grail, a bytecode
language which combines functional and object oriented features.  However, there also the main focus is the development of a sound proof system.
% In both cases, the authors address the problem of building an infrastructure for PCC.
 %But in order to make such a framework work especially for nontrivial policies, the untrusted code should come  annotated.
 BML comes in reply to the need of  writing  and encoding understandable specifications for
bytecode.

The development of BML is clearly inspired by the development of the
JML specification language~\cite{JMLRefMan}. Both JML and
BML follow the Design by Contract principle introduced first in
Eiffel~\cite{Meyer97}. JML is a rich specification language which supports many specification constructs. Note that the semantics of 
 few of the specification  constructs in BML is still under discussion. Currently, BML supports only a subset of JML  corresponding
basically to the so called Level 0 of JML~\cite{JMLRefMan} but  which has a well established semantics.
JML is ``the most popular formal specification'' of Java and thus 
we consider that supporting a relation between a Java bytecode specification language and JML is important.  

% JVer is a tool to verify annotated
%bytecode~\cite{ChanderEILN05}. However, as specification language they
%use a subset of JML, \emph{i.e.}\ a source code level specification language.

The Extended Virtual Platform project\footnote{See \url{http://www.cs.usm.maine.edu/~mroyer/xvp/}.} also is very close to JML.
 This project aims at developing a framework that allows to compile JML annotations, to
allow run-time checking~\cite{AlagicXVP05}. However, in contrast to
our work, they do not intend to do static verification of bytecode
programs. Moreover, the Extended Virtual Platform takes JML-annotated source code
files as starting point, so it is not possible to annotate bytecode
applications directly.

The Spec\# programming system~\cite{BLS04sp} is probably the system which is closest to BML as  
introduces in similarly the Design by Contract principles into the C\#
programming language. However, we consider that the design goals of both Spec\# and BML 
are not exactly the same.
 Let us give a brief description of the architecture of the  Spec\# system. %, both at source code level and for CIL, the .NETintermediate language.
 It consists of the following components:  a programming language Spec\#, a compiler from Spec\# to 
 CLR,( the .NET intermediate language  \cite{B02EN}), a runtime checker and a static verification scheme
 based on an intermediate language BoogiePL and the static verifier Boogie~\cite{BarnettCDJL05}.
 In particular, Spec\# is a superset of the programming language  C\#. Spec\# allows for expressing method (preconditions, postconditions and frameconditions )
 and class contracts as well as class contracts (class invariants). Moreover, the language extends the programming type system with non - null types,
 field initializers and expose blocks for an object (those constructs embrace a  block which  may break the object's invariant and at the end of its execution must reestablish it).
 These additional elements of the language are enforced with runtime checks emitted by the Spec\# compiler. 
  Spec\# programs can be verified dynamically and statically. 
 Both verification styles work on  CLR as the Spec\# compiler produces not only intermediate interpreted code but also metadata which contains 
 the translation of the source specifications. %Moreover, Spec\# supports the C\# custom attributes in specifications which are compiled
 %into metadata in the CIL format. This metadata  information is then used by the verification mechanisms on runtime
 %or statically. %For the moment,  BML is not connected to metadata which becomes official part of the newest
 % Java 5 (Tiger). But note that  we have taken the design  decision to relate BML to JML via a compiler. For the moment we have not considered such possibilty 
 % but we could exploit in the future the facilities of metadata via a compiler from Java metadata to BML. 
  As we stated above, the design of Spec\# is such that it alters the underlying programming language C\#. This is especially suitable for 
 producing a high level quality software as the language obliges programmers to respect a good programming discipline. However,  this does not fit completely 
 in a mobile code scenario as a specified and statically verified CLR code using the Spec\#  system, should be produced only if the code has been
 originally written in Spec\#. But restricting mobile code producers to use a special
 programming system may be a hard restriction. This is a difference between BML and Spec\#.
 BML targets  standard Java source programs and specifications written in JML which is not part of the Java language. 
 Moreover, it is compatible with any non optimizing Java compiler and thus does not provide a major restriction over the producer of the source code. 


 
 


