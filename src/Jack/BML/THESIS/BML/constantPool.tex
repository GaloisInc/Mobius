\newcommand{\cpLength}{\mbox{\rm\textsf{cpLength}}}
\newcommand{\cpElems}{\mbox{\rm\textsf{cpElems}}}
\newcommand{\classConst}{\mbox{\rm\textbf{cpConst}}}


\section{Background information of the class file format}
In this section,  we introduce few data structures of the class file format which are important
for the understanding of the coming sections.

%However, for those who do not know much about it, this chapter is useful for 
%understanding the JML compiler presented in the next section \ref{BCSLcompile}.
% we will need a background information about the class file format. 


 In particular, we will focus on the 
 \constantPool \ data structure as well as of several optional data structures
 contained in the  class file: the \localVariableTable \ and \\
the \lineNumberTable. 
In what follows, we give a consize description of these class file data structures. 


\subsection{The constant pool table}
 Recall that a class file defines
a single class or interface and contains information about  the class name, interfaces implemented by the class, super class, methods
 and fields declared in the class and references. The JVM  \cite{VMSpec} mandates that the class
 file contains data structure usually referred as the constant pool table  which is used to construct the runtime constant pool upon class or 
interface creation. The runtime constant pool serves for loading, linking and resolution of references used in the class.
In the rest of the chapter we will denote the constant pool with \constantPool.
The \constantPool has the following structure:

$$ 
\begin{array}{l}
          %\forall  \clazz : \ClassSet , \\
         \constantPool = \left\{\begin{array}{ll} \cpLength    & :   nat \\
                                                  \cpElems   & :   \classConst [ ]
	                        \end{array} \right\}
   \end{array} 
$$
The first field \cpLength \  contains the length of the second component \cpElems. \cpElems \
is an array containing a data structure for every constant used in the class. The JVM specification defines
 seven kinds of data structures that can be elements of the constant pool.
However, here we will look only on the following elements:
$$ \begin{array}{ll}\classConst & ::=   \mbox{\rm\textbf{CONSTANT\_Fieldref\_info}} \\
		     & \mid \mbox{\rm\textbf{CONSTANT\_Class\_info}} \\
		     & \mid \mbox{\rm\textbf{CONSTANT\_Method\_info}}\\
		      & \mid \mbox{\rm \textbf{CONSTANT\_Utf8\_info}} \\
		      & \mid \mbox{\rm \textbf{CONSTANT\_NameAndType\_info}}
                    \end{array}$$

%Java virtual machine instructions do not rely on the runtime layout of classes, interfaces,
% class instances, or arrays. Instead, instructions refer to symbolic information contained
%in a data structure named  \constantPool. The data structures that may appear in the \constantPool \
%are defined by the JVM specification.

Thus, the \constantPool \ contains elements describing :
\begin{itemize}
  \item every field which is dereferenced in any of the methods
of the current class. The corresponding data structure which stands for a particular field constant reference is 
 \textbf{CONSTANT\_Fieldref\_info}. Its structure is given in Fig.\ref{fldConstant}. The figure shows that
 a constant  field reference data structure contains information about the class or interface where the field is declared 
( the second element of the data structure, \textbf{class\_index}  )
 as well a description of its name and type (the field \textbf{name\_and\_type\_index}~)
   \begin{figure}
$$
\mbox{\rm\textbf{CONSTANT\_Fieldref\_info}} =  \left\{\begin{array}{ll} 
                                                   \mbox{\rm\textsf{tag}}    & :   nat \\
                                                   \mbox{\rm\textsf{class\_index}}     & :   nat \\
						   \mbox{\rm\textsf{name\_and\_type\_index}} & : nat
	                        \end{array} \right\}$$

\begin{itemize}
\item \textsf{tag} is a tag of one byte  whose value is 9 and  determines without 
       ambiguity that the current attribute describes a field reference constant

\item \textsf{class\_index} The value of this item must be a valid index into the \constantPool \ table. 
                            The \constantPool \ entry at that index must be a \textsf{CONSTANT\_Class\_info} structure
			    representing the class or interface type that contains the declaration of the field or method.

\item \textsf{name\_and\_type\_index}   The value of the item must be a valid index into the \constantPool \ table.
                                        The \constantPool \ entry at that index must be a \textsf{CONSTANT\_NameAndType\_info }
					structure. This \constantPool \ entry indicates the name and descriptor of the field.

\end{itemize}
\caption{ { \sc Structure of the } \textbf{CONSTANT\_Fieldref\_info} { \sc attribute }  }
\label{fldConstant}
\end{figure}

\item every class referenced in the current class.  A class constant is stored in the constant pool
         in a  \textbf{CONSTANT\_Class\_info} data structure. The data structure is described in Fig. \ref{clsConstant} 
  \begin{figure}
$$
\mbox{\rm\textbf{CONSTANT\_Class\_info}} =  \left\{\begin{array}{ll} 
                                                   \mbox{\rm\textsf{tag}}    & :   nat \\
                                                   \mbox{\rm\textsf{ name\_index}}     & :   nat \\
						  
	                        \end{array} \right\}$$

\begin{itemize}
\item \textsf{tag} is a tag of one byte  whose value is 7 and  determines without 
       ambiguity that the current attribute describes a class  reference constant

\item \textsf{name\_index} The value of this item must be a valid index into the \constantPool \ table. The \constantPool \ entry at that index must be a
       \textbf{ CONSTANT\_Utf8\_info} data structure representing the name of the class described by the data structure 
 \end{itemize}
\caption{ { \sc Structure of the } \textbf{CONSTANT\_Class\_info} { \sc attribute }  }
\label{clsConstant}
\end{figure}
  
 \item every method which is called in any of the methods
of the current class. It is represented by a  \textbf{CONSTANT\_Method\_info} data structure
      
	
\item  every string constant value is represented as \textbf{CONSTANT\_Utf8\_info}
\item  \textbf{CONSTANT\_NameAndType\_info}  structure is used to represent a field or method, without indicating which class or interface type it belongs to.
       It contains only information about the type and the source name of the field or  method. 
       (see for more detailed explanation \cite{VMSpec}, section 4.4) 

\end{itemize}

 



\subsection{Representation of method in the class file format}

Each method, including each instance initialization method and the class or interface initialization method, is described by a special data structure
called \textbf{method\_info}. Every \textbf{method\_info} structure is supplied with obligatory and optional attributes.
For instance,  an obligatory attribute is  the data structure called  \textbf{Code}.
A \textbf{Code} attribute contains the Java virtual machine instructions and auxiliary information for a single method, instance initialization method,
 or class or interface initialization method.
The \textbf{Code} attribute has a list of optional  attributes which should be ignored by the JVM but which can be used by other tools, as for instance debuggers.
The JVM specification defines two attributes --- the local variable table \ and the line number table,  which may appear
 as attributes in the  \textbf{Code} data structure.
We give hereafter a description of the last two data structures as they will play a role in the JML2BML compilation process. 

\subsubsection{The local variable table attribute } \label{locVarTab}
The local variable table attribute is an optional variable-length attribute of a method \textbf{Code}  attribute. 
We will denote this data structure as  \localVariableTable.
It may be used by debuggers to determine the value of a given local variable during the execution of a method.
In the following, we give a modelization of this attribute specified by the JVM specification as well as the meaning of its components.



$$\localVariableTable = \left\{\begin{array}{ll} \nameInd  & :   nat \\
                                                    \attLen & : nat \\
                                                \lvLength   & :  nat\\
						\lvTab  & : \locVarEls []
	                        \end{array} \right\} $$


Let us see what is the meaning of the components of this data structure:
\begin{itemize}
\item  \nameInd \\
    The value of this item must be a valid index into the \constantPool \ table.
      %The constant_pool entry at that index must be a CONSTANT_Utf8_info (ยง4.4.7) structure representing the string "LocalVariableTable".

 \item \attLen \\
    The value of the item indicates the length of the attribute, excluding the initial six bytes.

 \item \lvLength \\
    The value of the item indicates the number of entries in the  \lvTab \  array.

\item \lvTab\\
    Each entry in the \lvTab \  array indicates a range of code array
    offsets within which a local variable has a value. It also indicates the index into the
    local variable array of the current frame at which that local variable can be found.
    Each entry is of type  \locVarEls
\end{itemize}



The data structure \locVarEls has the following structure:
$$\locVarEls  = \left\{\begin{array}{ll}  \lvElStart  & :   nat \\
                                          \lvElLen  & :  nat \\
					  \nameInd  & : nat \\
					 \descrInd & : nat \\
					\lvElInd & : nat \\
	                        \end{array} \right\} $$

The meaning of the elements of \locVarEls is the following:
\begin{itemize}

\item \lvElStart, \lvElLen \\ 
    The given local variable must have a value at indices into the code array in the interval [\lvElStart, \lvElLen],
    that is, between \lvElStart \ and  \lvElStart +\lvElLen  \ inclusive. 
    The value of \lvElStart \ must be a valid index into the code array of this \textbf{Code}
    attribute and must be the index of the opcode of an instruction. Either the value of \lvElStart +\lvElLen \  must
     be a valid index into the code array of this \textbf{Code} attribute and be the index of the opcode of an instruction,
    or it must be the first index beyond the end of that code array.

\item \nameInd,\descrInd \\
    The value of the \nameInd \ item must be a valid index into the \constantPool \ table. 
    The \constantPool \ entry at that index must contain a data structure representing a valid local variable name 

    The value of the \descrInd \ item must be a valid index into the \constantPool \ table. 
    The \constantPool \ entry at that index must contain a data structure representing a field descriptor encoding the type of a local variable in the source program.

\item \lvElInd \\
    The given local variable must be at index in the local variable array of the current frame.
    If the local variable at index is of type double or long, it occupies both \lvElInd \ and \lvElInd +1.

\end{itemize}
Note that the JVM allows that  there might be more than one \localVariableTable \ attribute per local variable in the \textbf{Code} attribute.
This means that a bytecode local variable might contain even values from incompatible types at different places of the program.  
Note, that in our compiler presented later in Section \ref{BCSLcompile}, we assume that every source method local variable and parameter is compiled to a unique
bytecode local variable which is different from the compilation of any other local variable or parameter in the method.


\subsubsection{The line number table attribute}\label{lineNumTab}

The Line number table attribute is an optional variable-length attribute in the attributes table of a method \textbf{Code} attribute and we call it 
for short \lineNumberTable.  
It may be used by debuggers to determine which part of the Java virtual machine code array corresponds to a given line number in the original source file.
 If a \lineNumberTable \ attribute is present in the attributes table of a given \textbf{Code} attribute, then they may appear in any order.
 Furthermore, multiple \lineNumberTable \ attributes may together represent a given line of a source file;
 that is, \lineNumberTable \  attributes need not be one-to-one with source lines.


