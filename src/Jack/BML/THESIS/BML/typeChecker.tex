
\newcommand{\getType}{\mbox{\rm\textsf{getType}}}
\newcommand{\constType}{\mbox{\rm\textsf{constType}}}
\newcommand{\getClass}{\mbox{\rm\textsf{getClass}}}
\newcommand{\application}{\mbox{\rm\textbf{CLS}}}
 
\section{Well formed BML specification}
In the previous Section \ref{BCSLgrammar}, we gave the formal grammar of BML.
However, we are interested in a strict subset of 
the specifications that can be generated from this grammar. In particular, we want that a
BML specification is well typed and respects few structural constraints.


Let's see few examples of type constraints that  a valid BML specification must respect : 
\begin{itemize}
    \item  the array expression $\arrayAccess{\expression^1}{\expression^2}$ must be such that 
$\expression^1$ is of array type and $\expression^2$  is of integer type
    \item the field access expression  $\fieldAccess{\expression}{\ident}$ is such that $\expression$ is of subtype
    of the class where the field described by the constant pool element at index $\ident$ is declared
    \item For any expression $ \expression^1 \op \expression^2$,  $ \expression^1$ and $ \expression^2$ must be of
          a numeric type

    \item \ldots
\end{itemize}

Example for structural constraint are :
\begin{itemize}
    \item All references to the constant pool must be to an entry of the appropriate type. For example:
          the field access expression  $\fieldAccess{\expression}{\ident}$ is such that the
	  $\ident$ must reference a field in the constant pool; or for the expression $\type{\ident}$, \ident
	  must be a reference to a constant class in the constant pool
    \item every $\ident$ in a BML specification must be a correct index in the constant pool table. 
    
\end{itemize}

Actually, an extension of the bytecode verifier may perform the checks
 if a BML specification  respects this kind of structural and type constraints.
However, we are not going farther in this subject as it is out of the scope of the present thesis.
For the curious reader, it will be certainly of interest to turn to the Java Virtual Machine specification  \cite{VMSpec} 
or to the existing literature on bytecode verification (see the overview article ~\cite{Ljbc} )
 







