
\newcommand{\getType}{\mbox{\rm\textsf{getType}}}
\newcommand{\constType}{\mbox{\rm\textsf{constType}}}
\newcommand{\getClass}{\mbox{\rm\textsf{getClass}}}
\newcommand{\application}{\mbox{\rm\textbf{CLS}}}
 
\section{Well formed BML specification}\label{BML:wf}
In the previous Section \ref{BCSLgrammar}, we gave the formal grammar of BML.
However, we are interested in a strict subset of 
the specifications that can be generated from this grammar. In particular, we want that a
BML specification is well typed and respects structural constraints.
The constraints that we impose here are similar to the type and structural constraints
that the bytecode verifier imposes over the class file format.

Examples for type constraints that  a valid BML specification must respect : 
\begin{itemize}
    \item  the array expression $\arrayAccess{\expression_1}{\expression_2}$ must be such that 
$\expression_1$ is of array type and $\expression_2$  is of integer type.

    \item the field access expression  $\fieldAccess{\expression}{\ident}$ is such that $\expression$ is of subtype
    of the class where the field described by the constant pool element at index $\ident$ is declared
    \item For any expression $ \expression_1 \op \expression_2$,  $ \expression_1$ and $ \expression_2$ must be of
          a numeric type.
    
    \item in the predicate $\expression_1 r \expression_2$ where $r =  \leq,<,\geq, >$  the expressions  $\expression_1$ and 
          $\expression_2$ must be of integer type.

     \item  in the predicate $\expression_1  \subtypeSpec \expression_2$, the expressions $\expression_1$
            and  $\expression_2$ must be of type \TYPE (which is the same as \texttt{java.lang.Class}).

     \item the expression $\elemtype{\expression}$ must be such that $\expression$ has an array type.
	    
     

	  
 \end{itemize}

Examples for structural constraint are :
\begin{itemize}
    \item All references to the constant pool must be to an entry of the appropriate type. For example:
          the field access expression  $\fieldAccess{\expression}{\ident}$ is such that the
	  $\ident$ must reference a field in the constant pool; or for the expression $\type{\ident}$, \ident
	  must be a reference to a constant class in the constant pool
    
    \item every $\ident$ in a BML specification must be a correct index in the constant pool table. 
    
    \item if the  expression $\locVar{i}$ appears in a method BML specification, then
          $i$ must be a valid index in the array of local variables of the method
\end{itemize}

An extension of the Java bytecode verifier may perform the checks
 over BML specification against such kind of structural and type constraints.
However, we have not worked on this problem and is a good candidate for a future work.
For the curious reader, it will be certainly of interest to turn to the Java Virtual Machine 
specification \cite{VMSpec} which contains the official
 specification of the Java bytecode verifier    
or to the existing literature on bytecode verification (see the overview article ~\cite{Ljbc}).
 







