\section{Design features of BML}\label{BML:design}
Before proceeding with the syntax and semantics 
of BML, we would like to discuss the design choices
 made in the language.
Particularly, we will see what are the benefits of our approach as 
well as the restrictions that we have to adopt.
Now, we focus on the desired features of BML, 
how  they compare to JML and what  are the motivations that led us to these decisions:
%First of all, let us look at the objectives of the language:



%Because BML is tailored to a directly interpreted bytecode, 
%the language should respect the following conditions:

\begin{itemize}

\item \textbf{Java compiler independance } \\
      Class files containing BML specification must not depend on 
      any non optimizing compiler. 
    
      To do this, the process of the Java source compilation is separate from the JML compilation. 
      More particularly, the \JMLtoBML (short for the compiler from JML to BML) \ compiler  takes as input a Java source file annotated with JML
      specification and its Java class produced by a non optimizing compiler containing a
      debug information.% As we shall see later in the coming sections, the debug data plays a role in the compilation of the JML specification into BML.
      
      %In other words, we would like that the compilation of BML specification  is not attached to a particular Java compiler. 
      %This makes BML independant from Java source compilation.
      % Note, however that we impose as a restriction that the compiler should be not optimizing. 
       % generating debug information~\footnote{the debug information is necessary for the compilation
      % from JML to BML as we shall see in the coming sections}.

\item \textbf{JVM compatibility } \\
            The class files augmented with the BML specification must be executable by any
	    implementation of the JVM specification.
	    % why do we do so?
	     Because the JVM specification does not allow inlining of any user specific data in the bytecode instructions 
	    BML annotations must be stored separately from the method body (the list of bytecode instructions which represents its body).
	  
	    
	    % how
	    In particular, the BML specification is written in the so
	    called user defined attributes in the class file.
	    The JVM specification defines the format of those attributes and mandates that any
	    user specific information should be stored in such attributes. 
	    Note, that attribute which encodes the specification  referring to a particular bytecode instruction contains
	    information about the index of this instruction. For instance,  BML loop invariants
	    are stored in a user defined attribute in the class file format which  contains the invariant
	    as well as the index of the entry point instruction of the loop.
	    
	    %comparison
	    Thus, BML encoding is different from the encoding of   JML specification where
	    annotations are written directly in the source text as comments
	    at a particular point in the program text or accompany a particular program structure. 
	    For instance, in Fig. \ref{replaceSrc} the
	    reader may notice that the loop specification
	    refers to the control structure which follows after the specification and which corresponds to the loop.
	    This is possible first because
	    the Java source language is structured, and second because writing comments in the source text
	    does not violate the Java or the JVM  specifications. 
	  

            %  However, on bytecode level we
	    %  could not write directly in the bytecode of a method body, as this will corrupt the performance of any standard Java Virtual Machine.
	    %  That's why specification is written outside the bytecode text and contains also information about the instruction to which the specification
	    %  refers. Then, as bytecode does not have control structures specification will always refer to a particular instruction in the bytecode. 
	    %  For instance, loops on bytecode are identified by a unique loop entry instruction and thus, a loop invariant must hold basically every time
	    %  the corresponding loop entry instruction is reached.

\item \textbf{Compactness} and \textbf{Efficiency}\\
      Although opposite, we consider those two features together because they are mutually dependent. 
      By the first, we mean that the class files augmented with BML should be as compact as possible.  
      The second feature refers to that tools supporting BML should not be slowed down by the processing
      of the BML specification and more  precisely  we refer verification condition generator tools.
      This is an important condition if verification is done  on devices with limited resources.

      For fulfilling these conditions, BML is designed to correspond to a subset of the desugared version of JML.
      In particular, it brings a relative compactness of the class
      file as well as makes the verification procedure more efficient. 

      % compactness   
      We first see in what sense this allows the class file compactness. 
      Because every kind of BML specification clause is
      stored in a different user defined attribute, supporting all constructs of JML would 
      mean that class files may contain a large number of attributes which would increase
      considerably the class file size. Of course, the size of a BML specification depends also 
      on how much detailed is the specification, the more
      detailed it is, the larger size it would have.
      
      % efficiency
      Because BML corresponds to a desugared version of JML, this means that on verification time
      the BML specification does not need much processing and thus, it can be easily translated to the
      data structures used in the verification scheme. This makes BML suitable for verification on devices
      with limitted resources.
      
\end{itemize}



As the attentive reader has noticed, we impose some restrictions on the structure of the class file format and the bytecode programs.
These restrictions are the following:
 


\begin{itemize}
  \item \textbf{Debug Information} \\ 
       A requirement to the class file format is that it must contain a debug information, more particularly
       the \textbf{Line\_Number\_Table} \\ 
       and \textbf{Local\_Variable\_Table}  attributes. The presence in the Java class file format of 
       these attribute is optional \cite{VMSpec}, yet almost all standard non optimizing compilers can generate these data. 
       The \textbf{Line\_Number\_Table} is part of the compilation of a method and 
       describes the link between the Java source lines and the Java bytecode.
       The \textbf{Local\_Variable\_Table} describes the local variables that appear in a method.  
       This debug information is necessary for the compiler from JML to BML, as we shall see later in Section \ref{BCSLcompile}.

\item  \textbf{Reducible control flow graph} \\ 
       The control flow graph corresponding to the list of bytecode instructions resulting from the compilation of a method
       body must be a reducible control flow graph. An intuition to the notion of reducibility is that every cycle in the
       graph must have exactly one entry point, 
       or in other words a cycle can not be jumped from outside inside (see \cite{ARUCom1986} for the definition of reducibility). This condition is necessary for the compilation
       phase of the loop  invariants as well as for the verification procedure (Section \ref{wpGeneral}).
       Note, that this restriction is realistic as nonoptomizing Java compilers produce
       reducible control flow graphs and in  practice even hand written code is in most cases reducible. 
\end{itemize}





