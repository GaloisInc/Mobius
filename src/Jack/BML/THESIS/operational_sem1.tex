\newtheorem{StateTransition}{Definition}

%\section{Logic, Language and Operational Semantics}\label{opSem}
 The present section introduces several notions which are fundamental 
 for our purposes: a language of expressions, a bytecode language, the notion of
 program state and an operational semantics of the bytecode language in terms of program state transitions. 
 The set of expressions supports the basic features of the expressions that Java bytecode programs manipulate.
 The instructions of which consists the bytecode language correspond to a representative subset of
 the Java bytecode language as it supports method invokations, object manipulation and creation, 
 exception throwing and subroutines. 
 
 In the following, subsection \ref{lang} presents the expressions that our bytecode programs manipulate, 
 subsection \ref{subst} discusses briefly how the substitution is defined,
 subsection \ref{formulas} gives the language of predicates in which the program properties will be expressed,
 subsection \ref{programLang} lists the bytecode instructions of the bytecode language along with their description,
 subsection \ref{def} introduces the notion of state configuration,
 subsection \ref{opSem} gives the operational semantics of 
 every instruction from the language.






\subsection{Related work}

%\subsection{Bytecode Programming Language}\label{programLang}


\input config.tex

\subsection{Bytecode Language and its Operational Semantics} \label{opSem}
 The bytecode language that we introduce here corresponds to a representative subset of the Java bytecode language. 
 In particular, it supports object manipulation and creation, method invokation, exception throwing and handling as
 well as subroutines. In fig. \ref{opSem:bclang}, we give the list of instructions that constitute our bytecode
 language.
 
 \begin{figure}[h] 
        \begin{array}{lll}
             \bcIns ::= & \ifCond & \\
	                & \mid \goto  & \\ 
			& \mid \return  &\\ 
			& \mid \op  & \\ 
			& \mid \load & \\ 
			& \mid \store & \\
			& \mid \push & \\
			& \mid \pop & \\
			& \mid \iinc & \\
			& \mid \new & \\
			& \mid \newarray &  \\
			& \mid \putfield & \\ 	
			& \mid \pop  & \\ 	
			& \mid \iinc  & \\
			& \mid \new  & \\
			& \mid \newarray &  \\
			& \mid \putfield  & \\
			& \mid \getfield  & \\
			& \mid \arrstore &  \\
			& \mid \arrload  & \\
			& \mid \arraylength  & \\
			& \mid \instanceof  & \\
			& \mid \checkcast &  \\
			& \mid \instanceof &  \\
			& \mid \athrow  & \\
			& \mid \invoke  & \\
			& \mid \jsr  & \\
			& \mid \ret  & \\
		
        \end{figure}
        \caption{Bytecode Language instructions }
        \label{opSem:bclang}
  \end{figure}  
 
 Next, we define the operational semantics. The operational semantics
 of an instruction states how the execution of an instruction affects the program state configuration 
 in terms of state configuration transitions defined in the previous subsection \ref{def}.
 Note that we do not model the frame stack of the JVM. 

\begin{StateTransition}[State Transition] \label{stateTrans} If an instruction starts execution in a state with configuration  
$\config{ \tau_1}{ \pc_1}$ and terminates execution in state with configuration $\config{\tau_2}{\pc_2}$.  
We note it by  $\config{\tau_1}{\mbox{ \rm \pc} _1} \stateTrans \config{ \tau_2}{\mbox{ \rm \pc} _2}$. 

%We say that there is a state transition from $\config{\heap_1}{ \tau_1}$ to $\config{\heap_2}{ \tau_2}$, that $\heap_1$ is $\prevState{\heap_2 }$ and  $\tau_1$ is $\prevState{\tau_2 }$
\end{StateTransition}

 JVM is stack based and a new method is called a new method frame is pushed on the frame stack and the execution continues on this new frame.
 A method frame contains the method operand stack, the array of registers and the constant pool of the class the method belongs to.
 When a method terminates its execution normally, the result, if any, is popped from the method operand stack, the method frame is
 popped from the frame stack and the method result (if any) is pushed on the operand stack
 of its caller. If the method terminates with an exception, it does not return any result and the exception object is propagated back to its callers.
 
Our formalization considers only single method execution abstracting from the method frame stack as it is sufficient for
 the proof of correctness of the definition of the weakest precondition calculus. This abstraction is possible as the proposed verification procedure is modular - 
when verifying a method we assume that all the other methods are correct and we are concerned
only with establishing the correctness of the current method.


 We introduce a special value for the program counter $\bottom$. The program counter receives this value whenever the method execution 
 terminates (normally or by throwing an
 exception).  $\tt{returnVal( m, o,arg_1, arg_2 ...arg_{numargs(m)}})$ stands for the value that a method \texttt{m} returns if invoked with  arguments
 $\tt{arg_1, arg_2 \ldots}$  $\tt{ arg_{numargs(m)}}$ and the method call receiver is the object referenced by $\tt{o}$. 
The key word \result \ is a special variable that stores the value that the current method returns.  
\todo{say more about exceptions: exception table, how the exception handler is searched in a separate section may be}
The function \texttt{excIndex{ind}{ExcType}} returns either the index of the exception handler that protects the instruction at index \texttt{ind} from exception 
type  \texttt{ExcType}, or $\bottom$ if such a handler does not exist :


\begin{itemize}
       \item Control transfer instructions \\\\

        \begin{enumerate}
            \item Conditional jumps : \ifCond


        $$ \begin{array}{l}
                 \frac{ \mbox{ \rm \texttt{ cond}}( \stack{\topStack}, \stack{\topStack - 1}) } 			       		               
                      {\ifCond \ n : \config{\heap }{\counter}{\stackOnly}{\locVarOnly}{\pc}
		                      \stateTrans 
				      \config{\heap}{\counter - 2}{\stackOnly}{\locVarOnly}{\pc + n}} 
                \\
                \\
		\\
                 \frac{  not (\mbox{ \rm \texttt{ cond}}( \stack{\topStack}, \stack{\topStack - 1})) }		                             
                     {\ifCond \ n : \config{\heap}{\counter}{\stackOnly}{\locVarOnly}{\pc} 
		                    \stateTrans 
                                    \config{\heap}{\counter - 2}{\stackOnly}{\locVarOnly}{\pc + 1}} 
          \end{array} $$
            

	    The condition \texttt{cond} is applied to the stack top and zero. If the condition is true then the control is transfered to the instruction
	    at index \texttt{n}, otherwise the control continues at the instruction following the current instruction. The top two elements \stack{\topStack} and
            \stack{\topStack - 1}  of the stack top are popped from the operand stack.
 
        \item Unconditional jumps: \goto \\
            $$ \frac{ \begin{array}{l} \tau_{1} = \tau_{0} \\     
                                       \pc_1 :=  \pc_0 +  n 
                      \end{array} }
	          {\goto \ n: \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}$$
   
             Transfers control to the instruction at position \textit{n}.


      \item \return
        $$ \frac{ \begin{array}{l}
		        \tau_{1} = \tau_{0} \substitution{\result}{\stack{\topStack} }  \\
		        \pc_1 = \bottom 
                   \end{array}} 
            {\return :\config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}  $$

	    The instruction transfers the control to the caller of the method and 
            if the current method is not void the value on the top of the stack of the current method is put 
	    in the special variable \result which contains the return value of the method.
	     
      \end{enumerate}








    \item Arithmetic operations \\\\ 	
           \op (\op =  \instr{add}, \instr{sub}, \instr{mult}, 
	 		\instr{and}, \instr{or}, \instr{xor} , \instr{ishr}, \instr{ishl}, \instr{div}, \instr{rem} )  \\ 

    $$ \frac{ \begin{array}{l}
		\tau_{1} = \tau_{0} \begin{array}{l}
		                      \substitution{\topStack}{\topStack - 1} \\
	                              \substitution{\stack{\topStack - 1} } {\stack{\topStack - 1} \ \rm{op} \ \stack{\topStack}}
				    \end{array} \\
		\pc_1 := \pc_0 + 1 
		\end{array}
	   } 
	   { \op : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}  $$\\\\
 
		  Pops the values which are on the stack top \stack{\topStack}  and \stack{\topStack - 1}  at the position below and applies the arithmetic operation \texttt{op} on them. 
		  The stack counter is decremented and  the resulting  value on the stack top \stack{\topStack - 1} \ \rm{op} \ \stack{\topStack} is pushed on the stack
		  top  \stack{\topStack - 1}. 
	\todo{case for arithmetic instructions that throw exception }
    \item Load Store instructions \\\\

      \begin{enumerate}
    
	\item \load
	$$ \frac{ \begin{array}{l} \tau_{1} = \tau_{0}  \begin{array}{l}
	                                                   \substitution{\topStack}{\topStack + 1}\\
							    \substitution{\stack{\topStack + 1} } {\locVar{ind} }
							\end{array} \\
               \pc_1 = \pc_0 + 1 
		\end{array} 
	    } 
	    {\load \ \it{ind} : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}} $$ \\\\
            The instruction loads increments the stack counter  \topStack and pushes
	    the content of the local variable $\register{i}$ \ on the stack top \stack{\topStack + 1}.
	    
        \item \store
        $$ \frac{  \begin{array}{l}\tau_{1} = \tau_{0}   \begin{array}{l} 
                                                        \substitution{\topStack}{\topStack - 1} \\
		                                        \substitution {\locVar{ind}}{\stack{\topStack} } 
						\end{array} 	 \\     
               \pc_1 =\pc_0  + 1 
		\end{array}  }
                { \store \ \it{ind} :  \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1} }  $$ \\\\
	     Pops the stack top element \stack{\topStack}  and stores it into local variable $\locVar{i}  $ and  decrements the stack counter 
	     \topStack  
	
        \item  \instr{iinc}

                $$\frac{ \begin{array}{l}
	                \tau_{1} = \tau_{0} \substitution{\locVar{ind}}{\locVar{ind} + 1 } \\
                       \pc_1 =\pc_0  + 1 
 	          \end{array}
	        } 
	        {\instr{iinc } \ \it{ ind}  :  \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1} } $$
            Increments the value of the local variable $\locVar{i}$ 
	
	\item \push
	       $$\frac{ \begin{array}{l}
	                \tau_{1} = \tau_{0}  \begin{array}{l} 
                                                \substitution{\topStack}{\topStack + 1} \\
						\substitution {\stack{\topStack + 1} }{i}
				             \end{array}  \\   
                         \pc_1 =\pc_0  + 1 
 	          \end{array}
	        } 
	        {\instr{push} \ i  :  \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1} }  $$ 
     
      \item \instr{pop} \todo{give the semantics}
    \end{enumerate}
	  The instruction pushes the integer \textit{i} on the top of the stack

    \item Object creation and manipulation 

     \begin{enumerate}

      \item \new \texttt{Cl}
            $$ \frac{ 
	          \begin{array}{l} 
	              \tau_{1} = \tau_{0} \begin{array}{l} \substitution{\heap }{\heap[\oplus \Ref{\tt{Cl} } \longrightarrow \objCl{Cl} ]}\\
                                                           \substitution{\topStack}{\topStack + 1} \\
                                                           \substitution{\stack{\topStack + 1 }}{\Ref{\tt{Cl} } }  
					  \end{array}		   
	 	      \\
		      \pc_1 :=  \pc_0 + 1 
	          \end{array} }
              {\new \tt{Cl} : \config{\tau_{0}}{\pc_0} \stateTrans \config{\tau_{1}}{\pc_1}} $$ \\\\
	      A new instance  $\objCl{Cl}$  of type \texttt{Cl} is allocated in the garbage-collected memory  heap and the store \heap is updated 
	      by mapping the fresh reference  $\Ref{\tt{Cl} }$ with the newly created object $\objCl{Cl}$. 
	      The stack counter \topStack is incremented.
	      The reference   $\Ref{\tt{Cl} }$ is put on the stack top \stack{\topStack + 1 }. 
	

      \item \putfield  
            $$\begin{array}{l} 
	      \frac{    
	          \begin{array}{l}
                      \stack{\topStack - 1} != \Mynull \Rightarrow \\
		      	\Myspace \Myspace      \tau_{1} =  \tau_{0} 
			                                      \begin{array}{l} \substitution{\topStack}{\topStack - 2} \\
		                                               \substitution{\field{c}{f}   }{\field{c}{f} [\oplus  \stack{\topStack-1} \longrightarrow  \stack{\topStack }] } 
							       \end{array} \\
		    	\Myspace \Myspace     \pc_1   = \pc_0 + 1                
		      \end{array}}  
		      {\putfield \ \field{c}{f}: \config{\tau_{0}}{\pc_0} \stateTrans  \config{\tau_{1}}{\pc_1}}
		      
                     \\ 
                     \\ 
		     \\
		     \frac{    
	                   \begin{array}{l}
			           \stack{\topStack - 1} == \Mynull \Rightarrow  \\
				   \Myspace \Myspace    \tau_{1} = \tau_{0}  \begin{array}{l}\substitution{\heap}{\heap[ \oplus \Ref{NullPointerExc} \longrightarrow \objCl{NullPointerExc} ]  } \\
      		                                  	     \substitution{\topStack}{0} \\
       		      	                                     \substitution{\stack{0}}{\Ref{NullPointerExc}  }
					       \end{array} \\
          			\Myspace \Myspace    \pc_1  = \tt{ \excIndex{\pc_0 }{NullPointerExc}}\\
       		 \end{array} }
              {\putfield \ \field{c}{f}: \config{\tau_{0}}{\pc_0} \stateTrans  \config{\tau_{1}}{\pc_1}} 	 \end{array} $$ \\\\
	      
        The top stack element \texttt{value} and the element below it \texttt{objRef} are popped from the stack. 
		  If \texttt{objRef} is not null, the value of the field \texttt{f} for the object  \texttt{objRef} is set
		  to \texttt{value}. If \texttt{objRef} is null then a \texttt{NullPointerExc} is thrown

      \item \getfield
          $$\begin{array}{l} 
	          \frac{ \begin{array}{l}
                               \stack{\topStack} \neq \Mynull \Rightarrow \\
			       \Myspace \Myspace \tau_{1} = \tau_{0}  \substitution{\stack{\topStack} } { \field{c}{f}(\stack{\topStack} )} \\
			       \Myspace \Myspace  \pc_1  =  \pc_0 + 1 
			\end{array}
                       }   
		       { \getfield \ \field{c}{f}  : \config{\tau_{0}}{\pc_0}  \stateTrans \config{\tau_{1}}{\pc_1} } 
		       \\
		       \\
		       \\
		  \frac{\begin{array}{l}
		              \stack{\topStack } == \Mynull \Rightarrow \\
			      \Myspace \Myspace  \tau_{1} = \tau_{0}\begin{array}{l} \substitution{\topStack}{0}\\
			                                                 	 \substitution{\stack{0}}{\Ref{NullPointerExc}}  \\
			                                                         \substitution{\heap}{\heap[\oplus \Ref{NullPointerExc} \longrightarrow \objCl{NullPointerExc} ]} 
                                                                 \end{array} \\
		 	       \Myspace \Myspace    \pc_1   = \tt{ \excIndex{\pc_0 }{NullPointerExc}}\\  
                        \end{array}}
                       { \getfield \ \field{c}{f}  : \config{\tau_{0}}{\pc_0}  \stateTrans \config{\tau_{1}}{\pc_1} }
	       \end{array}   $$ \\\\
 	
	      
	      The top stack element \stack{\topStack}  is popped from the stack. If \stack{\topStack} is not \Mynull the value of the field \texttt{f}
	      in the object referenced by the reference contained in \stack{\topStack}, is fetched and pushed onto the operand stack \stack{\topStack}.
	      If \stack{\topStack} is \Mynull then a \texttt{NullPointerExc} is thrown, i.e. the stack counter is set to 0, a new object of type
	      \texttt{NullPointerExc} is created in the memory heap store \heap and a reference to it $\Ref{NullPointerExc}$ is pushed onto the operand stack.
	

	\item  \instr{newarray  \ type}\\
		  A new array whose components are of type \texttt{type} and whose length is the stack top value is allocated on the heap.
		  The array elements are initialised to the default value of  \texttt{type} and a reference to it is put on the stack top. 
		  In case the stack top is less than 0, then \texttt{NegativeArraySizeExc} is thrown
 		
		
 		
	
		 

		    
     \item \instr{type\_astore}\\
		  Stores a value in an array component. 
		  The top stack element \texttt{value}, the stack element below it \texttt{ind} and the stack element \texttt{arrInd}
		  below \texttt{ind} are popped from the operand stack. The type \texttt{value} must be assignment 
		  compatible\todo{say what assignment compatible is}. with the type
		  of the elements of the array referenced by \texttt{arrRef}. \texttt{ind} must be of type ind. 
		  \texttt{arrRef} must be a reference to an array whose components must be of type \textrm{type}.
		  The value \texttt{value} is stored in the component at index \texttt{ind} of the array referenced by \texttt{arrRef}.  
		  If \texttt{arrRef} is \Mynull a \texttt{NullPointerExc} is thrown. If \texttt{ind}  is not in the bounds of the array 
		  object referenced by \texttt{arrRef}  a \texttt{ArrIndexOutOfBoundExc} is thrown. If \texttt{value} is not assignment 
		  compatible with the type of the components of the array, then \texttt{ArrStoreExc} is thrown.


     \item \arrload
           
         $$ \begin{array}{l}
	           \frac{ \begin{array}{l}
	                  \left. \begin{array}{l}
                                        \stack{\topStack - 1} \neq \Mynull  \wedge \\
					\stack{\topStack} \geq 0 \wedge  \\
					\stack{\topStack} < \arrayLength (  \stack{\topStack - 1}  )
			 \end{array}\right\}   \Rightarrow \\
			 \Myspace \tau_{1} = \tau_{0} \begin{array}{l}
			                                 \substitution{\topStack } { \topStack - 1} \\
						         \substitution{\stack{\topStack - 1 } } { \arrayAccess{ \stack{ \topStack -1 }}{\stack{ \topStack} } } \\
					             \end{array}\\
			 \Myspace   \pc_1  =  \pc_0 + 1
			 \end{array}}
			  { \arrload \   : \config{\tau_{0}}{\pc_0}  \stateTrans \config{\tau_{1}}{\pc_1} }  
			  \\ \\ \\
	           
		   \frac{ \begin{array}{l}
                                 \stack{\topStack -1 } == \Mynull \Rightarrow \\
				  \Myspace   \tau_{1} = \tau_{0}\begin{array}{l}
			                                     \substitution{\topStack}{0}\\
			                                      \substitution{\stack{0}}{\Ref{NullPointerExc}}  \\
			                                    \substitution{\heap}{\heap[\oplus \Ref{NullPointerExc} \longrightarrow \objCl{NullPointerExc} ]}  
                                                      \end{array} \\
                                  \Myspace \pc_1   = \tt{ \excIndex{\pc_0 }{NullPointerExc}}
		         \end{array}
		         }   
			 { \arrload \   : \config{\tau_{0}}{\pc_0}  \stateTrans \config{\tau_{1}}{\pc_1} }
                        \\ \\ \\
		
		    \frac{ \begin{array}{l}
			\begin{array}{l}
                            \stack{\topStack - 1} \neq \Mynull \wedge \\
			       ( \stack{\topStack} < 0 	\vee  \\
			       \stack{\topStack} \geq \arrayLength (  \stack{\topStack - 1}  ) )
			\end{array}
                      \Rightarrow \\
			\Myspace     \tau_{1} = \tau_{0} \begin{array}{l}
                                                                \substitution{\topStack}{0}\\
		             	                                \substitution{\stack{0}}{\Ref{ArrIndexOutOfBoundExc }}  \\
			        	                         \substitution{\heap}{\heap[\oplus \Ref{ArrIndexOutOfBoundExc} \longrightarrow \objCl{ArrIndexOutOfBoundExc} ]} 
                                                          \end{array} \\
		      	\Myspace  \pc_1   = \tt{ \excIndex{\pc_0 }{ArrIndexOutOfBoundExc}}
                \end{array}}
              { \arrload \   : \config{\tau_{0}}{\pc_0}  \stateTrans \config{\tau_{1}}{\pc_1} } 
	      \end{array}$$ \\\\
	      
	       Loads a value from an array. The top stack element \stack{\topStack} and the element below it \stack{\topStack -1 }
	       are popped from the operand stack.  \stack{\topStack} must be of type \Myint.\stack{\topStack -1 } must be 
               of type \reff whose components are of type \textrm{type}. The value in the component of the array  \texttt{arrRef} 
	       at index \texttt{ind} is retrieved and pushed onto the operand stack.
	       If \stack{\topStack -1 } contains the value \Mynull a \texttt{NullPointerExc} is thrown. If \stack{\topStack}  is
	       not in the bounds of the array object referenced by \stack{\topStack -1 }  a \texttt{ArrIndexOutOfBoundExc} is thrown

      \item \arraylength
               $$ \begin{array}{l}
		         \frac{ \begin{array}{l}
			              \stack{ \counter } \neq \Mynull \Rightarrow \\
				      \Myspace \tau_{1} = \tau_{0} \substitution{ \stack{ \counter}}{ \arrayLength{\stack{\counter} } } \\ 
				      \Myspace \pc_1 = \pc_0 + 1                              
			        \end{array}
			      }
			      { \arraylength : \config{\tau_{0}}{\pc_0} \stateTrans \config{\tau_{1}}{\pc_1}  }
			      \\ \\ \\ 
			 \frac{ \begin{array}{l}
			              \stack{ \counter } == \Mynull \Rightarrow \\
				      \Myspace \tau_{1} = \tau_{0} \begin{array}{l}
			                                     \substitution{\topStack}{0}\\
			                                      \substitution{\stack{0}}{\Ref{NullPointerExc}}  \\
			                                    \substitution{\heap}{\heap[\oplus \Ref{NullPointerExc} \longrightarrow \objCl{NullPointerExc} ]}  
                                                      \end{array} \\
				      \Myspace \pc_1 = \pc_0 + 1                              
			        \end{array}
			      }
			      { \arraylength : \config{\tau_{0}}{\pc_0} \stateTrans \config{\tau_{1}}{\pc_1}  }     
		  
		 \end{array}
	       $$
		  The stack top element is popped from the stack. It must be a 
		  reference that points to an array. If the stack top element \stack{\counter} is not \Mynull  the length of the array  
		  \arrayLength{\stack{\counter} } is fetched and pushed on the stack.
		  If the stack top element \stack{\counter} is \Mynull then a \texttt{NullPointerExc} is thrown.

      \item \instanceof
            $$ \begin{array}{l}
	             \frac{ \begin{array}{l}
                            subtype(\stack{\counter},\tt{Class}) \Rightarrow \\		
		\Myspace    \tau_{1} = \tau_{0} \substitution{\stack{\counter} }{1}   \\
                 \Myspace     \pc_1 :=  \pc_0  +1 
		           \end{array}}
                  {\instanceof  \ \tt{Class} : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}} 
		  \\ \\  \\
		
		\frac{ \begin{array}{l}
                not( subtype(\stack{\counter},\tt{Class})) \vee \stack{\counter} == \Mynull   \Rightarrow  \\
		  \Myspace \Myspace \tau_{1} = \tau_{0} \substitution{\stack{\counter} }{0}  \\
      		    \Myspace  \Myspace  \pc_1 :=   \pc_0 +1 
            \end{array} }
            {\instanceof  \ \tt{Class} : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}
	     \end{array}  $$
	    The stack top is popped from the stack. If it is of subtype \texttt{Class} or
	   is \Mynull, then the   \texttt{1} is pushed on the stack, otherwise \texttt{0}. 

	\item \checkcast
          $$\begin{array}{l}
	           \frac{\begin{array}{l}
		               subtype(\stack{\counter},\tt{Class})  \vee \stack{\counter} == \Mynull  \Rightarrow \\
			       \Myspace  	\tau_{1} = \tau_0   \\   
			       \Myspace  	\pc_1 :=  \pc_0  +1 \\
                          \end{array}}
		         {\checkcast \ \tt{Class} : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}   
		   \\ \\  \\ 
		   \frac{\begin{array}{l}	   
                               not( subtype(\stack{\counter},\tt{Class})) \Rightarrow  \\
			       \Myspace  \tau_{1} = \tau_{0} \begin{array}{l}
		                                                    \substitution{\stack{0}}{\Ref{ClassCastExc}} \\
								    \substitution{ \heap}{\heap[\oplus \Ref{ClassCastExc} \longrightarrow \objCl{\tt{ClassCastExc}} ]}
						             \end{array}\\
		               \Myspace   \pc_1 = \tt{ \excIndex{\pc_0 }{NullPointerExc}}\\
			  \end{array} }
            {\checkcast \ \tt{Class} : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}
	    \end{array}  $$

	   The stack top is popped from the stack. If it is not of subtype \texttt{Class} an exception of type \texttt{ClassCastExc} is thrown.
		    


\end{enumerate}
	      
    \item Throw exception instruction
            $$ \frac{\begin{array}{l}	 
		\tau_{1} = \tau_{0}\substitution{\heap}{ \heap[\oplus \Ref{Exc} \longrightarrow \objCl{Exc}]} 
				 \substitution{\topStack }{0}  \substitution{\stack{0} }{\Ref{Exc}}  \\
		  \pc_1 :=  \tt{ \excIndex{\pc_0 }{NullPointerExc}}\\
		\end{array}}
              {\athrow \ \texttt{Exc} : \config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}  $$
           The stack top element  must be a reference of an object of type \texttt{Throwable}. 
	  If there is a handler that protects this bytecode instruction from the exception thrown, the control is transfered
	  to the instruction at which the exception handler starts\footnote{for every method the ExceptionHandler
	  table describes the corresponding exception handler by the limits of the 
	  region it protects, the Exception that it catches, and the instruction at which it starts}.
	  If the object on the stack top is \Mynull, a \texttt{NullPointerExc} \ is thrown. 

    \item Method Invokation. We consider only the case when  the invoked method returns a value:
           $$ \frac{
\begin{array}{l}
if \ method \ \tt{m} \ terminates \ normally \ then \\
\tau_{1} = \tau_{0} \substitution{\heap }{\heap[\oplus \Ref{Cl_s} \longrightarrow \objCl{Cl_s}  }_{s=0}^{numNewObj}\\
 \Myspace \Myspace \substitution{ \topStack }{\topStack - numArg(\tt{m})}\\
 \Myspace \Myspace  \substitution{ \stack{\topStack} }{returnVal( \tt{m,\stack{\counter - numArgs(\tt{m})},..,\stack{\counter - numArgs(\tt{m})+i} ..\stack{\counter} })} \\
 \Myspace \Myspace \substitution{ \modExp }{\tt{val_i} }_{i=1}^n \\
 \pc_1 = \pc_0 + 1 \\
\\
if \ method \ \texttt{m} \ terminates \ with \ an \ exception \ then\\ 
\tau_{1} = \tau_{0} \substitution{\heap }{\heap[\oplus \Ref{Cl_s} \longrightarrow \objCl{Cl_s}  }_{s=0}^{numNewObj}\\
 \Myspace \Myspace  \substitution{\topStack}{0}\\
 \Myspace \Myspace  \substitution{\stack{0} }{\Ref{class(\stack{\topStack}) }} \\
 \pc_1 :=  \tt{ \excIndex{\pc_0 }{NullPointerExc}}
\end{array}}{\invoke \  \tt{m} :\config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}  }$$
	
		  Invokes a method \texttt{m}. If \texttt{m} receives \texttt{n} arguments and is not static, 
		  the local variables of \texttt{m} are initilised with the first \texttt{n} elements of the stack
		  and the callee object is initialised with the element at position \texttt{n+1} of the stack.
		  If the element of the stack at position \texttt{n+1} is \Mynull it throws a \texttt{NullPointerExc}.

    %     \item else
       %      $$ \frac{ \begin{array}{l} \tau_{1} = \tau_{0} \substitution{ \topStack }{\topStack -
       %        numArg( \texttt{m} ) - 1}  \ \pc_{\tau_{1} } :=  \pc_{\tau_{0} } + 1 \ in \  normal \ case \ execution \\ 
	%      \tau_{1} = \tau_{0} \substitution{\topStack}{0} \substitution{\stack{\topStack} }{\Ref{class(\stack{\topStack}) }}	 \ \pc_{\tau_{1} } :=  e \ in \ exceptional \ case
% 	\end{array} }
%  {\rm{invoke} \  \texttt{m} : \tau_{0} \rightarrow \tau_{1} }
 %           $$
	
	
In this rule, the index $e$ denotes either the index in the array of bytecode instructions at which the corresponding exception handler starts if it exists, 
or has value $\bottom$ in case the exception thrown is not handled (see \cite{VMSpec} ). 
The operational semantics of the \instr{invoke}  instruction  says that after the method call 
the memory heap can change,	
that the expressions $\texttt{\modExp}_i, i = 1 .. n $ can be  modified by the invoked method \texttt{m} and $\tt{v_i}$ are their new values.  
The notation as stated earlier \\
$ returnVal( \tt{m,\stack{\counter - numArgs(\tt{m})},..,\stack{\counter - numArgs(\tt{m})+i} ..\stack{\counter} }$ is the value that the invoked method \texttt{m}
returns for  the actual parameters $\stack{\counter - numArgs(\tt{m}) + 1} ..  \stack{\counter - numArgs(\tt{m}) + i}...\stack{\counter}  $ and call receiver
$\stack{\counter - numArgs(\tt{m}) }$.   

    \item Subroutines 
	\begin{enumerate}		
         \item     $$  \frac{ \tau_{1} = \tau_{0} \ \     \pc_1 :=  \pc_0  + \it{ind} } 
{\jsr \ \it{ind} :\config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}} $$
	
	\item  $$  \frac{ \tau_{1} = \tau_{0} \ \     \pc_1 :=  \pc_0  + \it{ind\_called\_jsr } + 1  }  
		{\ret \ \it{ind} :\config{\tau_{0}}{\pc_0} \rightarrow \config{\tau_{1}}{\pc_1}}  $$
%	When a subroutine is executed we assume that it must return to the instruction after the corresponding \textrm{jsr} .

	\end{enumerate}
\end{itemize}
