

\section{Java Runtime Exceptions}
\label{sec:runtimeexceptions}
% Why runtime exceptions
The JVM~\cite{Lindholm2000} specifies a safe execution environment for Java programs. Contrary to native execution, which does not automatically control the safety of the program's operations, the Java virtual machine ensures that every instruction operates safely. The Java environment may throw predefined runtime exceptions at runtime, like the following ones:

\begin{description}
\item[\texttt{NullPointerException}]
This exception is thrown when the program tries to dereference a \texttt{null} pointer. Among the instructions
that may throw this exceptions are: \texttt{getfield}, \texttt{putfield}, \texttt{invokevirtual}, \texttt{invokespecial}, the set of  \texttt{\emph{type}astore} instructions\footnote{the JVM instructions are parametrized, thus we denote by \texttt{\emph{type}astore} the set of array store instructions, which includes \texttt{iastore}, \texttt{sastore}, \texttt{lastore}, ...} may throw such an exception.
\item[\texttt{ArrayIndexOutOfBoundsException}] If an array is accessed out of its bounds, this exception is thrown to prevent the program from accessing an illegal memory location. According to the Java Virtual Machine specification, the instructions of the family \texttt{\emph{type}astore} and \texttt{\emph{type}aload} may throw such an exception.
\item[\texttt{ArithmeticException}] This exception is thrown when exceptional arithmetic conditions are met. Actually, there is only one such case that may occur during runtime, namely the division of an integer by zero, which may be done by \texttt{idiv}, \texttt{irem}, \texttt{ldiv} and \texttt{lrem}.
\item[\texttt{NegativeArraySizeException}] Thrown when trying to allocate an array of negative size. \texttt{newarray}, \texttt{anewarray} and \texttt{multianewarray} may throw such an exception.
\item[\texttt{ArrayStoreException}] Thrown when an object is attempted to be stored into an array of incompatible type. This exception may be thrown by the \texttt{aastore} instruction.
\item[\texttt{ClassCastException}] Thrown when attempting to cast an object to an incompatible type. The \texttt{checkcast} instruction may throw such an exception.
\item[\texttt{IllegalMonitorStateException}] Thrown when the current thread is not the owner of a released monitor, typically by \texttt{monitorexit}.

\end{description}

If the JVM detects that executing the next instruction will result in an inconsistency or an illegal memory access, it throws a runtime exception, that may be caught by the current method or by other methods on the current stack. If the exception is not caught, the virtual machine exits. This safe execution mode implies that many checks are made during runtime to detect potential inconsistencies. For instance, the \texttt{aastore} bytecode, which stores an object reference into an array, may throw three different exceptions:
\begin{itemize}
\item \texttt{NullPointerException}, if the reference to the array is \texttt{null},
\item \texttt{ArrayIndexOutOfBoundsException}, if the index in which to store the object is not within the bounds of the array,
\item \texttt{ArrayStoreException}, if the object to store is not assignment-compatible with the array (for instance, storing an \texttt{Integer} into an array of \texttt{Boolean}).
\end{itemize}

Of the 202 bytecodes defined by the Java virtual machine specification, we noticed that 43 require at least one runtime exception check before being executed. While these checks are implicitly performed by the bytecode interpreter in the case of interpreted code, they must explicitly be issued every time such a bytecode is compiled into native code, which leads to a code size explosion. Ishizaki et al. measured that bytecodes requiring runtime checks are frequent in Java programs: for instance, the natively-compiled version of the SPECjvm98 \texttt{compress} benchmark has 2964 exception check sites for a size of 23598 bytes. As for the \texttt{mpegaudio} benchmark, it weights 38204 bytes and includes 6838 exception sites~\cite{Ishizaki1999}. The exception check sites therefore make a non-neglectable part of the compiled code.

Figure~\ref{fig:javatoc} shows an example of Java bytecode that requires a runtime check to be issued when being compiled into native code.

\begin{figure}[t]
\begin{center}
\begin{minipage}[b]{0.4\linewidth}
\textbf{Java version:}
\centering
\begin{verbatim}
  iload i
  iload j
  idiv
  ireturn
\end{verbatim}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\textbf{C version:}
\centering
\begin{verbatim}
1   int i, j;
2   if (j == 0) 
3     THROW(ArithmeticException);
4   RETURN_INT(i / j);
\end{verbatim}
\end{minipage}
\end{center}
\caption{A Java bytecode program and its (simplified) C-compiled version. The behavior of the division operator in Java must be entirely reproduced by the C program, which leads to the generation of a runtime exception check site}
\label{fig:javatoc}
\end{figure}

It is, however, possible to eliminate these checks from the native code if the execution context of the bytecode shows that the exceptional case never happens. In the program of figure~\ref{fig:javatoc}, the lines 2 and 3 could have been omitted if we were sure that for all possible program paths, \texttt{j} can never be equal to zero at this point. This allows to generate less code and thus to save memory. Removing exception check sites is a topic that has largely been studied in the domain of JIT and AOT compilation.
