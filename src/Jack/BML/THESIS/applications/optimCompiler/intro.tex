
\label{sec:intro}

In this chapter, we will focus on the use of our verification scheme in  Java native compiler optimizations.
Let us first see what is the context and motivations for applying formal program verification in compiler optimization.

% Pertinence of compiling bytecode into native codefor embedded devices
Enabling Java on embedded and restrained systems is an important challenge for today's industry and research groups~\cite{Mulchandani1998}. Java brings features like execution safety and low-footprint program code that make this technology appealing for embedded devices which have obvious memory restrictions, as the success of Java Card witnesses. However, the memory footprint and safety features of Java come at the price of a slower program execution, which can be a problem when the host device already has a limited processing power. As of today, the interest of Java for smart cards is still growing, with next generation operating systems for smart cards that are closer to standard Java systems~\cite{Lagosanto2002,Grimaud2003}, but runtime performance in still an issue. To improve the runtime performances of Java systems, a common practice is to translate some parts of the program bytecode into native code.

% Cost of native code
Doing so removes the interpretation layer and improves the execution speed, but also greatly increases the memory footprint of the program: it is expected that native code is about three to four times the size of its Java counterpart, depending on the target architecture. This is explained by the less-compact form of native instructions, but also by the fact that many safety-checks that are implemented by the virtual machine must be reproduced in the native code. For instance, before dereferencing a pointer, the virtual machine checks whether it is \texttt{null} and, if it is, throws a \NullPointerExc. Every time a bytecode that implements such safety-behaviors is compiled into native code, these behaviors must be reproduced as well, leading to an explosion of the code size. Indeed, a large part of the Java bytecode implement these safety mechanisms.

% Usefulness of runtime checks
Although the runtime checks are necessary to the safety of the Java virtual machine, they are most of the time used as a protection mechanism against programming errors or malicious code: A runtime exception should be the result of an exceptional, unexpected program behavior and is rarely thrown when executing sane code - doing so is considered poor programming practice. The safety checks are therefore without effect most of the time, and, in the case of native code, uselessly enlarge the code size.

% Our contribution
Several studies proposed to factorize these checks or in some case to eliminate them, but none proposed a complete elimination without hazarding the system security.
 In the following, we use formal proofs to ensure that run-time checks can never be true in a program, which allows us to completely and safely eliminate them from the generated native code.
 The programs to optimize are JML-annotated against runtime exceptions and verified by the JACK. We have been able to remove almost all of the runtime 
 checks on tested programs, and obtained native ARM thumb code which size was comparable to the original bytecode.

% Plan
The remainder of this paper is organized as follows. In section~\ref{sec:sota}, we overview the methods used for compiling Java bytecode into native code,
 and evaluate the previous work aiming at optimizing runtime exceptions in the native code. Section~\ref{sec:runtimeexceptions} is a brief presentation 
of the runtime exceptions in Java. 
Then, section~\ref{sec:method} describes our method for removing runtime exceptions on the basis of formal proofs. We experimentally evaluate this method in 
section~\ref{sec:experiments}, discuss its limitations in~\ref{sec:limitations} and conclude in~\ref{sec:conclusion}.
