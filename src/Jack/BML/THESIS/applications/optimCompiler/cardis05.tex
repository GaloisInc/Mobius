

% Keywords: embedded devices, Java, Java card, exceptions, ahead of time compilation






\subsection{Generation of the Verification Conditions}
\label{vcGen}
For generating the verification conditions, we use a bytecode verification condition generator (vcGen) based on a bytecode weakest precondition calculus~\cite{JBL05MP}. The weakest precondition function $wp$ returns for every instruction \texttt{ins}, normal postcondition $\psi$, and exceptional function $\excPost$ the weakest predicate \\ $\wpi( \texttt{ins} ,\psi ,\excPost)$ such that if it holds in the pre-state of the instruction \texttt{ins} and if the instruction terminates normally, then the normal postcondition $\psi$ holds in the poststate and if \texttt{ins} terminates on an exception \texttt{Exc}, then the predicate $\excPost(\texttt{Exc})$ holds. From the annotated bytecode the vcGen calculates a set of verification conditions for every method of the application. The verification conditions for a method are generated by tracing all the execution paths in it starting at every \texttt{return}, \texttt{athrow} and loop end instruction up to reaching the method entry point. During the process of generation of the verification conditions, for every instruction that may throw a \verb!Runtime! exception a new verification condition is generated.

In figure \ref{fig:wpRule}, we show the weakest precondition rule for the \texttt{getfield} instruction. As the virtual machine is stack-based, the rule mentions the stack \texttt{stack} and the stack counter \texttt{cntr}, thus the stack top element is referred as \stack{\counter}. If the top stack element \stack{\counter} is not null, \texttt{getfield} pops \stack{\counter} which is an object reference and pushes the value of the referenced field onto the operand stack in \stack{\counter}. If the stack top element is null, the Java Virtual Machine specification says that the \texttt{getfield} instruction throws a \texttt{NullPointerException}.

When the verification condition generator works over a method, it labels the formula related to the exceptional termination of every instruction with the index of the instruction in the bytecode array of the method. For example, if a \texttt{getField} instruction is met in the bytecode of a method, a conjunction is generated and the conjunct related to the exception is labeled as shown by figure \ref{fig:wpRule}. Finally, indexing the verification conditions allows to identify later in the proof phase which instructions can be optimized.



\begin{figure}
$$
\begin{array}{l}
\wpi(ind : \texttt{getfield} \ \texttt{Cl.f}, \ \psi, \ \excPost) = \\
\biggl( 
\begin{array}{l}
	%\begin{array}{l}
   		\stack{\counter} \not= \Mynull\Rightarrow   \\
	\Myspace \psi\begin{array}{l} \subst{\stack{\counter}}{\texttt{Cl.f} (\stack{ \counter}) } \\[0 mm]

		\end{array}\\
	%\end{array}
   \wedge \\
    ind : \stack{\counter} = \Mynull 	\Rightarrow\\
   \Myspace	 \excPost(\texttt{NullPointerException})
        \begin{array}{l}
          \subst{ \counter }{ 0} \\
          \subst{\stack{0}}{ \texttt{ref}_{NullPointer} }
	\end{array}
    \end{array} \biggr)
\end{array}
 $$
\caption{The weakest precondition rule for the \texttt{putfield} instruction}
\label{fig:wpRule}
\end{figure}



%\nocite{Adl-Tabatabai1998, Cierniak2000}

