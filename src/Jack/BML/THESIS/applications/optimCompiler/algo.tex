\section{Optimizing ahead-of-time compiled Java code}
\label{sec:method}

% short description
For verifying the bytecode that will be compiled into native code, we use the JACK verification framework.
In particular, we use the compiler from JML to BML and the bytecode verification condition generator.


% JACK is designed as a plugin for the eclipse interface development environment.
% It supports both the Java Modeling Language (JML~\cite{Leavens2005}) and the ByteCode Specification Language (BML~\cite{JBL05MP}), respectively at source and bytecode level, and also supplies a compiler from JML to BML. The tool supports only the sequential subset of the Java and Java bytecode languages, but this is sufficient for the purpose of the present paper. Thus, from a Java program annotated with JML or a bytecode program annotated with BML, JACK generates proof obligations at the source or bytecode level respectively. JACK can then translate the resulting verification conditions for several theorem provers: Coq, Simplify, Atelier B.

%verification procedure
Verifying that a bytecode program does not throw Runtime exceptions using JACK involves several stages:
\begin{enumerate}
\item writing the JML specification at the source level of the application, which expresses that no runtime exceptions are thrown.
\item compiling the Java sources into bytecode 
\item compiler the JML specification into BML specification and add it in the class file
\item generating the verification conditions over the bytecode and its BML specification, and proving the verification conditions~\ref{proofs}. During the calculation process of the verification conditions, they are indexed with the index of the instruction in the bytecode array they refer to and the type of specification they prove (e.g. that the proof obligation refers to the exceptional postcondition in case an exception of type \texttt{Exc} is thrown when executing the instruction at index \texttt{i} in the array of bytecode instructions of a given method). Once the verifications are proved, information about which instructions can be compiled without runtime checks is inserted in user defined attributes of the class file.
\item using these class file attributes in order to optimize the generated native code. When a bytecode that has one or more runtime checks in its semantics is being compiled, the bytecode attribute is checked in order to make sure that the checks are necessary. It indicates that the exceptional condition has been proved to never happen, then the runtime check is not generated.
\end{enumerate}

Our approach benefits from the accurateness of the JML specification and from the bytecode verification condition generator. Performing the verification over the bytecode allows to easily establish a relationship between the proof obligations generated over the bytecode and the bytecode instructions to optimized.

In the rest of this section, we explain in detail all the stages of the optimization procedure.
