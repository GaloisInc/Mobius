\section{More Precise Optimizations}

\label{section:optimprecise}

As we discussed earlier, in order to optimize an instruction in a method body, the method precondition must be established at every call site and the method implementation must be proved not to throw an exception under the assumption that the method precondition holds. This means that if there is one call site where the method precondition is broken then no instruction in the method body will be optimized.

Actually, the analysis may be less conservative and therefore more precise. We illustrate with an example how
one can achieve more precise results.

Consider the example of figure \ref{fig:jmlpreciseex}. On the left side of the figure, we show source code for method \verb!setTo0! which sets the \verb!buff! array element at index \verb!k! to 0. On the right side, we show the bytecode of the same method. The \texttt{iastore} instruction at index \texttt{3} may throw two different runtime exceptions: \NullPointerExc, or \ArrIndexOutOfBoundExc. For the method execution to be safe (i.e. no Runtime exception is thrown), the method requires some certain conditions to be fulfilled by its callers. Thus, the method's precondition states that the \verb!buff! array parameter must not be null and that the \verb!k! parameter must be inside the bounds of \verb!buff!. If at all call sites we can establish that the \verb!buff! parameter is always different from null, but there are sites at which an unsafe parameter \verb!k! is passed the optimization for \NullPointerExc is still safe although the optimization for \ArrIndexOutOfBoundExc is not possible. In order to obtain this kind of preciseness, a solution is to classify the preconditions of a method with respect to what kind of runtime exception they protect the code from. For our example, this classification consists of two groups of preconditions. The first is related to \NullPointerExc, i.e. \texttt{buff != null} and the second consists of preconditions related to \ArrIndexOutOfBoundExc, i.e. \verb! k >= 0 && k <= buff.length!. Thus, if the preconditions of one group are established at all call sites, the optimizations concerning the respective exception can be performed even if the preconditions concerning other exceptions are not satisfied.

\begin{figure}
\begin{minipage}[b]{0.5\linewidth}
%\begin{lstlisting}[frame=trbl] 
\begin{verbatim}
...

//@requires buff != null;
//@requires k >= 0 ;
//@requires k <= buff.length;
//@ensures true;
//@exsures (Exception) false;
public void setTo0(int k,int[] buff)
{
  buff[k] = 0;
}
\end{verbatim}
%\end{lstlistings}
\end{minipage}
\hspace{.5cm}
\begin{minipage}[b]{0.4\linewidth}
\begin{verbatim}
% \begin{lstlisting}[frame=trbl] 
 0 aload 2
 1 iload 1
 2 iconst 0
 3 iastore
 4 return
%\end{lstlistings}
\end{verbatim}
\end{minipage}
\caption{The source code and bytecode of a method that may throw several exceptions}
\label{fig:jmlpreciseex}
\end{figure}
