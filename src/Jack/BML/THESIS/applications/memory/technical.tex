


\section{Principles} \label{sec:principles}
Let us begin with a very simple memory consumption policy which aims
at enforcing that  programs do not consume more than
some fixed amount of memory \Max . To enforce this policy, we first
introduce a ghost variable \Mem{} that represents at any given point of
the program the memory used so far. Then, we annotate the program both
with the policy and with additional statements that will be used to
check that the application respects the policy.



\paragraph{The precondition} of the method $\method$ should ensure that
there must be enough free memory for the method execution. Suppose
that we know an upper bound of the allocations done by method $\method$
in any execution. We will denote this upper bound by
\allocMethod{\method}. Thus there must be at least
\allocMethod{\method}\ free memory units from the allowed \Max\ when
method $\method$ starts execution. Thus the precondition for the method
$\method$ is:
$$
\requires \ \Mem + \allocMethod{\method}  \leq \Max.
$$

%\todo{ to leave this paragraph or not. It is about the initialization of the variable \Mem} 
The precondition of the
program entry point (i.e., the method from which an application
may start its execution) should state that the program has not
allocated any memory, i.e. require that variable \Mem \ is  0:
$$
\requires \ \Mem == 0.
$$
\paragraph{The normal postcondition} of the method $\method$ must
guarantee that the memory allocated during a normal execution of
$\method$ is not more than some fixed number \allocMethod{\method}\
of memory units. Thus for the method $\method$ the postcondition is:
$$
\ensures \  \Mem \leq \old{\Mem} + \allocMethod{\method}.
$$

\paragraph{The exceptional postcondition} of the method $\method$ must
say that the memory allocated during an execution of $\method$ that
terminates by throwing an exception \texttt{Exception} is not more
than \allocMethod{\method}\ units. Thus for the method $\method$ the
exceptional postcondition is:

$$
\exsures{} \Exception \  \Mem \leq \old{\Mem} + \allocMethod{\method}.
$$


\paragraph{Loops} must also be annotated with appropriate invariants. 
%Assuming that we know that loop $\progLoop{l}$ iterates no more than $\maxIter{l}$ as well as an upper bound  $\allocLoop{l}$ of the allocations done per iteration in $l$. 
Let us assume that loop $\progLoop{l}$ iterates no more than $\maxIter{l}$ and let $\allocLoop{l}$ be an upper bound of the memory allocated per iteration in $l$.
Below we give a general form of loop specification w.r.t. the property for constraint memory consumption. The loop invariant of a loop $\progLoop{l}$ states that at every iteration the loop body is not going to allocate more than $\allocLoop{l}$ memory units and that the iterations are no more than $\maxIter{l}$. We also declare an expression which guarantees loop termination, i.e. a variant (here an integer expression whose values decrease at every iteration  and is always bigger or equal to 0).
$$\begin{array}{ll}
\modifies &  \ i, \Mem \\
\invariant: & \ \Mem \le \atState{\Mem}{Before_{l}} + i * \allocLoop{l} \\
                & \wedge \\
                & i \le \maxIter{l}\\
\variant: & \maxIter{l} - i \\
\end{array}$$
 A special variable appears in the invariant, $\atState{\Mem}{Before_{l}}$. It denotes the value of the consumed memory just before entering for the first time the loop \progLoop{l}. At every iteration the consumed memory must not go beyond the upper bound given for the body of loop.

\paragraph{For every instruction that allocates memory} the ghost
variable \Mem\ must also be updated accordingly. For the purpose of
this paper, we only consider dynamic object creation with the bytecode
\new; arrays are left for future work and briefly discussed in the
conclusion. 

The function $\allocInstanceOnly: Class \rightarrow int$ gives an estimation of the memory used by an instance of a class. 
Note that the memory allocated for a class instance is specific to the implementation of the virtual machine.
%In order to perform the update for \new\ bytecodes, we must assume given a function $allocInstance: Class \rightarrow int$ which maps classes to an estimation of the memory that any instance of the class may occupy. 
At every program point where a bytecode \srcCode{\new \ A} is found, the ghost variable \Mem\ must be incremented by $\allocInstance{A}$. This
is achieved by inserting a ghost assignment immediately after any \new\ instruction, as shown below:
$$
\begin{array}{l}
\srcCode{\new \ A} \\
 // \set \ \Mem = \Mem + $\allocInstance{A}$.
\end{array}
$$


