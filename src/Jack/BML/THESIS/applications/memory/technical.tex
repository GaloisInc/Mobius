The objective of this section is to demonstrate how the user can
annotate and verify programs in order to obtain an upper bound on
memory consumption. We begin by describing the principles of our
approach, then turn to establish its soundness, and finally show
how it can be applied to non-trivial examples involving recursive
methods and exceptions.


\subsection{Principles}
Let us begin with a very simple memory consumption policy which aims
at enforcing that  programs do not consume more than
some fixed amount of memory \Max . To enforce this policy, we first
introduce a ghost variable \Mem\ that represents at any given point of
the program the memory used so far. Then, we annotate the program both
with the policy and with additional statements that will be used to
check that the application respects the policy.



\paragraph{The precondition} of the method $\method$ should ensure that
there must be enough free memory for the method execution. Suppose
that we know an upper bound of the allocations done by method $\method$
in any execution. We will denote this upper bound by
\allocMethod{\method}. Thus there must be at least
\allocMethod{\method}\ free memory units from the allowed \Max\ when
method $\method$ starts execution. Thus the precondition for the method
$\method$ is:
$$
\requires \ \Mem + \allocMethod{\method}  \leq \Max.
$$
%\todo{ to leave this paragraph or not. It is about the initialization of the variable \Mem} 
The precondition of the
program entry point (i.e., the method from which an application
may start its execution) should state that the program has not
allocated any memory, i.e. require that variable \Mem \ is  0:
$$
\requires \ \Mem == 0.
$$
\paragraph{The normal postcondition} of the method $\method$ must
guarantee that the memory allocated during a normal execution of
$\method$ is not more than some fixed number \allocMethod{\method}\
of memory units. Thus for the method $\method$ the postcondition is:
$$
\ensures \  \Mem \leq \old(\Mem) + \allocMethod{\method}.
$$

\paragraph{The exceptional postcondition} of the method $\method$ must
say that the memory allocated during an execution of $\method$ that
terminates by throwing an exception \texttt{Exception} is not more
than \allocMethod{\method}\ units. Thus for the method $\method$ the
exceptional postcondition is:

$$
\exsures{Exception} \  \Mem \leq \old(\Mem) + \allocMethod{\method}.
$$


\paragraph{Loops} must also be annotated with appropriate invariants. 
%Assuming that we know that loop $\progLoop{l}$ iterates no more than $\maxIter{l}$ as well as an upper bound  $\allocLoop{l}$ of the allocations done per iteration in $l$. 
Let us assume that loop $\progLoop{l}$ iterates no more than $\maxIter{l}$ and let $\allocLoop{l}$ be an upper bound of the memory allocated per iteration in $l$.
Below we give a general form of loop specification w.r.t. the property for constraint memory consumption. The loop invariant of a loop $\progLoop{l}$ states that at every iteration the loop body is not going to allocate more than $\allocLoop{l}$ memory units and that the iterations are no more than $\maxIter{l}$. We also declare an expression which guarantees loop termination, i.e. a variant (here an integer expression whose values decrease at every iteration  and is always bigger or equal to 0).
$$\begin{array}{ll}
\modifies &  \ i, \Mem \\
\invariant: & \ \Mem \le \atState{\Mem}{Before_{l}} + i * \allocLoop{l} \\
                & \wedge \\
                & i \le \maxIter{l}\\
\variant: & \maxIter{l} - i \\
\end{array}$$
 A special variable appears in the invariant, $\atState{\Mem}{Before_{l}}$. It denotes the value of the consumed memory just before entering for the first time the loop \progLoop{l}. At every iteration the consumed memory must not go beyond the upper bound given for the body of loop.

\paragraph{For every instruction that allocates memory} the ghost
variable \Mem\ must also be updated accordingly. For the purpose of
this paper, we only consider dynamic object creation with the bytecode
\new; arrays are left for future work and briefly discussed in the
conclusion. 

The function $allocInstance: Class \rightarrow int$ gives an estimation of the memory used by an instance of a class.
%In order to perform the update for \new\ bytecodes, we must assume given a function $allocInstance: Class \rightarrow int$ which maps classes to an estimation of the memory that any instance of the class may occupy. 
At every program point where a bytecode \srcCode{\new \ A} is found, the ghost variable \Mem\ must be incremented by $\allocInstance{A}$. This
is achieved by inserting a ghost assignment immediately after any \new\ instruction, as shown below:
$$
\begin{array}{l}
\srcCode{\new \ A} \\
 // \set \ \Mem = \Mem + $\allocInstance{A}$.
\end{array}
$$

\subsection{Correctness}
%An important question is if the annotations that we prescribe here guarantees that the memory used in a program is not more than a fixed upper bound \Max. 
We want to guarantee that the memory allocated by a given program is bounded by a constant \Max.
We can prove that our annotation is correct w.r.t. to the policy for constraint memory use, by instrumenting the operational semantics of the bytecode language given in
 Section \ref{subsec:sound}. The instrumented operational semantics
manipulates states as before, but it is extended with the special variable \Mem. Thus, states in the new semantics have the form:

$$\configMem{h,\fram{m,\pc,l,s},\stf,\Mem}$$

%The variable \Mem \ changes its value only for instructions that allocate space in the heap, i.e. \new\ instructions:

%$$\small{\frac{
%\begin{array}[c]{c}
%\ \InstAt(m,\pc)=\new \ A ,
%\end{array}}
%{\begin{array}[t]{c} \config{h,\fram{m,\pc,l,v::s},\stf, \Mem} \to_{\new\ A} \\ \config{h + \allocInstance{A},\fram{m,\pc+1,l,s},\stf ,\Mem + \allocInstance{A}}
%\end{array}}}$$



The other instructions do not affect \Mem, so the corresponding rules of the operational semantics are as before. As we saw in the previous section to every
instruction of the form $\new\ A$ we attach the annotation $\set\ \Mem = \Mem + \allocInstance(A)$. The proof obligation generator converts this annotation into new value for the variable \Mem:

$$
\begin{array}{l}
wp(\set \ \Mem = \Mem + \allocInstance{A}, \psi) = \\
\ \ \ \ \ \ \ \ \ \ \ \ \psi[ \Mem \leftarrow \Mem + \allocInstance{A} ]
\end{array}
$$

We can prove that whenever the allocated space in the heap increments, 
the ghost variable \Mem\ also increments, which is a sufficient condition to guarantee the correctness of the annotations. 
So far we do not deal with garbage collection (see discussion in Section \ref{sec:conc}).

\subsection{Examples}
We illustrate hereafter our approach by several examples. 
%\alarm{talk about number of proof obligations, which are discharged automatically in Coq, etc}

\subsubsection{Inheritance and overridden methods} Overriding methods are treated as follows: whenever a call is performed to a method \method,
we require that there is enough free memory space for the maximal
consumption by all the  methods that override or are overridden by
\method. In Fig. \ref{classExt} we show a class \verb!A! and its
extending class \verb!B!, where \verb!B! overrides the method \method\ from class \verb!A!. Method \method\ is invoked by $n$. Given that the dynamic type of the parameter passed to $n$ is not known, we cannot know which of the two
methods will be invoked. This is the reason for requiring enough memory space for the execution of any of these methods.
%After the method execution we consider the extreme case where there is executed the method \method\ that consumes the most.

\begin{figure}[!htp]
Specification of method $m$ in class A:
$$
\begin{array}{ll}
\requires & \Mem + k  \leq \Max \\
\modifies & \Mem \\
\ensures & \Mem  \leq \old(\Mem) + k
\end{array}
$$

Specification for method $m$ in class B:
$$
\begin{array}{ll}
\requires & \Mem + l  \leq \Max \\
\modifies & \Mem \\
\ensures & \Mem  \leq \old(\Mem) + l
\end{array}
$$

\begin{verbatim}
method n(A a)
...
//{ prove Mem <= Mem +max(l,k) }
invokevirtual m <A>
//{ assume Mem <= \old(Mem) + max(l,k)}
...
\end{verbatim}
\caption{\sc Example of overridden methods}
\label{classExt}
\end{figure}


\subsubsection{Recursive Methods} In Fig. \ref{recMeth} the bytecode of the recursive method $m$ and its specification is shown. For sake of space we show only a simplified version of the bytecode; we assume that the constructors for the class \srcCode{A} and \srcCode{C} do not allocate memory. Besides the precondition and the postcondition, the specification also includes information about the termination of the method: \variant\ $\local{1}$, meaning that the local variable $\local{1}$ decreases on every recursive call down to and no more than $0$, guaranteeing that the execution of the method will terminate.
 
%Now we explain why such a precondition is required for method \textbf{m} in order to specify the property for constraint memory consumption. 

We explain first the precondition. If the condition of line \srcCode{1} is not true, the execution continues at line \srcCode{2}.

\begin{figure}[!hbp]
\begin{alltt}
public class D \{
  public void m( int i) \{
    if (i > 0) \{
      new A();
      m(i - 1);
      new A();
    \} else \{
      new C();
      new A();
   \}
  \}
\}
\end{alltt}

$$
\begin{array}{ll}
 \requires & ( \Mem + \local{1}*2*\allocInstance{A} + \\
           &  \allocInstance{A} + \allocInstance{C}) \le \Max \\
 \variant  & \local{1} \\
 \ensures  & \local{1} \ge 0 \\
           & \wedge \\
           & \Mem <= \old(\Mem) +  \old(\local{1})*2*\allocInstance{A} + \allocInstance{A}\\
           &  +  \allocInstance{C})
\end{array}$$

\begin{alltt}
\srcCode{\textbf{public void m()}}
//\small{\textit{local variable loaded on} }
//\small{\textit{the operand stack of method \textbf{m}}}
\srcCode{0 \load\_1}
//\small{ \textit{ if \local{1} <= 0 jump}}
\srcCode{1 ifle 12}
\srcCode{2 new <A>} //\small{ \textit{ here \local{1} > 0  } }
//set \Mem = \Mem +  \allocInstance{A}
\srcCode{3 invokespecial <A.<init>>}
\srcCode{4 aload\_0}
\srcCode{5 iload\_1}
\srcCode{6 iconst\_1}
//\small{\textit{\local{1} decremented with 1}}
\srcCode{7 isub}
//\small{ \textit{ recursive call with the new value of \local{1}}}
\srcCode{8 invokevirtual <D.m>}//
\srcCode{9 new <A>}
//set \Mem = \Mem +  \allocInstance{A}
\srcCode{10 invokespecial <A.<init>>}
\srcCode{11 goto 16}
//\small{\textit{target of the jump at \srcCode{1}}}
\srcCode{12 new <A>}
//set \Mem = \Mem +  \allocInstance{A}
\srcCode{13 invokespecial <A.<init>>}
\srcCode{14 new  <C>}
//set \Mem = \Mem +  \allocInstance{C}
\srcCode{15 invokespecial <C.<init>>}
\srcCode{16 return}
\end{alltt}

\caption{\sc Example of a recursive method}
 \label{recMeth}
\end{figure}

In the sequential execution up to line \srcCode{7}, the program allocates at most $\allocInstance{A}$ memory units and decrements by $1$ the value of $\local{1}$. The instruction at line \srcCode{8} is a recursive call to $m$, which either will take the same branch if $\local{1} > 0 $ or will jump to line \srcCode{12} otherwise, where it allocates at most $\allocInstance{A} +  \allocInstance{C}$ memory units. On returning from the recursive call one more allocation will be performed at line \srcCode{9}.
 Thus $m$ will execute, $\local{1}$ times, the instructions from lines \srcCode{4} to \srcCode{35},  and it finally will execute all the instructions from lines  \srcCode{12} to \srcCode{16}.
The postcondition states that the method will perform no more
than $\old(\local{1})$ recursive calls (i.e., the value of the register variable in the pre-state of the method) and that on every recursive call it allocates no more than two instances of class \texttt{A} and that it will finally allocate one instance of class \texttt{A} and another of class \texttt{C}.


\subsubsection{More precise specification} We can be more precise in specifying the precondition of a method by considering what are the field values of an instance, for example. Suppose that we have the method \method\ as shown in Fig. \ref{excMeth}. We assume that in the constructor of the class \texttt{A} no allocations are done. The first line of the method \method\ initializes one of the fields of field \texttt{b}. Since nothing guarantees that field \texttt{b} is not \Mynull, the execution may terminate with
\texttt{NullPointerException}. Depending on the values of the parameters passed to \method, the memory allocated will be different. The precondition establishes what is the expected space of free resources depending on if the field
\texttt{b} is \Mynull  or not. In particular we do not require anything for
the free memory space in the case when \texttt{b} is \Mynull. In the
normal postcondition we state that the method has allocated an
object of class \texttt{A}. The exceptional postcondition states
that no allocation is performed if \texttt{NullpointerException} causes the execution termination.

\begin{figure}[!hbp]
$$
\begin{array}{ll}
 \requires &  \local{1} != \Mynull \Rightarrow  \\
           & \phantom{\local{1}} \Mem +  \allocInstance{A} \le \Max \\
       %& \wedge \\
       %&  \local{1} == \Mynull \Rightarrow  \\
           %& \phantom{\local{1}} \Mem +  \allocInstance{B} + \allocInstance{A}   \le \Max \\
  \modifies & \Mem \\
  \ensures  & \Mem \le \old(\Mem) +  \allocInstance{A} \\
  \exsures{NullPointerException}  & \Mem == \old(\Mem)   \\
\end{array}$$

\begin{tabular}{lr}
\begin{minipage}[t]{170pt}
\begin{alltt}
\srcCode{0 aload\_0}
\srcCode{1 getfield<C.b>}
\srcCode{2 iload\_2}
\srcCode{3 putfield <B.i>}
\srcCode{4 new <A>}
//set \Mem = \Mem +
      \allocInstance{A}
\srcCode{5 dup}
\srcCode{6 invokespecial <A.<init>>}
\srcCode{7 astore\_1}
\srcCode{8 return}
\end{alltt}
\end{minipage}
 &
\begin{minipage}[t]{170pt}
\begin{alltt}
public class C \{
  B b;
  public void m(A a, int i) \{
    b.i = i ;
    a = new A();
  \}
\}
\end{alltt}
\end{minipage}
\end{tabular}
\caption{\sc Example of a method with possible exceptional termination}
\label{excMeth}
\end{figure}
