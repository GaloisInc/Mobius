Our work is based on the Carmel intermediate representation of Java Card
byte code \cite{marlet01sjc}. 

\subsection{Carmel}
The Carmel language consists of byte codes for a
stack-oriented machine whose 
instructions include stack operations, numeric operations,
conditionals, object creation and modification, and method invocation
and return. We do not deal with subroutines (the Java \jsr\ instruction) nor with exceptions. Although our approach may be extended to the whole Carmel, in order to avoid a proliferation of case-by-case treatment, we will concentrate on the following instruction set:

\begin{itemize}
\item The null instruction: \nop;
\item Stack manipulation: \push, \pop, \dup, \dup 2, \swap, \numop;
\item Local variables manipulation: \load, \store;
\item Jump instructions: \If, \goto;
\item Heap manipulation: \new, \putfd, \getfd;
\item Array instructions: \arrst, \arrld;
\item Method calls and return: \invvir, \return.
\end{itemize}


%In this paper, we restrict attention to the subset of instructions concerned with control flow and memory allocation (\texttt{if},\texttt{goto},\texttt{invokevirtual},\texttt{return},\texttt{new}). The rest of the  instructions may have different effects on the operand stack and local variables but behave similar with respect to memory and control flow (move to the next instruction without doing any memory allocation). For clarity and in order to focus on the essentials, these instructions have been grouped into one abstract instruction \texttt{instr} with this behaviour. 


\newcommand{\spp}{\hspace{1.5cm}}

\begin{figure}[htbp]
  \begin{center}
\begin{tabular}[c]{cc}
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\mathtt{nop}\ 
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,s},\stf} \to_{\nop}\\
\spp \config{h,\fram{m,\pc+1,l,s},\stf}
\end{array}}$$
\end{minipage}
&
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\push\ c
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,s},\stf} \to_{\push\ c}\\
\spp \config{h,\fram{m,\pc+1,l,\num(c)::s},\stf}
\end{array}}$$
\end{minipage}

\\

\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\pop
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,v::s},\stf} \to_{\pop}\\
\spp \config{h,\fram{m,\pc+1,l,s},\stf}
\end{array}}$$
\end{minipage}
&
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\putfd\ f\\
(h, loc)=o\quad \wedge\quad o'=o[f\mapsto v]\\
\exists c\in \classes(P)\text{ with } \nameClass(c)=\class(o)
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,v::\reff(loc)::s},\stf} \to_{\putfd\ f}\\
\spp \config{h[loc\mapsto o'],\fram{m,\pc+1,l,s},\stf}
\end{array}}$$
\end{minipage}

\\

\multicolumn{2}{c}{
\begin{minipage}[c]{10cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\getfd\ f\\
(h, loc)=o\quad \wedge\quad \exists c\in \classes(P)\text{ with } \nameClass(c)=\class(o)
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,\reff(loc)::s},\stf} \to_{\getfd\ f}\\ 
\spp \config{h,\fram{m,\pc+1,l,\fieldValue(o, f)::s},\stf}
\end{array}}
$$
\end{minipage}}
\vspace*{0.15cm}
\\

\multicolumn{2}{c}{
\begin{minipage}[c]{10cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\numop\ op
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,\num(n_1)::\num(n_2)::s},\stf} \to_{\numop\ op}\\ 
\spp \config{h,\fram{m,\pc+1,l,\num(\ia{op}(n_1,n_2))::s},\stf}
\end{array}}
$$
\end{minipage}}

\\

\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\load\ x
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,s},\stf} \to_{\load\ x}\\
\spp \config{h,\fram{m,\pc+1,l,l[x]::s},\stf}
\end{array}}$$
\end{minipage}
&
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\store\ x
\end{array}}}%
{\begin{array}[t]{l}
\config{h,\fram{m,\pc,l,v::s},\stf} \to_{\store\ x}\\
\spp \config{h,\fram{m,\pc+1,l[x\mapsto v],s},\stf}
\end{array}}$$
\end{minipage} 
\\
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\If\ \pc'\ \\
n=0
\end{array}}}%
{\begin{array}[t]{l}\config{h,\fram{m,\pc,l,n::s},\stf} \to_{\If\ \pc'}\\
\spp \config{h,\fram{m,\pc',l,s},\stf}\end{array}}$$
\end{minipage}
&
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\If\ \pc' \\
n\not=0
\end{array}}}%
{\begin{array}[t]{l}\config{h,\fram{m,\pc,l,n::s},\stf} \to_{\If\ \pc'}\\
\spp \config{h,\fram{m,\pc+1,l,s},\stf}\end{array}}$$
\end{minipage}
\\
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{\ \InstAt_P(m,\pc)=\goto\ \pc'}%
{\begin{array}[t]{l}\config{h,\fram{m,\pc,l,s},\stf} \to_{\goto\ \pc'}\\
\spp \config{h,\fram{m,\pc',l,s},\stf}\end{array}}$$
\end{minipage}
&
\begin{minipage}[c]{6cm}  \footnotesize
$$\frac{%
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_P(m,\pc)=\new\ cl\ \\
\exists c\in\classes(P)\text{ with } \nameClass(c)=cl \\
\left(h',loc\right)=\newObject(cl,h)
\end{array}}}%
{\begin{array}[t]{l}\config{h,\fram{m,\pc,l,s},\stf} \to_{\new\ cl}\\
\spp \config{h',\fram{m,\pc+1,l,loc::s},\stf}\end{array}}$$
\end{minipage}

\\

\multicolumn{2}{c}{
\begin{minipage}[c]{10cm}  \footnotesize
$$\frac{
{\renewcommand{\arraystretch}{1} 
\begin{array}[c]{c}
\ \InstAt_{P}(m,\pc)=\invvir\ M\\
\begin{array}[c]{crcl}
h(loc) = o \quad m'= \methodLookup(M, o)\quad &
f &=&  \fram{m,\pc,l,loc::V::s} \\
f'=\fram{m',1,V,\varepsilon}
& f'' &=& \fram{m,\pc,l,s}
\end{array}
\end{array}}}
{ \begin{array}[t]{c}
\config{h,f,\stf} \to_{\invvir\ M}
\config{h,f',f''::\stf}
\end{array}}
$$
\end{minipage}}

\\

\multicolumn{2}{c}{\begin{minipage}[c]{10cm}  \footnotesize
$$
\frac{
{\renewcommand{\arraystretch}{0.7} \begin{array}[c]{c}
\ \InstAt_{P}(m,\pc)=\return 
 \quad  f'=\fram{m',\pc',l',s'}
\end{array}}}%
{
\config{h,\fram{m,\pc,l,v::s},f'::\stf} \to_{\return}
\config{h,\fram{m',\pc'+1,l',v::s'},\stf}
}$$
\end{minipage}}

\end{tabular}
    
    \caption{Carmel operational semantics}
    \label{fig:sem}
  \end{center}
\end{figure}

The formal definition of the language is given as a small-step operational semantics with a 
state of the form $\config{h,\fram{m,\pc,l,s},\stf}$, where $h$ is the
heap of objects, $\fram{m,\pc,l,s}$  is the current \emph{frame} and
$\stf$ is the current call stack (a list of frames). A frame
 $\fram{m,\pc,l,s}$ 
contains a method name $m$ and a program point $\pc$ within $m$, a set
of local variables $l$, and a local operand stack~$s$ (see
\cite{Siveroni:03:JavaCardSemantics} for details). Let $\State_P$ be the set of all the states of a given program $P$. We will write simply \State\ if $P$ is understood from the context.
The transition relation $\to_{I}$ describes how the execution of instruction $I$
changes the state.
This is extended to a transition relation $\to$ on traces such that
$\mathit{tr}:::s_1 \to \mathit{tr}:::s_1 :::s_2$ if there exists an
instruction $I$ such that $s_1 \to_I s_2$\footnote{Here and everywhere in the paper, ``:::'' denotes the ``cons'' operation for traces (appending an element to the right of the trace). We will use ``::'' as the ``cons'' operation of the operand stack (the top of the stack being on the left).}.

%The instructions concerned with control flow and memory allocation: \If, \goto, \invvir, \return\ and \new, need a special treatment in our analysis. 
%The rest of the  instructions may have different effects on the
%operand stack and local variables but behave similarly with respect to memory and
%control flow (move to the next instruction without doing any memory
%allocation). For clarity and in order to focus on the essentials,
%these instructions have been grouped into one generic instruction
%\instr\ with this behaviour.  Fig. \ref{fig:sem} shows the rules describing the operational semantics of Carmel. 

%The rule for the generic instruction \instr\ is formalised as a
%(non-deterministic) transition from state
%$\config{h,\fram{m,\pc,l,s},\stf}$ to any state of form
%$\config{h,\fram{m,\pc+1,l',s'},\stf}$. 

Fig. \ref{fig:sem} shows the rules describing the operational semantics of Carmel; in what follows we only explain the instructions concerned with control flow and memory allocation: \If, \goto, \invvir, \return\ and \new.
Instructions \If\ and
\goto\ affect the control flow by modifying the $\pc$
component of the state. The \If\ instruction produces a jump to an indicated program
point $\pc'$ if the top of the operand stack is $0$;  otherwise it 
moves to the instruction $\pc+1$. The $\goto\ \pc'$ unconditionally
jumps to $\pc'$. The \new\ instruction modifies the heap ($h'$) creating an object of class $cl$ on location $loc$; $loc$ is added to the stack and the $\pc$ is incremented.

The rule for \invvir\ is slightly more complicated. Let
$M$ be a method name. The instruction $\invvir\ M$ at
address $(m,\pc)$ of state $\sigma =\config{h,f,\stf}$ may only
occur if the current frame $f$  of $\sigma$ has an
operand stack of the form $\mathit{loc}::V::s$, i.e., it starts with a
{\em heap location} denoted by \textit{loc}, followed by a vector of
values $V$. The actual method that will be called is to be found in
the object $o$ that resides in the heap $h$ at the address $h(loc)$, and
the actual parameters of that method are contained in the vector
$V$. Then, the \methodLookup\ function searches the class hierarchy
for the method name $M$ in the object $o$, and returns the actual method
to which the control will be transferred.  The new method, together
with its starting point $\pc = 1$, its vector $V$ of actual parameters,
and an empty operand stack $\varepsilon$, constitute a new frame $f'$
pushed on top of the call stack of the resulting state 
$\sigma' = \config{h,f',f''::\stf}$, where $f'' = \fram{m,\pc,l,s}$ is the frame to be taken into account after the completion of the method invocation.
Finally, the \return\ instruction pops the control stack and
execution continues at the program point indicated in the frame that is
now on top of the control stack. 

The {\em partial trace semantics} $\ia{P}$ of a Carmel program $P$
is defined as the set of reachable partial traces:
$$\ia{P} = \left\lbrace s_0:: s_1::\cdots ::s_n \in\State^+\ \left|\ 
    \begin{array}[c]{l}
s_0\in\mathcal{S}_{\mathit{init}}\ \wedge\\
\forall k<n,\ \exists i,\ s_k\to_i s_{k+1}
\end{array}\right.
\right\rbrace\in\wp(\State^+)$$
where $\mathcal{S}_{\mathit{init}}$ is the set of initial states. 

\subsection{Annotated Carmel}
In order to reason using our methodology based on the weakest precondition calculus, we need to annotate byte code programs with {\em ghost} variables. In particular, we have a ghost variable called \Mem\ which keep track of the memory consumed till the current program state. We assume we know the memory allocated for each instance of a class $C$. 

An {\em annotated Carmel program} is a Carmel program where each occurrence of an instruction of the form $\new\, \cl$ is replaced by  

$$
\new\, \cl \ \ // \Mem == \Mem + \Size(\cl),
$$ 

where $\Size(\cl)$ gives the memory allocated to an object of class $\cl$.



%\newcommand{\config}[1]{{\langle\langle #1 \rangle\rangle}}
%\newcommand{\fram}[1]{{\left\langle #1 \right\rangle}}
%\newcommand{\num}{{\text{num}}}
%\newcommand{\reff}{{\text{ref}}}
%\newcommand{\nul}{{\text{null}}}
%\newcommand{\some}{{\text{some}}}
%\newcommand{\nameClass}{{\text{nameClass}}}
%\newcommand{\class}{{\text{class}}}
%\newcommand{\newObject}{{\text{newObject}}}
%\newcommand{\fieldValue}{{\text{fieldValue}}}
%\newcommand{\Value}{{\text{Value}}}
%\newcommand{\classes}{{\text{classes}}}
%\newcommand{\RefValue}{{\text{RefValue}}}
%\newcommand{\Location}{{\text{Location}}}
%\newcommand{\methodLookup}{{\text{methodLookup}}}
%\newcommand{\nbArgument}{{\text{nbArgument}}}
%\newcommand{\nameMethod}{{\text{nameMethod}}}


%$$
%\begin{array}[t]{rclcl}
%  \RefValue &::=&  loc & & loc\in\Location \\
%  \Value    &::=&  \num\ n & &  n\in\mathbb{N}\\
%            &   &  \reff\ r & &  r\in\RefValue\\
%            &   &  \nul
%\end{array}$$
          
%\noindent
%\coqdockw{Record} \coqdocid{ClassInst} : \coqdocid{Set} := \coqdocid{classInstConstr}\{\coqdoceol
%\coqdocindent{1.00em}
%\coqdocid{class} : \coqdocid{ClassName};\coqdoceol
%\coqdocindent{1.00em}
%\coqdocid{fieldValue} : \coqdocid{FieldName} \ensuremath{\rightarrow} \coqdocid{Value}\coqdoceol
%\coqdocindent{1.00em}
%\}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"x


