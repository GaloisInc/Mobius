In the previous section, we have described how the memory consumption
of a program can be modeled in BML and verified using an appropriate
verification environment. While our examples illustrate the benefits
of our approach, especially regarding the precision of the analysis,
the applicability of our method is hampered by the cost of providing
the annotations manually. In order to reduce the burden of manually
annotating the program, one can rely on annotation assistants that
infer automatically some of the program annotations (indeed such
assistants already exist for loop invariants, loop variants, or
class invariants). In this section, we describe an implementation of
an annotation assistant dedicated to the analysis of memory consumption,
and illustrate its working on an example.

\subsection{Annotation assistant}
The inference algorithm proposed here works on programs
 without recursive methods, exception throwing and handling.  


The user must provide information about the memory required to create objects of the given classes,
 i.e. he must give the definition  of the function $\allocInstance{\cdot}$.
 The variant and the maximum number of iterations $\maxIter{l}$ for every loop $l$  are either given by the
 user or are synthesized  through appropriate mechanisms. 

%Given a control flow graph of the program --which is computed by the verification environment, a function that gives for each class the memory required to create an object of that class, which is provided by the user, and a variant for each loop and recursive method, which can either be provided by the user, or synthesized through appropriate mechanisms. 

Based on this information, the annotation assistant 
inserts the ghost assignments on appropriate places, and then computes
recursively the memory allocated on each loop and method. 
A pseudo-code of the algorithm for inferring an upper bound for method allocations is given in Fig. \ref{methodAlloc}.
Essentially, it finds the maximal memory that can be allocated in a method by exploring all its possible execution paths.  
The algorithm for exploring an execution path starts from the last instruction in the path (i.e. a \return{} instruction). 
The algorithm use standars techniques to detect the loop entry instructions. For each loop entry instruction it also finds  
the set  of the corresponding ``loop end'' instructions i.e. the  instructions  that target   to  and which are dominated by
the loop entry instruction; you are not entering in detail in the loop detection
algorithm as it is standard and the reader may  see Section 10 of 
 \cite{ASU86cpt} for a description of the algorithms.

\begin{figure}[!htp]
function $\allocMethod{.}$\\
\textbf{Input:} Bytecode of a method \methodd{} . \\
\textbf{Output:} Upper bound of the memory allocated by \methodd{} . \\
\textbf{Body:}
\begin{enumerate}
   \item Detect all the loops in \methodd{}; for every loop $l$ determine $\loopSet{l}$, $\loopEntry{l}$ and $\loopEndsSet{l}$;
   \item Apply the function \allocatedOnly \  to each instruction $\instrAt{k}$, such that $\instrAt{k} = \return$;
   \item Take the maximum of the results given in the previous step: \\
 $max_{\instrAt{k} = \return } \allocated{\instrAt{k}}$.
\end{enumerate}
\caption{\sc Inference algorithm}
\label{methodAlloc}
\end{figure}

The auxiliary function $allocPath$, which infers the maximal allocations done by the set of execution paths ending with the same \return{} instruction,
 is given in Fig. \ref{fig:allocMethod}.
Inferring the memory allocated inside loops is done by the function $\allocLoopWithEnd{\cdot}{\cdot}$, which is invoked by \allocatedOnly{} whenever the 
current instruction belong to a loop. The specification of the function is shown in Fig. \ref{fig:loopPath}.

\begin{figure}[!hbp]
%\centerline{
$\allocated{\instrAt{s}}$ = 
$$ \left\{ \begin{array}{ll}
\allocIns{\instrAt{s} }   &  if \ \instrAt{s} \ has \ no \ predecessors \\
& \\
  \begin{array}{l}
            \allocLoop{\loopEntry{l}} \\
             + \\
            max_{\instrAt{k} \in \preds(\instrAt{s} )-\loopEndsSet{\progLoop{l}}}( \allocated{\instrAt{k}} ) \\
                   \end{array}      & if \  \instrAt{s} \in \loopSet{\progLoop{l}} \\
& \\
\begin{array}{l}
\allocIns{\instrAt{s}} \\
 + \\
max_{\instrAt{k} \in \preds(\instrAt{s} )}
 ( \allocated{\instrAt{k}} )
                       \end{array} & else 
\end{array}
\right.
$$
\caption{\sc Definition of the function $\allocated{\instrAt{s}}$} 
\label{fig:allocMethod}
\end{figure}


\begin{figure}[!hbp]
$\allocLoop{\loopEntry{l}} = $
$$ \begin{array}{l}
    \maxIter{l} * max_{ \instrAt{e} \in \loopEndsSet{l}  } (\allocLoopWithEnd{\loopEntry{l}}{\instrAt{e}} )
   \end{array}$$



$\allocLoopWithEnd{\loopEntry{l}}{\instrAt{s}} = $
$$ 
\left\{\begin{array}{ll}

 \allocIns{\loopEntry{l}}  & if \  \instrAt{s} = \loopEntry{l} \\
  & \\
 \begin{array}{l}
           \allocLoop{\loopEntry{l'}} \\
          + \\
      max_{\instrAt{k} \in \preds(\loopEntry{l'} ) - \loopEndsSet{\progLoop{l'}}}
       ( \allocLoopWithEnd{\loopEntry{l}}{\instrAt{k}} )
    \end{array} &  \begin{array}{l}
                                        if \  \instrAt{s} \in  \loopSet{\progLoop{l'}} \\
                                          \progLoop{l'} \ is \  nested \ in \ \progLoop{l}
                                    \end{array} \\
  & \\
  \begin{array}{l}
     \allocIns{\instrAt{s}} \\
     + \\
     max_{\instrAt{k} \in \preds(\instrAt{s} )}
     ( \allocLoopWithEnd{\loopEntry{l}}{\instrAt{k}} )
                       \end{array} & else \\

\end{array} \right.
$$
 \caption{\sc Definition of the function $\allocLoop{\cdot}$ and  $\allocLoopWithEnd{\cdot}{\cdot}$ }
\label{fig:loopPath}
\end{figure}


%In essence, it first analyses the method's bytecode by identifying the entry loop instruction, the instructions
% that are inside the loop and the set of instructions by which the loop terminates. 
%Then  it finds the maximal number of allocations that can be done per execution path: 
%it starts from all \return \ instructions and ``inspects'' the execution paths upto the entry program
%instruction (in backwards direction  );  if an instruction in the path belongs to a loop then the allocations done per iteration in the loop are 
%calculated and the analysis proceeds from the instructions that target the entry of the loop and that do not belong to the loop; the assistant computes the memory required for %each loop using the memory required for each iteration of the loop, and the variant of the loop, which provides information about the number of
%iterations; upper bound of the allocations done per iteration in a loop are calculated also in a backwards direction 
%(starting from instructions that belong to the loop and whose next instruction is the unique loop entry) by finding the 
%maximal number of allocations per iteration path and if an instruction in an iteration path appears to be instruction that belongs to an inner loop 
%then first an upper bound for the allocations done in the inner loop are inferred and the analysis continues from instructions that target the entry of the nested loop and do not belong to the nested loop.    

The annotation assistant currently synthesize only simple
memory policies (i.e., whenever the memory consumption policy does not depend on
the values of inputs).
%and could be significantly improved in this respect. 
Furthermore, it does not deal with arrays, subroutines, nor exceptions. Our approach may be extended to treat such cases (see the discussion in Section \ref{sec:conc} about how to include arrays in our analysis). For sake of simplicity,
we have also restricted the loop analysis only to those with a unique
entry point, which is the case for code produced by non-optimizing
compilers.
Dealing with loops with a multiple entry points is left for a future work. %A pre-analysis could give us all the entry points of more
%general loops, for instance by the algorithms given in \cite{CJPS05cmu}; our approach may be thus applied straightforwardly.

