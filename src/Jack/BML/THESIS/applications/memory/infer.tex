In the previous section, we have described how the memory consumption
of a program can be modeled in BML and verified using an appropriate
verification environment. While our examples illustrate the benefits
of our approach, especially regarding the precision of the analysis,
the applicability of our method is hampered by the cost of providing
the annotations manually. In order to reduce the burden of manually
annotating the program, one can rely on annotation assistants that
infer automatically some of the program annotations (indeed such
assistants already exist for loop invariants, loop variants, or
class invariants). In this section, we describe an implementation of
an annotation assistant dedicated to the analysis of memory consumption,
and illustrate its working on an example.

\subsubsection{Annotation assistant}
The user must provide annotations about the memory required to create objects of the given classes.
 The variants for each loop and recursive method may be given by the user or be synthesized through appropriate mechanisms.

%Given a control flow graph of the program --which is computed by the verification environment, a function that gives for each class the memory required to create an object of that class, which is provided by the user, and a variant for each loop and recursive method, which can either be provided by the user, or synthesized through appropriate mechanisms. 

Based on this information, the annotation assistant 
inserts the ghost assignments on appropriate places, and then computes
recursively the memory allocated on each loop and method. 
A pseudo-code of the algorithm for inferring an upper bound for method allocations is given in Fig. \ref{methodAlloc}.
Essentially, it finds the maximal memory that can be allocated in a method by exploring all its possible execution path.
The algorithm computes the set of blocks contained in a loop, the loop entry block and the set of end blocks of a loop; see Section 10 of 
 \cite{ASU86cpt} for a description of the algorithms used.

\begin{figure}[!htp]
function $\allocMethod{.}$\\
\textbf{Input:} Bytecode of a method $m$. \\
\textbf{Output:} Upper bound of the memory allocated by $m$. \\
\textbf{Body:}
\begin{enumerate}
   \item Detect all the loops in $m$; for every loop $l$ determine $\loopSet{l}$, $\loopEntry{l}$ and $\loopEndsSet{l}$;
   \item Apply the function \allocatedOnly \  to each instruction $\instrAt{k}$, such that $\instrAt{k} = \return$;
   \item Take the maximum of the results given in the previous step: \\
 $max_{\instrAt{k} = \return } \allocated{\instrAt{k}}$.
\end{enumerate}
\caption{\sc Inference algorithm}
\label{methodAlloc}
\end{figure}

The auxiliary function $allocPath$, which infers the maximal allocations done by the set of execution paths ending with the same \return\ instruction,
 is given in Fig. \ref{fig:allocMethod}.
Inferring the memory allocated inside loops is done by the function $\allocLoopWithEnd{\cdot}{\cdot}$, which is invoked by $allocPath$ whenever the 
current instruction belong to a loop. The specification of the function is shown in Fig. \ref{fig:loopPath}.

\begin{figure}[!hbp]
%\centerline{
$\allocated{\instrAt{s}}$ = 
$$ \left\{ \begin{array}{ll}
\allocIns{\instrAt{s} }   &  if \ \instrAt{s} \ has \ no \ predecessors \\
& \\
  \begin{array}{l}
            \allocLoop{\loopEntry{l}} \\
             + \\
            max_{\instrAt{k} \in preds(\instrAt{s} )-\loopEndsSet{\progLoop{l}}}( \allocated{\instrAt{k}} ) \\
                   \end{array}      & if \  \instrAt{s} \in \loopSet{\progLoop{l}} \\
& \\
\begin{array}{l}
\allocIns{\instrAt{s}} \\
 + \\
max_{\instrAt{k} \in preds(\instrAt{s} )}
 ( \allocated{\instrAt{k}} )
                       \end{array} & else 
\end{array}
\right.
$$
\caption{\sc Definition of the function $\allocated{\instrAt{s}}$} 
\label{fig:allocMethod}
\end{figure}


\begin{figure}[!hbp]

$\allocLoopWithEnd{\loopEntry{l}}{\instrAt{s}} = $
$$ 
\left\{\begin{array}{ll}

 \allocIns{\loopEntry{l}}  & if \  \instrAt{s} = \loopEntry{l} \\
  & \\
 \begin{array}{l}
           \allocLoop{\loopEntry{l'}} \\
          + \\
      max_{\instrAt{k} \in preds(\loopEntry{l'} ) - \loopEndsSet{\progLoop{l'}}}
       ( \allocLoopWithEnd{\loopEntry{l}}{\instrAt{k}} )
    \end{array} &  \begin{array}{l}
                                        if \  \instrAt{s} \in  \loopSet{\progLoop{l'}} \\
                                          \progLoop{l'} \ is \  nested \ in \ \progLoop{l}
                                    \end{array} \\
  & \\
  \begin{array}{l}
     \allocIns{\instrAt{s}} \\
     + \\
     max_{\instrAt{k} \in preds(\instrAt{s} )}
     ( \allocLoopWithEnd{\loopEntry{l}}{\instrAt{k}} )
                       \end{array} & else \\

\end{array} \right.
$$
 \caption{\sc Definition of the function $\allocLoopWithEnd{\loopEntry{l}}{\instrAt{s}}$}
\label{fig:loopPath}
\end{figure}


%In essence, it first analyses the method's bytecode by identifying the entry loop instruction, the instructions
% that are inside the loop and the set of instructions by which the loop terminates. 
%Then  it finds the maximal number of allocations that can be done per execution path: 
%it starts from all \return \ instructions and ``inspects'' the execution paths upto the entry program
%instruction (in backwards direction  );  if an instruction in the path belongs to a loop then the allocations done per iteration in the loop are 
%calculated and the analysis proceeds from the instructions that target the entry of the loop and that do not belong to the loop; the assistant computes the memory required for %each loop using the memory required for each iteration of the loop, and the variant of the loop, which provides information about the number of
%iterations; upper bound of the allocations done per iteration in a loop are calculated also in a backwards direction 
%(starting from instructions that belong to the loop and whose next instruction is the unique loop entry) by finding the 
%maximal number of allocations per iteration path and if an instruction in an iteration path appears to be instruction that belongs to an inner loop 
%then first an upper bound for the allocations done in the inner loop are inferred and the analysis continues from instructions that target the entry of the nested loop and do not belong to the nested loop.    

The annotation assistant currently synthesize only simple
memory policies (i.e., whenever the memory consumption policy does not depend on
the values of inputs).
%and could be significantly improved in this respect. 
Furthermore, it does not deal with arrays, subroutines, nor exceptions. Our approach may be extended to treat such cases (see the discussion in Section \ref{sec:conc} about how to include arrays in our analysis). For sake of simplicity,
we have also restricted the loop analysis only to those with a unique
entry point, which is the case for code produced by non-optimizing
compilers. A pre-analysis could give us all the entry points of more
general loops, for instance by the algorithms given in \cite{CJPS05cmu}; our approach may be thus applied straightforwardly.

\subsubsection{Example}
%Our assistant is able to handle programs with complex features, such as \alarm{mariela}.\alarm{fix section}

Let us consider the bytecode given in Fig. \ref{inf:src}, which is a simplified version of the bytecode corresponding to the source code given in the
 right of the figure. For simplicity of presentation, we do not show all the instructions (the result of the inference procedure is not affected).
 Method $m$ has two branching instructions, where two objects are created: one instance of class $A$ and another of class $B$. Our inference algorithm gives
 that $\allocMethod{m} = \allocInstance{A} + \allocMethod{A.init} + \allocInstance{B} + \allocMethod{B.init}$. Due to limitation on space, we do not explain
 the details of such inference, which are given in Fig. \ref{inf:ex} ($\instrAt{k}$ refers to the bytecode instruction at position $k$).


%It infers the maximal memory used for the example program at Fig. \ref{inf:src}. 
%In the examples $\instrAt{k}$ refers to the instruction in the bytecode at position $k$.

\begin{figure}[!hbp]
\begin{tabular}{lr}
\begin{minipage}[t]{170pt}
\begin{alltt}
\begin{small}
\srcCode{0 aload\_1} 
\srcCode{1 ifnonnull 6 } 
\srcCode{2 new <A>}
... 
\srcCode{4 invokespecial <A.<init>>} 
\srcCode{6 aload\_2}
\srcCode{7 ifnonnull 12}
\srcCode{8 new <B>} 
... 
\srcCode{10 invokespecial <B.<init>>}
...
\srcCode{12 return}
\end{small}
\end{alltt}
\end{minipage} &

\begin{minipage}[t]{170pt}
\begin{alltt}
\small{
public void m(A a , B b ) \{
  if ( a == null ) \{
    a = new A();
  \}
  if (b == null) \{
    b = new B();
  \}
\}
}
\end{alltt}
\end{minipage}
\end{tabular}
\caption{\sc Example}
\label{inf:src}
\end{figure}


\begin{figure}[!hbp]
$\begin{array}{l}
\\
\allocMethod{m}\\
=\\
\allocated{\instrAt{12}} \\
= max_{\instrAt{k} \in preds(1_{12})} (\allocated{\instrAt{k} }) + \allocIns{ \instrAt{12}}\\
\{\allocIns{\instrAt{12}} = 0, preds(\instrAt{i_{12}} ) = \{ i_{10}, i_7 \}\}\\
= max( \allocated{\instrAt{10}} , \allocated{\instrAt{7}} ) \\
= max(max_{ \instrAt{k} \in preds(\instrAt{10})}(\allocated{ \instrAt{k}}) + \allocIns{\instrAt{10}} ,\\
\phantom{= max.}
max_{ \instrAt{k} \in preds(\instrAt{7} )}(\allocated{ \instrAt{k}}) +\allocIns{\instrAt{7}}   \\
\phantom{=}) \\

\{preds(\instrAt{10} ) = \{ i_8 \} , preds(\instrAt{7} ) = \{ i_6 \} \} \\

= max( \allocated{\instrAt{8}} + \allocIns{\instrAt{10}}, \allocated{\instrAt{6}} + \allocIns{\instrAt{7}} ) \\
\{ \allocIns{\instrAt{10}} = \allocMethod{B.init} ,  \allocIns{\instrAt{7}} = 0 \} \\

= max( max_{ \instrAt{k} \in preds(\instrAt{8} )}(\allocated{ \instrAt{k}})  +  \allocIns{\instrAt{8}} + \allocMethod{B.init}  , \\
 \phantom{= max.} max_{ \instrAt{k} \in preds(\instrAt{6} )}(\allocated{ \instrAt{k}})  +   \allocIns{\instrAt{6}}  \\
\phantom{=}) \\

\{preds(\instrAt{8} ) = \{ i_7 \}, preds(\instrAt{6} ) = \{ i_4 \} \} \\

= max( \allocated{\instrAt{7}}  +  +  \allocIns{\instrAt{8}} + \allocMethod{B.init}  , \\ 
 \phantom{= max.} \allocated{\instrAt{4}}  + \allocIns{\instrAt{6}}  \\
\phantom{=}) \\

\{ \allocIns{\instrAt{8}} = \allocInstance{B} ,  \allocIns{\instrAt{6}} = 0 \} \\

= max( max_{ \instrAt{k} \in preds(\instrAt{7} )}(\allocated{ \instrAt{k}})  +  \allocIns{\instrAt{7}} + \allocInstance{B} +\allocMethod{B.init}  , \\
 \phantom{= max.} max_{ \instrAt{k} \in preds(\instrAt{4} )}(\allocated{ \instrAt{k}}) + \allocIns{\instrAt{4}}\\
 \phantom{=}) \\
\{ preds(\instrAt{7}) = \{ i_6\}, preds(\instrAt{4}) = \{ i_2 \}  \}\\
 = max(\allocated{i_6} + \allocIns{\instrAt{7}} + \allocInstance{B} +\allocMethod{B.init}, \\
   \phantom{= max.}   \allocated{i_2} +\allocIns{i_4} \\
  \phantom{=} ) \\ 
\{ \allocIns{\instrAt{7}} = 0 ,  \allocIns{\instrAt{4}} = \allocMethod{A.init} \} \\
 = max( max_{ \instrAt{k} \in preds(\instrAt{6} )}(\allocated{ \instrAt{k}})  +  \allocIns{\instrAt{6}} + \allocInstance{B} +\allocMethod{B.init}  , \\
  \phantom{= max.} max_{ \instrAt{k} \in preds(\instrAt{2} )}(\allocated{ \instrAt{k}}+  \allocIns{\instrAt{2}}  +  \allocMethod{A.init} \\
  \phantom{=} ) \\ 
  =  \{ preds(\instrAt{6}) = \{ i_4, i_1\}, preds(\instrAt{2}) = \{ i_1 \}  \} \\
  = max( max(\allocated{i_4} , \allocated{i_1})  +  \allocIns{\instrAt{6}} + \allocInstance{B} +\allocMethod{B.init}  , \\
  \phantom{= max.} \allocated{i_1} +  \allocIns{\instrAt{2}} +  \allocMethod{A.init} \\
\phantom{=} ) \\ 
\{ \allocIns{\instrAt{6}} = 0 ,  \allocIns{\instrAt{2}} = \allocInstance{A} \} \\
= max( max ( max_{i_k \in preds(i_4)}( \allocated{i_k} ) + \allocIns{i_4}, \\
\phantom{ = max. max.} max_{i_k \in preds(i_1)}( \allocated{i_k} ) + \allocIns{i_1} \\
\phantom{ = max.} ) + \allocInstance{B} +\allocMethod{B.init}  , \\
\phantom{= max .}  \allocated{i_0}+ \allocInstance{A} + \allocMethod{A.init}  , \\
\phantom{=} ) \\ 
 \{ preds(i_4)= \{i_2 \}, preds(i_1) =\{i_0 \} \} \\
 \{ \allocated{i_0} = \allocIns{i_0} = 0, \allocIns{i_1} = 0 , \allocIns{i_4} = \allocMethod{A.init} \} \\
 = max(   max ( \allocated{i_2} + \allocMethod{A.init} , \\
 \phantom{ = max. max.}\allocated{i_0}   \\
 \phantom{ = max.} ) + \allocInstance{B} +\allocMethod{B.init}  , \\
 \phantom{= max .} \allocInstance{A} + \allocMethod{A.init}  , \\
 \phantom{=} ) \\ 
  \{ \allocated{i_0} = \allocIns{i_0} = 0 \} \\
 = max(   \allocated{i_2} + \allocMethod{A.init} + \allocInstance{B} +\allocMethod{B.init}  , \\
 \phantom{= max .} \allocInstance{A} + \allocMethod{A.init}  , \\
 \phantom{=} ) \\ 
 \ldots \\
 = max(   \allocInstance{A} + \allocMethod{A.init} + \allocInstance{B} +\allocMethod{B.init}  \\
 \phantom{= max .} \allocInstance{A} + \allocMethod{A.init}  , \\
 \phantom{=} ) \\ 
 =   \allocInstance{A} + \allocMethod{A.init} + \allocInstance{B} +\allocMethod{B.init}
  
\end{array} $ \\

\caption{\sc Inference of the memory allocated by the method $m$ of Fig. \ref{inf:src}}
\label{inf:ex}
\end{figure}

%The procedure presented above terminates as an acyclic
%representation of the control flow graph is used.
