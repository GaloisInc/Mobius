%Verifying programs being correct
\label{verification}
Once an appropriate annotation is attached to the code, a
static verification procedure is applied to the bytecode and
the annotation. This static analysis is based on a predicate transformer
function. The predicate transformer is defined over almost the whole
set of sequential Java instructions except for 64 bit data and floating
point arithmetic, including instructions treating references,
exceptions and subroutines. The calculus supports a superset of the
specification language BML that is considered in the present work. The predicate
transformer takes a predicate $\psi$ that must hold in the poststate of
the program and translates the bytecode and its specification into
predicate$\phi$. The relation between the two predicates $\psi$ and
$\phi$ must be the following: \textit{if $\phi$ holds in the prestate
of the program then the predicate $\psi$ must hold in the program
poststate. }

For example the rule for the instructions \srcCode{putfield} is given
at fig.~\ref{wpInstr}. The rule considers also the cases for
exceptional termination of the instruction execution (e.g. the rule
for the \srcCode{putField} instruction has two conjuncts : the one
assumes that the reference is not null thus this is the normal
execution case and the other assumes that the reference whose field is
accessed is null). Aliasing is treated by an overriding function.

\begin{figure}[!hbp] 
$
\begin{array}{ll}
\wpi{putfield \ \it{ind} }{\normalPost}{\excPost} & =   \left\{ \begin{array}{l}
                               \stack{\topStack - 1} != \javaNull \Rightarrow \\
                                \phantom{aaaaa} \normalPost \substitution{\topStack}{\topStack - 2} \substitution{cp(ind)( \stack{\topStack - 1} )}{\stack{\topStack}} \\
                \wedge \\
        \stack{\topStack - 1} == \javaNull \Rightarrow \\
             \phantom{aaaaa}\excPost(NullPointerExc) \begin{array}{l} \substitution{\topStack}{0}\\
                                     \substitution{\stack{\topStack}}{\Ref{NullPointerExc}  }
                                    \end{array}
                    \end{array} \right.\\

\end{array}
$
$\stack$ stands for the method stack \\
$\topStack$ is the stack counter \\
\caption{wp rule for the instruction \srcCode{putfield} }
\label{wpInstr}
\end{figure}

As bytecode programs lack structure we define wp rules also for basic
blocks. Thus the rule for treating the conditional jump is given at
fig.~\ref{wpBlock}.

\begin{figure}[!hbp]
 $$ \begin{array}{ll}
                 \wpExe{\If \ k} & =  \left\{ \begin{array}{l}
                                                cond( \stack{\topStack}, \stack{\topStack - 1}) \Rightarrow  \psi_{1}\substitution{\topStack }{\topStack - 2}   \\                                                              \wedge \\
                                        not (cond( \stack{\topStack}, \stack{\topStack - 1})) \Rightarrow \psi_{2}\substitution{\topStack}{\topStack - 2 }  
                                        \end{array} 
                                   \right. 
         \end{array}
     $$


$\stack$ stands for the method stack \\
$\topStack$ is the stack counter \\
$\psi_{1}$ is the weakest precondition for the block \blockm{k} \\
$\psi_{2}$ is the weakest precondition for the block \blockm{\nextIns{\srcCode{\If \  k}}}
\caption{Weakest precondition rule for conditional jump.}
 \label{wpBlock}
\end{figure}


