\section{Defintitions}
We introduce definitions related to the control flow graph of a
method.

We assume that a bytecode is an array of instructions from our
language. The $k-th$ instruction from a given bytecode is denoted
with $\instrAt{k}$.

We denote by $\Gamma  = ( \Omega, \ll)$ the execution graph of a
bytecode $\Pi$ where the set of nodes $\Omega$ is the set of
blocks. The set of edges $\ll$ defines the execution relation
between blocks.Using standard terminology \cite{ARU1986com}, a
basic block is a code segment that has no unconditional jump or
conditional branch statements except for possibly the last
statement, and none of its statements, except possibly the first,
is a target of any jump or branch statement.

We denote a block that starts at instruction $\instrAt{j}$
respectively by \blockm{j}. Let's have the bytecode $\Pi$ and the
set of its blocks  be $\bbb$. The edges ( $\ll \ \subseteq \bbb \ \times \ \bbb $ ) define the order of block execution.


\begin{defn}[Entry block for a method]\label{entryBlock}
Let's have the control flow graph $\Gamma  = ( \Omega, \ll)$ for a bytecode $\Pi$. We assume that every execution path of $\Gamma$ starts at the block starting at
 $\instrAt{0}$. We denote this block with \blockm{entry}. We say
 also that $\instrAt{0}$ is the entry instruction of the program.
\end{defn}

\begin{defn}[Execution relation between blocks]\label{execRel}
\begin{tabbing}
\\Let \=  have \= the blocks \blockm{j} and   \blockm{k}. They
are\\
in execution relation  and we note it by \blockm{j} $\ll$ \blockm{k}\\
(this means that \blockm{k} can immediately follow\\
\> \blockm{j} in some execution sequence  ) if : \\
\>  if  \blockm{j} ends with a conditional or unconditional jump to the first instruction of \blockm{k}\\
\>  if  \blockm{j}  immediately follows \blockm{k} in the order of the program and does not end in an\\
\> unconditional jump \\
\end{tabbing}
We say that \blockm{j}  is a \textit{predecessor}of \blockm{k} and
that \blockm{k} is a \textit{successor} of \blockm{j}.
\end{defn}

\begin{defn}[Execution relation between instructions]\label{execRelInstr}
We also  define execution relation between instructions. If
\blockm{j} $\ll$ \blockm{k} (see def.~\ref{execRel}) and if
\blockm{j} terminates with instruction $\instrAt{m}$ then we also
say that $\instrAt{m}$ is a \textit{predecessor} of $\instrAt{k}$.
If two instructions $\instrAt{k}$ and $\instrAt{k+1}$ are in the
same basic block then $\instrAt{k}$ is a \textit{predecessor} of
$\instrAt{k+1}$. The predecessors of instructions $\instrAt{k}$
are denoted by $preds(\instrAt{k}) $. In the same way is defined
\textit{successor} for instructions.
\end{defn}

%We say that there exists a path between \blockm{i} and \blockm{j}
%and we note it with  \pathm{i}{j}, if there exists blocks
%\blockm{s_{1}}... \blockm{s_{n}} such that \blockm{i}$\ll$
%\blockm{s_{1}}$\ll$ \blockm{s_{2}} $\ll$ ...$\ll$
%\blockm{s_{n}}$\ll$ \blockm{j}

\begin{defn}[Loop Definition]\label{defLoop}
Let's have a well formed bytecode  $\Pi$ representing the body of
method \method. We say that  \loopSet{l} is the set of blocks of a
loop $l$ , \blockm{s} $ \in \loopSet{l}$ is the entry block of
loop $l$ in $\Pi$ and \loopEndsSet{l} $ \subseteq \loopSet{l}$ is
the set of end blocks of $l$ if:
\begin{itemize}
\item if $\forall  $ \blockm{e} $ \in  \loopSet{l}$ every path
from the entry block \blockm{entry} of the method \method to
\blockm{e} goes through \blockm{s}

%\item $\forall  $ \blockm{e} $ \in  \loopEndsSet{l}$ there exists
%a path in the execution graph starting at the entry block
%\blockm{entry} of the method \method (i.e. the one that starts
%with the entry instruction) of $\Pi$ and that passes first through
%\blockm{s} and later through \blockm{e}, i.e.\blockm{entry}
%$\ll^{*}$ \blockm{s} $\ll^{*}$ \blockm{e}

\item $\forall  $ \blockm{e} $ \in  \loopEndsSet{l}$  \blockm{e}
$\ll$ \blockm{s}
\end{itemize}
The instruction $\instrAt{s}$ at which the entry loop block
\blockm{s} starts is denoted with \loopEntry{l}

\end{defn}




%Note that every loop in the control graph has at least one backedge: an edge in the control flow graph that goes from some $\instrAt{j}$ to $\instrAt{k}$ such that $k \le j$ (% that makes possible that there is a path from the start instruction of the loop to itself. We denote a backedge as $\backedge{\instrAt{j}}{\instrAt{k}}$). For reasons of being simpler we assume here that there is only one backedge per loop (actually it is quite normal to have more than one backedge : for example if in the loop there is a \texttt{continue} in a loop but this will make the explanations more complicated).
% Note also that the instructions that are between the end of a loop and the start of a loop have their number in the bytecode array smaller than the start of the corresponding backedge and bigger than the end of the backedge.

\begin{defn}[Nested Loops]
\label{nestedLoops}
We say that a loop \progLoop{l2} is nested into  \progLoop{l1} that in the body of a method \method \   iff :
\begin{itemize}
\item every path starting at the entry block \blockm{entry} of the method \method \  and that reaches the entry block of \progLoop{l2} passes through the entry block of \progLoop{l1}
\item no path that starts at the entry block of \progLoop{l2} and that reaches an end instruction of \progLoop{l2} passes through the end of \progLoop{l1}
\end{itemize}
\end{defn}

%\begin{defn}[Loop Ordering]
%\label{loopOrder}
%For every loop \progLoop{l} in the control flow graph a number is
%associated to its entry block $\numLoop{\progLoop{l}} $. Thus
 %               \begin{enumerate}
  %                      \item if a loop \progLoop{l2} is nested in \progLoop{l1}, \numLoop{\progLoop{l1}} $ <$ \numLoop{\progLoop{l2}}
   %                     \item if a loop \progLoop{l2}  is not nested in \progLoop{l1} but their entry blocks are  \blockm{i} and \blockm{j} respectively such that
    %                            $ i < j $ then  \numLoop{\progLoop{l1}} $ <$ \numLoop{\progLoop{l2}}
     %           \end{enumerate}
%\end{defn}
