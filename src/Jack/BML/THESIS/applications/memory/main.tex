\documentclass{llncs}
\usepackage[latin1]{inputenc}
\usepackage[dvips]{epsfig}
\usepackage{alltt,amsmath,amssymb}
\usepackage{latexsym,pstricks,pst-node,pst-tree,boxedminipage,stmaryrd}
%\usepackage{times}
\usepackage{listings}
\def\lstlanguagefiles{lstlangjml.sty}
\lstloadlanguages{Jml}


 %% The frameit and Frameit environments formats text within a single
  %% Anything can be framed, including verbatim text.

\def\doframeit#1{\vbox{%
  \hrule height\fboxrule
    \hbox{%
      \vrule width\fboxrule \kern\fboxsep
      \vbox{\kern\fboxsep #1\kern\fboxsep }%
      \kern\fboxsep \vrule width\fboxrule }%
    \hrule height\fboxrule }}

\def\frameit{\smallskip \advance \linewidth by -7.5pt \setbox0=\vbox \bgroup
\strut \ignorespaces }

\def\endframeit{\ifhmode \par \nointerlineskip \fi \egroup
\doframeit{\box0}}

\newcommand{\alarm}[1]{\marginpar{#1}}

\begin{document}

\title{Precise analysis of memory consumption using program logics}
\author{Gilles Barthe\inst{1}\and Mariela Pavlova\inst{1}
\and Gerardo Schneider\inst{2}}
\institute{INRIA Sophia--Antipolis, France
\and Department of Informatics, University of Oslo, Norway}

\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% DEFINITIONS
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{mydef}

\maketitle

\abstract{Memory consumption policies provide a means to control
resource usage on constrained devices, and play an important role
in ensuring the overall quality of software systems, and in
particular resistance against resource exhaustion attacks. Such
memory consumption policies have been previously enforced through
static analyses, which yield automatic bounds at the
cost of precision, or run-time analyses, which incur an overhead
that is not acceptable for constrained devices.

In this paper, we study the use of logical methods to specify and
verify statically precise memory consumption policies for Java
bytecode programs. First, we demonstrate how the Bytecode Modeling
Language BML (a variant of the Java Modeling Language JML tailored to
bytecode) can be used to specify precise memory consumption policies
for (sequential) Java applets, and how verification tools can
be used to enforce such memory consumption policies. Second, we
consider the issue of inferring some of the annotations required to
express the memory consumption policy. We report on an inference
algorithm and illustrate its applicability on non-trivial examples.


Our broad conclusion is that logical methods provide a suitable means
to specify and verify expressive memory consumption policies, with a
minimal overhead.}




%\vspace*{0.1cm}
%\noindent {\bf Keywords:}

\section{Introduction}
\input{intro}

\section{Preliminaries}\label{sec:prelim}
\input{prelim}

\section{Modeling memory consumption}\label{sec:verif}
\input{technical}

\section{Inferring memory allocation for methods}\label{sec:infer}
\input{infer}

\section{Related work}\label{sec:rel}
\input{relatedworks}

\section{Conclusion}\label{sec:conc}
\input{conclusion}


\bibliographystyle{plain}
%\bibliography{bib/string,bib/gilles,bib/article,bib/book,bib/lncs,bib/misc,bib/proceedings,bib/techrep,bib/thesis,bib/software,bib_mem-wpc}
\bibliography{bib_mem-wpc}


\end{document}
