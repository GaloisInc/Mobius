
\section{Examples}\label{sec:examples}
We illustrate hereafter our approach by several examples. 
%\alarm{talk about number of proof obligations, which are discharged automatically in Coq, etc}

\subsection{Inheritance and overridden methods} Overriding methods are treated as follows: whenever a call is performed to a method \method,
we require that there is enough free memory space for the maximal
consumption by all the  methods that override or are overridden by
\method. In Fig. \ref{classExt} we show a class \verb!A! and its
extending class \verb!B!, where \verb!B! overrides the method \method\ from class \verb!A!. Method \method\ is invoked by $n$. Given that the dynamic type of the parameter passed to $n$ is not known, we cannot know which of the two
methods will be invoked. This is the reason for requiring enough memory space for the execution of any of these methods.
%After the method execution we consider the extreme case where there is executed the method \method\ that consumes the most.

\begin{figure}[!htp]
\begin{frameit}
\begin{center}
\begin{minipage}[c]{\linewidth}%{110mm}
\begin{lstlisting}[frame=trbl]
Specification of method
 m in class A:

requires MemUsed + k  <= Max 
modifies MemUsed 
ensures  MemUsed  <= \old(MemUsed) + k
\end{lstlisting}

\begin{lstlisting}[frame=trbl]
Specification for method m in class B:

requires MemUsed + l  <= Max 
modifies MemUsed 
ensures  MemUsed  <=  \old(Mem) + l
\end{lstlisting}

\end{minipage}

\begin{minipage}[c]{\linewidth} %{110mm}
\begin{lstlisting}[frame=trbl]
void method n(A a)
...
//{ prove MemUsed <= Mem +max(l,k) }
invokevirtual m A
//{ assume MemUsed <= \old{MemUsed} + max(l,k)}
...
\end{lstlisting}
\end{minipage}

\caption{\sc Example of overridden methods}
\label{classExt}
\end{center}
\end{frameit}
\end{figure}


\subsection{Recursive Methods} In Fig. \ref{recMeth} the bytecode of the recursive method \methodd{} and its specification is shown. 
 We show a simplified version of the bytecode; we assume that the constructors for the class \srcCode{A} and \srcCode{C}
 do not allocate memory. Besides the precondition and the postcondition, the specification also includes information 
 about the termination of the method: \variant\ $\local{1}$, meaning that the local variable $\local{1}$ decreases on every recursive call down to and no more than $0$, guaranteeing
 that the execution of the method will terminate.
 
%Now we explain why such a precondition is required for method \textbf{m} in order to specify the property for constraint memory consumption. 

We explain first the precondition. If the condition of line \srcCode{1} is not true, the execution continues at line \srcCode{2}.

\begin{figure}[!hbp]

\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[frame=trbl]

 requires  MemUsed +
           reg(1)*2*allocInstance(A) + 
           allocInstance(A) +
	   allocInstance(C) <=  Max 

 variant   reg(1) 

 ensures   reg(1) >= 0 
           &&
	   MemUsed <= old(MemUsed)+  
	   \old(reg(1))*2*allocInstance(A)+
	   allocInstance(A) + 
           allocInstance(C)
 
public void m()
//local variable loaded on 
//the operand stack of method m
 0 load 1
// if \reg(1) <= 0 go to 12
 1 ifle 12}
 2 new A 
// here reg(1) > 0 
//@ set MemUsed = MemUsed +  allocInstance(A)
 3 invokespecial A.init
 4 aload 0
 5 iload 1
 6 iconst 1
// reg(1) decremented with 1
 7 isub
//recursive call with the new 
//value of reg(1)
 8 invokevirtual D.m
 9 new A
//set MemUsed = MemUsed + allocInstance(A)
 10 invokespecial A.init
 11 goto 16
 target of the jump at  1
 12 new A
//set MemUsed = MemUsed +  allocInstance(A)
 13 invokespecial A.init
 14 new  C
//set MemUsed = MemUsed +  allocInstance(C)
 15 invokespecial C.init
 16 return
\end{lstlisting} 
\end{minipage}



\begin{minipage}[c]{\linewidth}%{90mm}
\begin{lstlisting}[frame=trbl]
public class D {
  public void m( int i) {
    if (i > 0) {
      new A();
      m(i - 1);
      new A();
    } else {
      new C();
      new A();
   }
  }
}
\end{lstlisting} 
\end{minipage}
\caption{\sc Example of a recursive method}
 \label{recMeth}
\end{figure}

In the sequential execution up to line \srcCode{7}, the program allocates at most $\allocInstance{A}$ memory units and decrements by $1$ the value of $\local{1}$. The instruction at line \srcCode{8} is a recursive call to \methodd{}, which either will take the same branch if $\local{1} > 0 $ or will jump to line \srcCode{12} otherwise, where it allocates at most $\allocInstance{A} +  \allocInstance{C}$ memory units. On returning from the recursive call one more allocation will be performed at line \srcCode{9}.
 Thus \methodd{} will execute, $\local{1}$ times, the instructions from lines \srcCode{4} to \srcCode{35}, 
and it finally will execute all the instructions from lines  \srcCode{12} to \srcCode{16}.
The postcondition states that the method will perform no more
than $\old{\local{1}}$ recursive calls (i.e., the value of the register variable in the pre-state of the method) and that on every recursive call it allocates no more than two instances of class \texttt{A} and that it will finally allocate one instance of class \texttt{A} and another of class \texttt{C}.


\subsection{More precise specification} We can be more precise in specifying the precondition of a method by considering what are the field values of an instance, for example. Suppose that we have the method \method\ as shown in Fig. \ref{excMeth}. We assume that in the constructor of the class \texttt{A} no allocations are done. The first line of the method \method\ initializes one of the fields of field \texttt{b}. Since nothing guarantees that field \texttt{b} is not \Mynull, the execution may terminate with
\texttt{NullPointerException}. Depending on the values of the parameters passed to \method, the memory allocated will be different. The precondition establishes what is the expected space of free resources depending on if the field
\texttt{b} is \Mynull  or not. In particular we do not require anything for
the free memory space in the case when \texttt{b} is \Mynull. In the
normal postcondition we state that the method has allocated an
object of class \texttt{A}. The exceptional postcondition states
that no allocation is performed if \texttt{NullpointerException} causes the execution termination.

\begin{figure}[!hbp]
% $$
%\begin{array}{ll}
%% \requires &  \local{1} != \Mynull \Rightarrow 
%             \Mem +  \allocInstance{A} \le \Max \\
%       %& \wedge \\
%       %&  \local{1} == \Mynull \Rightarrow  \\
%           %& \phantom{\local{1}} \Mem +  \allocInstance{B} + \allocInstance{A}   \le \Max \\
%  \modifies & \Mem \\
%  \ensures  & \Mem \le \old{\Mem} +  \allocInstance{A} \\
%  \exsures{} \NullPointerExc \  & \Mem == \old{\Mem}   \\
%\end{array}$$


\begin{minipage}[c]{\linewidth}

\begin{lstlisting}[frame=trbl]
 requires  reg(1) !=  null ==>  Mem +  allocInstance(A) <= Max 
 modifies  Mem 
 ensures   Mem  <= \old(Mem) +  \allocInstance(A) \\
 exsures   NullPointerExc  Mem == old(Mem)

 0 load 0
 1 getfield C.b
 2 load 2
 3 putfield B.i
 4 new A 
//set MemUsed =  MemUsed + allocInstance(A)
 5 dup
 6 invokespecial A.init
 7 store 1
 8 return
\end{lstlisting}

\end{minipage}


\begin{minipage}[c]{\linewidth}

\begin{lstlisting}[frame=trbl]
public class C{
 B b;
 public void m(A a,int i){
   b.i = i ;
   a = new A();
 }
}
\end{lstlisting}

\end{minipage}

\caption{\sc Example of a method with possible exceptional termination}
\label{excMeth}
\end{figure}
