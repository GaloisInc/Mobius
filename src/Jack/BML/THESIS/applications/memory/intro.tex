

%The approach is based on program logics, which originate from the seminal
%work on program verification by C.A.R.~Hoare and E.W.~Dijkstra and
%have been used traditionally to verify functional properties of
%programs. In earlier work, we have shown how general purpose logics
%can be used to enforce security properties of Java programs, including
%confidentiality~\cite{gpt04:csfw} and high-level security
%rules~\cite{m+04:cardis}. In this paper, we demonstrate that program
%logics are also appropriate for performing a precise analysis of
%resource consumption for Java programs.  Although our method is
%applicable both at source code level and bytecode level, our work 
%has focused on bytecode level, since in many application domains
%verification has to be performed without access to the source code
%of the applet. 


In order to illustrate the principles of our approach, let us consider
the following program:

\begin{lstlisting}[frame=trbl] 
public void m(A a){
  if (a  == null) {
    a = new A();
  }  
   a.b = new B();
}
\end{lstlisting}

For modeling the memory consumption of this program, we introduce
a \ghost{}  variable \lstinline!Mem! that accounts for memory consumption; more
precisely, the value of \lstinline!Mem! at any given program point is meant
to provide an upper bound to the amount of memory consumed so far. To
keep track of the memory consumption, we perform immediately after every 
bytecode that allocates memory an increment of \lstinline!Mem! \ by the amount
of memory consumed by the allocation. Thus, if the programmer specifies
that \lstinline!ka! and \lstinline!kb! is the memory consumed by the allocation of 
an instance of class \lstinline!A! and  \lstinline!B! respectively, the program must
be annotated as:
\begin{lstlisting}[frame=trbl] 
public void m(A a) {
  if (a  == null) {
    a = new A();
    // set Mem = ka;
  }  
   a.b = new B();
   // set Mem = kb;}
\end{lstlisting}

Such annotations allow to compute at run-time the memory consumption of 
the program. However, we are interested in static prediction of memory
consumption, and resort to preconditions and postconditions to this end.
Even for a simple example as above, one can express the specification
at different levels of granularity. For example, fixing the amount of memory that
the the program may use \lstinline!Max! one can specify that the method will use at most 
\lstinline! ka +  kb! memory units and will not overpass the authorized limit to use \lstinline!Max! with the following specification:

\begin{lstlisting}[frame=trbl] 
//@  requires Mem + ka +  kb <= Max 
//@ ensures  Mem <= \old(Mem) + ka +  kb     
public void m(A a) {
  if (a  == null) {
    a = new A();
    // set Mem = ka;
  }  
   a.b = new B();
   // set Mem = kb;
}
\end{lstlisting}
Or try to be more precise and relate memory consumption to inputs with
the following specification:
\begin{lstlisting}[frame=trbl] 
//@ requires a == null ==> Mem + ka +  kb <= Max &&	 
    !(a  == null) ==> Mem + kb <= Max
//@ ensures \old(a) == null ==> 
    Mem <= \old(Mem) + ka +  kb && 
    !(\old(a)  == null) ==> Mem <= \old(Mem) + kb    
public void m(A a) {
  if (a  == null) {
    a = new A();
  }  
   a.b = new B();
}
\end{lstlisting}
More complex specifications are also possible. For example, one can
take into account whether the program will throw an exception or not.
using (possibly several) exceptional postconditions stating that
$\texttt{k}_{\texttt{E}}$ memory units are allocated in case the
method exits on exception \texttt{E}.



The main characteristics of our approach are:
\begin{itemize}
\item \emph{Precision:} our analysis allows to specify and enforce
precise memory consumption policies, including policies that take
into account the results of branching statements or the values of
parameters in method calls. Being based on program logics, which are
very versatile, the precision of our analysis can be further improved
by using it in combination with other analyses, such as control flow
analysis and exception analysis;


\item \emph{Correctness:} our analysis exploits existing program logics
which are (usually) already known to be sound. In fact, it is immediate
to derive the soundness of our analysis from the soundness of the program
logic, provided ghost annotations that update memory consumption variables
are consistent with an instrumented semantics that  extends the language
operational semantics with a suitable cost model that reflects resource
usage;

\item \emph{Language coverage:} our analysis relies on the existence
of a verification condition generator for the programming language at
hand, and is therefore scalable to complex programming features.  In
the course of the paper, we shall illustrate applications of our
approach to programs featuring recursive methods, method
overriding and exceptions;


%\item \emph{Usability:} our approach can be put to practice
%immediately using existing verification tools for program logics. We
%have applied our approach to annotated Java bytecode programs using a
%verification environment developed in \cite{LM05:acc}, but it is also possible to use our approach on
%JML annotated Java source code~\cite{BRL03:fme}, and more generally on
%programs that are written in a language for which appropriate support
%for contract-based reasoning exists;



\item \emph{Annotation generation:} in contrast to other techniques
discussed above, our approach requires user interaction, both for
specifying the program and for proving that it meets its specification.
In order to reduce the burden of the user, we have developed heuristics
that infer automatically part of the annotations;


\item \emph{Feasibility:} thanks to annotation generation mechanisms
and powerful provers that help discharge many proof obligations
automatically, our approach can be applied to realistic Java bytecode
programs with a reasonable overhead.
\end{itemize}
In the course of this section, we illustrate the principles and
characteristics of our approach in the context of Java bytecode
programs. More specifically,  the rest of this section is organized
 as follows:
%Section~\ref{sec:prelim} provides a brief introduction to Java
%bytecode programs and to the modeling language and weakest
%precondition calculus used to specify and verify such programs.
Section~\ref{sec:verif} describes how we specify a bytecode against
a constraint memory usage policy. 
%infrastructure described in Section~\ref{sec:prelim} can be used to
%specify and verify precise memory consumption
%policies. 
Section~\ref{sec:infer} is devoted to a presentation of our
algorithms for inferring automatically part of the annotations annotations.
 We conclude in Section~\ref{sec:rel} with related work and in Section~\ref{sec:conc}
with directions for future work.

