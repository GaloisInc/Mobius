\subsection{Java class files} \label{classFileFormat}
The standard format for Java bytecode programs is the so-called class
file format which is specified in the Java Virtual Machine
Specification~\cite{JVMspec}. For the purpose of this paper, it is
sufficient to know that class files contain the definition of a single
class or interface, and are structured into a hierarchy of different attributes that
contain information such as the class name, the name of its superclass
or the interfaces it implements, a table of the methods declared in the class. 
Moreover an attribute may contain other attributes. For example the attribute that 
describes a single method contains an \verb!Local_Variable_Table! attribute that describes 
the method parameters and its local variables; further in this section we will denote the 
table of local variables by $l$ and the $i^{th}$ variable by $l[i]$. In addition to these attributes which
provide all the information required by a standard implementation of
the Java Virtual Machine, class files can accommodate user-defined
attributes, which are not used by standard implementations of the Java
Virtual Machine but can be used for other purposes. We take advantage
of this possibility and introduce additional attributes that contain
annotations such as method preconditions and postconditions, variants
and invariants. Annotations are given in the Bytecode Modeling
Language, which we describe below.

\subsection{The  Bytecode Modeling Language}
The bytecode modeling language \annotation\ is a variant of the Java
Modeling Language (JML) \cite{JMLRefMan} tailored to Java bytecode;
the BML specification language is described in~\cite{LM05:acc}. For
our purposes, we only need to consider a restricted fragment of BML,
which is given in Fig.~\ref{fig:bml}; we let $\expression$ and
$\predicate$ denote respectively the set of BML expressions and BML
predicates. As for JML, BML specifications contain different forms of
statements, in the form of BML predicates tagged with appropriate
keywords. BML predicates are built from BML expressions using standard
predicate logic; furthermore BML expressions are bytecode programs
that correspond to effect-free Java expressions, or BML specific
expressions.  The latter include expressions of the form
\verb!\old(exp)! which refers to the value of the expression
\verb!exp! at the beginning of the method, or
$\mbox{\tt exp}^{\mbox{{\tt pc}}}$ which refers to the
value of the expression \verb!expr! at program point
\verb!pc!. Note that the latter is not a standard expression in JML
but can be emulated introducing a ghost variable 
$\mbox{\tt exp}^{\mbox{{\tt pc}}}$ and performing the ghost 
assignment \verb!set exp!$\mbox{}^{\mbox{{\tt pc}}}$\verb!= exp! at
program point \verb!pc!.

Statements can be used for the following purposes:
\begin{itemize}
\item Specifying method preconditions, which following the design by
contract principles, must be satisfied upon method invocation. Such
preconditions are formulated using statements of the form $\requires \
\predicate$;


\item Specifying method postconditions, which following the design by
contract principles, must be guaranteed upon returning normally from the
method. Such postconditions are formulated using statements of the form
$\ensures\ \predicate$;

\item Specifying method exceptional postconditions, which must be
guaranteed upon returning exceptionally from the method. Such
postconditions are formulated using statements of the form \\
$\exsures{Exception} $ $ \predicate$, that record the reason for
exceptional termination;

\item Stating loop invariants, which are predicates that must hold
every time the program enters the loop;

\item Guaranteeing termination of loops and recursive methods, using
statements of the form $\variant\ \expression$ which provide a measure (in
the case of BML a positive number) that strictly decreases at each
iteration of the loop/recursive call;


\item Local assertions, using $\assert \ \predicate$, which asserts
that $\predicate$ holds at the program point immediately after the
assertion;

\item Declaring and updating ghost variables, using statements of the
form $\declare \ \ghost \ Type \ name$ and $ \set \ \expression = \expression$;

\item Keeping track of variables that are modified by a method or in a
loop, using declarations of the form $\modifies \ var$. During the
generation of verification conditions, one checks that variables that
are not declared as modifiable by the clause above will not be
modified during the execution of the method/loop, and one also uses
the information about modified variables to generate the verification
conditions.
\end{itemize}

\begin{figure}
%\begin{frameit}
$$
\begin{array}{lll} 
\mbox{\annotation}-{\sf stmt} & = &
                                       \requires \ \predicate \\
                              & \mid & \ensures  \ \predicate  \\
                           & \mid  & \exsures{Exception} \ \predicate  \\
                               & \mid  &  \assert  \ \predicate  \\
                                & \mid & \invariant \  \predicate  \\
                                & \mid & \variant \  \expression  \\
                                & \mid &  \declare \ \ghost \ Type \ name \\
                                 & \mid & \modifies  \ var  \\
                                 & \mid & \set \ \expression = \expression

\end{array}
$$
\caption{{\sc Specification language}}\label{fig:bml}
%\end{frameit}
\end{figure}

Note that, as alluded in the previous paragraph, annotations are not
inserted directly into bytecode; instead they are gathered into
appropriate user defined attributes of an extended class file. Such
extended class files can be obtained either through direct
manipulation of standard class files, or using an extended compiler
that outputs extended class files from JML annotated programs,
see~\cite{LM05:acc}.

\subsection{Verification of annotated bytecode}
In order to validate annotated Java bytecode programs, we resort to a
verification environment for Java bytecode (described in~\cite{LM05:acc}), which is an adaptation of JACK~\cite{BRL03:fme}. It consists of two main components:

%The environment, which is an adaptation of JACK~\cite{BRL03:fme}, and was developed by L.~Burdy and the second author, see~\cite{LM05:acc}, consists of two main components:

\begin{itemize}
\item A verification condition generator, which takes as input an annotated
applet and generates a set of verification conditions which are sufficient
to guarantee that the applet meets its specification;

\item A proof engine that attempts to discharge the verification
conditions automatically using automatic tools such as B and Simplify,
and then sends the remaining verification conditions to proof assistants
where they can be discharged interactively by the user.  We are
currently generating verification conditions for the proof assistants
Coq~\cite{coq} and PVS~\cite{pvs}.
\end{itemize}


\subsubsection{Generating the Verification Conditions}\label{subsec:verification}
The verification condition generator, or VCGen for short, takes as
input an extended class file and returns as outputs a set of proof
obligations, whose validity guarantees that the program satisfies its
annotations. The VCGen proceeds in a modular fashion in the sense that
it addresses each method separately, and is based on computing weakest
preconditions. More precisely, for every method
$\method$, postcondition $\psi$ that must hold after normal
termination of $\method$, and exceptional postcondition $\psi'$ that
must hold after exceptional termination of $\method$ (for simplicity
we consider only one exception in our informal discussion), the VCGen computes a predicate $\phi$ whose validity at the onset of method
execution guarantees that $\psi$ will hold upon normal termination,
and $\psi'$ will hold upon exceptional termination. The VCGen will
then return several proof obligations that correspond, among other
things, to the fact that the precondition of $\method$ given by the
specification entails the predicate $\phi$ that has been computed, and
to the fact that variants and invariants are correct.


The procedure for computing weakest preconditions is described in
detail in~\cite{LM05:acc}. In a nutshell, one first defines for each
bytecode a predicate transformer that takes as input the
postconditions of the bytecode, i.e. the predicates to be satisfied
upon execution of the bytecode (different predicates can be provided
in case the bytecode is a branching instruction), and returns a
predicate whose validity prior to the execution of bytecode guarantees
the postconditions of the bytecode. The definition of such functions is
completely generic and independent of any program, so the next step is
to use these functions to compute weakest preconditions for programs.
This is done by building the control flow graph of the program, and then
by computing the weakest preconditions of the program using its control
flow graph.

Note that the verification condition generator operates on BML
statements which are built from extended BML expressions. Indeed,
predicate transformers for instructions need to refer to the operand
stack and must therefore consider expressions of the form
\verb!st(top -+ i)! which represent the \verb!st(top -+ i)!-th 
element from the stack top:
$$wp( \store \ l(i) , \psi , \psi') = \psi[\verb!top! \leftarrow \verb!top-1!][l[i] \leftarrow \verb!st(top)!].$$


\subsubsection{Discharging verification conditions}
Verification conditions are expressed in an intermediate language
for which translations to automatic theorem provers and proof
assistants exist.


\subsection{Correctness of the method}\label{subsec:sound}
The verification method is correct in the sense that one can prove
that for all methods $\method$ of the program the postcondition (resp.
exceptional postcondition) of the method holds upon termination (resp.
exceptional termination) of the method provided the method is called
in a state satisfying the method precondition and provided all
verification conditions can be shown to be valid.


The correctness of the verification method is established relative to
an operational semantics that describes the transitions to be taken by
the virtual machine depending upon the state in which the machine is
executed. There are many formalizations of the operational semantics
of the Java Virtual Machine, see
%e.g.~\cite{BSS:jbook,FM03:jar,KN02:tcs,Siveroni:03:JavaCardSemantics}. Such
e.g.~\cite{BSS:jbook,FM03:jar,KN02:tcs,SH01pjo}. Such
semantics manipulate states of the form
$\configMem{h,\fram{m,\pc,l,s},\stf}$,
 where $h$ is the heap of objects,
$\fram{m,\pc,l,s}$ is the current \emph{frame} and $\stf$ is the
current call stack (a list of frames). A frame $\fram{m,\pc,l,s}$
contains a method name $m$ and a program point $\pc$ within $m$, a set
of local variables $l$, and a local operand stack~$s$.
%The rule for the generic instruction \instr\ is formalized as a
The operational semantics for each instruction is formalized as rules specifying
 transition between states, or between a state and some tag that
indicates abnormal termination. For example, the semantics of
 the instruction $\store$ is given by the transition
rule below, where  $\instrAt (m,\pc)$ is the function that extracts
the $\pc$-th instruction from the body of method $\method$.

$$\frac{\begin{array}[c]{c}
\ \instrAt (m,\pc)=\store \ i
\end{array}}%
{\begin{array}[t]{c}
\configMem{h,\fram{m,\pc,l,v::s},\stf} \to_{\store\ i}
\configMem{h,\fram{m,\pc+1,l[i \mapsto v],s},\stf}.
\end{array}}$$
In order to establish the correctness of our method, one first needs
to establish the correctness of the predicate transformer for each
bytecode. For example for the instruction $\store$ we show that:

$$\begin{array}[t]{c} 
wp(\store \ i , \psi )( \configMem{h,\fram{m,\pc,l,v::s},\stf} ) \\ 
\Rightarrow  
\\
\psi( \configMem{h,\fram{m,\pc+1,l[i \mapsto v],s},\stf})
\end{array}$$
In the above $\psi(\configMem{h,\fram{m,\pc,l,v::s},\stf} )$ is to be
understood as the instance of the formula $\psi$ in which all local
variables $l$ and field references are substituted with their
corresponding values in state $\configMem{h,\fram{m,\pc,l,v::s},\stf} $.


The proof proceeds by a case analysis on the instruction to be
executed, and makes an intensive use of auxiliary substitution
lemmas that relate e.g. the stack of the pre-state with the stack
of the post-state of executing an instruction. Then one proves the
correctness of the method by induction on the length of the
execution sequence. We have proved the correctness of our method
for a fragment of the JVM that includes the following constructs:
\begin{itemize}
\item Stack manipulation: \push, \pop, \dup, \dup 2, \swap etc;
\item Arithmetic instructions: \arithOp;
\item Local variables manipulation: type\_\load, type\_\store, etc;
\item Jump instructions: \ifCond, \goto, etc;
\item Object creation and  object manipulation: \new, \putfield, \getfield, \newarray, etc;
\item Array instructions: \arrstore, \arrload, etc;
\item Method calls and return: \invoke, \return, etc;
\item subroutines: \jsr\ and \ret.
\end{itemize}


Note however that our method imposes some mild restrictions on the
structure of programs: for example, we require that $\jsr$ and $\throw$ instructions
are not entry for loops in the control flow graph in order to prevent pathological recursion.
Lifting such restrictions is left for future work.




%\subsubsection{Building the Control Flow Graph}\label{cntrlFlow}
%\input{cntrlFlow}

%\subsubsection{Generating the Verification Conditions}
%\input{verification}

%\subsubsection{Correctness of the method}
%\input{sound}
