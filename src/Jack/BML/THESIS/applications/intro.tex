

In this chapter, we will focus on two applications of our verification 
framework described in the previous chapters.  


The first application that will be presented is how
constraint memory consumption policies can be checked using the
verification scheme. 
The second application is an optimizing native compiler which removes
unnecessary checks for runtime exceptions.
Both of the applications consider practical issues and show that
 formal program verification for bytecode is useful and feasable.
 
