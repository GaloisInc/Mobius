
%\newtheorem{wellDef}{Definition}[section]
\newtheorem{interpretation}{Definition}[section]
\newtheorem{assertLangTh}{Lemma}[section]
%\newtheorem{interpTypeExpr}[interpExpr]{Definition} 
%\newtheorem{interpPred}[interpExpr]{Definition}
%\newtheorem{predicate}[interpExpr]{Definition}


\subsection{Interpretation}\label{interpret}
%
In this section, we shall focus on the semantics of formulas and expressions w.r.t. a state configuration.
A subtle point in giving the evaluation rules for expressions and the interpretation of formulas
is the fact that the evaluation is actually  a partial function. % Note that we shall give a semantics which ignores partiality in the language. Of course, this is an 
%important theoretical question which by itself have given rise to a lot of research and h%as received different answers.
%The part which deserves a more  careful attention is the question of partiality in the language.
What we mean by partiality is the existence of functions like division or dereferencing of a field, array indexing etc. 
To get a precise idea of the problem we can consider the following logical statements: 

$$
\begin{array}{l} 
\numConclusion{1} \  \fieldAccess{\expression}{\fieldd} == 3\\
\numConclusion{2} \ \arrayAccess{\expression_1} {\expression_2} == 5
\end{array}
$$   

Under certain conditions, these formulas may not have a meaning. In case 
\numConclusion{1},  the statement does not make sense in a state where
$\expression$ is a reference which does not belong to the valid references in the heap 
or evaluates to  \Mynull. In case  \numConclusion{2}  the statement does not make sense in 
a state where if either $\expression_1 $ is not a valid reference in the current or is \Mynull{}  or $\expression_2$  is not in the bounds of $\expression_1 $.

Building a logic for partiality is not trivial. Different solutions exist. 
A naive three valued logic, where expressions may be evaluated to a value or  undefined  in a state and
 formulas might be \false{}, \true{} or undefined in a state appear to loose certain nice properties
 which standard logic with equality have
as for instance associativity of equality, the excluded middle \cite{gries95avoiding} etc. 
Gries and Schnieder \cite{gries95avoiding} give a solution which consists in function 
underspecification  and thus  avoid the problem of undefideness. 
 More particularly, their approach considers all functions as total but for argument values for which the function is actually 
not defined the function may return whatever value. 
For instance, using the semantics of underspecification, the formula $\Mynull.\fieldd== \Mynull.\fieldd$  will evaluate to true.
This approach is adopted in JML \cite{JMLRefMan}. However, seeing the expressions in specifications 
as totally defined functions may sometimes lead to unsoundness in program verification.
 Thus,  not all tools supporting JML support the semantics of underspecification. %%%%Reference esc/java 
An alternative is to check specifications for if they are well formed.
 For instance, ESC/java supports well-definedness checks of specifications.

%This approach, although practical requires certain restriction over the definition 
%of recursive functions in order to keep the logic consistent as pointed in \cite{J95PFL}.
% In  \cite{schieder99adapting}, the authors give 
%  an extension  of the calculus of boolean structures proposed by Dijkstra and Scholten (\cite{WPCDS}) with a  third boolean value 
%undefined.  The logical connectives are extended in a non monotonic way and preserve the properties of the classical logic
%on the price  of having two sorts of equality.

In \cite{burdy98treatment}, L. Burdy proposes a three valued logic in which the above features of classical logic are preserved.
He introduces a well-definedness operator $\wellDefined{}: \expression \cup \predWp \rightarrow \predWp$
 over expressions and formulas. Thus, formulas can be either \true{}, \false{} or not defined and
expressions may evaluate to a value or be undefined. The operator  $\wellDefined{\expression}$ ($\wellDefined{\predWp}$) 
 gives the necessary and sufficient
 conditions such that $\expression$(\predWp ) is defined. 
 Particularly, the application of the operator   $\wellDefined{\expression}$  ($\wellDefined{\predWp}$) over $\expression$  (\predWp ) 
 evaluates only either to \true{} or \false{}, i.e.  it holds in a state only if the expression $\expression$ has  a value in this state, otherwise it is interpreted to \false{}.   
  

 This in particular, means that for every formula and its subexpressions additional verification conditions for well-definedness must be generated.
 Thus a formula may hold in a state only under the condition that
 it is  defined, i.e. all the expression contained in the formula should have a meaning in  this state.
  Here, we shall not enter in details of the definition of the well definedness operator  $\wellDefined{}$  but discuss it informally through an example.
   Let us see the definition of  the operator  $\wellDefined{}$   in case of an array access:
$$
\begin{array}{l}
 \wellDefined{ \arrayAccess{\expression_1} {\expression_2} } = 
            \begin{array}{l}
              \wellDefined{\expression_1} \wedge \\
     \wellDefined{\expression_2} \wedge \\
              \expression_1 \neq \Mynull \wedge\\
             0 \le  \expression_2 < \arraylength(\expression_1)
            \end{array} 
 %\\
 %\\
 % \wellDefined{ \locVar{i}} = \validLocVarIndex(i)
 \end{array}
$$

 Thus for an array access to be well formed, we require that its two subexpressions are well formed, that 
 $\expression_1$ denotes a reference in the heap in the current state, that the evaluation of $ \expression_2 $ is a valid index in the array 
 $\expression_1$. %For a local variable access, the well definedness condition is expressed through the predicate  \validLocVarIndex{} whose interpretation is that  the index is a valid index in the array of local registers. 
 
 Although the evaluation of expression is partial, we shall consider only the validity of well defined 
 formulas in a state, i.e. formulas which talk only about well defined expressions in a state. 
 Thus we define interpretation of formulas  in a two valued logic.
 %Well definedness is usually established as we said above by the validity of a formula which expresses that
 %a specification formula or expression is well defined. Those formulas are generated by 
 %a well definedness operator. 
 
 We ignore a lot of formulas, i.e. those which are not well defined,
 this will be sufficient for our proof of correctness of the verification condition generator later in Chapter \ref{proofGeneral} as 
 we assume that programs are bytecode verified and that specifications
 are well defined. Under these assumptions and because the verification condition generator preserves well definedness of formulas, we 
 can perform the correctness proof in Chapter \ref{proofGeneral}.

 We use the notation $\interp{\predWp}{s}$ to say that the well defined
  formula  $\predWp$ is valid w.r.t. a current state
  $s$ and an initial state $s_0$.

The interpretation $\interp{\predWp}{s}$ is defined in the standard way.
 For instance, the statement $\interp{\expression_1 \  \predicates \  \expression_2 }{s}$
 by definition means that the evaluation   $\evalExp{ \expression_1 }{s } $ of $\expression_1$ and the evaluation $\evalExp{ \expression_2 }{s } $ of $\expression_2$
 are in relation $ \predicates$ or written formally that the following holds:
 $\evalExp{ \expression_1 }{s } \ \predicates \ \evalExp{ \expression_2 }{s}$.
 The formal statement   $\interp{\instances(\referenceOnly)}{s}$  by definition means that the reference \referenceOnly{} is part of the heap locations in state s or in other words 
 that the following holds  $\referenceOnly \in s.\heap.\heapLocs $.

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%deprcated%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% In \cite{bijlsma90sqb}, Bijlsma comes up with another solution where the  properties of the logic are preserved but  however compositionality of expression evaluation does not hold anymore.

%In \cite{gries95avoiding}, Gries and Schnieder give another solution to the problem which consists in underspecification 
%and thus  avoiding the special object of undefideness.
% More particularly, their approach considers all functions as total but for some value of the argument 
%the function is not specified. 

%In \cite{schieder99adapting},  B. Schieder and M. Broy give 
%  an extension  of the calculus of boolean structures proposed by Dijkstra and Scholten (\cite{WPCDS}) with a  third boolean value 
%undefined where  the logical connectives are extended in a nonmonotonic way preserves the properties of the classical logic
%on the price  of having two sorts of equality. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%deprcated%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

%In \cite{} \todo{Owe, Lilian}, the authors propose a three valued logic for dealing with partiality by introducing
%a well-definedness operator $\wellDefined{}: \expression \cup \predWp \rightarrow \predWp$ over expressions and formulas. Thus formulas can be either \true{}, \false{} or not defined and
%expressions may evaluate to a value or be undefined. The operator  $\wellDefined{\expression}$ ($\wellDefined{\predWp}$) 
% gives the, necessary and sufficient
% conditions such that $\expression$(\predWp ) is defined.
% More particularly, the application of the operator   $\wellDefined{\expression}$  ($\wellDefined{\predWp}$) over $\expression$  (\predWp ) 
% holds in a state only if the expression $\expression$ has  a value in this state, otherwise it is \false{}. To get a more precise idea of the operator $\wellDefined{}$
%we scatch it hereafter:

 
%\begin{wellDef}[Well defined expressions] \label{wellDef}

%$$
%\begin{array}{l}
%\wellDefined{v} = \My\true{} \\
%\\
%\wellDefined{\fieldd(\expression )} =\wellDefined{\expression} \wedge  \expression \neq \Mynull \\
%\\
%\wellDefined{ \arrayAccess{\expression_1} {\expression_2}   } = 
%           \begin{array}{l}
%             \expression_1 \neq \Mynull \wedge\\
%            0 \le  \expression_2 < \arraylength(\expression_1)
%           \end{array} \\
%
%\wellDefined{\predWp_1 \wedge \predWp_2} =  \begin{array}{l} 
%                                                     \wellDefined{\predWp_1} \wedge  \wellDefined{\predWp_2} \wedge \\
%                                                     
%                                          
%                                       
%                                            \end{array} \\                                                
%\ldots 
%\end{array}
%$$ 

 
We define a function for expression evaluation
 which evaluates expressions in a state and which has the following signature:
%\rightharpoonup
$$
\evalExpName : \expression \rightarrow \SetConfigs  \rightarrow \SetConfigs  \rightharpoonup  \Values \cup \JavaType
$$
The evaluation function   takes  an expression of the assertion language presented in the previous Section 
\ref{assertLang:lang} and a state (see Section \ref{def} for the definition of state)  and returns a value or a class type
(see Section \ref{types} for the definition of values and types in the language). 


\begin{interpretation}[Evaluation of expressions] \label{interpExpr} 
The evaluation in a state 
$s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$  or $s = \configFinal{\heap}{\Final }$  of an expression $\expression$
w.r.t. an initial state $ s_{0} = \config{\heap_{0}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $ 
is denoted with $\evalExp{\expression}{s}$  and is defined in its domain inductively over  the grammar of expressions $\expression$ \  as follows:
 
$$
\begin{array}{lll}
\evalExp{ v  }{s } & = & v\\
  where \  v \in \  \Myint   \ \vee  \  v \in  \RefValues \\

 \evalExp{\fieldAccess{\expression}{\fieldd  } ) }{s} & = & \heap(\fieldd) (\evalExp{ \expression}{ s } ) \\


 \evalExp{ \fieldAccess{ \expression_3}{\update{\fieldd}{\expression_1}{\expression_2} }}{ s } & = &
\update{\heap}{\fieldd }{\update{\fieldd}{  \evalExp{\expression_1}{s } }{ \evalExp{\expression_2}{s }  }} (\fieldd)
                                            (  \evalExp{\expression_3}{ s } ) \\



 \evalExp{\arrayAccess{\expression_1} {\expression_2}  }{ s } & = & 
  \heap (\evalExp{ \expression_1}{ s } ,\evalExp{ \expression_2}{ s } )   \\

 \evalExp{ \update{ \arrayAccessOnly}{ (\expression_1 , \expression_2)}{ \expression_3} (\expression_4,\expression_5)  } { s } & =&
  \update{\heap}{ ( \evalExp{\expression_1}{s } ,  \evalExp{\expression_2}{s } ) }  
                 { \evalExp{\expression_3}{s }} 
                 ( \evalExp{\expression_4}{s } ,  \evalExp{\expression_5}{ s  } ) \\

 \evalExp{ \locVar{i} } { s } & =  &\locVarOnly(i) \\


% \evalExp{ \old{\expression} } { s } &  = & \evalExp{ \expression }{  s_{0}} \\

 \evalExp{\expression_1 \ \op \ \expression_2   } { s } &  =  &  \evalExp{\expression_1}{s} \op  \evalExp{\expression_2}{s}  \\


\evalExp{ \typeof{\expression}}{s } & = &
\left\{\begin{array}{ll}
      \Myint                                           & \evalExp{\expression}{s} \in \Myint \\
      \heapTypeOf(\evalExp{\expression}{s} ) & else \\
           
\end{array}\right. \\


\evalExp{ \elemtype{\expression}}{s } & = &
\begin{array}{ll}
            \mbox{ \rm \texttt{T} }  & where \   \heapTypeOf(\evalExp{\expression}{s} ) = \mbox{ \rm \texttt{T[ ] } } 
\end{array}\\


\evalExp{ \TYPE }{s } & =  & \mbox{ \rm \texttt{java.lang.Class}} 
\end{array}
$$

The evaluation of stack expressions can be done only in intermediate state configurations $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ :
$$
\begin{array}{lll}
 \evalExp{ \counter   } { s } & =  & \counterOnly \\


 \evalExp{ \stack{ \expression}   } { s } &  = & \stackOnly ( \evalExp{\expression}{s} ) \\


\end{array}
$$
The evaluation of the following expressions can be done only in a final state:
$$
\begin{array}{ll}
\evalExp{ \result }{s } = \Res  & where \ s=  \configFinalNorm{\heap}{\Res} \\
\evalExp{ \EXC }{s } = \Exc  & where \ s=  \configFinalExc{\heap}{\Exc}
\end{array}
$$
  \end{interpretation}

% The definition is standard, except that we evaluate w.r.t. to two states, an initial and a final state. Actually, the unique non standard
% case is the evaluation of an old expression ( $\old{\expression}$) where $\expression$ is evaluated in the initial state.
% We can actually make a more general conclusion, i.e.\ if an expression ( formula) does not contain old subexpressions then the initial state does not
% matter for the evaluation of expressions or the validity in a state of a formula.

 
%\begin{assertLangTh}\label{assert:interp:oldExp}
%Let $\expression$ be an expression which does not contain subexpressions of the form $\old{\expression'}$.
%Then for any two initial states $s_0, s'_0$, the evaluation of $\expression$ in the state $s$ 
%is the  same:
%$$ \evalExpStates{ \expression }{s_0 }{s} = \evalExpStates{ \expression }{s'_0 }{s} $$
%\end{assertLangTh}
%The proof is by induction over the expression structure. 
%%
%\begin{assertLangTh}\label{assert:interp:oldExp}
%Let $\psi$ be a formula which does not contain subexpressions of the form $\old{\expression'}$.
%Then for any two initial states $s_0, s'_0$, the interpretation of  of $\psi$ in the state $s$ 
%is the  same:
%$$ \interpSpecTwoStates{ \psi }{s_0 }{s} \Leftrightarrow  \interpSpecTwoStates { \psi }{s'_0 }{s} $$
%\end{assertLangTh}



% Thus, for instance the evaluation  $\evalExp{ \fieldAccess{\locVar{1}}{\fieldd}  }{s}$ of the expression $ \fieldAccess{\locVar{1}}{\fieldd} $  in the
% state $s =\config{\heap}{\counterOnly}{ \stackOnly }{\locVar{1} \rightarrow \Mynull  }{\pc } $ is not defined.



% Note that the interpretation of 
%  $\wellDefined{\expression}$($\wellDefined{\predWp}$) cannot be undefined, it is either \true{} or \false{}.
%As we shall see, the relation  $\vDash$  interprets formulas to the $\true{}$ value under the condition
%is well -defined in the sense of the operator $\wellDefined{}$
%$$ \vDash :  \SetConfigs *  \predWp  $$
%In the following, we shall define an evaluation function $\evalPredName$ with signature: 
%$$\evalPredName :\predWp \rightarrow \SetConfigs  \rightarrow \SetConfigs  \rightharpoonup  \true \cup \false $$
%As we can see from its signature, the predicate evaluation will project predicates from  our assertion language 
%into boolean values. Because the predicate evaluation depends on the expression evaluation, the function for predicate 
%evaluation is also partial. This intuitively means that as far as the predicate contains undefined expressions
%%it cannot be said if it is \true{} or \false. 

%\begin{interpretation}[Evaluation of predicates in a state] \label{interpPred} 
%The evaluation $ s\evalPred{\predWp}{s} $ of a predicate $\predWp$ in a state configuration $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ 
%w.r.t. an initial state  $ s_{0} = \config{\heap_{0}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $ is defined inductively as follows:
%$$
%\begin{array}{lll}
%\evalPred{\Mytrue}{s} &  = & \true \\
%
%\evalPred{\Myfalse}{s} & = & \false \\
%
%%\evalPred{  \neg \ \predWp  }{s} & = & \left\{ \begin{array}{ll} 
%                                                 \true   &  if  \ \evalPred{\predWp}{s} = \false \\
%                                                \false  &  if  \ \evalPred{\predWp}{s} = \true \\
%%                                               \bottom &  else
%                                  \end{array}\right. 
%\\
%%
%\evalPred{\predWp_1  \wedge  \predWp_2 }{s} & = &   \left\{ \begin{array}{ll} 
%                                                              \true  &  if  \ \evalPred{\predWp_1}{s} =\true \  and  \  \evalPred{\predWp_2}{s} = \true  \\
%                                                             \false &  if  \ \evalPred{\predWp_1}{s} =\false \ or   \  \evalPred{\predWp_2}{s} = \false \\
%                                                             \bottom & else
%                                                  \end{array}\right.\\
%
%
%\evalPred{\predWp_1  \vee  \predWp_2 }{s} & = &  \left\{ \begin{array}{ll} 
%                                                            \true  &  if \ \evalPred{\predWp_1}{s} = \true \   or   \    \evalPred{\predWp_2}{s} = \true  \\
%                                                           \false &  if  \ \evalPred{\predWp_1}{s} =\false \  and   \  \evalPred{\predWp_2}{s} = \false \\
%                                                           \bottom & else
%                                            \end{array}\right.   \\
%%
%\evalPred{\predWp_1  \Rightarrow  \predWp_2 }{s} & = & \left\{ \begin{array}{ll} 
%                                                                 \true   &  if \  \evalPred{\predWp_1}{s} = \false \ or  \ \evalPred{\predWp_2}{s}  = \true \\
%                                                                \false  &  if \  \evalPred{\predWp_1}{s} =  \true \ and  \ \evalPred{\predWp_2}{s}  = \false \\
%                                                                \bottom &  else
%                                                        \end{array}\right.\\
%
%\evalPred{\forall x  :T. \predWp(x)   }{s} & = & \left\{ \begin{array}{ll} 
%                                                           \true   & if   \ \forall \mbox{ \rm \textbf{v}} \ of \ type \ T \  \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \true    \\
%                                                          \false  & if   \ \exists \mbox{ \rm \textbf{v}} \ of \ type \ T \  \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \false \\
%                                                          \bottom & else
%                                                  \end{array}\right.   \\
%
%
%\evalPred{\exists x .  \predWp(x)   }{s} & = & \left\{ \begin{array}{ll} 
%%                                                         \true  & if \ \exists \mbox{ \rm \textbf{v}} \ \in \Values  \ of \ type \ T  \\
%                                                                & \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \true \\
%                                                        \false & if \ \forall \mbox{ \rm \textbf{v}} \ \in \Values  \ of \ type \ T \\
 %                                                               & \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \false \\
%                                                        \bottom & else
%                                           \end{array}\right.   \\
%                                          
%
%\evalPred{\expression_1 \  \predicates \  \expression_2 }{s} & = & 
%%                    \left\{ \begin{array}{ll} 
%                           \evalExp{\expression_1 }{s} \predicates \evalExp{\expression_2 }{s}  & \evalExp{\expression_1}{s} \neq \bottom \ and  \  \evalExp{\expression_2}{s} \neq \bottom\\
%                           \bottom & else
%                   \end{array}\right.   \\                                                 
%
%
%\evalPred{\instances(\referenceOnly) }{s} & = &   \referenceOnly \in \heap.\heapLocs
%\end{array}
%$$   
%\end{interpretation}


  

% We now turn to define what means for a formula  to hold  in a given state.
%The relation $\vDash$ that we define next, gives a meaning to the formulas from our
% assertion language $\predWp$ w.r.t. two state configurations - a current state and an initial state. 
%In particular, we say that a predicate holds in a state if under the condition that its evaluation in this states
%is defined then  it evaluates to the true boolean value. 


%\begin{interpretation}[A predicate holds in a state] \label{interpPred}
%We say that the predicate $\predWp$  holds  in the state $s$  w.r.t. an initial state $s_0$, if the following holds
%$$   \interp{\predWp}{s} =^{def} \evalPred{\predWp}{s}  \neq  \bottom  \ and \  \evalPred{\predWp}{s} = \phi  \ then \ \phi = \true    $$ 
%
%\end{interpretation}

%Let us return to our initial examples. The interpretation $\interp{\fieldAccess{\locVar{1}}{\fieldd} ==~3}{s}$
% of the predicate $\fieldAccess{\locVar{1}}{\fieldd} ==~3$ in a state  $s =\config{\heap}{\counterOnly}{ \stackOnly }{\locVar{1} \rightarrow \Mynull  }{\pc } $ 
%is \true{} following the above definition. Note that its negation  $\interp{\neg (\fieldAccess{\locVar{1} }{\fieldd} ==~3}{s}$
%is also \true. This follows from the above definition for evaluation of formulas and the fact that
% $ \evalExp{\fieldAccess{\locVar{1}{\fieldd}  }}{ s}  $ is not defined.
% It also follows from the definition that the negation of the statement $ \neg \interp{\fieldAccess{\locVar{1} }{\fieldd} == 3 }{s}$ is \false. 
%Note also, that in this interpretation, for any two states $s_0, s$ we have that $ \interp{1/0 = 1/0}{s}$ holds. 



% Note that the upper definition interprets atomic formulas in  states $s$ and $s_0$, i.e. formulas which 
%represent relations between expressions, as \true only if the evaluation of these expressions is defined
%in $s$ and $s_0$. However, the interpretation of the logical connectors is standard.
 

The next definition introduces the notion of an assertion formula logically valid 
in every program state. We call such formulas  valid formulas. 

\begin{interpretation}[Valid formulas]\label{assertLang:interpretation:valid}
  We say that the formula  $ \predWp $ a valid formula if forall states $s$  $\interp{\predWp}{s}{s}$. 
We note this with  $\validFormula{\predWp}$ 
\end{interpretation}
