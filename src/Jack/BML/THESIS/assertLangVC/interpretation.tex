
%\newtheorem{wellDef}{Definition}[section]
\newtheorem{interpretation}{Definition}[section]
%\newtheorem{interpTypeExpr}[interpExpr]{Definition} 
%\newtheorem{interpPred}[interpExpr]{Definition}
%\newtheorem{predicate}[interpExpr]{Definition}


\subsection{Interpretation}\label{interpret}
%
In this section, we shall focus on the semantics of formulas and expressions w.r.t. a state configuration.
A subtle point in giving the evaluation rules for expressions and the interpretation of formulas
is the fact that the evaluation is actually  a partial function.% Note that we shall give a semantics which ignores partiality in the language. Of course, this is an 
%important theoretical question which by itself have given rise to a lot of research and h%as received different answers.
%The part which deserves a more  careful attention is the question of partiality in the language.
What we mean by partiality is the existence of functions like division or dereferencing of a field, array indexing etc. 
To get a precise idea of the problem we can consider the following logical statements: 

$$
\begin{array}{l} 
\numConclusion{1} \  \fieldAccess{\expression}{\fieldd} == 3\\
\numConclusion{2} \ \arrayAccess{\expression_1} {\expression_2} == 5
\end{array}
$$   

Under certain conditions, these formulas may not have a meaning. In case 
\numConclusion{1}  the statement does not make sense if
$\exprWp$ is \Mynull. In case  \numConclusion{2}  the statement does not make sense if 
either $\expression_1 $ is \Mynull{} or $\expression_2$  is not in the bounds of $\expression_1 $.


Building a logic for partiality is not a trivial task. A naive three valued logic, where expressions may be evaluated to a value or  undefined  in a state and
 formulas might be \false{}, \true{} or undefined in a state appear to loose certain nice properties
 which standard logic with equality have
as for instance associativity of equality, the excluded middle \cite{gries95avoiding} etc. In \cite{schieder99adapting},  the authors give 
  an extension  of the calculus of boolean structures proposed by Dijkstra and Scholten (\cite{WPCDS}) with a  third boolean value 
undefined.  The logical connectives are extended in a non monotonic way and preserve the properties of the classical logic
on the price  of having two sorts of equality.
Another solution is to use well-definedness operators as in \cite{burdy98treatment}.
There, the author proposes a three valued logic in which the above features of classical logic are preserved.
He introduces a well-definedness operator $\wellDefined{}: \expression \cup \predWp \rightarrow \predWp$
 over expressions and formulas. Thus, formulas can be either \true{}, \false{} or not defined and
expressions may evaluate to a value or be undefined. The operator  $\wellDefined{\expression}$ ($\wellDefined{\predWp}$) 
 gives the necessary and sufficient
 conditions such that an expression $\expression$ or a predicate \predWp{} are defined.
 More particularly, the application of the operator   $\wellDefined{\expression}$  ($\wellDefined{\predWp}$) over $\expression$  (\predWp ) 
 holds in a state only if the expression $\expression$ has  a value in this state, otherwise it is interpreted to \false{}.
 This in particular, means that for every formula and its subexpressions additional verification conditions for well-definedness must be generated.
 In the following, we define interpretation of formulas  in a two valued logic. However, a formula may hold in a state only under the condition that
 it is  defined, i.e. all the expression contained in the formula should have a meaning in  this state.
 
 Here, we shall use a two valued interpretation, which avoids the undefinedness
by underspecification and which was proposed by Gries and Schnieder   in \cite{gries95avoiding}.
 Their approach consists in function underspecification, which means that
 all functions are considered  as total but for argument values for which the function is actually 
not defined the function may return whatever value. For instance, using underspecification, the value of the function application  $1/0$  
may have whatever value. The same happens for the expression $\fieldAccess{\Mynull}{\fieldd}$ where the function $\fieldd$ is underspecified for 
the value $\Mynull$. In the settings of underspecification, the definition of validity of formulas is slightly different from the standard
definition where functions are total.  In particular, if a formula \predWp{} contains an expression which is undefined
then the formula must be valid for every value that can be assigned to the undefined expression.

 We use the notation $\interp{\predWp}{s}$ to say that the formula  $\predWp$ is valid w.r.t.
 a current state  $s$ and an initial state $s_0$. 
% Let us see the meaning  of a formula \predWp{} which contains underspecified expression $\expression{}$
% in  state $s$ and w.r.t. initial state $s_0$:
% $$if \ \expression \ is \ underspecified \ then \  \interp{\predWp(\expression)}{s} \ holds \ if \ and \ only \ if \ \interp{  \forall x, \predWp(\expression)\subst{\expression}{x}  }{s}$$
 For the cases when \predWp{} does not have undefined subexpressions,
 $\interp{\predWp}{s}$ is defined in the standard way.  
For instance, the statement $\interp{\expression_1 \  \predicates \  \expression_2 }{s}$
 by definition means that the evaluation   $\evalExp{ \expression_1 }{s } $ of $\expression_1$ and the evaluation $\evalExp{ \expression_2 }{s } $ of $\expression_2$
 are in relation $ \predicates$ or written formally that the following holds:
 $\evalExp{ \expression_1 }{s } \ \predicates \ \evalExp{ \expression_2 }{s}$.
 The formal statement   $\interp{\instances(\referenceOnly)}{s}$  by definition means that the reference \referenceOnly{} is part of the heap locations in state s or in other words 
 that the following holds  $\referenceOnly \in s.\heap.\heapLocs $.
By using such a semantics, our examples above are false in any state.


This approach, although practical imposes restrictions on  the definition 
of recursive functions in order to keep the logic consistent as pointed in \cite{J95PFL}.
In the literature, the common example is the factorial function which if defined recursively 
as follows \textit{ fact(i) = if \ i = 0 \ else  fact(i - 1)*i }   allows to conclude that $ fact(-1) = -fact(-2) $. However,
in \cite{gries95avoiding}, the authors point out that the reason for it is the function definition as it overspecifies  the function for negative integers.
The correct definition of factorial using underspecification would be: $ fact(0) = 1; \forall i > 0, fact(i) = i*fact(i - 1) $.
In our formalization, recursive functions are not a major issue as our assertion language does not handle recursive functions. 


% Here, we shall not enter into these problems. Although the evaluation of expression is partial, we shall consider only the validity of well defined 
% formulas in a state, i.e. formulas which talk only about defined expressions in a state.
% Thus, we will avoid the treatment of partiality. In particular, we will remain in 
% a classical two valued logic. 
% Thus, we ignore a lot of formulas, i.e. those which are not well defined in a state, but howevrer
% this will be sufficient for our proof of correctness of the verification condition generator later in Chapter \ref{proofGeneral}.
% This is because we will assume that the specifications are well defined formulas and second, because  
% the verification condition generator preserves well definedness of formulas. 




 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%deprcated%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% In \cite{bijlsma90sqb}, Bijlsma comes up with another solution where the  properties of the logic are preserved but  however compositionality of expression evaluation does not hold anymore.

%In \cite{gries95avoiding}, Gries and Schnieder give another solution to the problem which consists in underspecification 
%and thus  avoiding the special object of undefideness.
% More particularly, their approach considers all functions as total but for some value of the argument 
%the function is not specified. 

%In \cite{schieder99adapting},  B. Schieder and M. Broy give 
%  an extension  of the calculus of boolean structures proposed by Dijkstra and Scholten (\cite{WPCDS}) with a  third boolean value 
%undefined where  the logical connectives are extended in a nonmonotonic way preserves the properties of the classical logic
%on the price  of having two sorts of equality. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%deprcated%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

%In \cite{} \todo{Owe, Lilian}, the authors propose a three valued logic for dealing with partiality by introducing
%a well-definedness operator $\wellDefined{}: \expression \cup \predWp \rightarrow \predWp$ over expressions and formulas. Thus formulas can be either \true{}, \false{} or not defined and
%expressions may evaluate to a value or be undefined. The operator  $\wellDefined{\expression}$ ($\wellDefined{\predWp}$) 
% gives the, necessary and sufficient
% conditions such that $\expression$(\predWp ) is defined.
% More particularly, the application of the operator   $\wellDefined{\expression}$  ($\wellDefined{\predWp}$) over $\expression$  (\predWp ) 
% holds in a state only if the expression $\expression$ has  a value in this state, otherwise it is \false{}. To get a more precise idea of the operator $\wellDefined{}$
%we scatch it hereafter:

 
%\begin{wellDef}[Well defined expressions] \label{wellDef}

%$$
%\begin{array}{l}
%\wellDefined{v} = \My\true{} \\
%\\
%\wellDefined{\fieldd(\expression )} =\wellDefined{\expression} \wedge  \expression \neq \Mynull \\
%\\
%\wellDefined{ \arrayAccess{\expression_1} {\expression_2}   } = 
%           \begin{array}{l}
%             \expression_1 \neq \Mynull \wedge\\
%	     0 \le  \expression_2 < \arraylength(\expression_1)
%           \end{array} \\
%
%\wellDefined{\predWp_1 \wedge \predWp_2} =  \begin{array}{l} 
%                                                     \wellDefined{\predWp_1} \wedge  \wellDefined{\predWp_2} \wedge \\
%                                                     
%                                          
%                                       
%                                            \end{array} \\                                                
%\ldots 
%\end{array}
%$$ 

 
We define the underspecified expression evaluation function 
 $\evalExpName$ which evaluates expressions in a state and which has the following signature:
%\righthrpoonup
$$
\evalExpName : \expression \rightarrow \SetConfigs  \rightarrow \SetConfigs    \rightarrow \Values \cup \JavaType \cup Var
$$
The evaluation function  takes as arguments an expression of the assertion language presented in the previous Section 
\ref{assertLang:lang} and two states (see Section \ref{def} for the definition of state)  and returns a value, a class type
(see Section \ref{types} for the definition of values and types in the language) or a variable in case of underspecification 
which shows that the evaluation can be whatever value. 
The evaluation of constant $v$ which can be $\Myint$   or  $\RefValues$, is itself $\evalExp{ v  }{s } = v $.
Let us see the definition of the function for 
field access expressions is the following:
$$
  \evalExp{\fieldAccess{\expression}{\fieldd  }  }{s}  =  
 \left\{\begin{array}{ll}
   var_{\scriptsize{ \fieldAccess{\expression}{\fieldd  }}  }         & if \  \evalExp{ \expression}{ s }  \notin \Dom(\heap(\fieldd)) \\
                                                        & \\
  \heap(\fieldd) (\evalExp{ \expression}{ s } )         & else
\end{array}\right.$$

We can see that if the evaluation $\evalExp{ \expression}{ s } $ is in the domain of the function representing the field \fieldd{},
(i.e.  $\evalExp{ \expression}{ s } $ is different from \Mynull{}, evaluates to a reference in the heap),  
then the evaluation of the field access expression evaluates to the application of the value  $\evalExp{ \expression}{ s } $ to
the function  $\heap(\fieldd)$. However, if  $\evalExp{ \expression}{ s } $ is not in the domain of \fieldd{} then the 
evaluation of the field access expression is  the  variable $var_{\scriptsize{ \fieldAccess{\expression}{\fieldd}}  }$.


For instance, if we have the formula $a.\fieldd = 3$ and the  state $s$ and an initial state $s_0$
 such that $\evalExp{a}{s} = \Mynull$ then the formula interpretation in $ s$  will be 
$var_{\scriptsize{ a.\fieldd}} = 3  $. Because $var_{\scriptsize{ a.\fieldd}} $ is a free variable, we have implicitely an universal
 quantification over it, i.e. the latter is the same as  $   \forall var_{a.\fieldd}, var_{\scriptsize{ a.\fieldd}} = 3 $ which is false.
The interpretation of the formula  $a.\fieldd = a.\fieldd $  in the same state $s$  is 
$var_{\scriptsize{ a.\fieldd}} =var_{\scriptsize{ a.\fieldd}}   $ which is actually true.


%Thus, for instance the evaluation  $\evalExp{ \fieldAccess{\locVar{1}}{\fieldd}  }{s}$ of the expression $ \fieldAccess{\locVar{1}}{\fieldd} $  in the
% state $s =\config{\heap}{\counterOnly}{ \stackOnly }{\locVar{1} \rightarrow \Mynull  }{\pc } $ is not defined.



% Note that the interpretation of 
%  $\wellDefined{\expression}$($\wellDefined{\predWp}$) cannot be undefined, it is either \true{} or \false{}.
%As we shall see, the relation  $\vDash$  interprets formulas to the $\true{}$ value under the condition
%is well -defined in the sense of the operator $\wellDefined{}$
%$$ \vDash :  \SetConfigs *  \predWp  $$
%In the following, we shall define an evaluation function $\evalPredName$ with signature: 
%$$\evalPredName :\predWp \rightarrow \SetConfigs  \rightarrow \SetConfigs  \rightharpoonup  \true \cup \false $$
%As we can see from its signature, the predicate evaluation will project predicates from  our assertion language 
%into boolean values. Because the predicate evaluation depends on the expression evaluation, the function for predicate 
%evaluation is also partial. This intuitively means that as far as the predicate contains undefined expressions
%%it cannot be said if it is \true{} or \false. 

%\begin{interpretation}[Evaluation of predicates in a state] \label{interpPred} 
%The evaluation $ s\evalPred{\predWp}{s} $ of a predicate $\predWp$ in a state configuration $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ 
%w.r.t. an initial state  $ s_{0} = \config{\heap_{0}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $ is defined inductively as follows:
%$$
%\begin{array}{lll}
%\evalPred{\Mytrue}{s} &  = & \true \\
%
%\evalPred{\Myfalse}{s} & = & \false \\
%
%%\evalPred{  \neg \ \predWp  }{s} & = & \left\{ \begin{array}{ll} 
%                                                 \true   &  if  \ \evalPred{\predWp}{s} = \false \\
%						 \false  &  if  \ \evalPred{\predWp}{s} = \true \\
%%						 \bottom &  else
%				   \end{array}\right. 
%\\
%%
%\evalPred{\predWp_1  \wedge  \predWp_2 }{s} & = &   \left\{ \begin{array}{ll} 
%                                                              \true  &  if  \ \evalPred{\predWp_1}{s} =\true \  and  \  \evalPred{\predWp_2}{s} = \true  \\
%							      \false &  if  \ \evalPred{\predWp_1}{s} =\false \ or   \  \evalPred{\predWp_2}{s} = \false \\
%							      \bottom & else
%						   \end{array}\right.\\
%
%
%\evalPred{\predWp_1  \vee  \predWp_2 }{s} & = &  \left\{ \begin{array}{ll} 
%                                                            \true   &  if \ \evalPred{\predWp_1}{s} = \true \   or   \    \evalPred{\predWp_2}{s} = \true  \\
%							     \false  &  if  \ \evalPred{\predWp_1}{s} =\false \  and   \  \evalPred{\predWp_2}{s} = \false \\
%							     \bottom & else
%					     \end{array}\right.   \\
%%
%\evalPred{\predWp_1  \Rightarrow  \predWp_2 }{s} & = & \left\{ \begin{array}{ll} 
%                                                                 \true   &  if \  \evalPred{\predWp_1}{s} = \false \ or  \ \evalPred{\predWp_2}{s}  = \true \\
%								 \false  &  if \  \evalPred{\predWp_1}{s} =  \true \ and  \ \evalPred{\predWp_2}{s}  = \false \\
%								 \bottom &  else
%                                                        \end{array}\right.\\
%
%\evalPred{\forall x  :T. \predWp(x)   }{s} & = & \left\{ \begin{array}{ll} 
%                                                           \true   & if   \ \forall \mbox{ \rm \textbf{v}} \ of \ type \ T \  \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \true    \\
%							   \false  & if   \ \exists \mbox{ \rm \textbf{v}} \ of \ type \ T \  \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \false \\
%							   \bottom & else
%						   \end{array}\right.   \\
%
%
%\evalPred{\exists x .  \predWp(x)   }{s} & = & \left\{ \begin{array}{ll} 
%%                                                         \true  & if \ \exists \mbox{ \rm \textbf{v}} \ \in \Values  \ of \ type \ T  \\
%                                                                & \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \true \\
%							 \false & if \ \forall \mbox{ \rm \textbf{v}} \ \in \Values  \ of \ type \ T \\
 %                                                               & \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \false \\
%							 \bottom & else
%                                           \end{array}\right.   \\
%                                          
%
%\evalPred{\expression_1 \  \predicates \  \expression_2 }{s} & = & 
%%                    \left\{ \begin{array}{ll} 
%                           \evalExp{\expression_1 }{s} \predicates \evalExp{\expression_2 }{s}  & \evalExp{\expression_1}{s} \neq \bottom \ and  \  \evalExp{\expression_2}{s} \neq \bottom\\
%			    \bottom & else
%		    \end{array}\right.   \\						    
%
%
%\evalPred{\instances(\referenceOnly) }{s} & = &   \referenceOnly \in \heap.\heapLocs
%\end{array}
%$$   
%\end{interpretation}


  

% We now turn to define what means for a formula  to hold  in a given state.
%The relation $\vDash$ that we define next, gives a meaning to the formulas from our
% assertion language $\predWp$ w.r.t. two state configurations - a current state and an initial state. 
%In particular, we say that a predicate holds in a state if under the condition that its evaluation in this states
%is defined then  it evaluates to the true boolean value. 


%\begin{interpretation}[A predicate holds in a state] \label{interpPred}
%We say that the predicate $\predWp$  holds  in the state $s$  w.r.t. an initial state $s_0$, if the following holds
%$$   \interp{\predWp}{s} =^{def} \evalPred{\predWp}{s}  \neq  \bottom  \ and \  \evalPred{\predWp}{s} = \phi  \ then \ \phi = \true    $$ 
%
%\end{interpretation}

%Let us return to our initial examples. The interpretation $\interp{\fieldAccess{\locVar{1}}{\fieldd} ==~3}{s}$
% of the predicate $\fieldAccess{\locVar{1}}{\fieldd} ==~3$ in a state  $s =\config{\heap}{\counterOnly}{ \stackOnly }{\locVar{1} \rightarrow \Mynull  }{\pc } $ 
%is \true{} following the above definition. Note that its negation  $\interp{\neg (\fieldAccess{\locVar{1} }{\fieldd} ==~3}{s}$
%is also \true. This follows from the above definition for evaluation of formulas and the fact that
% $ \evalExp{\fieldAccess{\locVar{1}{\fieldd}  }}{ s}  $ is not defined.
% It also follows from the definition that the negation of the statement $ \neg \interp{\fieldAccess{\locVar{1} }{\fieldd} == 3 }{s}$ is \false. 
%Note also, that in this interpretation, for any two states $s_0, s$ we have that $ \interp{1/0 = 1/0}{s}$ holds. 



% Note that the upper definition interprets atomic formulas in  states $s$ and $s_0$, i.e. formulas which 
%represent relations between expressions, as \true only if the evaluation of these expressions is defined
%in $s$ and $s_0$. However, the interpretation of the logical connectors is standard.
 
Finally, we identify  a particular set of assertion formulas which  hold in every program state. We call them  valid formulas. 
\begin{interpretation}[Valid formulas]\label{assertLang:interpretation:valid}
  If an assertion formula  $ \predWp $ holds in any current state and any initial state, i.e.
$\forall s, s_{0}, \  \interp{\predWp}{s} $ we say that this is a valid formula and we note it with :
  $\validFormula{\predWp} $ 
\end{interpretation}
