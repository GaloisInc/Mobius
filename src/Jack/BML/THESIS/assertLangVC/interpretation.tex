
%\newtheorem{wellDef}{Definition}[section]
\newtheorem{interpretation}{Definition}[section]
%\newtheorem{interpTypeExpr}[interpExpr]{Definition} 
%\newtheorem{interpPred}[interpExpr]{Definition}
%\newtheorem{predicate}[interpExpr]{Definition}


\subsection{Interpretation}\label{interpret}
%
In this section, we shall focus on the semantics of formulas and expressions w.r.t. a state configuration.
A subtle point in giving the evaluation rules for expressions and the interpretation of formulas
is the fact that the evaluation is actually  a partial function.% Note that we shall give a semantics which ignores partiality in the language. Of course, this is an 
%important theoretical question which by itself have given rise to a lot of research and h%as received different answers.
%The part which deserves a more  careful attention is the question of partiality in the language.
What we mean by partiality is the existence of functions like division or dereferencing of a field, array indexing etc. 
To get a precise idea of the problem we can consider the following logical statements: 

$$
\begin{array}{l} 
\numConclusion{1} \  \fieldAccess{\exprWp}{\fieldd} == 3\\
\numConclusion{2} \ \arrayAccess{\expression_1} {\expression_2} == 5
\end{array}
$$   

Under certain conditions, these formulas may not have a meaning. In case 
\numConclusion{1}  the statement does not make sense if
$\exprWp$ is \Mynull. In case  \numConclusion{2}  the statement does not make sense if 
either $\expression_1 $ is \Mynull{} or $\expression_2$  is not in the bounds of $\expression_1 $.


Building a logic for partiality is not trivial. Different solutions exist. 
Gries and Schnieder \cite{gries95avoiding} give a solution to the problem which consists in function 
underspecification  and thus  avoid the problem of undefideness.
 More particularly, their approach considers all functions as total but for argument values for which the function is actually 
not defined the function may return whatever value. This approach, although practical requires certain restriction over the definition 
of recursive functions in order to keep the logic consistent as pointed in \cite{J95PFL}. In  \cite{schieder99adapting}, the authors give 
  an extension  of the calculus of boolean structures proposed by Dijkstra and Scholten (\cite{WPCDS}) with a  third boolean value 
undefined.  The logical connectives are extended in a non monotonic way and preserve the properties of the classical logic
on the price  of having two sorts of equality.
A naive three valued logic, where expressions may be evaluated to a value or  undefined  in a state and
 formulas might be \false{}, \true{} or undefined in a state appear to loose certain nice properties
 which standard logic with equality have
as for instance associativity of equality, the excluded middle \cite{gries95avoiding} etc. 
In \cite{burdy98treatment}, L. Burdy proposes a three valued logic in which the above features of classical logic are preserved.
He introduces a well-definedness operator $\wellDefined{}: \expression \cup \predWp \rightarrow \predWp$
 over expressions and formulas. Thus, formulas can be either \true{}, \false{} or not defined and
expressions may evaluate to a value or be undefined. The operator  $\wellDefined{\expression}$ ($\wellDefined{\predWp}$) 
 gives the necessary and sufficient
 conditions such that $\expression$(\predWp ) is defined.
 More particularly, the application of the operator   $\wellDefined{\expression}$  ($\wellDefined{\predWp}$) over $\expression$  (\predWp ) 
 holds in a state only if the expression $\expression$ has  a value in this state, otherwise it is interpreted to \false{}.
 This in particular, means that for every formula and its subexpressions additional verification conditions for well-definedness must be generated.
 In the following, we define interpretation of formulas  in a two valued logic. However, a formula may hold in a state only under the condition that
 it is  defined, i.e. all the expression contained in the formula should have a meaning in  this state.
 
 Here, we shall not enter into these problems. Although the evaluation of expression is partial, we shall consider only the validity of well defined 
 formulas in a state, i.e. formulas which talk only about defined expressions in a state.
 Thus, we will avoid the treatment of partiality. In particular, we will remain in 
 a classical two valued logic. 
 Although, we ignore a lot of formulas, i.e. those which are not well defined,
 this will be sufficient for our proof of correctness of the verification condition generator later in Chapter \ref{proofGeneral} as 
 the verification condition generator preserves well definedness of formulas in a state and moreover, we  assume that specification are well defined.

 We use the notation $\interp{\predWp}{s}$ to say that the well defined formula  $\predWp$ is valid w.r.t. a current state  $s$ and an initial state $s_0$.
 $\interp{\predWp}{s}$ is defined in the standard way. For instance, the statement $\interp{\expression_1 \  \predicates \  \expression_2 }{s}$
 by definition means that the evaluation   $\evalExp{ \expression_1 }{s } $ of $\expression_1$ and the evaluation $\evalExp{ \expression_2 }{s } $ of $\expression_2$
 are in relation $ \predicates$ or written formally that the following holds:
 $\evalExp{ \expression_1 }{s } \ \predicates \ \evalExp{ \expression_2 }{s}$.
 The formal statement   $\interp{\instances(\referenceOnly)}{s}$  by definition means that the reference \referenceOnly{} is part of the heap locations in state s or in other words 
 that the following holds  $\referenceOnly \in s.\heap.\heapLocs $.

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%deprcated%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% In \cite{bijlsma90sqb}, Bijlsma comes up with another solution where the  properties of the logic are preserved but  however compositionality of expression evaluation does not hold anymore.

%In \cite{gries95avoiding}, Gries and Schnieder give another solution to the problem which consists in underspecification 
%and thus  avoiding the special object of undefideness.
% More particularly, their approach considers all functions as total but for some value of the argument 
%the function is not specified. 

%In \cite{schieder99adapting},  B. Schieder and M. Broy give 
%  an extension  of the calculus of boolean structures proposed by Dijkstra and Scholten (\cite{WPCDS}) with a  third boolean value 
%undefined where  the logical connectives are extended in a nonmonotonic way preserves the properties of the classical logic
%on the price  of having two sorts of equality. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%deprcated%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

%In \cite{} \todo{Owe, Lilian}, the authors propose a three valued logic for dealing with partiality by introducing
%a well-definedness operator $\wellDefined{}: \expression \cup \predWp \rightarrow \predWp$ over expressions and formulas. Thus formulas can be either \true{}, \false{} or not defined and
%expressions may evaluate to a value or be undefined. The operator  $\wellDefined{\expression}$ ($\wellDefined{\predWp}$) 
% gives the, necessary and sufficient
% conditions such that $\expression$(\predWp ) is defined.
% More particularly, the application of the operator   $\wellDefined{\expression}$  ($\wellDefined{\predWp}$) over $\expression$  (\predWp ) 
% holds in a state only if the expression $\expression$ has  a value in this state, otherwise it is \false{}. To get a more precise idea of the operator $\wellDefined{}$
%we scatch it hereafter:

 
%\begin{wellDef}[Well defined expressions] \label{wellDef}

%$$
%\begin{array}{l}
%\wellDefined{v} = \My\true{} \\
%\\
%\wellDefined{\fieldd(\expression )} =\wellDefined{\expression} \wedge  \expression \neq \Mynull \\
%\\
%\wellDefined{ \arrayAccess{\expression_1} {\expression_2}   } = 
%           \begin{array}{l}
%             \expression_1 \neq \Mynull \wedge\\
%            0 \le  \expression_2 < \arraylength(\expression_1)
%           \end{array} \\
%
%\wellDefined{\predWp_1 \wedge \predWp_2} =  \begin{array}{l} 
%                                                     \wellDefined{\predWp_1} \wedge  \wellDefined{\predWp_2} \wedge \\
%                                                     
%                                          
%                                       
%                                            \end{array} \\                                                
%\ldots 
%\end{array}
%$$ 

 
We define a function for expression evaluation
 $\evalExpName$ which evaluates expressions in a state has the following signature:
%\rightharpoonup
$$
\evalExpName : \expression \rightarrow \SetConfigs  \rightarrow \SetConfigs  \rightharpoonup  \Values \cup \JavaType
$$
The evaluation function   takes as arguments an expression of the assertion language presented in the previous Section 
\ref{assertLang:lang} and two states (see Section \ref{def} for the definition of state)  and returns a value or a class type
(see Section \ref{types} for the definition of values and types in the language). 


\begin{interpretation}[Evaluation of expressions] \label{interpExpr} 
The evaluation in a state 
$s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$  or $s = \configFinal{\heap}{\Final }$  of an expression $\expression$
w.r.t. an initial state $ s_{0} = \config{\heap_{0}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $ 
is denoted with $\evalExp{\expression}{s}$  and is defined in its domain inductively over its  the grammar of expressions $\expression$ \  as follows:
 
$$
\begin{array}{lll}
\evalExp{ v  }{s } & = & v\\
  where \  v \in \  \Myint   \ \vee  \  v \in  \RefValues \\

 \evalExp{\fieldAccess{\expression}{\fieldd  } ) }{s} & = & \heap(\fieldd) (\evalExp{ \expression}{ s } ) \\


 \evalExp{ \fieldAccess{ \expression_3}{\update{\fieldd}{\expression_1}{\expression_2} }}{ s } & = &
\update{\heap}{\fieldd }{\update{\fieldd}{  \evalExp{\expression_1}{s } }{ \evalExp{\expression_2}{s }  }} (\fieldd)
                                            (  \evalExp{\expression_3}{ s } ) \\



 \evalExp{\arrayAccess{\expression_1} {\expression_2}  }{ s } & = & 
  \heap (\evalExp{ \expression_1}{ s } ,\evalExp{ \expression_2}{ s } )   \\

 \evalExp{ \update{ \arrayAccessOnly}{ (\expression_1 , \expression_2)}{ \expression_3} (\expression_4,\expression_5)  } { s } & =&
  \update{\heap}{ ( \evalExp{\expression_1}{s } ,  \evalExp{\expression_2}{s } ) }  
                 { \evalExp{\expression_3}{s }} 
                 ( \evalExp{\expression_4}{s } ,  \evalExp{\expression_5}{ s  } ) \\

 \evalExp{ \locVar{i} } { s } & =  &\locVarOnly(i) \\


 \evalExp{ \old{\exprWp} } { s } &  = & \evalExp{ \exprWp }{  s_{0}} \\

 \evalExp{\expression_1 \ \op \ \expression_2   } { s } &  =  &  \evalExp{\expression_1}{s} \op  \evalExp{\expression_2}{s}  \\


\evalExp{ \typeof{\exprWp}}{s } & = &
\left\{\begin{array}{ll}
      \Myint                                           & \evalExp{\exprWp}{s} \in \Myint \\
      \heap. \heapTypeOf(\evalExp{\exprWp}{s} ) & else \\
           
\end{array}\right. \\


\evalExp{ \elemtype{\exprWp}}{s } & = &
\begin{array}{ll}
            \mbox{ \rm \texttt{T} }  & where \   \heap. \heapTypeOf(\evalExp{\exprWp}{s} ) = \mbox{ \rm \texttt{T[ ] } } 
\end{array}\\


\evalExp{ \TYPE }{s } & =  & \mbox{ \rm \texttt{java.lang.Class}} 
\end{array}
$$

The evaluation of stack expressions can be done only in intermediate state configurations $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ :
$$
\begin{array}{lll}
 \evalExp{ \counter   } { s } & =  & \counterOnly \\


 \evalExp{ \stack{ \exprWp}   } { s } &  = & \stackOnly ( \evalExp{\exprWp}{s} ) \\


\end{array}
$$
The evaluation of the following expressions can be done only in a final state $s = \configFinal{\heap}{\locVarOnly}{\Final }$:
$$
\begin{array}{ll}
\evalExp{ \result }{s } = \Res  & where \ s=  \configFinalNorm{\heap}{\locVarOnly}{\Res} \\
\evalExp{ \EXC }{s } = \Exc  & where \ s=  \configFinalExc{\heap}{\locVarOnly}{\Exc}
\end{array}
$$
  

\end{interpretation}

%Thus, for instance the evaluation  $\evalExp{ \fieldAccess{\locVar{1}}{\fieldd}  }{s}$ of the expression $ \fieldAccess{\locVar{1}}{\fieldd} $  in the
% state $s =\config{\heap}{\counterOnly}{ \stackOnly }{\locVar{1} \rightarrow \Mynull  }{\pc } $ is not defined.



% Note that the interpretation of 
%  $\wellDefined{\expression}$($\wellDefined{\predWp}$) cannot be undefined, it is either \true{} or \false{}.
%As we shall see, the relation  $\vDash$  interprets formulas to the $\true{}$ value under the condition
%is well -defined in the sense of the operator $\wellDefined{}$
%$$ \vDash :  \SetConfigs *  \predWp  $$
%In the following, we shall define an evaluation function $\evalPredName$ with signature: 
%$$\evalPredName :\predWp \rightarrow \SetConfigs  \rightarrow \SetConfigs  \rightharpoonup  \true \cup \false $$
%As we can see from its signature, the predicate evaluation will project predicates from  our assertion language 
%into boolean values. Because the predicate evaluation depends on the expression evaluation, the function for predicate 
%evaluation is also partial. This intuitively means that as far as the predicate contains undefined expressions
%%it cannot be said if it is \true{} or \false. 

%\begin{interpretation}[Evaluation of predicates in a state] \label{interpPred} 
%The evaluation $ s\evalPred{\predWp}{s} $ of a predicate $\predWp$ in a state configuration $s = \config{\heap}{\counterOnly}{ \stackOnly }{\locVarOnly}{\pc }$ 
%w.r.t. an initial state  $ s_{0} = \config{\heap_{0}}{ 0 }{ \lbrack \ \rbrack  }{\locVarOnly}{ 0 } $ is defined inductively as follows:
%$$
%\begin{array}{lll}
%\evalPred{\Mytrue}{s} &  = & \true \\
%
%\evalPred{\Myfalse}{s} & = & \false \\
%
%%\evalPred{  \neg \ \predWp  }{s} & = & \left\{ \begin{array}{ll} 
%                                                 \true   &  if  \ \evalPred{\predWp}{s} = \false \\
%                                                \false  &  if  \ \evalPred{\predWp}{s} = \true \\
%%                                               \bottom &  else
%                                  \end{array}\right. 
%\\
%%
%\evalPred{\predWp_1  \wedge  \predWp_2 }{s} & = &   \left\{ \begin{array}{ll} 
%                                                              \true  &  if  \ \evalPred{\predWp_1}{s} =\true \  and  \  \evalPred{\predWp_2}{s} = \true  \\
%                                                             \false &  if  \ \evalPred{\predWp_1}{s} =\false \ or   \  \evalPred{\predWp_2}{s} = \false \\
%                                                             \bottom & else
%                                                  \end{array}\right.\\
%
%
%\evalPred{\predWp_1  \vee  \predWp_2 }{s} & = &  \left\{ \begin{array}{ll} 
%                                                            \true  &  if \ \evalPred{\predWp_1}{s} = \true \   or   \    \evalPred{\predWp_2}{s} = \true  \\
%                                                           \false &  if  \ \evalPred{\predWp_1}{s} =\false \  and   \  \evalPred{\predWp_2}{s} = \false \\
%                                                           \bottom & else
%                                            \end{array}\right.   \\
%%
%\evalPred{\predWp_1  \Rightarrow  \predWp_2 }{s} & = & \left\{ \begin{array}{ll} 
%                                                                 \true   &  if \  \evalPred{\predWp_1}{s} = \false \ or  \ \evalPred{\predWp_2}{s}  = \true \\
%                                                                \false  &  if \  \evalPred{\predWp_1}{s} =  \true \ and  \ \evalPred{\predWp_2}{s}  = \false \\
%                                                                \bottom &  else
%                                                        \end{array}\right.\\
%
%\evalPred{\forall x  :T. \predWp(x)   }{s} & = & \left\{ \begin{array}{ll} 
%                                                           \true   & if   \ \forall \mbox{ \rm \textbf{v}} \ of \ type \ T \  \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \true    \\
%                                                          \false  & if   \ \exists \mbox{ \rm \textbf{v}} \ of \ type \ T \  \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \false \\
%                                                          \bottom & else
%                                                  \end{array}\right.   \\
%
%
%\evalPred{\exists x .  \predWp(x)   }{s} & = & \left\{ \begin{array}{ll} 
%%                                                         \true  & if \ \exists \mbox{ \rm \textbf{v}} \ \in \Values  \ of \ type \ T  \\
%                                                                & \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \true \\
%                                                        \false & if \ \forall \mbox{ \rm \textbf{v}} \ \in \Values  \ of \ type \ T \\
 %                                                               & \evalPred{\predWp(\mbox{ \rm \textbf{v}})}{s} = \false \\
%                                                        \bottom & else
%                                           \end{array}\right.   \\
%                                          
%
%\evalPred{\expression_1 \  \predicates \  \expression_2 }{s} & = & 
%%                    \left\{ \begin{array}{ll} 
%                           \evalExp{\expression_1 }{s} \predicates \evalExp{\expression_2 }{s}  & \evalExp{\expression_1}{s} \neq \bottom \ and  \  \evalExp{\expression_2}{s} \neq \bottom\\
%                           \bottom & else
%                   \end{array}\right.   \\                                                 
%
%
%\evalPred{\instances(\referenceOnly) }{s} & = &   \referenceOnly \in \heap.\heapLocs
%\end{array}
%$$   
%\end{interpretation}


  

% We now turn to define what means for a formula  to hold  in a given state.
%The relation $\vDash$ that we define next, gives a meaning to the formulas from our
% assertion language $\predWp$ w.r.t. two state configurations - a current state and an initial state. 
%In particular, we say that a predicate holds in a state if under the condition that its evaluation in this states
%is defined then  it evaluates to the true boolean value. 


%\begin{interpretation}[A predicate holds in a state] \label{interpPred}
%We say that the predicate $\predWp$  holds  in the state $s$  w.r.t. an initial state $s_0$, if the following holds
%$$   \interp{\predWp}{s} =^{def} \evalPred{\predWp}{s}  \neq  \bottom  \ and \  \evalPred{\predWp}{s} = \phi  \ then \ \phi = \true    $$ 
%
%\end{interpretation}

%Let us return to our initial examples. The interpretation $\interp{\fieldAccess{\locVar{1}}{\fieldd} ==~3}{s}$
% of the predicate $\fieldAccess{\locVar{1}}{\fieldd} ==~3$ in a state  $s =\config{\heap}{\counterOnly}{ \stackOnly }{\locVar{1} \rightarrow \Mynull  }{\pc } $ 
%is \true{} following the above definition. Note that its negation  $\interp{\neg (\fieldAccess{\locVar{1} }{\fieldd} ==~3}{s}$
%is also \true. This follows from the above definition for evaluation of formulas and the fact that
% $ \evalExp{\fieldAccess{\locVar{1}{\fieldd}  }}{ s}  $ is not defined.
% It also follows from the definition that the negation of the statement $ \neg \interp{\fieldAccess{\locVar{1} }{\fieldd} == 3 }{s}$ is \false. 
%Note also, that in this interpretation, for any two states $s_0, s$ we have that $ \interp{1/0 = 1/0}{s}$ holds. 



% Note that the upper definition interprets atomic formulas in  states $s$ and $s_0$, i.e. formulas which 
%represent relations between expressions, as \true only if the evaluation of these expressions is defined
%in $s$ and $s_0$. However, the interpretation of the logical connectors is standard.
 

The next definition defines a particular set of assertion formulas which  hold in every program state. We call them  valid formulas. 
\begin{interpretation}[Valid formulas]\label{assertLang:interpretation:valid}
  If an assertion formula  $ \predWp $ holds in any current state and any initial state, i.e.
$\forall s, s_{0}, \  \interp{\predWp}{s} $ we say that this is a valid formula and we note it with :
  $\validFormula{\predWp} $ 
\end{interpretation}
