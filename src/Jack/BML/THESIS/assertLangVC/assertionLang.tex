%\section{Assertion language for the verification condition generator}\label{bml:assertionLang}
% why do we concentrate only on a particular part of BML
In this chapter we shall focus on 
 a particular fragment of BML which will be extended with 
few new constructs.  The part of BML in question  
is the assertion language that our  verification condition generator manipulates
 as we shall see in the next Chapter \ref{wpGeneral}.

% what is exactly the fragment of interest
% The BML fragment that will be of interest here will be the language of BML expressions
% (nonterminal $\expression$) and the  language of the BML predicates (nonterminal $\formulaBc$). 
% % why do we discard the rest. 
% We abstract from the rest of the BML grammar, as it boils down to BML
% expressions and  predicates. We will discuss what is the encoding of the method
% specification which is used by the verification condition generator.


The assertion language presented here will abstract from most of the BML specification clauses described in Section \ref{BCSLgrammar}.
Our interest will be focused only on method and loop specification.
Note that  the assertion language presented here discards class invariants,
 history constraints  because  they boil down to method pre and postconditions. 
%Specification inheritance in case of overriden methods also can be encoded as method pre and postconditions.  


The rest of this chapter is organized as follows. Section \ref{assertLang:lang} presents
what is exactly the BML fragment of interest and its extensions.
Section \ref{methExtend} shows how we encode method and loop specification as well as presents a discussion
how some of the ignored BML specification constructs are transformed into method pre and postconditions.
The last two sections are concentrated on the formal meaning of the assertion language, i.e.
Section \ref{subst} defines the substitution for the assertion language and 
 Section \ref{interpret} gives formal semantics of the assertion language.

