\subsection{The assertion language} \label{assertLang:lang}
The assertion language in which we are interested corresponds to the
BML  expressions (nonterminal $\expression$) and predicates 
(nonterminal $\formulaBc$) extended with several new constructs.
 The extensions that we add are the following:
\begin{description}
    \item [Extensions to expressions] 
         The assertion language that we present here must be suitable for the verification condition calculus.
	 Because the verification calculus talks about updated field and array access
	 we should be able  to express  them in the assertion language. Thus we extend the grammar of BML expression
	 with the following constructs concerning update of fields and arrays :

        \begin{itemize}
	       \item update field access expression 
		  $\update{\fieldd}{ \expression}{\expression}(\expression)$.

	       \item update array access expression 
                   $ \update{ \arrayAccessOnly}{ (\expression , \expression)}{ \expression} (\expression,\expression)$
	\end{itemize}

	The verification calculus will need to talk about reference values. Thus we extend the BML expression grammar to  support
	reference values \RefValues. Note that in the following integers \Myint\  and \RefValues \ will be referred to with \Values.
    \item [Extensions to predicates] Our bytecode language is object oriented and thus supports new object creation. Thus we
          will need a means for expressing that a new object has been created during the method execution. 

	  We extend the language of BML  formulas
	  with a new user defined predicate $ \instances(\RefValues)$. Informally, the semantics of the predicate
	  $\instances(\referenceOnly)$ where $\referenceOnly \in \RefValues$
	  means that the reference $\referenceOnly  $  is allocated in the current state.
        
\end{description}

The assertion language will use the names of fields and classes for the sake of readability instead of their corresponding indexes
in the constant pool as is in BML. 
The assertion language discussed here supports only method pre and postconditions. Note that as we discussed earlier in 
Section \ref{BCSLprelim}
class invariants and history constraints can be encodes as pre and postconditions. 
