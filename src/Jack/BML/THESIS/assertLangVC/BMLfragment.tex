\section{The assertion language} \label{assertLang:lang}
The assertion language in which we are interested corresponds to the
BML  expressions (nonterminal $\expression$) and predicates 
(nonterminal $\formulaBc$) extended with several new constructs.
 The extensions that we add are the following:
\begin{description}
    \item [Extensions to expressions] 
         The assertion language that we present here must be suitable for the verification condition calculus.
	 Because the verification calculus talks about updated field and array access
	 we should be able  to express  them in the assertion language. Thus we extend the grammar of BML expression
	 with the following constructs concerning update of fields and arrays :

        \begin{itemize}
	       \item update field access expression 
		  $\update{\fieldd}{ \expression}{\expression}(\expression)$.

	       \item update array access expression \\
                   $ \update{ \arrayAccessOnly}{ (\expression , \expression)}{ \expression} (\expression,\expression)$
	\end{itemize}

	The verification calculus will need to talk about reference values. Thus we extend the BML expression grammar to  support
	reference values \RefValues. Note that in the following integers \Myint\  and \RefValues \ will be referred to with \Values.
    \item [Extensions to predicates] Our bytecode language is object oriented and thus supports new object creation. Thus we
          will need a means for expressing that a new object has been created during the method execution. 

	  We extend the language of BML  formulas
	  with a new user defined predicate $ \instances(\RefValues)$. Informally, the semantics of the predicate \\
	  $\instances(\referenceOnly)$ where $\referenceOnly \in \RefValues$
	  means that the reference $\referenceOnly  $  has been allocated when the current method started execution.
        
\end{description}

The assertion language will use the names of fields and classes for the sake of readability instead of their corresponding indexes
in the constant pool as is in BML.

We would like to discuss in the following how and why BML constructs like class invariants and history constraints and inherited specification
(multiple specification cases for a method) can be expressed as 
method pre and postconditions:

\begin{description} 
  \item [Class invariants] A class invariant (\ClassInv)  is a property that must hold at every visible state of the class. This means that a
        class invariant must hold when a method is called and also must be established at the end of a method execution. 
	A class invariant must be established in the poststate 
	of the constructor of this class.
	Thus the semantics of
	a class invariant is part of the pre and  postcondition of every method and is a part of the postcondition of the constructor of the class.
        
  \item [History constraints] A class history constraint (\ClassHistoryConstr) gives a relation between the pre and poststate of every method in the class. 
        A class history constraint thus can be expressed as a postcondition of every method in the class.
        
  \item [Behavioral subtyping for overriding methods]
        Method overriding appears in case when in a subclass a method is reimplemented.  For instance, in Fig. \ref{assertLang:lang:inherit},
	we give an example of a class \lstinline!B! which extends class   \lstinline!A! and overrides method  \lstinline!m!. 
	This kind of methods are dinamically bound, i.e. can not determine statically in case of overriden methods which will be executed.
	If we go back to the figure, this means that the invokation of method   \lstinline!m! on the object reference of type \lstinline!A!
        may stand for the method  \lstinline!m! declared in class \lstinline!B! or the one declared in \lstinline!A! because the dynamic type of the
	reference stored in the field  \lstinline!a! may be \lstinline!A! or \lstinline!B!. Because  \lstinline!m! from
        class \lstinline!B! can be called whenever method  \lstinline!m! from  \lstinline!A! may be called, we want that first has the same 
	type as the second which is expressed as subtype conditions on their respective return and argument types. We also require that \lstinline!m! from
        class \lstinline!B! behaves like method \lstinline!m! from \lstinline!A! or as we say that method is a behavioral subtype of \lstinline!A!. 
	
        This is expressed by the two covariant conditions over their postconditions:
	\begin{itemize}
	   \item the precondition of the  overriden method must  imply
	         the precondition of the overriding method 
	   \item the postcondition of the overriding method must imply 
	         the postcondition of the overriden method.
	\end{itemize}
	We adopt the specification inheritance technique which allows to encode behavioral subtyping in the specification of the 
	overriding method. The methodology consists in expressing the specification of the overriden method 
	as part of the specification of the overriding method. The reader may have a look for a detailed description of
	specification inheritance  in  the article \cite{Dhara-Leavens95} of K.Dhara and G.T.Leavens. Here, we will 
	illustrate the specification inheritance through the example given in Fig. \ref{assertLang:lang:inherit}. We show on the right in the figure
	the new specification of method  \lstinline!m!  from class \lstinline!B!. Its precondition is the disjunction of the its specified postcondition 
	and the precondition of the method it overrides. On the other hand, its new postcondition expresses that depending what held in the precondition 
	of the  method then either its postcondition holds or the postcondition of the method it overrides. Note that the new 
	specification of \lstinline!m!  declared in class \lstinline!B!  respects the two covariant condition described above.
	
	

\begin{figure}[ht!]
%\begin{tabular}{ll}
\begin{lstlisting}[frame=trbl]
class A {
  //@ requires Pre1;
  //@ ensures  Post1;
  int m(){
  }
}

class B extends A {
  //@ requires Pre2;
  //@ ensures  Post2;
  int m(){
  }
}

class C{
  A a;
  void n (){
    ...
    a.m()
  }
} 

class B extends A {
  //@ requires Pre1 || Pre2;
  //@ ensures  (\old(Pre2) ==> Post2) && 
               (\old(Pre1)==> Post1) ;
  int m(){
  }
}

\end{lstlisting}
 
%\end{tabular}
 \caption{\sc An example for a specification inheritance} \label{assertLang:lang:inherit}
\end{figure}

\end{description}

 % why do we discard the rest. 
% We abstract from the rest of the BML grammar, as it boils down to BML
% expressions and  predicates. 


