
In the end of this thesis, we would like to summerize 
its contents and to focus on the future objectives. 

% done. summary
So far, we have  presented a bytecode logic which allows to reason about potentially
complex  functional and security properties.
 For this, we have 
introduced a specification language BML tailored to Java bytecode, a compiler
from the Java source specification language JML to BML and a verification 
condition generator for Java bytecode programs. Moreover, we have
shown that the verification procedure over Java like source program
and Java like bytecode are syntactically equivalent (modulo names and types). 
This scheme is actually part of the PCC architecture of 
European project Mobius\footnote{the site name} which aims to resolve the problems
of mobile and ubicuous computing via PCC. 
We have implemented a prototype of the bytecode verification condition generator and a compiler 
from source JML specification into bytecode BML specification. Those components are integrated in the JACK verification framework. 

%presentation of the implementation
JACK stands for Java Applet Correctness Kit. The tool is a plugin for the Java interface development
 environment eclipse and has a user friendly interface. It was originally tailored to the verification of Java source programs 
w.r.t. their JML specifications. The tool has an intermediate proof obligation language which allows to extend it easily to interface more 
 theorem provers. Thus, the tool interfaces several theorem provers - Simplify
 which is an automatic decision procedure, the Atelier B and the Coq
 interactive theorem prover assistant. 


The extension of the tool to  the verification of bytecode programs also interfaces these theorem provers. The bytecode 
verification condition generator works as follows. For the verification of a class file it will generate verification conditions for every
 method of this class including the constructors. For generating the verification conditions over a method body, first the control flow
 graph corresponding to the bytecode instruction is built.
 Then the verification procedure proceeds by generating for every execution path in the control flow graph its corresponding verification conditions.
The bytecode verification condition generator benefits from the original user friendly interface of the JACK tool. 
As we already mentioned, we have an implementation also of the compiler from
JML to BML. The compiler takes as input an annotated with JML Java source file
and its corresponding class file and returns a class file augmented with
attributes containing the compilation of the JML annotation into BML.

% extension to multithreading
 We have used the prototype of the bytecode verification condition generator
 for the case studies presented in Chapter \ref{applications:optimComp}. 
 We have thus shown that bytecode verification with logical methods is possible
 and moreover can benefit from the verification on source level. 
 However, the bytecode verification condition generator presented here works only for the
 sequential fragment of Java. This is a limitation  as realistic applications  
 rely often on multi-threading. Even the last Java Card provides support for
 multi-threading programs. Thus, an important and challenging direction for future work
 is the extension of the verification procedure to multi-threading. 
 Also, in our work we have ignored floating point arithmetic which is also a
 candidate for future work.

% establish a relation btw Java and optimised version
So far, we have shown that non-optimizing Java compilation
 preserves the  form of the verification conditions on source and
 bytecode. However, it is interesting to investigate if such a relation  holds also  for
 optimizing compilers. This is especially  interesting for small devices with limited resources
  where an optimized version of the rich Java code might be preferred. 
% implement the compiler from Java source pogs to bytecode pogs
Moreover, we have experimented with the verification conditions on source and
 bytecode in JACK and saw that in practice they are almost equivalent
 syntactically. From one part, there are the difference in the types 
 supported on bytecode and source level. For instance, the JVM does not
 provide support for boolean type values which are basically encoded as
 integer values. The same is true for byte and short values.  Another
 difference is the identifiers for variables and fields. For instance, in Java
 names for fields, method local variables and parameters are their identifiers which are given by the
 program developer. On bytecode method local variables and parameters are encoded as elements of the
 method register table and field names are encoded as numbers of the constant
 pool table of the class. A next simple but useful extension to the prototype
 is a compiler from source proof obligations to bytecode proof obligations
 which overcomes those differences. This can be considered also as a step in
 building a PCC architecture where the certificate generation benefits from
 the source level verification and thus allows for treating sophisticated
 security policies.
 

 % extension  to PCC
Beside this, in order to get a complete PCC framework we still need to define the
format of the certificate, i.e. 
the guarantee sent along with the bytecode which certifies that the bytecode 
respects the client requirements. The decision for an encoding of the
certificate should take into account 
several factors:
\begin{itemize} 
  \item certificate size must be reasonably small. This is important, for
    instance,  if the certified program comes over a network 
    with a limited bandwidth
  \item certificates must be easily checked. This means that the certificate checker is  small and simple.
               Of course, the code consumer might not want to spend all of its computation 
              resources for checking that the certificate guarantees the
               program conformance to its policies   
\end{itemize}

Certificate size and its checking complexity are dual: the
bigger the certificate is more manageable is the checking 
process and vice versa.  The problem becomes even more difficult if the
certificate must be checked on the device because 
of the computational and space constraints. In this case, a possible solution
is that the certificate is not stored on the device. It is instead checked
while read and as soon as a piece  of the certificate is checked it is
discarded and the checking continues with the next piece of the certificate.
% towards.PCC
% For building a PCC framework from the components cited above 
% % there is still missing the proof certificate, the decision procedure
% that will be used by the producer for the certificate generation and the type checker used by the code
% client for checking the certificate. Important problems in this direction are
% \begin{itemize}
%  \item light weight verification condition generators. In particular, we refer 
%        to verification condition generation techniques which are simple and do not need
%       much computational resources. Because a verification condition generator always
%       form part of the trusted computing base on the client side, building such verification 
%       condition generators is important for on - device checking which rely on limitted computational 
%       resources  
  
%   \item generation of certificates. This is important for several reasons.
%         The certificate may certainly  arrive via the network and should not corrupt the performance 
%  
% 
% %  \item efficient type checker on the client site. This is in particular important 
%         if the device is with limitted resources where a complex certificate checking procedure
%         may corrupt the performance of the device
%        
%     
% \end{itemize}


 %To do this,  it is still missing the proof
%certificate, the decision procedure used by the code producer 
%for building the certificate  as well as the type checker used by the code
%client for checking the certificate. 

% to do. type systems
Another perspective is the encoding of  type systems as suggested in \cite{BeringerH06},  into
bytecode specification such that whenever the program is typeable then  the verification conditions generated over
the bytecode and the specification are valid. This can be useful as type
systems provide a high level of automation and thus certificate generation
with type systems does not need user interaction.  \todo{references to the
  work of M&L}


