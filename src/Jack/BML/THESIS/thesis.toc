\contentsline {chapter}{\numberline {1}Introduction}{7}
\contentsline {section}{\numberline {1.1}Contributions}{8}
\contentsline {section}{\numberline {1.2}Related work}{10}
\contentsline {section}{\numberline {1.3}Applications}{11}
\contentsline {section}{\numberline {1.4}Plan of the thesis}{11}
\contentsline {chapter}{\numberline {2} Java bytecode language and its operational semantics}{13}
\contentsline {section}{\numberline {2.1}Related Work}{16}
\contentsline {section}{\numberline {2.2}Notation}{17}
\contentsline {section}{\numberline {2.3}Classes, fields and methods}{17}
\contentsline {section}{\numberline {2.4}Program types and values}{19}
\contentsline {section}{\numberline {2.5}State configuration}{20}
\contentsline {subsection}{\numberline {2.5.1}Modeling the object heap}{21}
\contentsline {subsection}{\numberline {2.5.2}Registers}{24}
\contentsline {subsection}{\numberline {2.5.3}The operand stack}{24}
\contentsline {subsection}{\numberline {2.5.4}Program counter}{25}
\contentsline {section}{\numberline {2.6}Throwing and handling exceptions}{25}
\contentsline {section}{\numberline {2.7}Design choices for the operational semantics}{26}
\contentsline {section}{\numberline {2.8}Bytecode language and its operational semantics}{27}
\contentsline {section}{\numberline {2.9}Representing bytecode programs as control flow graphs}{35}
\contentsline {chapter}{\numberline {3}Bytecode modeling language}{39}
\contentsline {section}{\numberline {3.1}Overview of JML}{39}
\contentsline {section}{\numberline {3.2}Design features of BML}{44}
\contentsline {section}{\numberline {3.3}The subset of JML supported in BML}{45}
\contentsline {subsection}{\numberline {3.3.1}Notation convention}{45}
\contentsline {subsection}{\numberline {3.3.2}BML Grammar}{46}
\contentsline {subsection}{\numberline {3.3.3}Syntax and semantics of BML}{47}
\contentsline {subsubsection}{BML expressions}{47}
\contentsline {subsubsection}{BML predicates}{48}
\contentsline {subsubsection}{Class Specification}{49}
\contentsline {subsubsection}{Frame conditions}{50}
\contentsline {subsubsection}{Inter --- method specification}{50}
\contentsline {subsubsection}{Intra --- method specification}{51}
\contentsline {section}{\numberline {3.4}Well formed BML specification}{53}
\contentsline {section}{\numberline {3.5}Compiling JML into BML}{54}
\contentsline {chapter}{\numberline {4}Assertion language for the verification condition generator}{59}
\contentsline {section}{\numberline {4.1}The assertion language}{60}
\contentsline {section}{\numberline {4.2}Substitution}{61}
\contentsline {section}{\numberline {4.3}Interpretation}{61}
\contentsline {section}{\numberline {4.4}Extending method declarations with specification}{65}
\contentsline {chapter}{\numberline {5}Verification condition generator for Java bytecode }{67}
\contentsline {section}{\numberline {5.1}Discussion}{67}
\contentsline {section}{\numberline {5.2}Related work}{69}
\contentsline {section}{\numberline {5.3}Weakest precondition calculus}{70}
\contentsline {subsection}{\numberline {5.3.1}Intermediate predicates}{73}
\contentsline {subsection}{\numberline {5.3.2}Weakest precondition in the presence of exceptions }{74}
\contentsline {subsection}{\numberline {5.3.3}Rules for single instruction}{75}
\contentsline {section}{\numberline {5.4}Example}{82}
\contentsline {chapter}{\numberline {6}Correctness of the verification condition generator}{85}
\contentsline {section}{\numberline {6.1}Proof outline}{85}
\contentsline {section}{\numberline {6.2}Relation between syntactic substitution and semantic evaluation}{87}
\contentsline {section}{\numberline {6.3}Proof of Correctness }{90}
\contentsline {chapter}{\numberline {7}Equivalence between Java source and bytecode proof Obligations}{101}
\contentsline {section}{\numberline {7.1}Related work}{102}
\contentsline {section}{\numberline {7.2}Source language}{103}
\contentsline {section}{\numberline {7.3}Compiler}{106}
\contentsline {subsection}{\numberline {7.3.1}Exception handler table}{106}
\contentsline {subsection}{\numberline {7.3.2}Compiling loop invariants}{107}
\contentsline {subsection}{\numberline {7.3.3}Compiling source program constructs in bytecode instructions}{107}
\contentsline {subsection}{\numberline {7.3.4}Properties of the compiler function}{112}
\contentsline {section}{\numberline {7.4}Weakest precondition calculus for source programs}{119}
\contentsline {subsection}{\numberline {7.4.1}Source assertion language}{119}
\contentsline {subsection}{\numberline {7.4.2}Weakest predicate transformer for the source language }{120}
\contentsline {subsubsection}{Exceptional Postcondition Function}{120}
\contentsline {subsubsection}{Expressions}{121}
\contentsline {subsubsection}{Statements}{121}
\contentsline {section}{\numberline {7.5}Weakest precondition calculus for bytecode programs}{123}
\contentsline {subsection}{\numberline {7.5.1}Properties of the \unhbox \voidb@x \hbox {\rm \textit {wp}}\ functions}{126}
\contentsline {section}{\numberline {7.6}Proof obligation equivalence on source and bytecode level}{131}
\contentsline {chapter}{\numberline {8}Constraint memory consumption policies using Hoare logics}{137}
\contentsline {section}{\numberline {8.1}Modeling memory consumption}{137}
\contentsline {section}{\numberline {8.2}Principles}{137}
\contentsline {paragraph}{The precondition}{137}
\contentsline {paragraph}{The normal postcondition}{138}
\contentsline {paragraph}{The exceptional postcondition}{138}
\contentsline {paragraph}{Loops}{138}
\contentsline {paragraph}{For every instruction that allocates memory}{139}
\contentsline {section}{\numberline {8.3}Examples}{139}
\contentsline {subsection}{\numberline {8.3.1}Inheritance and overridden methods}{139}
\contentsline {subsection}{\numberline {8.3.2}Recursive Methods}{139}
\contentsline {subsection}{\numberline {8.3.3}More precise specification}{140}
\contentsline {section}{\numberline {8.4}Inferring memory allocation for methods}{142}
\contentsline {subsection}{\numberline {8.4.1}Annotation assistant}{143}
\contentsline {section}{\numberline {8.5}Related work}{145}
\contentsline {chapter}{\numberline {9}A Low-Footprint Java-to-Native Compilation Scheme Using Formal Methods}{147}
\contentsline {section}{\numberline {9.1}Ahead-of-time \& just-in-time compilation}{148}
\contentsline {section}{\numberline {9.2}Java runtime exceptions}{149}
\contentsline {section}{\numberline {9.3}Optimizing ahead-of-time compiled Java code}{151}
\contentsline {subsection}{\numberline {9.3.1}Methodology for writing specification against runtime exception}{152}
\contentsline {subsection}{\numberline {9.3.2}From program proofs to program optimizations }{153}
\contentsline {section}{\numberline {9.4}Experimental results}{154}
\contentsline {subsection}{\numberline {9.4.1}Methodology}{154}
\contentsline {subsection}{\numberline {9.4.2}Results}{155}
\contentsline {section}{\numberline {9.5}Limitations}{157}
\contentsline {subsection}{\numberline {9.5.1}Multi-threaded programs}{157}
\contentsline {subsection}{\numberline {9.5.2}Dynamic code loading}{157}
\contentsline {section}{\numberline {9.6}Related work}{157}
\contentsline {chapter}{\numberline {10}Conclusion}{159}
\contentsline {chapter}{Appendices}{159}
\contentsline {section}{\numberline {.1}Proofs of properties from Section 7.3.4\hbox {} }{159}
\contentsline {section}{\numberline {.2}Proofs from Section 7.6\hbox {}}{162}
