


\begin{appendix} 
\section{Specification of the Bytecode Specification Compiler} \label{appendix1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\subsection{Class annotation} 
\label{Classspecification}
The following attributes can be added (if needed) only to the array of attributes of  the \texttt{class\_info } structure.

\subsubsection{Ghost variables} \label{modelvar}
\textbf{
\begin{tabbing}
Gho\=st\_Field\_attribute \{\\
\\
\> u2 attribute\_name\_index; \\
\> u4 attribute\_length;\\
\> u2 fields\_count;\\
\> \{\hspace{3 mm}\= u2 access\_flags; \\  
\> \> u2 name\_index;\\
\> \> u2 descriptor\_index;\\
\> \} fields[fields\_count];\\
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index}\\
    The value of the attribute\_name\_index item must be a valid index into the constant\_pool table  . The constant\_pool entry at that index must be a CONSTANT\_Utf8\_info structure representing the string "Ghost\_Field".\\

\textbf{ attribute\_length }\\
   the length of the attribute in bytes = 2 + 6*fields\_count.\\

\textbf{ access\_flags} \\
  The value of the access\_flags item is a mask of modifiers used to describe access permission to and properties of a field. \\

\textbf{ name\_index} \\
The value of the name\_index item must be a valid index into the constant\_pool table. The constant\_pool entry at that index must be a CONSTANT\_Utf8\_info structure which must represent a valid Java field name stored as a simple (not fully qualified) name, that is, as a Java identifier. \\

\textbf{ descriptor\_index} \\
   The value of the descriptor\_index item must be a valid index into the constant\_pool table. The constant\_pool entry at that index must be a CONSTANT\_Utf8 structure which must represent a valid Java field descriptor.

% \subsubsection{Model(pure)  methods} \label{modelvar}
%\textbf{
%\begin{tabbing}
%Pur\=e\_Method\_attribute \{\\
%\\
%%\> u2 attribute\_name\_index; \\
%\> u4 attribute\_length;\\
%\> u2 methods\_count;\\
%\> \{\hspace{3 mm}\= u2 access\_flags; \\
%\> \> u2 name\_index;\\
%\> \> u2 descriptor\_index;\\
%\> \> u2 attributes\_count;\\
%\> \> attribute\_info attributes[attributes\_count];\\
%\> \} method\_info\_structure[methods\_count];\\
%\}
%\end{tabbing}
%}

%\textbf{  attribute\_name\_index}\\
%    The value of the attribute\_name\_index item must be a valid index into the constant\_pool table  . The constant\_pool entry at that index must be a CONSTANT\_Utf8\_info structure representing the string "Model\_Method".\\

%\textbf{ attribute\_length }\\
%   the length of the attribute in bytes.\\

%\textbf{ method\_info\_structure } \\
% a structure where the name\_index, descriptor\_index are indexes in the constant pool.

\subsubsection{Class invariant}
\textbf{
\begin{tabbing}
JML\=ClassInvariant\_attribute \{ \\ 
\> u2 attribute\_name\_index;\\ 
\> u4 attribute\_length;\\ 
\> formula attribute\_formula;\\ 
\}  
\end{tabbing}
}

\textbf{   attribute\_name\_index}\\
  The value of the attribute\_name\_index item must be a valid index into the  constant\_pool table. The constant\_pool entry at that index must be a CONSTANT\_Utf8\_info structure representing the string "ClassInvariant".\\

\textbf{   attribute\_length}\\
   the length of the attribute in bytes - 6.\\

\textbf{   attribute\_formula} \\
   code of the formula that represents the invariant, see  ~(\ref{formula}) for formula grammar \\\\

\subsubsection{History Constraints}
\textbf{
\begin{tabbing}
JML\=HistoryConstraints\_attribute \{ \\ 
\> u2 attribute\_name\_index;\\ 
\> u4 attribute\_length;\\ 
\> formula attribute\_formula;\\ 
\}
\end{tabbing}
}

\textbf{   attribute\_name\_index}\\
  The value of the attribute\_name\_index item must be a valid index into the constant\_pool table. The constant\_pool entry at that index must be a CONSTANT\_Utf8\_info structure representing the string "Constraint".\\

\textbf{   attribute\_length}\\
   the length of the attribute in bytes - 6.\\

\textbf{   attribute\_formula} \\
   code of the formula that is a predicate of the form \texttt{P\( state, old(state)\)} that establishes relation between the prestate and the postate  of a method execution. see  ~(\ref{formula}) for formula grammar \\\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Method annotation}

\subsubsection{Method specification}
The \rm{JML} keywords \texttt{requires, ensures, exsures} will be defined in a newly attribute in Java VM bytecode that can be inserted into the structure \texttt{method\_info}  as elements of the array \texttt{attributes}.


\textbf{    
\begin{tabbing}
JML\=Method\_attribute \{ \\ 
\> u2 attribute\_name\_index;\\ 
\> u4 attribute\_length;\\ 
\> formula requires\_formula;\\
\> u2 spec\_count;\\
\> \{\hspace{3 mm}\= formula spec\_requires\_formula; \\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula ensures\_formula;\\
\> \> u2 exsures\_count;\\
\> \> \{\hspace{3 mm}\= u2 exception\_index; \\
\> \> \> formula exsures\_formula;\\
\> \> \} exsures[exsures\_count];\\
\> \} spec[spec\_count];   \\
\}
\end{tabbing}
}

\textbf{   attribute\_name\_index}\\
  The value of the attribute\_name\_index item must be a valid index into the constant\_pool table. The constant\_pool entry at that index must be a CONSTANT\_Utf8\_info structure representing the string "MethodSpecification".\\

\textbf{   attribute\_length}\\
   The length of the attribute in bytes.\\

\textbf{   requires\_formula} \\
   The formula that represents the precondition (in the subsection see Formulas )\\

\textbf{   spec\_count} \\
   The number of specification case.\\

\textbf{   spec[]} \\
   Each entry in the spec array represents a case specification. Each entry must contain the following items:\\

\textbf{   spec\_requires\_formula} \\
   The formula that represents the precondition (in the subsection see Formulas )\\

\textbf{   modifies\_count} \\
   The number of modified variable.\\

\textbf{   modifies[]} \\
   The array of modified formula.\\

\textbf{  ensures\_formula } \\
   The formula that represents the postcondition (in the subsection see Formulas )\\\\

\textbf{   exsures\_count} \\
   The number of exsures clause.\\

\textbf{   exsures[] } \\
   Each entry in the exsures array represents an exsures clause. Each entry must contain the following items:\\

\textbf{   exception\_index} \\
   The index must be a valid index into the constant\_pool table. The constant\_pool entry at this index must be a CONSTANT\_Class\_info structure representing a class type that this clause is declared to catch.\\

\textbf{  exsures\_formula } \\
   The formula that represents the exceptional postcondition (in the subsection see Formulas )\\
\textit{Note:}\\
if the exsures clause is of the form: \\  
\texttt{ exsures} (\texttt{Exception\_name}  e) P(e) 
it is first  transformed in : 
\texttt{exsures} \texttt{Exception\_name} P(e)[e $\leftarrow$ \textrm{EXCEPTION}], 
where \textrm{ EXCEPTION} is a special keyword for the specification language, for which in JML there is no correspondent one.

\subsubsection{Set}
These are particular assertions that assign to model fields. 
 %Asserts must bve relied the proper place where the loop starts. To identify where exactly the bytecode for a loop starts, the assumption that the \texttt{code } attribute   \texttt{LineNumberTable} must be present.    
\textbf{  
\begin{tabbing}
Ass\=ert\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;\\
\> u2 set\_count;\\
\> \{\hspace{3 mm}\= u2 index; \\
\> \> expression e1; \\
\> \> expression e2; \\
\> \} set[set\_count];\\
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index}\\
    The value of the attribute\_name\_index item must be a valid index into the \texttt{ constant\_pool table}  . The \texttt{constant\_pool} entry at that index must be a\texttt{ CONSTANT\_Utf8\_info} structure representing the string "Set".\\

\textbf{  attribute\_length} \\
   The length of the attribute in bytes.

\textbf{  set\_count} \\
   The number of set statement.\\

\textbf{  set[]} \\
   Each entry in the set array represents a set statement. Each entry must contain the following items:\\

\textbf{  index} \\
   The index in the bytecode where the \textbf{ assignment} is done.\\

\textbf{  e1 } \\
the expression to which is assigned a value. It must be a JML expression, i.e. a JML field, or a dereferencing a field of JML reference object
  an assignment expression see ~(\ref{jmlExprs})\\

\textbf{  e2 } \\
the expression that is assigned as value to the JML expression\\ 


\subsubsection{Assert}
 %Asserts must bve relied the proper place where the loop starts. To identify where exactly the bytecode for a loop starts, the assumption that the \texttt{code } attribute   \texttt{LineNumberTable} must be present.    
\textbf{  
\begin{tabbing}
Ass\=ert\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;\\
\> u2 assert\_count;\\
\> \{\hspace{3 mm}\= u2 index; \\
\> \> formula predicate; \\
\> \} assert[assert\_count];\\
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index}\\
    The value of the attribute\_name\_index item must be a valid index into the \texttt{ constant\_pool table}  . The \texttt{constant\_pool} entry at that index must be a\texttt{ CONSTANT\_Utf8\_info} structure representing the string "Assert".\\

\textbf{  attribute\_length} \\
   The length of the attribute in bytes.

\textbf{  assert\_count} \\
   The number of assert statement.\\

\textbf{  assert[]} \\
   Each entry in the assert array represents an assert statement. Each entry must contain the following items:\\

\textbf{  index} \\
   The index in the bytecode where the \textbf{ predicate} must hold

\textbf{  predicate } \\
  the predicate that must hold at index  \textbf{index} in the bytecode ,see  ~(\ref{formula})


\subsubsection{Loop specification}
%Loops are ordered by giving to every loop entry a different number. An inner loop has always a number bigger than the loop that contains it. A loop that is after another loop has always a bigger number than the loop that is  executed before it. One can find the same order of loops on source and bytecode level. 
\textbf{     
\begin{tabbing}
JML\=Loop\_specification\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;\\
\> u2 loop\_count;\\
\> \{\hspace{3 mm}\= u2 index;\\
\> \> u2 modifies\_count;\\
\> \> formula modifies[modifies\_count];\\
\> \> formula invariant;\\
\> \> expression decreases;\\
\> \} loop[loop\_count];\\
\}
\end{tabbing}
}

\textbf{   attribute\_name\_index }\\
    The value of the attribute\_name\_index item must be a valid index into the  \texttt{ constant\_pool table}. The \texttt{constant\_pool} entry at that index must be a\texttt{ CONSTANT\_Utf8\_info} structure representing the string "Loop\_Specification''.

\textbf{   attribute\_length }\\
    The length of the attribute in bytes\\

\textbf{   loop\_count }\\
    The length of the array of loop specifications\\

\textbf{   index }\\  
    The index of the instruction in the bytecode array that corresponds to the  entry of the loop 
\\ %in the  \texttt{LineNumberTable } where the beginning of the corresponding loop is described\\

\textbf{   modifies\_count}\\
    The number of modified variable.\\

\textbf{   modifies[]} \\
    The array of modified expressions.\\

\textbf{  invariant } \\
    The predicate that is the loop invariant. It is a formula written in the grammar specified in the section Formula ,see  ~(\ref{formula}) \\

\textbf{  decreases } \\
    The expression whose decreasing after every loop execution will guarantee loop termination 

\subsubsection{Block specification}
Here also the   \texttt{LineNumberTable}  attribute must be present.    

\textbf{  
\begin{tabbing}
Blo\=ck\_attribute \{\\
\> u2 attribute\_name\_index;\\
\> u4 attribute\_length;     \\
\> u2 start\_index;          \\
\> u2 end\_index;            \\
\> formula precondition;\\
\> u2 modifies\_count;\\
\> formula modifies[modifies\_count];\\
\> formula postcondition; \\ 
\}
\end{tabbing}
}

\textbf{  attribute\_name\_index }\\
    The value of the attribute\_name\_index item must be a valid index into the \texttt{ constant\_pool table}. The \texttt{constant\_pool} entry at that index must be a\texttt{ CONSTANT\_Utf8\_info} structure representing the string "\_specification ".\\

\textbf{  attribute\_length } \\
   The length of the attribute in bytes - 6, i.e. equals \texttt{n+m}.\\

\textbf{start\_index} \\
   The index in the  \texttt{LineNumberTable } where the beginning of the block  is described

\textbf{end\_index} \\
   The index in the  \texttt{LineNumberTable } where the end of the block  is described

\textbf{  precondition} \\
  The predicate that is the precondition of the block ,see  ~(\ref{formula})

\textbf{   modifies\_count} \\
   The number of modified variable.\\

\textbf{   modifies[]} \\
   The array of modified formula.\\

\textbf{  postcondition} \\
  the predicate that is the postcondition of the block ,see  ~(\ref{formula})

\subsection{Formula and Expression compiler function }
The compiler function is denoted with  $ \ulcorner \urcorner_{\tt{context}}$. It is defined inductively over the grammar of the specification language as defined in Section 
\ref{grammar} and more particularly on Fig. \ref{bclGrammar}. 
The compiling function depends on the context $\tt{context}$ and in particular it is important for compiling field references and method call expressions.
 The context is the class where the method or field is declared. For example when  compiling the fully qualified name \texttt{a.b } the two subexpressions \texttt{a} and \texttt{b}
are compiled one after another. The subexpression \texttt{a} will be compiled in the context of \texttt{this} type ,i.e. in the context of the class where this expression appears and the subexpression \texttt{b} will be compiled in the context of the class of the subexpression \texttt{a} as it is a field of the class of the
 subexpression \texttt{a}.  

\subsection{Formulas} \label{formula}

%\textit{Notation} : $...$ - means that the preceding expression may be repeated 0 or more times.  
\subsubsection{Translation of formulas}
\begin{tabbing}
$\ulcorner \tt{Formula} \urcorner_{\tt{context}}$ ::= \= $\ulcorner \tt{Connector} \urcorner \ \ulcorner \tt{Formula_1} \urcorner_{\tt{context}} \  ... \  \ \ulcorner \tt{Formula_n} \urcorner_{\tt{context}} \mid $\\
\> $\ulcorner \tt{Quantifier} \urcorner \ulcorner \tt{Formula_1} \urcorner_{\tt{context}}$\\
\> $\ulcorner \tt{PredicateSymbol} \urcorner \ \ulcorner \tt{Expression} \urcorner_{\tt{context}} \  ... \ulcorner \tt{Expression } \urcorner_{\tt{context}}  \mid$ \\
\> $\ulcorner \tt{True} \urcorner \mid $ \\
\> $\ulcorner \tt{False} \urcorner $
\end{tabbing}

\textit{Remark:}
$n$ is coded in 1 byte.\\
Every quantification that contains a range , i.e. every formula of the form : $\forall \  A \  a; P(a); Q(a)$ should be  transformed into  $\forall \ A \ a; P(a) \Rightarrow Q(a)$

\subsubsection{Predicate constants}

\begin{center}
\begin{tabular}[t]{|c|l|}
\hline
\texttt{Predicate} & \code\\
\hline
$\tt{True} $ & 0x00 \\
$\tt{False}$ & 0x01\\
\hline
\end{tabular}\\[2 mm]
Codes for the predicate constants \texttt{True}, \texttt{False}
\end{center}
$ \ulcorner$ \texttt{True}$\urcorner_{\tt{context}} $  ::= $ \code(\tt{True})   $ \\
$ \ulcorner$ \texttt{False}$\urcorner_{\tt{context}} $  ::= $ \code(\tt{False}) $ \\

\subsubsection{Logical connectors}
\begin{center}
\begin{tabular}[t]{|c|l|}
\hline
\texttt{Connector} & \code \\
\hline
$\wedge$ & 0x02 \\
$\vee$   & 0x03  \\
$\Rightarrow$ & 0x04 \\
$!$ & 0x05  \\
\hline
\end{tabular}\\[2 mm]
Codes for the \texttt{Connector} symbols  
\end{center}
\begin{tabbing}
$\ulcorner \tt{Connector} \urcorner_{\tt{context}} $ ::= \= \code $(\tt{Connector}) $ \\
\end{tabbing}

\subsubsection{Quantifiers}

$ \ulcorner \tt{Quantifier} \urcorner ::= \ulcorner \tt{Quantificator symbol} \urcorner \ (\ulcorner \rm{Type} \urcorner_{\tt{context}} \ \ulcorner \rm{BoundVar} \urcorner_{\tt{context}})_n $, where $n$ is the number of bound variables. \\

\subsubsection{Bound Variables}
$\ulcorner \tt{BoundVar} \urcorner_{\tt{context}}  $ = code(\texttt{BoundVar} ) \texttt{int}\\
where \texttt{int} is a fresh integer value.


\subsubsection{Quantificator symbols }
\begin{center}  
\begin{tabular}[t]{|c|l|}
\hline
\texttt{Quantificator symbol} &\code\\
\hline
$\forall$ & 0x06  \\
$\exists$  & 0x07 \\
\hline
\end{tabular}\\[2 mm]
Codes for \texttt{Quantification symbols}
\end{center}
$\ulcorner$\texttt{ Quantification symbol} $\urcorner_{\tt{context}} $ ::= code(\texttt{ Quantification symbol} )

The code of any bound variable $ident$ is a fresh variable coded in \emph{1 byte} that must replace any occurrence of $ident$ in the  predicate coming after the quantification expression\\ 
The type \textrm{Type} is a \texttt{ fully qualified  name} expression.


\subsubsection{Predicate symbols }
\begin{center}
\begin{tabular}{|c|l|}
\hline 
\texttt{PredicateSymbol } & \code \\
\hline
$ \tt{==} $ &  0x10 \\ 
$ \tt{> } $ &  0x11 \\
$ \tt{<}  $ &  0x12 \\
$ \tt{<=} $ &  0x13 \\
$ \tt{>= }$ &  0x14 \\
$ \tt{instanceof }$ &  0x15 \\
$ \tt{<:}$ &  0x16 \\
\hline
\end{tabular}\\[2 mm]
Codes for the \texttt{Predicate Symbols} symbols
\end{center}
\begin{tabbing}
$\ulcorner \tt{PredicateSymbol} \urcorner_{\tt{context}} $ ::= \= $ \code(\tt{PredicateSymbol}) $ \\
\end{tabbing}



\subsection{Expressions}

Here the grammar for well formed expressions is described. We use the prefixed representation of expressions , e.g    $ + \ \tt{Arithmetic\_Expression \ Arithmetic\_Expression}  $ which stands for the infix representation    $  \tt{Arithmetic\_Expression \ +  \ Arithmetic\_Expression}  $


\subsubsection{Arithmetic Expressions}

\begin{center}
\begin{tabular}{|c|c|}
  \hline
  Operator Symbol  & \code  \\
  \hline
  + & 0x20  \\
  - & 0x21  \\
  * & 0x22 \\
  / & 0x23 \\
  \% & 0x24 \\
  - & 0x25  \\
  int Literal i & 0x40i \\
  char Literal i & 0x41i \\
  \hline

\end{tabular}\\[2 mm]
Codes for Arithmetic operations
\end{center}
binary operations : \\
$\ulcorner \tt{ op \ Expression_1 \ Expression_2 } \urcorner_{\tt{context}} $ = \\
\phantom{..............................................} \code \texttt{$($op$ ) $} \\
\phantom{..............................................} $ \ulcorner  \tt{  Expression_1 }  \urcorner_{\tt{context}}$ \\
\phantom{..............................................} $\ulcorner \tt{ Expression_2 } \urcorner_{\tt{context}}$ \\\\\\
%\phantom{..............................................} 0x00 \\\\\\


unary operations : \\
$\ulcorner \tt{ op \ Expression }   \urcorner_{\tt{context}}$ = \\
\phantom{..................................... }\code \texttt{$($op$)$} \\
\phantom{.....................................} $\ulcorner \tt{Expression}  \urcorner_{\tt{context}} $\\
% \phantom{.....................................} 0x00


\subsubsection{JML expressions}

\begin{center}
\begin{tabular}{|c|l|}
\hline
   JML constant & \code  \\
\hline
  $\backslash$ \texttt{typeof}   & 0x50 \\
  $\backslash$ \texttt{elemtype} & 0x51 \\
  $\backslash$ \texttt{result} & 0x52 \\
  $\backslash$ \texttt{old} &  \\
  $\ast$ &  0x53 \\
 $\backslash$ \texttt{type} & 0x54  \\ 
 $\backslash$ \texttt{Type} & 0x55  \\ 
\hline
\end{tabular}\\[2 mm]
Codes of JML constant
\end{center}
$\ulcorner \tt{ \backslash typeof(Expression) } \urcorner_{\tt{context}}$ = \\
\phantom{.................... .........} $  \tt{code(\backslash typeof) }  $\\
\phantom{.................... ........} $\  \ulcorner \tt{ Expression } \urcorner_{\tt{context}} $ \\
%\phantom{.................... ........}0x00 \\\\

$\ulcorner \tt{ \backslash elemtype(Expression) } \urcorner_{\tt{context}}$ = \\
\phantom{.................... ........} $ \tt{code(\backslash elemtype) } $ \\
\phantom{.................... ........}$\ulcorner \tt{ Expression } \urcorner_{\tt{context}}$ \\
%\phantom{.................... ........}0x00 \\\\

$\ulcorner \tt{ \backslash result } \urcorner_{\tt{context}}$ =  \texttt{code( $\backslash$ \texttt{result})} \\\\ % 0x00 \\\\

$\ulcorner \tt{ \lbrack } \ \tt{ Expression} \ \ast \ \urcorner_{\tt{context}}$  = $ \ulcorner \tt{\lbrack} \urcorner_{\tt{context}} $  $ \ulcorner \tt{Expression } \urcorner_{\tt{context}} \ \ulcorner \ast \urcorner_{\tt{context}} $ \\\\ %0x00 \\\\

$\ulcorner \tt{\backslash old (Expression ) } \urcorner_{\tt{context}} $ = $\tt{code(\backslash old )} \ulcorner \tt{Expression} \urcorner_{\tt{context}}$ \\
%\textit{Note:} $\ulcorner . \urcorner_{\tt{context}}^{old}$ is the same as $\ulcorner . \urcorner_{\tt{context}}$ with the exception that for  identifiers code it is using the function \textrm{old}, defined in  ~\ref{Codesvariables}\\\\

$\ulcorner \backslash \tt{type}( Expression) \urcorner_{\tt{context}} $ = $\ulcorner \backslash \tt{type} \urcorner_{\tt{context}} $ \\
\phantom{$\ulcorner \backslash \tt{type}( Expression) \urcorner $ = } $ \ulcorner Expression \urcorner_{\tt{context}} $\\
%\phantom{$\ulcorner \backslash \tt{type}( Expression) \urcorner $ = } 0x00 \\\\




$\ulcorner \backslash \tt{TYPE} \urcorner_{\tt{context}} $ = \code($\tt{TYPE} $ ) \\ %0x00 \\
see  ~\ref{Codesvariables}, etc. see  ~\ref{CodesJMLkw}, ~\ref{CodesJavakw} \\ 

% \subsubsection{ Calls to Pure Methods}
% \begin{center}
% \begin{tabular}{|c|c|}
%    \hline
%    symbol & \code \\
%    \hline
%    \texttt{( } &  0x60  \\
%    \hline
% \end{tabular}\\[2 mm]
% Code for method call symbol
% % \end{center}
% $\ulcorner \tt{(}  \urcorner_{\tt{context}} $ = \code( $ \tt{ ( \phantom{)} }$ )

% $\ulcorner \tt{ (  \ Expression \ Expression_1 ...... Expression_n  } \urcorner_{\tt{context}}$ = \\
% $ \phantom{................................................} $ $\ulcorner \tt{(} \urcorner_{\tt{context}} $  \\
% $ \phantom{................................................} $ $\ulcorner \tt{Expression} \urcorner_{\tt{context}}$  \\
% $ \phantom{................................................} $ $ n$  \\
% $ \phantom{................................................} $ $\ulcorner \tt{Expression_1} \urcorner_{\tt{type(this)}} $ \\
% $ \phantom{................................................} $ ...\\
% $ \phantom{................................................} $ $\ulcorner \tt{Expression_n} \urcorner_{\tt{type(this)}} $ \\
%$ \phantom{................................................}$  0x00 

\subsubsection{Array access}
\begin{center}

\begin{tabular}{|c|c|}
\hline
symbol & \code \\
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...

   \texttt{ [ } &  0x61 \\
  \hline
\end{tabular}\\[2 mm]
Code for array access symbol
\end{center}
$\ulcorner \tt{[}  \urcorner_{\tt{context}} $ = \code(\texttt{[})

$\ulcorner \tt{ [  \ Expression \ Arithmetic\_Expression   } \urcorner_{\tt{context}}$ = \\
$ \phantom{................................................}$  $\ulcorner \tt{[} \urcorner_{\tt{context}}$  \\
$ \phantom{................................................}$  $\ulcorner \tt{Expression} \urcorner_{\tt{context}}$\\ 
$ \phantom{................................................}$  $\ulcorner \tt{Arithmetic\_Expression} \urcorner_{\tt{context}}$ \\ 
%$ \phantom{................................................}$  0x00 

\subsubsection{Cast expression}

\begin{center}
\begin{tabular}{|c|c|}
   \hline
  symbol & \code \\
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
   \texttt{cast } &  0x62  \\
  \hline
\end{tabular}\\[2 mm]
Codes for cast symbol
\end{center}
$\ulcorner \tt{cast }\urcorner_{\tt{context}} $ = \code(\texttt{cast})

$\ulcorner \tt{cast} \ \tt{Expression} \ \tt{Expression} \urcorner_{\tt{context}}$ = \\
$ \phantom{................................................}$  $\ulcorner \tt{cast} \urcorner_{context} $ \\
$ \phantom{................................................}$  $\ulcorner \tt{Expression} \urcorner_{context}$\\ 
$ \phantom{................................................}$  $\ulcorner \tt{Expression} \urcorner_{context}$ \\ 
%$ \phantom{................................................}$  0x00 

\subsubsection{References} \label{Codesvariables}


\subsubsection{Variable Names}
Variable names denote either local variables (parameters) , class or instance fields, either JML ghost fields. 


\begin{tabular}{|c|l|}
\hline
kind of name   & compile name    \\
\hline 
Field name   & 0x80 \indexComp ( Field Name)    \\
& \\
 Local Variable &  0x90 \indexComp(  Local Variable )    \\
& \\
JML ghost Field name   & 0xA0 \indexComp (JML ghost Field name  )   \\
 ) \\ 
\hline
\end{tabular}\\[2 mm]

The function \indexComp is defined as follows : \\ \\ \\
\begin{tabular}{|c|l|}
\hline
Variable Identifier & \indexComp ( Name)\\
\hline
Field name  & the constant pool index at which a  ConstantFieldReference attribute \\
& describes the  field  \\
& \\
JML field name & the constant pool index at which a  ConstantFieldReference attribute \\
& describes the  field \\
& \\
Local Variable & the index of the registers of the method that represents \\
&  this variable(  + start\_ind + length )  \\
\hline
\end{tabular}

Two remarks :
\begin{enumerate}
\item the function \texttt{index } has the same definition for JML ghost fields and Java fields. Note that Java compiler adds constant fields data structures in the constant\_pool only for fields that are dereferenced. For any field that is mentioned in the specification but not dereferenced in the Java code a new constant field refernence will be added  on JML compilation time.
\item Note that Java compilers may generate code that uses the same register to store values of different types at different states of execution (and consequently at different points in the bytecode ). In the present specification we consider that any register contains exactly one type of values at any point in the code and that it hold not more than one method parameter at any point in the bytecode.
\end{enumerate}

\subsubsection{Java keywords}\label{CodesJavakw}
\begin{center}
\begin{tabular}{|c|l|}
\hline
Java keyword  & \code  \\
\hline
\texttt{this} & \texttt{0x8000} \\
\texttt{null} & \texttt{0x06}   \\
\hline
\end{tabular}\\[2 mm]
Codes for Java keywords
\end{center}
$\ulcorner$ keyword $\urcorner_{context}$ = \code(keyword)\\


\textit{Note:} for the reserved Java keyword \texttt{this}, the JVMS always puts the reference to the \texttt{this} object at position 0 in the array of local variables for any non static method. 

\subsubsection{Fully qualified names} \label{References}

\begin{center}
\begin{tabular}{|c|c|}
\hline \\
symbol & \code \\ 
\hline \\
\texttt{.} & 0x63 \\
\hline
\end{tabular}\\[2 mm]
\end{center}


$\ulcorner \tt{.} \urcorner_{context} $ = \code( \texttt{.})  \\

$\ulcorner \tt{.} \ \tt{Expression_1}  \tt{Expression_2}  \urcorner_{context}$ =  \[ \left \{ \begin{array}{ll} 
   \ulcorner\tt{.} \urcorner_{\tt{context}}   \ulcorner \tt{Expression_2} \urcorner_{type(\tt{this})}  \  \ulcorner \tt{this}\urcorner_{\tt{context}}  & if \ \tt{Expression_1} == \tt{this} \\
    & \\
    \ulcorner \tt{Expression_2} \urcorner_{type(\tt{Expression_1})}                                             & if \ \tt{Expression_1} == \tt{super} \\
    & \\
    \ulcorner \tt{Expression_2} \urcorner_{\tt{Expression_1}}                                      & if \ \tt{Expression_1} \ is \  a  \ class \  name \\
    & \\
   \ulcorner\tt{.} \urcorner_{\tt{context}} \ulcorner \tt{Expression_2} \urcorner_{typelocal(s)} \ \ulcorner \tt{local(s)}\urcorner_{\tt{context}}  &  if \ \tt{Expression_1} \\
                                                                      &  is \ a \ local \ variable \\
                                                                      & \wedge \\
                                                                      & index\_in\_local\_array(\tt{Expression_1}  ) \\ 
                                                                      & == s \\
                                                                     
    & \\
   \ulcorner\tt{.} \urcorner_{\tt{context}} \ulcorner  \tt{Expression_2} \urcorner_{ret\_type(expr)} \ \ulcorner \tt{Expression_1}  \urcorner_{\tt{context}}  & if \ \tt{Expression_1}   = \\
                                                                                                                   & \phantom{...} \tt{ ( } \\
                                                                                                                   & \phantom{...} \tt{expr}\\
                                                                                                                   & \phantom{...} length(list\_expr)\\
                                                                                                                   & \phantom{...} list\_expr \\ 
                                                                                                                  
     & \\
    \ulcorner\tt{.} \urcorner_{\tt{context}} \ulcorner \tt{Expression_2} \urcorner_{elem\_type(expr_1)} \  \ulcorner  \tt{Expression_1} \urcorner_{\tt{context}}   
      & if \ \tt{Expression_1} = \\ 
                                                                                                                   & \phantom{...} \tt{ [ expr_1 \ expr_2} \\ 
   
   
    & \\   
   \ulcorner\tt{.} \urcorner_{\tt{context}} \ulcorner  \tt{Expression_2} \urcorner_{type(\tt{Expression_1})} \  \rm{code}(context, \tt{Expression_1})   & if \ \tt{Expression_1} \ is \\
   &  a \ field \ name \\
   
   & \\  
   \ulcorner\tt{.} \urcorner_{\tt{context}} \ulcorner  \tt{Expression_2} \urcorner_{type(\tt{Expression_1})} \  \ulcorner Expression_1 \urcorner_{\tt{context}}    & else  \\
                                       
                                            \end{array}
                                            \right .
                                            \]





\subsubsection{Specific keywords for the language} 
We introduce the keyword  \textrm{EXCEPTION} that may appear only in exceptional postconditions. It stands for the thrown exception  object
\begin{center}
\begin{tabular}{|c|c|}
\hline \\
\textrm{EXCEPTION} & 0xB5 \\
\hline
\end{tabular}\\[2 mm]
\subsubsection{Codes}
\end{center}
$\ulcorner \rm{EXCEPTION} \urcorner_{\tt{context}} $ = code(\textrm{EXCEPTION}) \\\\\\\\\\\\\\
 




\subsection{Codes}
\begin{center}
\begin{tabular}[t]{|c|c|l|}
\hline
\texttt{Code}&\texttt{Symbol}&\texttt{Grammar}\\
\hline
0x00 & $\tt{True}$  & \\
0x01 & $\tt{False}$ &\\
0x02 & $\wedge$ & Formula Formula \\
0x03 & $\vee$ & Formula Formula \\
0x04 & $\Rightarrow$ & Formula Formula \\
0x05 & $!$ & Formula\\
0x06 & $\forall$ & n $($ Type $)_n$ Formula \\
0x07 & $\exists$ & n $($ Type $)_n$ Formula \\
0x10 & $\tt{==} $ & Expression Expression \\ 
0x11 & $\tt{> } $ & Expression Expression \\
0x12 & $\tt{<}  $ & Expression Expression \\
0x13 & $\tt{<=} $ & Expression Expression \\
0x14 & $\tt{>= }$ & Expression Expression \\
0x15 & $\tt{instanceof }$ & Expression Type \\
0x16 & $\tt{<:}$ & Type Type \\
0x20 & $+$ & Expression Expression \\
0x21 & $-$ & Expression Expression \\
0x22 & $*$ & Expression Expression \\
0x23 & $/$ & Expression Expression \\
0x24 & $\%$ & Expression Expression \\
0x25 & $-$ & Expression \\
0x30 & $and$ & Expression Expression \\
0x31 & $or$ & Expression Expression \\
0x32 & $xor$ & Expression Expression \\
0x33 & $<<$ & Expression Expression \\
0x34 & $>>$ & Expression Expression \\
0x35 & $>>>$ & Expression Expression \\
0x40 & $\tt{int \ constant}$ & i \\
0x41 & $\tt{char \ constant}$ & i \\
0x50 & $\backslash$ \texttt{typeof} & Expression \\
0x51 & $\backslash$ \texttt{elemtype} & Type \\
0x52 & $\backslash$ \texttt{result} & \\
0x53 & $\ast$ & Expression \\
0x54 & $\backslash$ \texttt{type} & Expression \\ 
0x55 & $\backslash$ \texttt{Type} & \\ 
0x56 & $\backslash$ \texttt{old} & \\ 
0x60 & \texttt{(} & Expression n $($ Expression $)_n$\\
0x61 & \texttt{[} & Expression Expression \\
0x62 & \texttt{cast} & Type Expression \\
0x63 & \texttt{.}& Expression Expression \\
0x64 & \texttt{? :} & Formula Formula Formula \\
0x70 & \texttt{this} & \\
0x72 & \texttt{null} & \\
0x80 & Fieldref & i \\
0x90 & Local variable & i \\
0xA0 & JML ghost field& i\\
0xB0 & Methodref & i \\
0xC0 & Type & i \\
0xE0 & BoundVar & i \\
0xF0 & Stack \\
0xF1 & Counter \\
\hline
\end{tabular}\\[2 mm]
\end{center}

\end{appendix}


