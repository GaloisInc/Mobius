
BonSourceFile = List<SpecificationElement>! bonSpecification, Indexing indexing;
SpecificationElement :> InformalChart, ClassDictionary, StaticDiagram, DynamicDiagram, NotationalTuning;

Indexing = List<IndexClause>! indexes;
IndexClause = String! id, List<String>! indexTerms;

InformalChart :> SystemChart, ClassChart, ClusterChart, EventChart, ScenarioChart, CreationChart;

ClassDictionary = String! systemName, List<DictionaryEntry>! entries, Indexing indexing, String explanation, String part; 
DictionaryEntry = String! name, List<String>! clusters, String! description;

SystemChart = String! name, List<ClusterEntry>! clusters, Indexing indexing, String explanation, String part;
ClusterChart = String! name, List<ClassEntry>! classes, List<ClusterEntry>! clusters, Indexing indexing, String explanation, String part;
ClassChart = String! name, List<String>! inherits, List<String>! queries, List<String>! commands, List<String>! constraints, Indexing indexing, String explanation, String part;

ClusterEntry = String! name, String! description;
ClassEntry = String! name, String! description;
 

EventChart = String! systemName, Boolean! incoming, Boolean! outgoing, List<EventEntry>! entries, Indexing indexing, String explanation, String part; 
EventEntry = String! name, List<String>! involved;

ScenarioChart = String! systemName, List<ScenarioEntry>! entries, Indexing indexing, String explanation, String part;
ScenarioEntry = String! name, String! description;

CreationChart = String! name, List<CreationEntry>! entries, Indexing indexing, String explanation, String part;
CreationEntry = String! name, List<String>! types;

StaticDiagram = List<StaticComponent>! components, String extendedID, String comment;

StaticComponent :> Cluster, Clazz, StaticRelation;
Cluster = String! name, List<StaticComponent>! components, Boolean! reused, String comment; 
//Can root, deferred, effective be an enum? Similarly reused, persistent, interfaced?
Clazz = enum(ModA: ROOT, DEFERRED, EFFECTIVE, NONE) modA,
        enum(ModB: REUSED, PERSISTENT, INTERFACED, NONE) modB,  
        ClassInterface classInterface, List<FormalGeneric> generics, String comment;
StaticRelation :> InheritanceRelation, ClientRelation;

InheritanceRelation = BONType! child, BONType! parent, Multiplicity multiplicity, String semanticLabel;
ClientRelation = BONType! client, BONType! supplier, ClientEntityExpression clientEntities, TypeMark typeMark, String semanticLabel;
ClientEntityExpression :> ClientEntityList, Multiplicity;
ClientEntityList = List<ClientEntity>! entities;
Multiplicity = Integer! multiplicity;
ClientEntity :> Infix, Prefix, SupplierIndirection, ParentIndirection;
SupplierIndirection = IndirectionFeaturePart indirectionFeaturePart, GenericIndirection! genericIndirection;
IndirectionFeaturePart :> FeatureName, IndirectionFeatureList;
IndirectionFeatureList = List<FeatureName> featureNames;
ParentIndirection = GenericIndirection! genericIndirection;
GenericIndirection = String! indirectionElement;
NamedIndirection = String! className, List<IndirectionElement>! indirectionElements; 
IndirectionElement :> NamedIndirection, ClassName;
TypeMark = enum(Mark: NONE, HASTYPE, AGGREGATE, SHAREDMARK) mark, Integer multiplicity;
ClassName = String! name;
ClassInterface = List<Feature>! features, List<BONType>! parents, List<AssertionClause> invariant, Indexing indexing;  
Feature = List<FeatureSpecification>! featureSpecifications, List<String> selectiveExport, String comment;
FeatureSpecification = enum(Modifier: NONE, DEFERRED, EFFECTIVE, REDEFINED) modifier, List<String>! featureNames, List<FeatureArgument>! arguments, ContractClause! contracts, HasType hasType, RenameClause renaming, String comment;
HasType = TypeMark! mark, BONType! type;
ContractClause = List<AssertionClause> preconditions, List<AssertionClause> postconditions;


RenameClause = String! className, String! featureName;

FeatureArgument = String identifier, BONType! type;
FormalGeneric = String! identifier, BONType type;

Type = String! identifier, List<BONType>! actualGenerics, String! fullString;

AssertionClause = Expression! expression;

Expression :> Quantification, BinaryExp, UnaryExp;

Quantification = enum(Quantifier: FORALL, EXISTS) quantifier, List<VariableRange> variableRanges, Expression restriction, Expression! proposition;
VariableRange :> MemberRange, TypeRange;
MemberRange = List<String>! identifiers, Expression! expression;
TypeRange =  List<String>! identifiers, BONType! type;

BinaryExp = enum(Op: ADD, SUB, MUL, DIV, INTDIV, MOD, POW, EQUIV, IMPLIES, AND, OR, XOR, LT, LE, GE, GT, EQ, NEQ, MEMBEROF, NOTMEMBEROF, HASTYPE) op, 
            Expression! left, Expression! right;

UnaryExp = enum(Op: NOT, DELTA, OLD, ADD, SUB) op, Expression! expression;

DynamicDiagram = List<DynamicComponent>! components, String extendedId, String comment;
DynamicComponent :> ScenarioDescription, ObjectGroup, ObjectStack, ObjectInstance, MessageRelation;
ScenarioDescription = String! name, List<LabelledAction>! actions, String comment;
LabelledAction = String! label, String! description;

ObjectGroup = enum(Nameless: NAMELESS, NOTNAMELESS) nameless, String! name, List<DynamicComponent>! components, String comment;
ObjectStack = ObjectName! name, String comment;
ObjectInstance = ObjectName! name, String comment;
ObjectName = String! className, String extendedId;