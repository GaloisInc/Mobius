
BONSourceFile = List<SpecificationElement>! bonSpecification, Indexing indexing;
SpecificationElement :> InformalChart, ClassDictionary, StaticDiagram, DynamicDiagram, NotationalTuning;

Indexing = List<IndexClause>! indexes;
IndexClause = String! id, List<String>! indexTerms;

InformalChart :> SystemChart, ClassChart, EventChart, ScenarioChart, CreationChart;

ClassDictionary = String! systemName, List<DictionaryEntry> entries, Indexing indexing, String explanation, String part; 
DictionaryEntry = String! name, List<String>! clusters, String! description;

SystemChart = String! name, List<ClusterEntry>! clusters, Indexing indexing, String explanation, String part;
ClusterChart = String! name, List<ClassEntry>! classes, List<ClusterEntry>! clusters, Indexing indexing, String explanation, String part;
ClassChart = String! name, List<String>! inherits, List<String>! queries, List<String>! commands, List<String>! constraints, Indexing indexing, String explanation, String part;

ClusterEntry = String! name, String! description;
ClassEntry = String! name, String! description;
 

EventChart = String! systemName, Boolean! incoming, Boolean! outgoing, List<EventEntry>! entries, Indexing indexing, String explanation, String part; 
EventEntry = String! name, List<String>! involved;

ScenarioChart = String! systemName, List<ScenarioEntry>! entries, Indexing indexing, String explanation, String part;
ScenarioEntry = String! name, String! description;

CreationChart = String! name, List<CreationEntry>! entries, Indexing indexing, String explanation, String part;
CreationEntry = String! name, List<String>! types;

StaticDiagram = List<StaticComponent>! components, String extendedID, String comment;

StaticComponent :> Cluster, Clazz, StaticRelation;
Cluster = String! name, List<StaticComponent>! components, Boolean! reused, String comment; 
//Can root, deferred, effective be an enum? Similarly reused, persistent, interfaced?
Clazz = Boolean! root, Boolean! deferred, Boolean! effective, Boolean! reused, Boolean! persistent, Boolean! interfaced, ClassInterface classInterface, List<FormalGeneric> generics, String comment;
StaticRelation :> InheritanceRelation, ClientRelation;

InheritanceRelation = StaticRef! child, StaticRef! parent, Multiplicity multiplicity, String semanticLabel;
ClientRelation = StaticRef! client, StaticRef! supplier, ClientEntityExpression clientEntities, TypeMark typeMark, String semanticLabel;
ClientEntityExpression :> ClientEntityList, Multiplicity;
ClientEntityList = List<ClientEntity>! entities;

ClientEntity :> Infix, Prefix, SupplierIndirection, ParentIndirection;
SupplierIndirection = IndirectionFeaturePart indirectionFeaturePart, GenericIndirection! genericIndirection;
IndirectionFeaturePart :> FeatureName, IndirectionFeatureList;
IndirectionFeatureList = List<FeatureName> featureNames;
ParentIndirection = GenericIndirection! genericIndirection;
GenericIndirection = String! indirectionElement;
NamedIndirection = String! className, List<IndirectionElement>! indirectionElements; 
IndirectionElement :> NamedIndirection, ClassName;
TypeMark = Boolean! hasMark, Boolean! isAggregate, Boolean! isSharedMark, Integer! multiplicity;
StaticRef = BONType! type;
ClassName = String! name;
ClassInterface = List<Feature>! features, List<BONType>! parents, Invariant invariant, Indexing indexing;  
Feature = List<FeatureSpecification> featureSpecifications, List<String> selectiveExport, String comment;
FeatureSpecification = List<String>! featureNames, Boolean! deferred, Boolean! effective, Boolean! redefined, List<FeatureArgument>! arguments, HasType hasType, RenameClause renaming, ContractClause contracts, String comment;
HasType = TypeMark! mark, BONType! type;
ContractClause = List<AssertionClause> preconditions, List<AssertionClause> postconditions;
Invariant = List<AssertionClause>! clauses;


RenameClause = String! className, String! featureName;

FeatureArgument = String identifier, BONType! type;
FormalGeneric = String! identifier, BONType type;

Type = String! identifier, List<BONType>! actualGenerics, String! fullString;

AssertionClause = Expression! expression;

Expression :> Quantification, BinaryExp, UnaryExp;

Quantification = enum(Quant: FORALL, EXISTS) quantifier, List<VariableRange> variableRanges, Expression restriction, Expression! proposition;
VariableRange :> MemberRange, TypeRange;
MemberRange = List<String>! identifiers, Expression! expression;
TypeRange =  List<String>! identifiers, BONType! type;

BinaryExp = enum(Op: ADD, SUB, MUL, DIV, INTDIV, MOD, EQUIV, IMPLIES, AND, OR, XOR, LT, LE, GE, GT, EQ, NEQ, MEMBEROF, NOTMEMBEROF, HASTYPE) op, 
            Expression! left, Expression! right;

UnaryExp = enum(Op: NOT, DELTA, OLD, ADD, SUB) op, Expression! expression;