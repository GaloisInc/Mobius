S
negb: (->  bool {[?]} bool {[?]})
integralLE: (->  Z {[?]} (->  Z {[?]} bool {[?]}) {[?]})
Zeq_bool: (->  Z {[?]} (->  Z {[?]} bool {[?]}) {[?]})
\/: (->  Prop {[?]} (->  Prop {[?]} Prop {[?]}) {[?]})
<>: (->  S {[T]} (->  S {[T]} Prop {[?]}) {[?]})
=: (->  Z {[?]} (->  Z {[?]} Prop {[?]}) {[?]})
S_to_Z: (->  S {[T]} Z {[?]})
Z_to_S: (->  Z {[?]} S {[T]})
Z_to_S_elim: (forall x {Z}, (= {Z -> Z -> Prop} (S_to_Z {S -> Z} (Z_to_S {Z -> S} x {Z}) {S}) {Z} x {Z}))
S_to_bool: (->  S {[T]} bool {[?]})
select: (->  S {[T]} (->  S {[T]} S {[T]}) {[?]})
store: (->  S {[T]} (->  S {[T]} (->  S {[T]} S {[T]}) {[?]}) {[?]})
arr_store: (->  S {[T]} (->  Z {[?]} (->  S {[T]} S {[T]}) {[?]}) {[?]})
store_int: (->  S {[T]} (->  S {[T]} (->  Z {[?]} S {[T]}) {[?]}) {[?]})
arr_store_int: (->  S {[T]} (->  Z {[?]} (->  Z {[?]} S {[T]}) {[?]}) {[?]})
store_bool: (->  S {[T]} (->  S {[T]} (->  bool {[?]} S {[T]}) {[?]}) {[?]})
arr_store_bool: (->  S {[T]} (->  Z {[?]} (->  bool {[?]} S {[T]}) {[?]}) {[?]})
null: S
isAllocated: (->  S {[T]} (->  S {[T]} Prop {[?]}) {[?]})
fClosedTime: (->  S {[T]} S {[T]})
refEQ: (->  S {[T]} (->  S {[T]} bool {[?]}) {[?]})
Types
subtypes: (->  Types {[T]} (->  Types {[T]} Prop {[?]}) {[?]})
typeof: (->  S {[T]} Types {[T]})
lockLT: (->  S {[T]} (->  S {[T]} Prop {[?]}) {[?]})
isField: (->  S {[T]} Prop {[?]})
allocNew_: S
asField: (->  S {[T]} (->  Types {[T]} Prop {[?]}) {[?]})
asElems: (->  S {[T]} Prop {[?]})
asLockSet: (->  S {[T]} Prop {[?]})
eClosedTime: (->  S {[T]} S {[T]})
arrayFresh: (->  S {[T]} (->  S {[T]} (->  S {[T]} (->  S {[T]} (->  S {[T]} (->  Types {[T]} (->  S {[T]} Prop {[?]}) {[?]}) {[?]}) {[?]}) {[?]}) {[?]}) {[?]})
arrayShapeOne: (->  S {[T]} S {[T]})
arrayShapeMore: (->  S {[T]} (->  S {[T]} S {[T]}) {[?]})
isNewArray: (->  S {[T]} Prop {[?]})
arrayLength: (->  S {[T]} S {[T]})
arrayLengthAx: 
  (forall a {S}, 
    (integralLE {Z -> Z -> bool} 0 {Z} 
    (S_to_Z {S -> Z} 
    (arrayLength {S -> S} a {S}) {S}) 
    {Z}))
array_axiom2_2: (forall n {S} e {S} b0 {S} a0 {S} a {S} T {Types} v {S}, (->  (arrayFresh {S -> S -> S -> S -> S -> Types -> S -> Prop} a {S} a0 {S} b0 {S} e {S} (arrayShapeOne {S -> S} n {S}) {S} T {Types} v {S}) {Prop} (isAllocated {S -> S -> Prop} a {S} b0 {S}) {Prop}))
array_axiom2_3: (forall n {S} e {S} b0 {S} a0 {S} a {S} T {Types} v {S}, (->  (arrayFresh {S -> S -> S -> S -> S -> Types -> S -> Prop} a {S} a0 {S} b0 {S} e {S} (arrayShapeOne {S -> S} n {S}) {S} T {Types} v {S}) {Prop} (<> {S -> S -> Prop} a {S} null {S}) {Prop}))
ecReturn: S
ecThrow: S
distinctAxiom: (<> {S -> S -> Prop} ecReturn {S} ecThrow {S})

[
 ** elimAnd
 elimAnd is used mainly to eliminate and within the hypothesis.
For the goals the preferred tactic is still split. ]

[
 ** elimNor
This tactic is used to remove the not in front of a or (in the hypothesis),
turning (~ (A \/  B) ) into ((~ A) /\ (~ B)).
 ]

[
 ** Cleansing
To clean up the mess (sometimes). ]
a_ou_a_donne_a: (forall a {Prop}, (->  (\/ {Prop -> Prop -> Prop} a {Prop} a {Prop}) {Prop} a {Prop}))
