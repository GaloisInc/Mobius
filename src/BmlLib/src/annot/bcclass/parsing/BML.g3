grammar BML;

options {
	output=AST;
	ASTLabelType=CommonTree;
	backtrack=true;
}

@header {
	package annot.bcclass.parsing;
	import annot.bcclass.*;
	import annot.bcclass.attributes.*;
	import annot.bcexpression.*;
	import annot.formula.*;
}

@members {
	public RecognitionException lastE = null;
	
	private BCMethod m;
	private int pc;

	// set context for attribute parsing.
	public void init(BCMethod m, int pc) {
		this.m = m;
		this.pc = pc;
	}

	public void reportError(RecognitionException re) {
		lastE = re;
//		System.out.println("PARSER ERROR");
//		super.reportError(re);
	}
}

@lexer::header {
	package annot.bcclass.parsing;
}

@lexer::members {
	public RecognitionException lastE = null;

	public void reportError(RecognitionException re) {
		lastE = re;
		System.out.println("LEXER ERROR");
		super.reportError(re);
	}
}

// parser :

printableAttribute returns [BCPrintableAttribute ast] :
	ASSERT f=formula EOF {$ast = new Assert($f.ast, pc, m);};

expression returns [Expression ast] :
	e=conditionalExpr {$ast = $e.ast;}
	| se=shiftExpr {$ast = $se.ast;}
	;

conditionalExpr returns [Expression ast] :
	se=shiftExpr {$ast = $se.ast;}
	| (e=formula
		COND1 t=conditionalExpr
		COND2 f=conditionalExpr)
			{$ast = new ConditionalExpression($e.ast, $t.ast, $f.ast);}
	;

formula returns [Formula ast] :
	UNKNOWN {$ast = new UnknownFormula();}
	| e=equivalenceExpr {$ast = $e.ast;}
	;

equivalenceExpr returns [Formula ast] :
	e=impliesExpr {$ast = $e.ast;}
	(EQUIV r=impliesExpr {$ast = new Formula($ast, $r.ast, Connector.EQUIV);})*
	;

impliesExpr returns [Formula ast] :
	e=logicalOrExpr {$ast = $e.ast;};

logicalOrExpr returns [Formula ast] :
	e=logicalAndExpr {$ast = $e.ast;};

logicalAndExpr returns [Formula ast] :
	e=inclusiveOrExpr {$ast = $e.ast;};

inclusiveOrExpr returns [Formula ast] :
	e=exclusiveOrExpr {$ast = $e.ast;};

exclusiveOrExpr returns [Formula ast] :
	e=andExpr {$ast = $e.ast;};

andExpr returns [Formula ast] :
	e=equalityExpr {$ast = $e.ast;};

equalityExpr returns [Formula ast] :
	e=relationalExpr {$ast = $e.ast;};

relationalExpr returns [Formula ast] :
	l=shiftExpr LESS r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.LESS);}
	| FALSE {$ast = Predicate0Ar.FALSE;}
	| TRUE {$ast = Predicate0Ar.TRUE;}
	| PAR_LEFT f=formula PAR_RIGHT {$ast = $f.ast;}
	;

shiftExpr returns [Expression ast] :
	e=additiveExpr {$ast = $e.ast;};

additiveExpr returns [Expression ast] :
	e=multExpr {$ast = $e.ast;};

multExpr returns [Expression ast] :
	e=unaryExpr {$ast = $e.ast;};

unaryExpr returns [Expression ast] :
	e=unaryExprNotPlusMinus {$ast = $e.ast;};

unaryExprNotPlusMinus returns [Expression ast] :
	e=postfixExpr {$ast = $e.ast;};

postfixExpr returns [Expression ast] :
	e=primaryExpr {$ast = $e.ast;};

primaryExpr returns [Expression ast] :
	PAR_LEFT e=expression PAR_RIGHT {$ast = $e.ast;}
	| n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
	;

// lexer :

ASSERT: 'assert';
UNKNOWN: '#';
COND1: '?';
COND2: ':';
PAR_LEFT: '(';
PAR_RIGHT: ')';
LESS: '<';
FALSE: 'false';
TRUE: 'true';
EQUIV: '<==>';

NAT: ('0'..'9')+;

WS: (' '|'\t')+ {skip();};
EOF: '\f';
