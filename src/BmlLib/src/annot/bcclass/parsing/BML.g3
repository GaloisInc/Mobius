grammar BML;

options {
	output=AST;
	ASTLabelType=CommonTree;
	backtrack=true;
}

@header {
	package annot.bcclass.parsing;
	import annot.bcclass.*;
	import annot.bcclass.attributes.*;
	import annot.bcexpression.*;
	import annot.formula.*;
}

@members {
	public RecognitionException lastE = null;
	
	private BCMethod m;
	private int pc;

	// set context for attribute parsing
	public void init(BCMethod m, int pc) {
		this.m = m;
		this.pc = pc;
	}

	public void reportError(RecognitionException re) {
		lastE = re;
//		System.out.println("PARSER ERROR");
//		super.reportError(re);
	}
}

@lexer::header {
	package annot.bcclass.parsing;
}

@lexer::members {
	public RecognitionException lastE = null;

	public void reportError(RecognitionException re) {
		lastE = re;
		System.out.println("LEXER ERROR");
		super.reportError(re);
	}
}

// parser :

printableAttribute returns [BCPrintableAttribute ast] :
	ASSERT f=formula EOF {$ast = new Assert($f.ast, pc, m);};

expression returns [Expression ast] :
	e=conditionalExpr {$ast = $e.ast;}
	| ioe=inclusiveOrExpr {$ast = $ioe.ast;}
	;

conditionalExpr returns [Expression ast] :
	(e=formula
		COND1 t=expression
		COND2 f=expression)
			{$ast = new ConditionalExpression($e.ast, $t.ast, $f.ast);}
	;

formula returns [Formula ast] :
	UNKNOWN {$ast = new UnknownFormula();}
	| e=equivalenceExpr {$ast = $e.ast;}
	;

equivalenceExpr returns [Formula ast] :
	e=impliesExpr {$ast = $e.ast;}
	( EQUIV r=impliesExpr {$ast = new Formula($ast, $r.ast, Connector.EQUIV);}
		| NOTEQUIV r=impliesExpr {$ast = new Formula($ast, $r.ast, Connector.NOTEQUIV);}
	)*;

impliesExpr returns [Formula ast] :
	e=logicalOrExpr {$ast = $e.ast;}
	(IMPLIES r=logicalOrExpr {$ast = new Formula($ast, $r.ast, Connector.IMPLIES);})?;

logicalOrExpr returns [Formula ast] :
	e=logicalAndExpr {$ast = $e.ast;}
	(LOG_OR r=logicalAndExpr {$ast = new Formula($ast, $r.ast, Connector.OR);})*;

logicalAndExpr returns [Formula ast] :
	e=equalityExpr {$ast = $e.ast;}
	(LOG_AND r=equalityExpr {$ast = new Formula($ast, $r.ast, Connector.AND);})*;

inclusiveOrExpr returns [Expression ast] :
	e=exclusiveOrExpr {$ast = $e.ast;}
	(OR r=exclusiveOrExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.BITWISEOR);})*;

exclusiveOrExpr returns [Expression ast] :
	e=andExpr {$ast = $e.ast;}
	(XOR r=andExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.BITWISEXOR);})*;

andExpr returns [Expression ast] :
	e=shiftExpr {$ast = $e.ast;}
	(AND r=shiftExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.BITWISEAND);})*;

equalityExpr returns [Formula ast] :
	e=relationalExpr {$ast = $e.ast;};

relationalExpr returns [Formula ast] :
	l=shiftExpr EQ r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.EQ);}
	| l=shiftExpr NEQ r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.NOTEQ);}
	| l=shiftExpr LESS r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.LESS);}
	| l=shiftExpr GRT r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.GRT);}
	| l=shiftExpr LESSEQ r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.LESSEQ);}
	| l=shiftExpr GRTEQ r=shiftExpr
		{$ast = new Predicate2Ar($l.ast, $r.ast, PredicateSymbol.GRTEQ);}
	| FALSE {$ast = Predicate0Ar.FALSE;}
	| TRUE {$ast = Predicate0Ar.TRUE;}
	| PAR_LEFT f=formula PAR_RIGHT {$ast = $f.ast;}
	;

shiftExpr returns [Expression ast] :
	e=additiveExpr {$ast = $e.ast;}
	( SHL l=additiveExpr {$ast = new ArithmeticExpression($ast, $l.ast, ExpressionConstants.SHL);}
		| SHR r=additiveExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.SHR);}
		| USHR u=additiveExpr {$ast = new ArithmeticExpression($ast, $u.ast, ExpressionConstants.USHR);}
	)*;
		
additiveExpr returns [Expression ast] :
	e=multExpr {$ast = $e.ast;}
	( PLUS r=multExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.ADD);}
		| MINUS r=multExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.SUB);}
	)*;

multExpr returns [Expression ast] :
	e=unaryExpr {$ast = $e.ast;}
	( MULT r=unaryExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.MULT);}
		| DIV r=unaryExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.DIV);}
		| REM r=unaryExpr {$ast = new ArithmeticExpression($ast, $r.ast, ExpressionConstants.REM);}
	)*;

unaryExpr returns [Expression ast] :
	e=unaryExprNotPlusMinus {$ast = $e.ast;}
	| MINUS e=unaryExprNotPlusMinus {$ast = new ArithmeticExpression($e.ast, ExpressionConstants.NEG);}
	| PLUS e=unaryExprNotPlusMinus {$ast = $e.ast;}
	;

unaryExprNotPlusMinus returns [Expression ast] :
	e=postfixExpr {$ast = $e.ast;};

postfixExpr returns [Expression ast] :
	e=primaryExpr {$ast = $e.ast;} (
		DOT LV LEFT_BR n=NAT RIGHT_BR
			{int index = Integer.parseInt($n.text);
			BCLocalVariable bcl = new BCLocalVariable("?", -1, -1, index, null, m);
			$ast = new FieldAccess(bcl, $ast);
			}
	)*;

primaryExpr returns [Expression ast] :
	PAR_LEFT e=expression PAR_RIGHT {$ast = $e.ast;}
	| n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
	| THIS {$ast = BCLocalVariable.THIS;}
	| NULL {$ast = annot.bcexpression.NULL.getNULL();}
	;

// lexer :

ASSERT: 'assert';
UNKNOWN: '#';
COND1: '?';
COND2: ':';
PAR_LEFT: '(';
PAR_RIGHT: ')';
LESS: '<';
GRT: '>';
LESSEQ: '<=';
GRTEQ: '>=';
FALSE: 'false';
TRUE: 'true';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
IMPLIES: '==>';
LOG_OR:	'||';
LOG_AND: '&&';
OR: '|';
XOR: '^';
AND: '&';
EQ: '==';
NEQ: '!=';
SHL: '<<';
SHR: '>>';
USHR: '>>>';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
REM: '%';
NULL: 'NULL';
THIS: 'this';
DOT: '.';
LV: 'lv';
LEFT_BR: '[';
RIGHT_BR: ']';

NAT: ('0'..'9')+;

WS: (' '|'\t')+ {skip();};
EOF: '\f';
