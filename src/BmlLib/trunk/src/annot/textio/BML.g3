/*
 * @title       "Umbra"
 * @description "An editor for the Java bytecode and BML specifications"
 * @copyright   "(c) 2006-2008 University of Warsaw"
 * @license     "All rights reserved. This program and the accompanying
 *               materials are made available under the terms of the LGPL
 *               licence see LICENCE.txt file"
 */
grammar BML;

options {
  output=AST;
  ASTLabelType=CommonTree;
  backtrack=true;
}

@header {
  package annot.textio;

  import annot.bcclass.*;
  import annot.attributes.*;
  import annot.bcexpression.*;
  import annot.bcexpression.javatype.*;
  import annot.bcexpression.modifies.*;
  import annot.bcexpression.formula.*;
  import annot.io.Code;
  import annot.io.ReadAttributeException;

  import org.apache.bcel.generic.MethodGen;
  import org.apache.bcel.generic.InstructionHandle;
  import org.apache.bcel.generic.InstructionList;
  import java.util.Vector;
}

@members {
  public RecognitionException lastE = null;
  
  // initial data (parser parameters)
  private BCClass bcc;
  private BCMethod m;
  private BCConstantPool cp;
  private InstructionHandle ih;
  private int minor;
  private boolean affectBcc = false;

  // global variables
  private int mnr;            // number of current method
  private int inr;            // number of current instruction
  private int bvc;              // number of currently visible bound variables
  private int lqfs;             // last (current) quantified formula size
  private HashMap<String, BoundVar> env;  // bound variable map
  private Vector<PosInCode> bml_positions = new Vector(); //postions of BML areas
  
  //local variables
  private boolean clr = false;
  private AbstractFormula prec;
  private ModifyList modif;
  private AbstractFormula postc;
  private Vector<Exsure> exc;
  private AbstractFormula inv;
  private AbstractIntExpression dec;

  // set whether to affect parsed BCClass, or only check syntax
  public void initClass(BCClass bcc, boolean affectBcc) {
    this.bcc = bcc;
    this.affectBcc = affectBcc;
    this.cp = bcc.getCp();
  }

  // initialize environment for expression parsing
  private void initExpression() {
    this.bvc = 0;
    this.lqfs = 0;
    this.env = new HashMap<String, BoundVar>();
  }

  // set context for attribute parsing
  public void init(BCClass bcc, BCMethod m, BCConstantPool cp, InstructionHandle ih, int minor) {
    this.bcc = bcc;
    this.m = m;
    this.cp = cp;
    this.ih = ih;
    this.minor = minor;
  }

  private void syso(String msg) {
    MLog.putMsg(MLog.LEVEL_PPARSER, msg);
  }

  public void reportError(RecognitionException rex) {
    if (rex == null)
      rex = new RecognitionException();
    lastE = rex;
    syso("*** error ***");
    if ((MLog.getLogMask() & MLog.LEVEL_PPARSER) > 0)
      super.reportError(rex);
  }
  
  // Searches for an identifier name in diffrent locations
  // and returns proper one, or null if no identifier
  // of this name could be found.
  private BCExpression whatIsIt(String ident) {
    if (ident == null) {
      reportError(null);
      return null;
    }
    boolean isOld = false;
    if (ident.startsWith("old_")) { //??!
      ident = ident.substring(4);
      isOld = true;
    }
    if (env.containsKey(ident))
      return new SingleOccurence(env.get(ident));
    if (m != null) {
      LocalVariable lv = m.findLocalVariable(ident);
      if (lv != null) {
        lv.setOld(isOld);
        return new SingleOccurence(lv);
      }
    }
    FieldRef bfr = FieldRef.getFieldOfName(isOld, bcc.getCp(), ident);
    if (bfr != null)
      return bfr;
    MLog.putMsg(MLog.LEVEL_PINFO, "undefined identifier: " + ident);
    reportError(null);
    return null;
  }
  
  public Vector<PosInCode> getBMLPositions() {
    return bml_positions;
  }
}

@lexer::header {
  package annot.textio;
  import annot.bcclass.*;
}

@lexer::members {
  public RecognitionException lastE = null;

  public void reportError(RecognitionException rex) {
    lastE = rex;
    MLog.putMsg(MLog.LEVEL_PPARSER, "LEXER ERROR");
    if ((MLog.getLogMask() & MLog.LEVEL_PPARSER) > 0) {
      System.err.println("LEXER ERROR");
      super.reportError(rex);
    }
  }
}

// ***** PARSER RULES *****

// bytecode level

parseClass :
  {syso("--------------- parsing started ---------------");}
  fileheader typeheader typebody EOF
  {syso("-------------- parsing completed --------------");};

fileheader :
  packageinfo constant_pools;

packageinfo :
  PACKAGE ( DEFAULTPACKAGE | typename ) (EOL)+
  {syso("packageinfo");};

typename returns [String name] :
    i=IDENT { $name = $i.getText(); }
    ((DIV | DOT) n=typename { $name +=  '/' + $n.name; })?
  | STRING_CP { $name = "String"; }
    ((DIV | DOT) n=typename { $name +=  '/' + $n.name; })?;

constant_pools : constant_pool ( second_constant_pool )? EOL;

constant_pool : CONSTANT_POOL EOL constant_pool_content
  {syso("constant_pool");};

second_constant_pool : SECOND_CONSTANT_POOL EOL constant_pool_content;

constant_pool_content : constant_pool_line EOL ( constant_pool_line EOL )*;

constant_pool_line : CONST cp_ref EQUALS constant_pool_entry;

constant_pool_entry : class_cp_entry | field_cp_entry 
   | method_cp_entry | interface_method_cp_entry
   | string_cp_entry | integer_cp_entry | float_cp_entry
   | long_cp_entry | double_cp_entry
   | name_and_type_cp_entry | utf8_cp_entry;
   
class_cp_entry : CLASS_CP cp_ref SEMICOLON ;

field_cp_entry : FIELDREF_CP cp_ref.cp_ref SEMICOLON;

method_cp_entry : METHODREF_CP cp_ref DOT cp_ref SEMICOLON;

interface_method_cp_entry : INTERFACEMETHODREF_CP cp_ref DOT cp_ref SEMICOLON;

string_cp_entry : STRING_CP cp_ref SEMICOLON;

integer_cp_entry : INTEGER_CP ( sign )? NAT SEMICOLON;

float_cp_entry : FLOAT_CP ( sign )? floating_point_literal SEMICOLON;

long_cp_entry : LONG_CP ( sign )? NAT SEMICOLON;

double_cp_entry : DOUBLE_CP ( sign )? floating_point_literal SEMICOLON;

name_and_type_cp_entry : NAMEANDTYPE_CP cp_ref COLON cp_ref SEMICOLON;

//slight simplification, any non-newline character is accepted as string
utf8_cp_entry : UTF8_CP (~('\n'))* SEMICOLON;

cp_ref : HASH NAT;

sign : PLUS | MINUS;

exponent_indicator : 'e' | 'E';

signed_integer : ( sign )? NAT;

exponent_part : exponent_indicator signed_integer;

floating_point_literal : NAT DOT ( NAT )? ( exponent_part )? ( float_type_suffix )?
        | DOT NAT ( exponent_part )? ( float_type_suffix )?
        | NAT exponent_part ( float_type_suffix )?
        | NAT ( exponent_part )? float_type_suffix;

float_type_suffix : 'f' | 'F' | 'd' | 'D';

typeheader :
  (  classmodifiers CLASS dotedname
     class_extends_clause? implements_clause?
   | interfacemodifiers INTERFACE dotedname
     interface_extends_clause? implements_clause?) (EOL)+
  {syso("type header");};

dotedname :
  IDENT ( DOT IDENT)*;

classmodifiers :
  classmodifier* {syso("class modifiers");};
  
interfacemodifiers :
  interfacemodifier* {syso("interface modifiers");};

classmodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | ABSTRACT
   | STATIC
   | FINAL
   | STRICTFP) {syso("class modifier");};
   
interfacemodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | ABSTRACT
   | STATIC
   | STRICTFP) {syso("interface modifier");};

class_extends_clause :
  EXTENDS typename
  {syso("class_extends_clause");};

interface_extends_clause :
  EXTENDS name_list
  {syso("interface_extends_clause");};

implements_clause :
  IMPLEMENTS name_list
  {syso("implements_clause");};

name_list :
  typename ( COMMA typename )*
  {syso("name_list");};

typebody :
  (staticsection)?
  (objectsection)?
  { syso("methods start here");
    mnr = 0;
    m = bcc.getMethod(mnr);
  }
  (method
   {
      syso("method");
      mnr++;
      if (mnr < bcc.getMethodCount())
        m = bcc.getMethod(mnr);
   })+
  {
     syso("methods parsed");
  };

staticsection :
  staticfields? staticspec?
  {
     syso("static section");
  };

staticfields : STATIC STATIC;

staticspec : staticinvariants? staticconstraints?
             staticrepresents? staticinitially?;

staticinvariants : BML_START STATIC INVARIANT BML_END EOL;

staticconstraints : BML_START STATIC CONSTRAINT BML_END EOL;

staticrepresents : BML_START STATIC REPRESENTS BML_END EOL;

staticinitially : BML_START STATIC INITIALLY BML_END EOL;

objectsection :
  objectfields? objectspec? (EOL)*
  {
     syso("object section");
  };

objectfields : PUBLIC PUBLIC;

objectspec : objectinvariants? objectconstraints?
             objectrepresents? objectinitially?;

objectinvariants :
  (objectinvariant)+ EOL
  {
     syso("object invariants");
  };

objectinvariant : 
     BML_START (EOL)? methodmodifier? INVARIANT f=formula (EOL)? BML_END EOL
     {
        if ($f.ast != null) {
          ClassInvariant inv = new ClassInvariant(bcc, $f.ast, true);
          bcc.setInvariant(inv);
        }
     }
  |  BML_START (EOL)* BML_END EOL
     {
        {syso("empty object invariant");}
     }
  |  BML_START (~('\n')* EOL)* BML_END EOL
     {
        {syso("wrong object invariant");}
     };

objectconstraints : BML_START CONSTRAINT BML_END EOL;
 
objectrepresents : BML_START REPRESENTS BML_END EOL;

objectinitially : BML_START INITIALLY BML_END EOL;

method :
   { syso("before method spec");}
   (met=methodSpecification {
      if ($met.ast != null) {
        syso("method attribute");
        if (clr) {
          syso("clearing method attributes");
          if (affectBcc) {
            m.setMspec(null);
            m.setMLocalSpecs(null);
          }
          clr = false;
        }
        if (affectBcc)
          $met.ast.replace(m);
      } else {
        syso("empty method attribute");
      }
    }) methodmodifiers type_spec? methodheader
        {
          if (clr) {
            syso("clearing method attributes");
            if (affectBcc) {
              m.setMspec(null);
              m.setMLocalSpecs(null);
            }
            clr = false;
          }
          syso("method header");
          inr = 0;
        }
        method_body
        {
           if (m.getInstructions() != null &&
               inr != m.getInstructions().getInstructionHandles().length) {
             syso("instruction count changed (2)");
             syso("previous length is: " + m.getInstructions().getInstructionHandles().length);
             syso("inr is: " + inr);
             reportError(null);
           }
           syso("end of method");
        } (EOL)*;

method_body :
   (specss=bml_in_method_spec? instruction_line
          {
             inr++;
             if ( specss != null ) {
           		  if (m != null && $specss.ast != null) {
               		$specss.ast.setIh(ih);
              	  m.addAttribute($specss.ast);
               		specss = null;
                }
             }
             syso("inner spec + instruction line");
          })+
 | EOL
   {
     syso("empty method body");
   };

methodmodifiers :
  methodmodifier* {syso("method modifiers");};
  
methodmodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | STATIC
   | ABSTRACT
   | FINAL
   | NATIVE
   | SYNCHRONIZED
   | TRANSIENT
   | VOLATILE
   | STRICTFP) {syso("method modifier");};  

type_spec :
    type (dims)? {syso("type_spec");};

type :
    reference_type
  | built_in_type ;
  
reference_type :
  name=typename {syso("reference type: " + $name.name);};

built_in_type :
  (  VOID
   | BOOLEAN
   | BYTE
   | CHAR
   | SHORT
   | INT
   | LONG
   | FLOAT
   | DOUBLE) {syso("built in type");};


methodheader :
  (i=IDENT | i=CONSNAME | i = STATICCONSNAME)
  {
     syso("method IDENT=" + $i.getText());
  }
  formals dims? EOL throws_clause?
  {
     syso("methodheader parsed");
  };

formals : 
  PAR_LEFT {syso("before param_declaration_list");} param_declaration_list? PAR_RIGHT;

param_declaration_list : {syso("started param_declaration_list");}
    param_declaration
      {
         syso("first param");
      }
    (COMMA param_declaration
      {
         syso("second or further param");
      }
    )*
  | param_declaration_noname (COMMA param_declaration_noname)*;

param_declaration :
  param_modifier? type_spec (i=IDENT
    {
       syso("IDENT=" + $i.getText());
    } | exponent_indicator | float_type_suffix)
  dims?
    {
      syso("param_declaration");
    };

param_declaration_noname :
  param_modifier? type_spec 
    {
       syso("noname ident");
    } 
  dims?
    {
      syso("param_declaration_noname");
    };

param_modifier :
  'final' | 'nullable' | 'non_null';

dims :
  (BR_LEFT BR_RIGHT)+
  {syso("dims");};
  
throws_clause :
  (THROWS typename EOL)+;

bml_in_method_spec returns [InCodeAttribute ast] :
      BML_ONE_LINE_START assrt=assertspec EOL
      {
         if ($assrt.ast != null) {
           $ast = $assrt.ast;
         }
         syso("one line assert with //@");
      }
   |  st=BML_START EOL*
      attr=inCodeAttribute EOL* en=BML_END EOL
      {
         $ast = $attr.ast;
         syso("inCodeAttribute in /*@ @*/");
      }
   | EOL
     {
       $ast = null;
       syso("empty BML spec inside method body");
     };

instruction_line returns [InstructionHandle ih] :
  { 
    if (m == null) {
      throw new RecognitionException();
    };
    MethodGen mg = m.getBcelMethod();
    if (mg == null) {
      throw new RecognitionException();
    }
    InstructionList il = mg.getInstructionList();
    if (il == null) {
      throw new RecognitionException();
    }
    InstructionHandle[] iha = il.getInstructionHandles();
    if (iha.length <= inr) {
      if (affectBcc) {
        System.err.println("mnr="+mnr+", index="+inr+", size="+iha.length);
        throw new RuntimeException("instruction count changed! Bytecode parsing unsupported.");
      } else {
        syso("instruction count changed (1)");
        syso("previous is: " + iha.length);
        syso("inr is: " + inr);
        reportError(null);
      }
    }
    if (inr < iha.length) {
      ih = iha[inr];
      syso("ih@" + inr + "="+ih);
    }
  } (n=NAT COLON (~'\n')* EOL {
      syso("instruction no " + n);
      SingleList sl = m.getAmap().getAllAt(ih);
      if (affectBcc) {
        sl.trunce(minor);
        syso("minor="+minor+", size="+sl.size());
        m.getAmap().setAtributesForInstruction(ih, sl);
      }
     }
    )
  ;

// bml level

printableAttribute returns [BCPrintableAttribute ast] :
  (c=classAttribute {$ast = $c.ast;}
  | met=methodAttribute {$ast = $met.ast;}
  | i=inCodeAttribute {$ast = $i.ast;})
  EOF
  ;

classAttribute returns [ClassAttribute ast] :
  | INVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast, true);}
  | STATIC INVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast, false);}
  ;

methodAttribute returns [MethodAttribute ast] :
  m=methodSpecification {$ast = $m.ast;};

methodSpecification returns [MethodSpecification ast] :
    emptyspec
      {
        syso("empty spec parsed");
        $ast = null;
      }
  | s=specCase 
      {
        syso("specCase parsed");
        $ast = new MethodSpecification(m);
        $ast.addCase($s.ast);
      };
  
emptyspec :
    st=BML_START (EOL)* en=BML_END EOL
      {
         bml_positions.add(new PosInCode($st.getLine(),
                                         $st.getCharPositionInLine()));
         bml_positions.add(new PosInCode($en.getLine(),
                                         $en.getCharPositionInLine()+3));
         syso("empty spec");
      } 
  | (st=BML_ONE_LINE_START en=EOL
       {
          bml_positions.add(new PosInCode($st.getLine(),
                                          $st.getCharPositionInLine()));
          bml_positions.add(new PosInCode($en.getLine()+1,
                                          0));
       }
    )+
      {
         syso("empty spec");
      };

exname returns [String name] :
  i=typename {$name = $i.name;}
    (SEMICOLON {$name = $name + ';';})?
  | i2=IDENT {$name = $i2.getText();}
    (SEMICOLON {$name = $name + ';';})?
  ;

specCase returns [SpecificationCase ast] :
  st=BML_START EOL
  (REQUIRES f1=formula EOL
   {
      prec = $f1.ast;
      modif = null;
      postc = null;
      exc = new Vector<Exsure>();
   }
   (MODIFIES ml=modifyList {modif = $ml.ast;} EOL)?
   (ENSURES f2=formula {postc = $f2.ast;} EOL)?
   (EXSURES 
     (i=exname COLON f3=formula EOL 
      {
        if (($i.name != null) && ($f3.ast != null)) {
          JavaReferenceType jrt = new JavaReferenceType($i.name);
          Exsure ex = new Exsure(jrt, $f3.ast);
          exc.add(ex);
        }
      }
     )+
   )?
  ) en=BML_END EOL
    {
      bml_positions.add(new PosInCode($st.getLine(),
                                      $st.getCharPositionInLine()));
      bml_positions.add(new PosInCode($en.getLine(),
                                      $en.getCharPositionInLine()+3));
      if (prec != null)
        $ast = new SpecificationCase(m, prec, modif, postc, exc);
    };

inCodeAttribute returns [InCodeAttribute ast] :
    assrt=assertspec
    {
       if ( $assrt.ast != null ) {
         $ast = $assrt.ast;
       }
       syso("inCodeAttribute, assertspec");
    }
  | LOOPSPEC EOL
    {
       modif = null;
       inv = null;
       dec = null;
     }
     (MODIFIES ml=modifyList {modif = $ml.ast;} EOL)?
     (LINVARIANT iv=formula {inv = $iv.ast;} EOL)?
     (LDECREASES de=expression {dec = $de.ast;} EOL)?
     {
        $ast = new SingleLoopSpecification(m, null, -1, modif, inv, dec);
     };

assertspec returns [SingleAssert ast]  :
  ASSERT f1=formula
    {
       if ( $f1.ast != null ) {
         $ast = new SingleAssert(m, null, -1, $f1.ast);
       }
       syso("assert formula (1?)");
    };

modifyList returns [ModifyList ast] :
  l=modifyExpression 
  {
    $ast = new ModifyList();
    $ast.addModify($l.ast);
  }
  (COMMA r=modifyExpression  
   {
      $ast.addModify($r.ast);
   }
  )*;

modifyExpression returns [ModifyExpression ast] :
  {initExpression();}
  (   NOTHING
      {
         $ast = ModifyExpression.Nothing;
      }
    | EVERYTHING
      {
         //syso("\\everything parsed");
         $ast = ModifyExpression.Everything;
      }
    | l=localVar
      {
         $ast = new ModifiesLocalVar(l.lv);
      }
    | i=modifySubExpr 
      {
         $ast = new ModifiesIdent($i.ast);
      }
      (DOT j=modifySubExpr 
       {
          $ast = new ModifiesDot($ast, $j.ast);
       }
      )* (BR_LEFT a=specArray BR_RIGHT
          {
             $ast = new ModifiesArray($ast, $a.ast);
          }
         )*
  );

modifySubExpr returns [BCExpression ast] :
  THIS {$ast = new THIS(false, bcc);}
  | OLD_THIS {$ast = new THIS(true, bcc);}
  | i=IDENT {$ast = whatIsIt($i.getText());}
  ;

specArray returns [SpecArray ast] :
  MULT {$ast = new ModifiesStar();}
  | e=expression {$ast = new ModifiesSingleIndex($e.ast);}
  (DOT2 t=expression {$ast = new ModifiesInterval($ast.getSubExpr(0), $t.ast);})?
  ;

formula returns [AbstractFormula ast] :
  {initExpression();}
  e=uncheckedExpression {
    if ($e.ast == null) {
      syso("*** error ***");
      syso("no unchecked expression error");
      reportError(null);
    } else {
      if ($e.ast.checkType() != JavaBasicType.JavaBool) {
        syso("*** error ***");
        syso("wrong type error");
        reportError(null);
      } else {
        if ($e.ast instanceof AbstractFormula) {
          $ast = (AbstractFormula)$e.ast;
        } else {
          $ast = new BooleanExpression($e.ast);
        }
      }
    }
  };

expression returns [AbstractIntExpression ast] :
  {initExpression();}
  e=uncheckedExpression {
    if ($e.ast == null) {
      syso("*** error ***");
      syso("no unchecked expression error");
      reportError(null);
    } else {
      if ($e.ast.getType() != JavaBasicType.JavaInt) {
        syso("*** error ***");
        syso("wrong type error");
        reportError(null);
      } else {
        if ($e.ast instanceof AbstractIntExpression) {
          $ast = (AbstractIntExpression)$e.ast;
        } else {
          $ast = new IntExpression($e.ast);
        }
      }
    }
  };

uncheckedExpression returns [BCExpression ast] :
  e=conditionalExpression {$ast = $e.ast;};

conditionalExpression returns [BCExpression ast] :
  c=equivalenceExpr {$ast = $c.ast;}
  (COND t=uncheckedExpression COLON f=uncheckedExpression {
    $ast = new ConditionalExpression($c.ast, $t.ast, $f.ast);
  })?
  ;

equivalenceExpr returns [BCExpression ast] :
  e=impliesExpr {$ast = $e.ast;}
  ( EQUIV r=impliesExpr {$ast = new Formula(Code.EQUIV, $ast, $r.ast);}
    | NOTEQUIV r=impliesExpr {$ast = new Formula(Code.NOTEQUIV, $ast, $r.ast);}
  )*
  ;

impliesExpr returns [BCExpression ast] :
  e=logicalOrExpr {$ast = $e.ast;}
  (IMPLIES r=logicalOrExpr {$ast = new Formula(Code.IMPLIES, $ast, $r.ast);})*
  ;

logicalOrExpr returns [BCExpression ast] :
  e=logicalAndExpr {$ast = $e.ast;}
  (LOG_OR r=logicalAndExpr {$ast = new Formula(Code.OR, $ast, $r.ast);})*
  ;

logicalAndExpr returns [BCExpression ast] :
  e=bitwiseOrExpr {$ast = $e.ast;}
  (LOG_AND r=bitwiseOrExpr {$ast = new Formula(Code.AND, $ast, $r.ast);})*
  ;

bitwiseOrExpr returns [BCExpression ast] :
  e=bitwiseXorExpr {$ast = $e.ast;}
  (BITWISEOR r=bitwiseXorExpr {$ast = new ArithmeticExpression(Code.BITWISEOR, $ast, $r.ast);})*
  ;

bitwiseXorExpr returns [BCExpression ast] :
  e=bitwiseAndExpr {$ast = $e.ast;}
  (BITWISEXOR r=bitwiseAndExpr {$ast = new ArithmeticExpression(Code.BITWISEXOR, $ast, $r.ast);})*
  ;

bitwiseAndExpr returns [BCExpression ast] :
  e=equalityExpr {$ast = $e.ast;}
  (BITWISEAND r=equalityExpr {$ast = new ArithmeticExpression(Code.BITWISEAND, $ast, $r.ast);})*
  ;

equalityExpr returns [BCExpression ast] :
    l=shiftExpr EQ r=shiftExpr
    {
       $ast = new Predicate2Ar(Code.EQ, $l.ast, $r.ast);
    }
  | l=shiftExpr NOTEQ r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.NOTEQ, $l.ast, $r.ast);
    }
  | e=relationalExpr
    {
      $ast = $e.ast;
    };

relationalExpr returns [BCExpression ast] :
    l=shiftExpr LESS r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.LESS, $l.ast, $r.ast);
    }
  | l=shiftExpr GRT r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.GRT, $l.ast, $r.ast);
     }
  | l=shiftExpr LESSEQ r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.LESSEQ, $l.ast, $r.ast);
    }
  | l=shiftExpr GRTEQ r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.GRTEQ, $l.ast, $r.ast);
    }
  | e=shiftExpr
    {
      $ast = $e.ast;
    };

shiftExpr returns [BCExpression ast] :
    p=additiveExpr
    {
      $ast = $p.ast;
    }
    (  SHL r1=additiveExpr
       {
         $ast = new ArithmeticExpression(Code.SHL, $ast, $r1.ast);
       }
     | SHR r2=additiveExpr
       {
         $ast = new ArithmeticExpression(Code.SHR, $ast, $r2.ast);
       }
     | USHR r3=additiveExpr 
       {
          $ast = new ArithmeticExpression(Code.USHR, $ast, $r3.ast);
        }
    )*;

additiveExpr returns [BCExpression ast] :
  e=multExpr {$ast = $e.ast;}
  (PLUS r1=multExpr {$ast = new ArithmeticExpression(Code.PLUS, $ast, $r1.ast);}
  | MINUS r2=multExpr {$ast = new ArithmeticExpression(Code.MINUS, $ast, $r2.ast);}
  )*
  ;

multExpr returns [BCExpression ast] :
  e=quantifiedFormula {$ast = $e.ast;}
  (MULT r1=quantifiedFormula {$ast = new ArithmeticExpression(Code.MULT, $ast, $r1.ast);}
  | DIV r2=quantifiedFormula {$ast = new ArithmeticExpression(Code.DIV, $ast, $r2.ast);}
  | REM r3=quantifiedFormula {$ast = new ArithmeticExpression(Code.REM, $ast, $r3.ast);}
  )*
  ;

quantifiedFormula returns [BCExpression ast] :
  ((FORALL {$ast = new QuantifiedFormula(Code.FORALL_WITH_NAME); lqfs=0;}
  | EXISTS {$ast = new QuantifiedFormula(Code.EXISTS_WITH_NAME); lqfs=0;})
   (t=ident v=ident {try {
      JavaBasicType jt = JavaType.getJavaBasicType($t.text);
      lqfs++;
      BoundVar bv = new BoundVar(jt, bvc++, (QuantifiedFormula)$ast, $v.text);
      // uncomment this to forbid bound variable shadowing
//      if (env.containsKey($v.text))
//        reportError(null);
      env.put($v.text, bv);
       ((QuantifiedFormula)$ast).addVariable(bv);
     } catch(ReadAttributeException e) {
       reportError(null);
       //throw new RuntimeException("Error in BML.g3.quantifiedFormula");
     }})+
     SEMICOLON 
     f=uncheckedExpression {((QuantifiedFormula)$ast).setFormula($f.ast);
       env.remove($v.text);
       bvc -= lqfs;
     }) |
  p=dotExpr {$ast = $p.ast;};

dotExpr returns [BCExpression ast] :
  l=primaryExpr {$ast = $l.ast;}
  (DOT r=primaryExpr {$ast = new FieldAccess(Code.FIELD_ACCESS, $ast, $r.ast);}
    | BR_LEFT p=uncheckedExpression BR_RIGHT {$ast = new ArrayAccess($ast, $p.ast);}
  )*
  ;

primaryExpr returns [BCExpression ast] :
  l=localVar {$ast = $l.lv;}
  | n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
  | i=ident {$ast = whatIsIt($i.text);}
  | MINUS min=primaryExpr {$ast = new UnaryArithmeticExpression(Code.NEG, $min.ast);}
  | PLUS px=primaryExpr {$ast = $px.ast;}
  | LOG_NOT p=primaryExpr {$ast = new Formula(Code.NOT, $p.ast);}
  | FALSE {$ast = new Predicate0Ar(false);}
  | TRUE {$ast = new Predicate0Ar(true);}
  | RESULT {if (m == null) {reportError(null);} else {$ast = new RESULT(m);}}
  | NULL {$ast = new NULL();}
  | THIS {$ast = new THIS(false, bcc);}
  | OLD_THIS {$ast = new THIS(true, bcc);}
  | OLD PAR_LEFT e1=uncheckedExpression PAR_RIGHT {$ast = new OLD(Code.OLD, $e1.ast);}
  | PAR_LEFT e=uncheckedExpression PAR_RIGHT {$ast = $e.ast;}
  | LENGTH {$ast = new ArrayLength();}
  ;

localVar returns [LocalVariable lv] :
  LV BR_LEFT n=NAT BR_RIGHT {
    int i;
    try {
      i = Integer.parseInt($n.text);
    } catch (NumberFormatException e) {
      i = -1;
    }
    if (m == null) {
      syso("*** error ***");
      syso("outside method error");      
      reportError(null);
    } else {
      if (!m.canBeLocalVariable(i)) {
        syso("*** error ***");
        syso("no such variable error");
        reportError(null);
      } else {
        $lv = m.getLocalVariable(false, i);
      }
    }
  };

ident returns [String name]:
  i=IDENT {$name = $i.getText();};

// ***** LEXER RULES *****

// bytecode level

//Java keywords

PACKAGE: 'package';
DEFAULTPACKAGE: '[default]';
IMPORT: 'import';
CLASS: 'class';
INTERFACE: 'interface';
PUBLIC: 'public';
PROTECTED: 'protected';
PRIVATE: 'private';
ABSTRACT: 'abstract';
STATIC: 'static';
FINAL: 'final';
NATIVE: 'native';
SYNCHRONIZED: 'synchronized';
TRANSIENT: 'transient';
VOLATILE: 'volatile';
STRICTFP: 'strictfp';
VOID: 'void';
BOOLEAN: 'boolean';
BYTE: 'byte';
CHAR: 'char';
SHORT: 'short';
INT: 'int';
LONG: 'long';
FLOAT: 'float';
DOUBLE: 'double';
EXTENDS: 'extends';
IMPLEMENTS: 'implements';
THROWS: 'throws';


// bml level
// IDisplayStyle must be modified as well

CONSNAME: '<init>';
STATICCONSNAME: '<clinit>';
ASSERT: 'assert';
LOOPSPEC: 'loop_specification';
LINVARIANT: 'loop_inv';
LDECREASES: 'decreases';
INVARIANT: 'invariant';
CONSTRAINT: 'constraint';
REPRESENTS: 'represents';
INITIALLY: 'initially';
REQUIRES: 'requires';
SC_START: '{|';
SC_END: '|}';
PRECONDITION: 'precondition';
MODIFIES: 'modifies';
ENSURES: 'ensures';
CONSTANT_POOL: 'Constant pool:';
SECOND_CONSTANT_POOL: 'Second constant pool:';
CONST: 'const';
COMMA: ',';
EXSURES: 'exsures';
COLON: ':';
NOTHING: '\\nothing';
EVERYTHING: '\\everything';
LOG_AND: '&&';
LOG_OR: '||';
IMPLIES: '==>';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
LOG_NOT: '~';
SEMICOLON: ';';
FORALL: '\\forall';
EXISTS: '\\exists';
TRUE: 'true';
FALSE: 'false';
LESS: '<';
LESSEQ: '<=';
EQ: '==';
NOTEQ: '!=';
GRTEQ: '>=';
GRT: '>';
EQUALS : '=';
PAR_LEFT: '(';
PAR_RIGHT: ')';
BR_LEFT: '[';
BR_RIGHT: ']';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
REM: '%';
HASH: '#';
SHL: '<<';
SHR: '>>';
USHR: '>>>';
BITWISEAND: '&';
BITWISEOR: '|';
BITWISEXOR: '^';
COND: '?';
NULL: 'null'|'NULL';
THIS: 'this'|'THIS';
OLD_THIS: 'old_this'|'OLD_THIS';
RESULT: '\\result';
LV: 'lv';
DOT2: '..';
DOT: '.';
OLD: '\\old';
LENGTH: 'length';
BML_ONE_LINE_START: '//@';
ONE_LINE_COMMENT: '//';
BML_START: '/*@';
BML_END: '@*/';
COMMENT_END: '*/';
CLASS_CP: 'Class';
FIELDREF_CP: 'Fieldref';
METHODREF_CP: 'Methodref';
INTERFACEMETHODREF_CP: 'InterfaceMethodref';
STRING_CP: 'String';
INTEGER_CP: 'Integer';
UTF8_CP: 'Utf8';
LONG_CP: 'Long';
DOUBLE_CP: 'Double';
NAMEANDTYPE_CP: 'NameAndType';
FLOAT_CP: 'Float';

IDENT: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
NAT: ('0'..'9')+;
STRING: '\"' (.* (~('\\')))? '\"';

WS: (' '|'\t')+ {skip();};
EOF: '\f';
EOL: '\n';