grammar BML;

options {
	output=AST;
	ASTLabelType=CommonTree;
	backtrack=true;
}

@header {
	package annot.textio;
	import org.apache.bcel.generic.InstructionHandle;
	import annot.bcclass.*;
	import annot.attributes.*;
	import annot.bcexpression.*;
	import annot.formula.*;
	import annot.io.Code;
	import annot.io.ReadAttributeException;
}

@members {
	public RecognitionException lastE = null;
	
	// initail data (parser parameters)
	private BCClass bcc;
	private BCMethod m;
	private BCConstantPool cp;
	private InstructionHandle ih;
	private int minor;
	private boolean affectBcc = false;

	// global variables
	private int mnr;						// number of current method
	private int inr;						// number of current instruction
	private int bvc;  						// number of currently visible bound variables
	private int lqfs; 						// last (current) quantified formula size
	private HashMap<String, BoundVar> env;	// bound variable map

	// set wether to affect parsed BCClass, or only check syntax
	public void initClass(BCClass bcc, boolean affectBcc) {
		this.bcc = bcc;
		this.affectBcc = affectBcc;
		this.cp = bcc.getCp();
	}

	// initialize environment for expression parsing
	private void initExpression() {
		this.bvc = 0;
		this.lqfs = 0;
		this.env = new HashMap<String, BoundVar>();
	}

	// set context for attribute parsing
	public void init(BCClass bcc, BCMethod m, BCConstantPool cp, InstructionHandle ih, int minor) {
		this.bcc = bcc;
		this.m = m;
		this.cp = cp;
		this.ih = ih;
		this.minor = minor;
	}

	private void syso(String msg) {
		MLog.putMsg(MLog.PParser, msg);
	}

	public void reportError(RecognitionException rex) {
		if (rex == null)
			rex = new RecognitionException();
		lastE = rex;
		syso("*** error ***");
		if ((MLog.mask & MLog.PParser) > 0)
			super.reportError(rex);
	}
	
	// Searches for an identifier name in diffrent locations
	// and returns proper one, or null if no identifier
	// of this name could be found.
	private BCExpression whatIsIt(String ident) {
		if (env.containsKey(ident))
			return env.get(ident);
		MLog.putMsg(MLog.PInfo, "undefined identifier: "+ident);
		RecognitionException rex = new RecognitionException();
		reportError(rex);
		return null;
	}
}

@lexer::header {
	package annot.textio;
	import annot.bcclass.*;
}

@lexer::members {
	public RecognitionException lastE = null;

	public void reportError(RecognitionException rex) {
		lastE = rex;
		MLog.putMsg(MLog.PParser, "LEXER ERROR");
		if ((MLog.mask & MLog.PParser) > 0) {
			System.err.println("LEXER ERROR");
			super.reportError(rex);
		}
	}
}

// ***** PARSER RULES *****

// bytecode level

parseClass :
	{syso("--------------- parsing started ---------------");}
	PACKAGE? CLASS?
	{syso("class");}
	(NO_CLA {syso("skipping class declarations");}
		| classComment {syso("class declarations");}
			EOD)
	{syso("end of class decl");
	mnr = 0;
	m = bcc.getMethod(mnr);
	}
	(method
		{syso("method");
		mnr++;
		if (mnr < bcc.getMethodCount())
			m = bcc.getMethod(mnr);
	})+
	EOF
	{syso("-------------- parsing completed --------------");}
	;

classComment :
	EOA {
		syso("begin of class decl");
		bcc.setInvariant(null);
	}
	(c=classAttribute {
		syso("next class attribute");
		if (affectBcc)
			$c.ast.replace(bcc);
	}
		EOA)*
	;

method :
	NO_METHOD {syso("skipping method");}
	|	((NO_MSPEC {syso("skipping method specification");}
		| met=methodSpecification {
				syso("method specification");
				if (affectBcc)
					m.setMspec($met.ast);
			} EOA)?
		MHEAD {
			syso("method header");
			inr = 0;
		}
		(instruction {inr++;})+
		EOM {syso("end of method");})
	;

instruction :
	{InstructionHandle[] iha = m.getBcelMethod().getInstructionList().getInstructionHandles();
		if (iha.length <= inr) {
			if (affectBcc) {
				System.err.println("mnr="+mnr+", index="+inr+", size="+iha.length);
				throw new RuntimeException("instruction count changed! Bytecode parsing unsupported.");
			} else {
				syso("instruction count changed");
				reportError(null);
			}
		}
		if (inr < iha.length) {
			ih = iha[inr];
			syso("ih="+ih);
		}
	}
	(NO_INSTRUCTION {syso("skipping instruction");}
	| ((comment {syso("comment");})?
		INSTRUCTION {
			syso("instruction");
			SingleList sl = m.getAmap().getAllAt(ih);
			if (affectBcc) {
				sl.trunce(minor);
				syso("minor="+minor+", size="+sl.size());
				m.getAmap().setAtributesForInstruction(ih, sl);
			}
		}))
	;

comment :
	EOA {syso("beginning of comment");
		minor = 0;
	}
	( NO_ANNOTATION {
		syso("annotation unaffected");
		minor++;
	}
		| ica=inCodeAttribute {
			syso("annotation");
			SingleList sl = m.getAmap().getAllAt(ih);
			if (affectBcc) {
				sl.setNth(minor, $ica.ast);
				m.getAmap().setAtributesForInstruction(ih, sl);
			}
			minor++;
		} EOA)*
	;

// bml level

printableAttribute returns [BCPrintableAttribute ast] :
	(c=classAttribute {$ast = $c.ast;}
	| met=methodSpecification {$ast = $met.ast;}
	| i=inCodeAttribute {$ast = $i.ast;})
	EOF
	;

classAttribute returns [ClassAttribute ast] :
	| CLASSINVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast);}
	;

methodSpecification returns [MethodSpecification ast] :
	| REQUIRES f3=formula {$ast = new MethodSpecification(m, $f3.ast, new SpecificationCase[0]);}
	;

inCodeAttribute returns [InCodeAttribute ast] :
	ASSERT f1=formula {$ast = new SingleAssert(m, ih, -1, $f1.ast);}
	;

expression returns [BCExpression ast] :
	e=shiftExpr {$ast = $e.ast;};

formula returns [AbstractFormula ast] :
	{initExpression();}
	e=uncheckedFormula {
		if ($e.ast == null) {
			reportError(null);
		} else {
			if ($e.ast.getType() != JavaType.JavaBool)
				reportError(null);
			$ast = (AbstractFormula)$e.ast;
		}
	};

uncheckedFormula returns [BCExpression ast] :
	e=equivalenceExpr {$ast = $e.ast;};

equivalenceExpr returns [BCExpression ast] :
	e=impliesExpr {$ast = $e.ast;}
	( EQUIV r=impliesExpr {$ast = new Formula(Code.EQUIV, $ast, $r.ast);}
		| NOTEQUIV r=impliesExpr {$ast = new Formula(Code.NOTEQUIV, $ast, $r.ast);}
	)*;

impliesExpr returns [BCExpression ast] :
	e=logicalOrExpr {$ast = $e.ast;}
	(IMPLIES r=logicalOrExpr {$ast = new Formula(Code.IMPLIES, $ast, $r.ast);})?;

logicalOrExpr returns [BCExpression ast] :
	e=logicalAndExpr {$ast = $e.ast;}
	(LOG_OR r=logicalAndExpr {$ast = new Formula(Code.OR, $ast, $r.ast);})*;

logicalAndExpr returns [BCExpression ast] :
	e=equalityExpr {$ast = $e.ast;}
	(LOG_AND r=equalityExpr {$ast = new Formula(Code.AND, $ast, $r.ast);})*;

equalityExpr returns [BCExpression ast] :
	l=shiftExpr EQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.EQ, $l.ast, $r.ast);}
	| l=shiftExpr NOTEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.NOTEQ, $l.ast, $r.ast);}
	| e=relationalExpr {$ast = $e.ast;}
	;

relationalExpr returns [BCExpression ast] :
	| l=shiftExpr LESS r=shiftExpr
		{$ast = new Predicate2Ar(Code.LESS, $l.ast, $r.ast);}
	| l=shiftExpr GRT r=shiftExpr
		{$ast = new Predicate2Ar(Code.GRT, $l.ast, $r.ast);}
	| l=shiftExpr LESSEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.LESSEQ, $l.ast, $r.ast);}
	| l=shiftExpr GRTEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.GRTEQ, $l.ast, $r.ast);}
	| q=quantifiedFormula {$ast = $q.ast;}
	;

quantifiedFormula returns [BCExpression ast] :
	(FORALL {$ast = new QuantifiedFormula(Code.FORALL_WITH_NAME); lqfs=0;}
	| EXISTS {$ast = new QuantifiedFormula(Code.EXISTS_WITH_NAME); lqfs=0;})
	 (t=IDENT v=IDENT {try {
			JavaType jt = JavaType.getJavaType($t.text);
			lqfs++;
			BoundVar bv = new BoundVar(jt, bvc++, (QuantifiedFormula)$ast, $v.text);
			if (env.containsKey($v.text))
				reportError(null);
			env.put($v.text, bv);
	 		((QuantifiedFormula)$ast).addVariable(bv);
	 	} catch(ReadAttributeException e) {
	 		reportError(null);
	 		//throw new RuntimeException("Error in BML.g3.quantifiedFormula");
	 	}})+
	 	SEMICOLON
	 	f=uncheckedFormula {((QuantifiedFormula)$ast).setFormula($f.ast);
	 		env.remove($v.text);
	 		bvc -= lqfs;
	 	}
	| p=primaryFormula {$ast = $p.ast;}
	;

primaryFormula returns [BCExpression ast] :
	FALSE {$ast = Predicate0Ar.FALSE;}
	| TRUE {$ast = Predicate0Ar.TRUE;}
	| i=IDENT {$ast = whatIsIt($i.text);}
	| LOG_NOT p=primaryFormula {$ast = new Formula(Code.NOT, $p.ast);}
	| PAR_LEFT f=uncheckedFormula PAR_RIGHT {$ast = $f.ast;}
	;

shiftExpr returns [BCExpression ast] :
	p=primaryExpr {$ast = $p.ast;};

primaryExpr returns [BCExpression ast] :
	n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
	| i=IDENT {$ast = whatIsIt($i.text);}
	| PAR_LEFT e=expression PAR_RIGHT {$ast = $e.ast;}
	;

// ***** LEXER RULES *****

// bytecode level

PACKAGE: '[package]';
CLASS: '[class]';
NO_CLA: '\\class attributes unaffected';
NO_METHOD: '\\method unaffected';
MHEAD: '[method header]';
NO_INSTRUCTION: '\\instruction unaffected';
INSTRUCTION: '[instruction]';
NO_MSPEC: '\\method specification unaffected';
NO_ANNOTATION: '\\annotation unaffected';
EOD: 'EOD';
EOM: 'EOM';
EOA: 'EOA';

// bml level

ASSERT: '\\assert';
CLASSINVARIANT: '\\class invariant';
REQUIRES: '\\requires';
LOG_AND: '&&';
LOG_OR: '||';
IMPLIES: '==>';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
LOG_NOT: '~';
SEMICOLON: ';';
FORALL: 'forall';
EXISTS: 'exists';
TRUE: 'true';
FALSE: 'false';
LESS: '<';
LESSEQ: '<=';
EQ: '==';
NOTEQ: '!=';
GRTEQ: '>=';
GRT: '>';
PAR_LEFT: '(';
PAR_RIGHT: ')';

NAT: ('0'..'9')+;
IDENT: ('a'..'z')+;

WS: (' '|'\t'|'\n')+ {skip();};
EOF: '\f';
