grammar BML;

options {
  output=AST;
  ASTLabelType=CommonTree;
  backtrack=true;
}

@header {
  package annot.textio;

  import annot.bcclass.*;
  import annot.attributes.*;
  import annot.bcexpression.*;
  import annot.bcexpression.javatype.*;
  import annot.bcexpression.modifies.*;
  import annot.bcexpression.formula.*;
  import annot.io.Code;
  import annot.io.ReadAttributeException;

  import org.apache.bcel.generic.InstructionHandle;
  import java.util.Vector;
}

@members {
  public RecognitionException lastE = null;
  
  // initial data (parser parameters)
  private BCClass bcc;
  private BCMethod m;
  private BCConstantPool cp;
  private InstructionHandle ih;
  private int minor;
  private boolean affectBcc = false;

  // global variables
  private int mnr;            // number of current method
  private int inr;            // number of current instruction
  private int bvc;              // number of currently visible bound variables
  private int lqfs;             // last (current) quantified formula size
  private HashMap<String, BoundVar> env;  // bound variable map
  private Vector<PosInCode> bml_positions = new Vector(); //postions of BML areas
  
  //local variables
  private boolean clr = false;
  private AbstractFormula prec;
  private ModifyList modif;
  private AbstractFormula postc;
  private Vector<Exsure> exc;
  private AbstractFormula inv;
  private AbstractIntExpression dec;

  // set whether to affect parsed BCClass, or only check syntax
  public void initClass(BCClass bcc, boolean affectBcc) {
    this.bcc = bcc;
    this.affectBcc = affectBcc;
    this.cp = bcc.getCp();
  }

  // initialize environment for expression parsing
  private void initExpression() {
    this.bvc = 0;
    this.lqfs = 0;
    this.env = new HashMap<String, BoundVar>();
  }

  // set context for attribute parsing
  public void init(BCClass bcc, BCMethod m, BCConstantPool cp, InstructionHandle ih, int minor) {
    this.bcc = bcc;
    this.m = m;
    this.cp = cp;
    this.ih = ih;
    this.minor = minor;
  }

  private void syso(String msg) {
    MLog.putMsg(MLog.LEVEL_PPARSER, msg);
  }

  public void reportError(RecognitionException rex) {
    if (rex == null)
      rex = new RecognitionException();
    lastE = rex;
    syso("*** error ***");
    if ((MLog.getLogMask() & MLog.LEVEL_PPARSER) > 0)
      super.reportError(rex);
  }
  
  // Searches for an identifier name in diffrent locations
  // and returns proper one, or null if no identifier
  // of this name could be found.
  private BCExpression whatIsIt(String ident) {
    if (ident == null) {
      reportError(null);
      return null;
    }
    boolean isOld = false;
    if (ident.startsWith("old_")) { //??!
      ident = ident.substring(4);
      isOld = true;
    }
    if (env.containsKey(ident))
      return new SingleOccurence(env.get(ident));
    if (m != null) {
      LocalVariable lv = m.findLocalVariable(ident);
      if (lv != null) {
        lv.setOld(isOld);
        return new SingleOccurence(lv);
      }
    }
    FieldRef bfr = FieldRef.getFieldOfName(isOld, bcc.getCp(), ident);
    if (bfr != null)
      return bfr;
    MLog.putMsg(MLog.LEVEL_PINFO, "undefined identifier: " + ident);
    reportError(null);
    return null;
  }
  
  public Vector<PosInCode> getBMLPositions() {
    return bml_positions;
  }
}

@lexer::header {
  package annot.textio;
  import annot.bcclass.*;
}

@lexer::members {
  public RecognitionException lastE = null;

  public void reportError(RecognitionException rex) {
    lastE = rex;
    MLog.putMsg(MLog.LEVEL_PPARSER, "LEXER ERROR");
    if ((MLog.getLogMask() & MLog.LEVEL_PPARSER) > 0) {
      System.err.println("LEXER ERROR");
      super.reportError(rex);
    }
  }
}

// ***** PARSER RULES *****

// bytecode level

parseClass :
  {syso("--------------- parsing started ---------------");}
  fileheader typeheader typebody EOF
  {syso("-------------- parsing completed --------------");};

fileheader :
  packageinfo constant_pools;

packageinfo :
  PACKAGE ( DEFAULTPACKAGE | typename ) EOL+
  {syso("packageinfo");};

typename returns [String name] :
    i=IDENT { $name = $i.getText(); }
    (DIV typename { $name +=  '/' + $typename.name; })?
  | STRING_CP { $name = "String"; }
    (DIV typename { $name +=  '/' + $typename.name; })?;

constant_pools : constant_pool ( second_constant_pool )? EOL;

constant_pool : CONSTANT_POOL EOL constant_pool_content
  {syso("constant_pool");};

second_constant_pool : SECOND_CONSTANT_POOL EOL constant_pool_content;

constant_pool_content : constant_pool_line EOL ( constant_pool_line EOL )*;

constant_pool_line : CONST cp_ref EQUALS constant_pool_entry 
  	{syso("constant_pool_line");};

constant_pool_entry : class_cp_entry | field_cp_entry 
   | method_cp_entry | interface_method_cp_entry
   | string_cp_entry | integer_cp_entry | float_cp_entry
   | long_cp_entry | double_cp_entry
   | name_and_type_cp_entry | utf8_cp_entry;
   
class_cp_entry : CLASS_CP cp_ref SEMICOLON 
  {syso("class_cp_entry");};

field_cp_entry : FIELDREF_CP cp_ref.cp_ref SEMICOLON
  {syso("field_cp_entry");};

method_cp_entry : METHODREF_CP cp_ref DOT cp_ref SEMICOLON
  {syso("method_cp_entry");};

interface_method_cp_entry : INTERFACEMETHODREF_CP cp_ref DOT cp_ref SEMICOLON
  {syso("interface_method_cp_entry");};

string_cp_entry : STRING_CP cp_ref SEMICOLON
  {syso("string_cp_entry");};

integer_cp_entry : INTEGER_CP ( sign )? NAT SEMICOLON
  {syso("integer_cp_entry");};

float_cp_entry : FLOAT_CP ( sign )? floating_point_literal SEMICOLON
  {syso("float_cp_entry");};

long_cp_entry : LONG_CP ( sign )? NAT SEMICOLON
  {syso("long_cp_entry");};

double_cp_entry : DOUBLE_CP ( sign )? floating_point_literal SEMICOLON
  {syso("double_cp_entry");};

name_and_type_cp_entry : NAMEANDTYPE_CP cp_ref COLON cp_ref SEMICOLON
  {syso("name_and_type_cp_entry");};

//slight simplification, any non-newline character is accepted as string
utf8_cp_entry : UTF8_CP (~('\n'))* SEMICOLON
  {syso("utf8_cp_entry");};

cp_ref : HASH NAT;

sign : PLUS | MINUS;

exponent_indicator : 'e' | 'E';

signed_integer : ( sign )? NAT;

exponent_part : exponent_indicator signed_integer;

floating_point_literal : NAT DOT ( NAT )? ( exponent_part )? ( float_type_suffix )?
        | DOT NAT ( exponent_part )? ( float_type_suffix )?
        | NAT exponent_part ( float_type_suffix )?
        | NAT ( exponent_part )? float_type_suffix;

float_type_suffix : 'f' | 'F' | 'd' | 'D';

typeheader :
  (  classmodifiers CLASS dotedname
     class_extends_clause? implements_clause?
   | interfacemodifiers INTERFACE dotedname
     interface_extends_clause? implements_clause?) EOL+
  {syso("type header");};

dotedname :
  IDENT ( DOT IDENT)*;

classmodifiers :
  classmodifier* {syso("class modifiers");};
  
interfacemodifiers :
  interfacemodifier* {syso("interface modifiers");};

classmodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | ABSTRACT
   | STATIC
   | FINAL
   | STRICTFP) {syso("class modifier");};
   
interfacemodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | ABSTRACT
   | STATIC
   | STRICTFP) {syso("interface modifier");};

class_extends_clause :
  EXTENDS typename
  {syso("class_extends_clause");};

interface_extends_clause :
  EXTENDS name_list
  {syso("interface_extends_clause");};

implements_clause :
  IMPLEMENTS name_list
  {syso("implements_clause");};

name_list :
  typename ( COMMA typename )*
  {syso("name_list");};

typebody :
  { syso("methods start here");
    mnr = 0;
    m = bcc.getMethod(mnr);
  }
  (method { syso("method");
            mnr++;
            if (mnr < bcc.getMethodCount())
              m = bcc.getMethod(mnr);
          }
  )+
  {syso("methods parsed");};

method :
   (met=methodSpecification {
      syso("method spec parsed");
      if ($met.ast != null) {
        syso("method attribute");
        if (clr) {
          syso("clearing method attributes");
          if (affectBcc)
            m.setMspec(null);
          clr = false;
        }
        if (affectBcc)
          $met.ast.replace(m);
      } else {
        syso("empty method attribute");
      }
    })+ methodmodifiers type_spec? methodheader {
      if (clr) {
        syso("clearing method attributes");
        if (affectBcc)
          m.setMspec(null);
        clr = false;
      }
      syso("method header");
      inr = 0;
    } (instruction_line {inr++;})*
    {
      if (m.getInstructions() != null &&
          inr != m.getInstructions().getInstructionHandles().length) {
        syso("instruction count changed!");
        reportError(null);
      }
      syso("end of method");
    } (EOL+ | EOF)
  ;

methodmodifiers :
  methodmodifier* {syso("method modifiers");};
  
methodmodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | STATIC
   | ABSTRACT
   | FINAL
   | NATIVE
   | SYNCHRONIZED
   | TRANSIENT
   | VOLATILE
   | STRICTFP) {syso("method modifier");};  

type_spec :
    type (dims)? {syso("type_spec");};

type :
    reference_type
  | built_in_type ;
  
reference_type :
  typename {syso("reference type");};

built_in_type :
  (  VOID
   | BOOLEAN
   | BYTE
   | CHAR
   | SHORT
   | INT
   | LONG
   | FLOAT
   | DOUBLE) {syso("built in type");};


methodheader :
  (i=IDENT | i=CONSNAME) {syso("method IDENT=" + $i.getText());} formals dims?
  throws_clause? EOL {syso("methodheader parsed");}
  ;

formals : 
  PAR_LEFT {syso("before param_declaration_list");} param_declaration_list? PAR_RIGHT;

param_declaration_list : {syso("started param_declaration_list");}
  param_declaration (COMMA param_declaration)*;

param_declaration :
  param_modifier? type_spec i=IDENT {syso("IDENT=" + $i.getText());} 
  dims? {syso("param_declaration");};

param_modifier :
  'final' | 'nullable' | 'non_null';

dims :
  (BR_LEFT BR_RIGHT)+
  {syso("dims");};
  
throws_clause :
  THROWS name_list;

instruction_line :
  { InstructionHandle[] iha = m.getBcelMethod().getInstructionList().
                              getInstructionHandles();
    if (iha.length <= inr) {
      if (affectBcc) {
        System.err.println("mnr="+mnr+", index="+inr+", size="+iha.length);
        throw new RuntimeException("instruction count changed! Bytecode parsing unsupported.");
      } else {
        syso("instruction count changed");
        reportError(null);
      }
    }
    if (inr < iha.length) {
      ih = iha[inr];
      syso("ih="+ih);
    }
  } (NAT COLON (~(EOL)*) EOL {
      syso("instruction");
      SingleList sl = m.getAmap().getAllAt(ih);
      if (affectBcc) {
        sl.trunce(minor);
        syso("minor="+minor+", size="+sl.size());
        m.getAmap().setAtributesForInstruction(ih, sl);
      }
     }
    )
  ;

// bml level

printableAttribute returns [BCPrintableAttribute ast] :
  (c=classAttribute {$ast = $c.ast;}
  | met=methodAttribute {$ast = $met.ast;}
  | i=inCodeAttribute {$ast = $i.ast;})
  EOF
  ;

classAttribute returns [ClassAttribute ast] :
  | CLASSINVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast, true);}
  | STATIC CLASSINVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast, false);}
  ;

methodAttribute returns [MethodAttribute ast] :
  m=methodSpecification {$ast = $m.ast;};

methodSpecification returns [MethodSpecification ast] :
    emptyspec
      {
        syso("empty spec parsed");
        $ast = null;
      }
  | s=specCase 
      {
        syso("specCase parsed");
        $ast = new MethodSpecification(m);
        $ast.addCase($s.ast);
      };
  
emptyspec :
    st=BML_START (EOL)* en=BML_END EOL
      {
         bml_positions.add(new PosInCode($st.getLine(),
                                         $st.getCharPositionInLine()));
         bml_positions.add(new PosInCode($en.getLine(),
                                         $en.getCharPositionInLine()+3));
         syso("empty spec");
      } 
  | (st=BML_ONE_LINE_START en=EOL
       {
          bml_positions.add(new PosInCode($st.getLine(),
                                          $st.getCharPositionInLine()));
          bml_positions.add(new PosInCode($en.getLine()+1,
                                          0));
       }
    )+
      {
         syso("empty spec");
      };

exname returns [String name] :
  i=typename {$name = $i.name;}
    (SEMICOLON {$name = $name + ';';})?
  | i2=IDENT {$name = $i2.getText();}
    (SEMICOLON {$name = $name + ';';})?
  ;

specCase returns [SpecificationCase ast] :
  st=BML_START
  (REQUIRES f1=formula {
     prec = $f1.ast;
     modif = null;
     postc = null;
     exc = new Vector<Exsure>();
   }
   (MODIFIES ml=modifyList {modif = $ml.ast;})?
   (POSTCONDITION f2=formula {postc = $f2.ast;})?
   (EXSURES 
     (i=exname COLON f3=formula {
        if (($i.name != null) && ($f3.ast != null)) {
          JavaReferenceType jrt = new JavaReferenceType($i.name);
          Exsure ex = new Exsure(jrt, $f3.ast);
          exc.add(ex);
        }
      })+
   )?
  ) en=BML_END EOL {
    bml_positions.add(new PosInCode($st.getLine(),
                                    $st.getCharPositionInLine()));
    bml_positions.add(new PosInCode($en.getLine(),
                                    $en.getCharPositionInLine()+3));
    if (prec != null)
      $ast = new SpecificationCase(m, prec, modif, postc, exc);
  };

inCodeAttribute returns [InCodeAttribute ast] :
  ASSERT f1=formula {$ast = new SingleAssert(m, ih, -1, $f1.ast);}
  | LOOPSPEC {
    modif = null;
    inv = null;
    dec = null;
  }
  (MODIFIES ml=modifyList {modif = $ml.ast;})?
  (LINVARIANT iv=formula {inv = $iv.ast;})?
  (LDECREASES de=expression {dec = $de.ast;})?
  {$ast = new SingleLoopSpecification(m, ih, -1, modif, inv, dec);}
  ;

modifyList returns [ModifyList ast] :
  l=modifyExpression {
    $ast = new ModifyList();
    $ast.addModify($l.ast);
  }
  (COMMA r=modifyExpression {
    $ast.addModify($r.ast);
  })*;

modifyExpression returns [ModifyExpression ast] :
  {initExpression();}
  (NOTHING {$ast = ModifyExpression.Nothing;}
    | EVERYTHING {$ast = ModifyExpression.Everything;}
        | l=localVar {$ast = new ModifiesLocalVar(l.lv);}
    | i=modifySubExpr {$ast = new ModifiesIdent($i.ast);}
      (DOT j=modifySubExpr {$ast = new ModifiesDot($ast, $j.ast);})*
      (BR_LEFT a=specArray BR_RIGHT {$ast = new ModifiesArray($ast, $a.ast);})*
  );

modifySubExpr returns [BCExpression ast] :
  THIS {$ast = new THIS(false, bcc);}
  | OLD_THIS {$ast = new THIS(true, bcc);}
  | i=IDENT {$ast = whatIsIt($i.getText());}
  ;

specArray returns [SpecArray ast] :
  MULT {$ast = new ModifiesStar();}
  | e=expression {$ast = new ModifiesSingleIndex($e.ast);}
  (DOT2 t=expression {$ast = new ModifiesInterval($ast.getSubExpr(0), $t.ast);})?
  ;

formula returns [AbstractFormula ast] :
  {initExpression();}
  e=uncheckedExpression {
    if ($e.ast == null) {
      reportError(null);
    } else {
      if ($e.ast.checkType() != JavaBasicType.JavaBool) {
        reportError(null);
      } else {
        if ($e.ast instanceof AbstractFormula) {
          $ast = (AbstractFormula)$e.ast;
        } else {
          $ast = new BooleanExpression($e.ast);
        }
      }
    }
  };

expression returns [AbstractIntExpression ast] :
  {initExpression();}
  e=uncheckedExpression {
    if ($e.ast == null) {
      reportError(null);
    } else {
      if ($e.ast.getType() != JavaBasicType.JavaInt) {
        reportError(null);
      } else {
        if ($e.ast instanceof AbstractIntExpression) {
          $ast = (AbstractIntExpression)$e.ast;
        } else {
          $ast = new IntExpression($e.ast);
        }
      }
    }
  };

uncheckedExpression returns [BCExpression ast] :
  e=conditionalExpression {$ast = $e.ast;};

conditionalExpression returns [BCExpression ast] :
  c=equivalenceExpr {$ast = $c.ast;}
  (COND t=uncheckedExpression COLON f=uncheckedExpression {
    $ast = new ConditionalExpression($c.ast, $t.ast, $f.ast);
  })?
  ;

equivalenceExpr returns [BCExpression ast] :
  e=impliesExpr {$ast = $e.ast;}
  ( EQUIV r=impliesExpr {$ast = new Formula(Code.EQUIV, $ast, $r.ast);}
    | NOTEQUIV r=impliesExpr {$ast = new Formula(Code.NOTEQUIV, $ast, $r.ast);}
  )*
  ;

impliesExpr returns [BCExpression ast] :
  e=logicalOrExpr {$ast = $e.ast;}
  (IMPLIES r=logicalOrExpr {$ast = new Formula(Code.IMPLIES, $ast, $r.ast);})*
  ;

logicalOrExpr returns [BCExpression ast] :
  e=logicalAndExpr {$ast = $e.ast;}
  (LOG_OR r=logicalAndExpr {$ast = new Formula(Code.OR, $ast, $r.ast);})*
  ;

logicalAndExpr returns [BCExpression ast] :
  e=bitwiseOrExpr {$ast = $e.ast;}
  (LOG_AND r=bitwiseOrExpr {$ast = new Formula(Code.AND, $ast, $r.ast);})*
  ;

bitwiseOrExpr returns [BCExpression ast] :
  e=bitwiseXorExpr {$ast = $e.ast;}
  (BITWISEOR r=bitwiseXorExpr {$ast = new ArithmeticExpression(Code.BITWISEOR, $ast, $r.ast);})*
  ;

bitwiseXorExpr returns [BCExpression ast] :
  e=bitwiseAndExpr {$ast = $e.ast;}
  (BITWISEXOR r=bitwiseAndExpr {$ast = new ArithmeticExpression(Code.BITWISEXOR, $ast, $r.ast);})*
  ;

bitwiseAndExpr returns [BCExpression ast] :
  e=equalityExpr {$ast = $e.ast;}
  (BITWISEAND r=equalityExpr {$ast = new ArithmeticExpression(Code.BITWISEAND, $ast, $r.ast);})*
  ;

equalityExpr returns [BCExpression ast] :
  l=shiftExpr EQ r=shiftExpr
    {$ast = new Predicate2Ar(Code.EQ, $l.ast, $r.ast);}
  | l=shiftExpr NOTEQ r=shiftExpr
    {$ast = new Predicate2Ar(Code.NOTEQ, $l.ast, $r.ast);}
  |
  e=relationalExpr {$ast = $e.ast;};

relationalExpr returns [BCExpression ast] :
  l=shiftExpr LESS r=shiftExpr
    {$ast = new Predicate2Ar(Code.LESS, $l.ast, $r.ast);}
  | l=shiftExpr GRT r=shiftExpr
    {$ast = new Predicate2Ar(Code.GRT, $l.ast, $r.ast);}
  | l=shiftExpr LESSEQ r=shiftExpr
    {$ast = new Predicate2Ar(Code.LESSEQ, $l.ast, $r.ast);}
  | l=shiftExpr GRTEQ r=shiftExpr
    {$ast = new Predicate2Ar(Code.GRTEQ, $l.ast, $r.ast);}
  |
  e=shiftExpr {$ast = $e.ast;};

shiftExpr returns [BCExpression ast] :
  p=additiveExpr {$ast = $p.ast;}
  (SHL r1=additiveExpr {$ast = new ArithmeticExpression(Code.SHL, $ast, $r1.ast);}
  | SHR r2=additiveExpr {$ast = new ArithmeticExpression(Code.SHR, $ast, $r2.ast);}
  | USHR r3=additiveExpr {$ast = new ArithmeticExpression(Code.USHR, $ast, $r3.ast);}
  )*
  ;

additiveExpr returns [BCExpression ast] :
  e=multExpr {$ast = $e.ast;}
  (PLUS r1=multExpr {$ast = new ArithmeticExpression(Code.PLUS, $ast, $r1.ast);}
  | MINUS r2=multExpr {$ast = new ArithmeticExpression(Code.MINUS, $ast, $r2.ast);}
  )*
  ;

multExpr returns [BCExpression ast] :
  e=quantifiedFormula {$ast = $e.ast;}
  (MULT r1=quantifiedFormula {$ast = new ArithmeticExpression(Code.MULT, $ast, $r1.ast);}
  | DIV r2=quantifiedFormula {$ast = new ArithmeticExpression(Code.DIV, $ast, $r2.ast);}
  | REM r3=quantifiedFormula {$ast = new ArithmeticExpression(Code.REM, $ast, $r3.ast);}
  )*
  ;

quantifiedFormula returns [BCExpression ast] :
  ((FORALL {$ast = new QuantifiedFormula(Code.FORALL_WITH_NAME); lqfs=0;}
  | EXISTS {$ast = new QuantifiedFormula(Code.EXISTS_WITH_NAME); lqfs=0;})
   (t=ident v=ident {try {
      JavaBasicType jt = JavaType.getJavaBasicType($t.text);
      lqfs++;
      BoundVar bv = new BoundVar(jt, bvc++, (QuantifiedFormula)$ast, $v.text);
      // uncomment this to forbid bound variable shadowing
//      if (env.containsKey($v.text))
//        reportError(null);
      env.put($v.text, bv);
       ((QuantifiedFormula)$ast).addVariable(bv);
     } catch(ReadAttributeException e) {
       reportError(null);
       //throw new RuntimeException("Error in BML.g3.quantifiedFormula");
     }})+
     SEMICOLON
     f=uncheckedExpression {((QuantifiedFormula)$ast).setFormula($f.ast);
       env.remove($v.text);
       bvc -= lqfs;
     }) |
  p=dotExpr {$ast = $p.ast;};

dotExpr returns [BCExpression ast] :
  l=primaryExpr {$ast = $l.ast;}
  (DOT r=primaryExpr {$ast = new FieldAccess(Code.FIELD_ACCESS, $ast, $r.ast);}
    | BR_LEFT p=uncheckedExpression BR_RIGHT {$ast = new ArrayAccess($ast, $p.ast);}
  )*
  ;

primaryExpr returns [BCExpression ast] :
  l=localVar {$ast = $l.lv;}
  | n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
  | i=ident {$ast = whatIsIt($i.text);}
  | MINUS min=primaryExpr {$ast = new UnaryArithmeticExpression(Code.NEG, $min.ast);}
  | PLUS px=primaryExpr {$ast = $px.ast;}
  | LOG_NOT p=primaryExpr {$ast = new Formula(Code.NOT, $p.ast);}
  | FALSE {$ast = new Predicate0Ar(false);}
  | TRUE {$ast = new Predicate0Ar(true);}
  | RESULT {if (m == null) {reportError(null);} else {$ast = new RESULT(m);}}
  | NULL {$ast = new NULL();}
  | THIS {$ast = new THIS(false, bcc);}
  | OLD_THIS {$ast = new THIS(true, bcc);}
  | OLD PAR_LEFT e1=uncheckedExpression PAR_RIGHT {$ast = new OLD(Code.OLD, $e1.ast);}
  | PAR_LEFT e=uncheckedExpression PAR_RIGHT {$ast = $e.ast;}
  | LENGTH {$ast = new ArrayLength();}
  ;

localVar returns [LocalVariable lv] :
  LV BR_LEFT n=NAT BR_RIGHT {
    int i=Integer.parseInt($n.text);
    if (m == null) {
      reportError(null);
    } else {
      if (i >= m.getLocalVariableCount()) {
        reportError(null);
      } else {
        $lv = m.getLocalVariable(false, i);
      }
    }
  };

ident returns [String name]:
  i=IDENT {$name = $i.getText();};

// ***** LEXER RULES *****

// bytecode level

//Java keywords

PACKAGE: 'package';
DEFAULTPACKAGE: '[default]';
IMPORT: 'import';
CLASS: 'class';
INTERFACE: 'interface';
PUBLIC: 'public';
PROTECTED: 'protected';
PRIVATE: 'private';
ABSTRACT: 'abstract';
STATIC: 'static';
FINAL: 'final';
NATIVE: 'native';
SYNCHRONIZED: 'synchronized';
TRANSIENT: 'transient';
VOLATILE: 'volatile';
STRICTFP: 'strictfp';
VOID: 'void';
BOOLEAN: 'boolean';
BYTE: 'byte';
CHAR: 'char';
SHORT: 'short';
INT: 'int';
LONG: 'long';
FLOAT: 'float';
DOUBLE: 'double';
EXTENDS: 'extends';
IMPLEMENTS: 'implements';
THROWS: 'throws';


// bml level
// IDisplayStyle must be modified as well

CONSNAME: '<init>';
ASSERT: 'assert';
LOOPSPEC: 'loop_specification';
LINVARIANT: 'loop_inv';
LDECREASES: 'decreases';
CLASSINVARIANT: 'invariant';
REQUIRES: 'requires';
SC_START: '{|';
SC_END: '|}';
PRECONDITION: 'precondition';
MODIFIES: 'modifies';
POSTCONDITION: 'ensures';
CONSTANT_POOL: 'Constant pool:';
SECOND_CONSTANT_POOL: 'Second constant pool:';
CONST: 'const';
COMMA: ',';
EXSURES: 'exsures';
COLON: ':';
NOTHING: '\\nothing';
EVERYTHING: '\\everything';
LOG_AND: '&&';
LOG_OR: '||';
IMPLIES: '==>';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
LOG_NOT: '~';
SEMICOLON: ';';
FORALL: '\\forall';
EXISTS: '\\exists';
TRUE: 'true';
FALSE: 'false';
LESS: '<';
LESSEQ: '<=';
EQ: '==';
NOTEQ: '!=';
GRTEQ: '>=';
GRT: '>';
EQUALS : '=';
PAR_LEFT: '(';
PAR_RIGHT: ')';
BR_LEFT: '[';
BR_RIGHT: ']';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
REM: '%';
HASH: '#';
SHL: '<<';
SHR: '>>';
USHR: '>>>';
BITWISEAND: '&';
BITWISEOR: '|';
BITWISEXOR: '^';
COND: '?';
NULL: 'null'|'NULL';
THIS: 'this'|'THIS';
OLD_THIS: 'old_this'|'OLD_THIS';
RESULT: '\\result';
LV: 'lv';
DOT2: '..';
DOT: '.';
OLD: 'old'|'OLD';
LENGTH: 'length';
BML_ONE_LINE_START: '//@';
ONE_LINE_COMMENT: '//';
BML_START: '/*@';
BML_END: '@*/';
COMMENT_END: '*/';
CLASS_CP: 'Class';
FIELDREF_CP: 'Fieldref';
METHODREF_CP: 'Methodref';
INTERFACEMETHODREF_CP: 'InterfaceMethodref';
STRING_CP: 'String';
INTEGER_CP: 'Integer';
UTF8_CP: 'Utf8';
LONG_CP: 'Long';
DOUBLE_CP: 'Double';
NAMEANDTYPE_CP: 'NameAndType';
FLOAT_CP: 'Float';

IDENT: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
NAT: ('0'..'9')+;
STRING: '\"' (.* (~('\\')))? '\"';

WS: (' '|'\t')+ {skip();};
EOF: '\f';
EOL: '\n';