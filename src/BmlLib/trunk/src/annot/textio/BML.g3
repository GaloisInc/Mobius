grammar BML;

options {
	output=AST;
	ASTLabelType=CommonTree;
	backtrack=true;
}

@header {
	package annot.textio;
	import org.apache.bcel.generic.InstructionHandle;
	import annot.bcclass.*;
	import annot.attributes.*;
	import annot.bcexpression.*;
	import annot.formula.*;
	import annot.io.Code;
	import annot.io.ReadAttributeException;
}

@members {
	public RecognitionException lastE = null;
	
	// initail data (parser parameters)
	private BCClass bcc;
	private BCMethod m;
	private BCConstantPool cp;
	private InstructionHandle ih;
	private int minor;

	// global variables
	private int bvc;  						// number of currently visible bound variables
	private int lqfs; 						// last (current) quantified formula size
	private HashMap<String, BoundVar> env;	// bound variable map

	// set context for attribute parsing
	public void init(BCClass bcc, BCMethod m, BCConstantPool cp, InstructionHandle ih, int minor) {
		this.bcc = bcc;
		this.m = m;
		this.cp = cp;
		this.ih = ih;
		this.minor = minor;
		this.bvc = 0;
		this.lqfs = 0;
		this.env = new HashMap<String, BoundVar>();
	}

	public void reportError(RecognitionException rex) {
		if (rex == null)
			rex = new RecognitionException();
		lastE = rex;
	}
	
	// Searches for an identifier name in diffrent locations
	// and returns proper one, or null if no identifier
	// of this name could be found.
	private BCExpression whatIsIt(String ident) {
		if (env.containsKey(ident))
			return env.get(ident);
		MLog.putMsg(MLog.PInfo, "undefined identifier: "+ident);
		RecognitionException rex = new RecognitionException();
		reportError(rex);
		return null;
	}
}

@lexer::header {
	package annot.textio;
	import annot.bcclass.*;
}

@lexer::members {
	public RecognitionException lastE = null;

	public void reportError(RecognitionException rex) {
		lastE = rex;
		MLog.putMsg(MLog.PError, "LEXER ERROR");
		super.reportError(rex);
	}
}

// PARSER RULES:

printableAttribute returns [BCPrintableAttribute ast] :
	ASSERT f1=formula EOF {$ast = new SingleAssert(m, null, -1, $f1.ast);}
	| CLASSINVARIANT f2=formula EOF {$ast = new ClassInvariant(bcc, $f2.ast);}
	| REQUIRES f3=formula EOF {$ast = new MethodSpecification(m, $f3.ast, new SpecificationCase[0]);}
	;

expression returns [BCExpression ast] :
	e=shiftExpr {$ast = $e.ast;};

formula returns [AbstractFormula ast] :
	e=uncheckedFormula {
		if ($e.ast == null) {
			$ast = null;
		} else {
			if ($e.ast.getType() != JavaType.JavaBool)
				reportError(null);
			$ast = (AbstractFormula)$e.ast;
		}
	};

uncheckedFormula returns [BCExpression ast] :
	e=equivalenceExpr {$ast = $e.ast;};

equivalenceExpr returns [BCExpression ast] :
	e=impliesExpr {$ast = $e.ast;}
	( EQUIV r=impliesExpr {$ast = new Formula(Code.EQUIV, $ast, $r.ast);}
		| NOTEQUIV r=impliesExpr {$ast = new Formula(Code.NOTEQUIV, $ast, $r.ast);}
	)*;

impliesExpr returns [BCExpression ast] :
	e=logicalOrExpr {$ast = $e.ast;}
	(IMPLIES r=logicalOrExpr {$ast = new Formula(Code.IMPLIES, $ast, $r.ast);})?;

logicalOrExpr returns [BCExpression ast] :
	e=logicalAndExpr {$ast = $e.ast;}
	(LOG_OR r=logicalAndExpr {$ast = new Formula(Code.OR, $ast, $r.ast);})*;

logicalAndExpr returns [BCExpression ast] :
	e=equalityExpr {$ast = $e.ast;}
	(LOG_AND r=equalityExpr {$ast = new Formula(Code.AND, $ast, $r.ast);})*;

equalityExpr returns [BCExpression ast] :
	l=shiftExpr EQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.EQ, $l.ast, $r.ast);}
	| l=shiftExpr NOTEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.NOTEQ, $l.ast, $r.ast);}
	| e=relationalExpr {$ast = $e.ast;}
	;

relationalExpr returns [BCExpression ast] :
	| l=shiftExpr LESS r=shiftExpr
		{$ast = new Predicate2Ar(Code.LESS, $l.ast, $r.ast);}
	| l=shiftExpr GRT r=shiftExpr
		{$ast = new Predicate2Ar(Code.GRT, $l.ast, $r.ast);}
	| l=shiftExpr LESSEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.LESSEQ, $l.ast, $r.ast);}
	| l=shiftExpr GRTEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.GRTEQ, $l.ast, $r.ast);}
	| q=quantifiedFormula {$ast = $q.ast;}
	;

quantifiedFormula returns [BCExpression ast] :
	(FORALL {$ast = new QuantifiedFormula(Code.FORALL_WITH_NAME); lqfs=0;}
	| EXISTS {$ast = new QuantifiedFormula(Code.EXISTS_WITH_NAME); lqfs=0;})
	 (t=IDENT v=IDENT {try {
			JavaType jt = JavaType.getJavaType($t.text);
			lqfs++;
			BoundVar bv = new BoundVar(jt, bvc++, (QuantifiedFormula)$ast, $v.text);
			if (env.containsKey($v.text))
				reportError(null);
			env.put($v.text, bv);
	 		((QuantifiedFormula)$ast).addVariable(bv);
	 	} catch(ReadAttributeException e) {
	 		reportError(null);
	 		//throw new RuntimeException("Error in BML.g3.quantifiedFormula");
	 	}})+
	 	SEMICOLON
	 	f=uncheckedFormula {((QuantifiedFormula)$ast).setFormula($f.ast);
	 		env.remove($v.text);
	 		bvc -= lqfs;
	 	}
	| p=primaryFormula {$ast = $p.ast;}
	;

primaryFormula returns [BCExpression ast] :
	FALSE {$ast = Predicate0Ar.FALSE;}
	| TRUE {$ast = Predicate0Ar.TRUE;}
	| i=IDENT {$ast = whatIsIt($i.text);}
	| PAR_LEFT f=uncheckedFormula PAR_RIGHT {$ast = $f.ast;}
	;

shiftExpr returns [BCExpression ast] :
	p=primaryExpr {$ast = $p.ast;};

primaryExpr returns [BCExpression ast] :
	n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
	| i=IDENT {$ast = whatIsIt($i.text);}
	| PAR_LEFT e=expression PAR_RIGHT {$ast = $e.ast;}
	;

// LEXER RULES:

ASSERT: '\\assert';
CLASSINVARIANT: '\\class invariant';
REQUIRES: '\\requires';
LOG_AND: '&&';
LOG_OR: '||';
IMPLIES: '==>';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
LOG_NOT: '~';
SEMICOLON: ';';
FORALL: 'forall';
EXISTS: 'exists';
TRUE: 'true';
FALSE: 'false';
LESS: '<';
LESSEQ: '<=';
EQ: '==';
NOTEQ: '!=';
GRTEQ: '>=';
GRT: '>';
PAR_LEFT: '(';
PAR_RIGHT: ')';

NAT: ('0'..'9')+;
IDENT: ('a'..'z')+;

WS: (' '|'\t')+ {skip();};
EOF: '\f';
