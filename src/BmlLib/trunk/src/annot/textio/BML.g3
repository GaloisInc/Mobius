/*
 * @title       "Umbra"
 * @description "An editor for the Java bytecode and BML specifications"
 * @copyright   "(c) 2006-2008 University of Warsaw"
 * @license     "All rights reserved. This program and the accompanying
 *               materials are made available under the terms of the LGPL
 *               licence see LICENCE.txt file"
 */
grammar BML;

options {
  output=AST;
  ASTLabelType=CommonTree;
  backtrack=true;
}

@header {
  package annot.textio;

  import annot.bcclass.*;
  import annot.attributes.*;
  import annot.attributes.clazz.*;
  import annot.attributes.field.*;
  import annot.attributes.method.*;
  import annot.bcexpression.*;
  import annot.bcexpression.javatype.*;
  import annot.bcexpression.modifies.*;
  import annot.bcexpression.formula.*;
  import annot.io.Code;
  import annot.io.ReadAttributeException;

  import org.apache.bcel.Constants;
  import org.apache.bcel.generic.MethodGen;
  import org.apache.bcel.generic.InstructionHandle;
  import org.apache.bcel.generic.InstructionList;
  import org.apache.bcel.generic.Type;
  import org.apache.bcel.classfile.ClassFormatException;
  import org.apache.bcel.classfile.Field;
  import java.util.Vector;
}

@members {
  public RecognitionException lastE = null;
  
  // initial data (parser parameters)
  private BCClass bcc;
  private BCMethod m;
  private BCConstantPool cp;
  private InstructionHandle ih;
  private int minor;
  private boolean affectBcc = false;

  // global variables
  private int mnr;            // number of current method
  private int inr;            // number of current instruction
  private int bvc;              // number of currently visible bound variables
  private int lqfs;             // last (current) quantified formula size
  private HashMap<String, BoundVar> env;  // bound variable map
  private Vector<PosInCode> bml_positions = new Vector(); //postions of BML areas
  private int invNo;           //the number of the current invariant
  
  //local variables
  private boolean clr = false;
  private AbstractFormula prec;
  private ModifyList modif;
  private AbstractFormula postc;
  private Vector<Exsure> exc;
  private AbstractFormula inv;
  private AbstractIntExpression dec;
  private BCField afield;
  private String fsig; // a signature of field's type

  // set whether to affect parsed BCClass, or only check syntax
  public void initClass(BCClass bcc, boolean affectBcc) {
    this.bcc = bcc;
    this.affectBcc = affectBcc;
    this.cp = bcc.getCp();
  }

  // initialize environment for expression parsing
  private void initExpression() {
    this.bvc = 0;
    this.lqfs = 0;
    this.env = new HashMap<String, BoundVar>();
  }

  // set context for attribute parsing
  public void init(BCClass bcc, BCMethod m, BCConstantPool cp, InstructionHandle ih, int minor) {
    this.bcc = bcc;
    this.m = m;
    this.cp = cp;
    this.ih = ih;
    this.minor = minor;
  }

  private void syso(String msg) {
    MLog.putMsg(MLog.LEVEL_PPARSER, msg);
  }

  public void reportError(RecognitionException rex) {
    if (rex == null)
      rex = new RecognitionException();
    lastE = rex;
    syso("*** error ***");
    if ((MLog.getLogMask() & MLog.LEVEL_PPARSER) > 0)
      super.reportError(rex);
  }
  
  // Searches for an identifier name in diffrent locations
  // and returns proper one, or null if no identifier
  // of this name could be found.
  private BCExpression whatIsIt(String ident) {
    if (ident == null) {
      reportError(null);
      return null;
    }
    if (env.containsKey(ident))
      return new SingleOccurence(env.get(ident));
    if (m != null) {
      LocalVariable lv = m.findLocalVariable(ident);
      if (lv != null) {
        return new SingleOccurence(lv);
      }
    }
    FieldRef bfr = FieldRef.getFieldOfName(bcc.getCp(), ident);
    if (bfr != null)
      return bfr;
    MLog.putMsg(MLog.LEVEL_PINFO, "undefined identifier: " + ident);
    reportError(null);
    return null;
  }
  
  public Vector<PosInCode> getBMLPositions() {
    return bml_positions;
  }
}

@lexer::header {
  package annot.textio;
  import annot.bcclass.*;
}

@lexer::members {
  public RecognitionException lastE = null;

  public void reportError(RecognitionException rex) {
    lastE = rex;
    MLog.putMsg(MLog.LEVEL_PPARSER, "LEXER ERROR");
    if ((MLog.getLogMask() & MLog.LEVEL_PPARSER) > 0) {
      System.err.println("LEXER ERROR");
      super.reportError(rex);
    }
  }
}

// ***** PARSER RULES *****

// bytecode level

parseClass :
  {syso("--------------- parsing started ---------------");}
  fileheader typeheader typebody EOF
  {syso("-------------- parsing completed --------------");};

fileheader :
  packageinfo constant_pools;

packageinfo :
  PACKAGE ( DEFAULTPACKAGE | typename ) (EOL)+
  {syso("packageinfo");};

typename returns [String name] :
    i=IDENT { $name = $i.getText(); }
    ((DIV | DOT) n=typename { $name +=  '/' + $n.name; })?
  | STRING_CP { $name = "String"; }
    ((DIV | DOT) n=typename { $name +=  '/' + $n.name; })?;

constant_pools : constant_pool ( second_constant_pool )? EOL;

constant_pool : CONSTANT_POOL EOL constant_pool_content
  {syso("constant_pool");};

second_constant_pool : SECOND_CONSTANT_POOL EOL constant_pool_content;

constant_pool_content : constant_pool_line EOL ( constant_pool_line EOL )*;

constant_pool_line : CONST cp_ref EQUALS constant_pool_entry;

constant_pool_entry : class_cp_entry | field_cp_entry 
   | method_cp_entry | interface_method_cp_entry
   | string_cp_entry | integer_cp_entry | float_cp_entry
   | long_cp_entry | double_cp_entry
   | name_and_type_cp_entry | utf8_cp_entry;
   
class_cp_entry : CLASS_CP cp_ref SEMICOLON ;

field_cp_entry : FIELDREF_CP cp_ref.cp_ref SEMICOLON;

method_cp_entry : METHODREF_CP cp_ref DOT cp_ref SEMICOLON;

interface_method_cp_entry : INTERFACEMETHODREF_CP cp_ref DOT cp_ref SEMICOLON;

string_cp_entry : STRING_CP cp_ref SEMICOLON;

integer_cp_entry : INTEGER_CP ( sign )? NAT SEMICOLON;

float_cp_entry : FLOAT_CP ( sign )? floating_point_literal SEMICOLON;

long_cp_entry : LONG_CP ( sign )? NATL SEMICOLON;

double_cp_entry : DOUBLE_CP ( sign )? floating_point_literal SEMICOLON;

name_and_type_cp_entry : NAMEANDTYPE_CP cp_ref COLON cp_ref SEMICOLON;

utf8_cp_entry :
  UTF8_CP StringLiteral SEMICOLON
  {
    syso("utf8_cp_entry");
  };

cp_ref : HASH NAT;

sign : PLUS | MINUS;

exponent_indicator : 'e' | 'E';

signed_integer : ( sign )? NAT;

exponent_part : exponent_indicator signed_integer;

floating_point_literal : NAT DOT ( NAT )? ( exponent_part )? ( float_type_suffix )?
        | DOT NAT ( exponent_part )? ( float_type_suffix )?
        | NAT exponent_part ( float_type_suffix )?
        | NAT ( exponent_part )? float_type_suffix;

float_type_suffix : 'f' | 'F' | 'd' | 'D';

typeheader :
  (  classmodifiers CLASS dotedname
     class_extends_clause? implements_clause?
   | interfacemodifiers INTERFACE dotedname
     interface_extends_clause? implements_clause?) (EOL)+
  {
    invNo = 0;
    syso("type header");
  };

dotedname :
  IDENT ( DOT IDENT)*;

classmodifiers :
  classmodifier* {syso("class modifiers");};
  
interfacemodifiers :
  interfacemodifier* {syso("interface modifiers");};

classmodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | ABSTRACT
   | STATIC
   | FINAL
   | STRICTFP) {syso("class modifier");};
   
interfacemodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | ABSTRACT
   | STATIC
   | STRICTFP) {syso("interface modifier");};

class_extends_clause :
  EXTENDS typename
  {syso("class_extends_clause");};

interface_extends_clause :
  EXTENDS name_list
  {syso("interface_extends_clause");};

implements_clause :
  IMPLEMENTS name_list
  {syso("implements_clause");};

name_list :
  typename ( COMMA typename )*
  {syso("name_list");};

typebody :
  (staticsection)?
  (objectsection)?
  { syso("methods start here");
    mnr = 0;
    m = bcc.getMethod(mnr);
  }
  (method
   {
      syso("method");
      mnr++;
      if (mnr < bcc.getMethodCount())
        m = bcc.getMethod(mnr);
   })+
  {
     syso("methods parsed");
  } EOL*;

staticsection :
  staticfields? staticspec?
  {
     syso("static section");
  };

staticfields :
  (staticfield EOL)* EOL*
  {
     syso("static fields");
  };

staticfield :
  {
    afield = new BCField(bcc);
    afield.setAccessFlags(Constants.ACC_STATIC);
  }
  STATIC field
  {
    if (afield.getNameIndex() >= 0) {
      bcc.updateFields(afield);
    }
    syso("static field");
  };

field returns [BCField bcf]:
  (nsfieldmodifier[afield])* typ=arr_type nm=ident SEMICOLON
  {
     if ($nm.name != null && $typ.typ != null) {
               //may be null in case of syntax error
     	afield.setName($nm.name);
     	afield.setType($typ.typ);
     }
     syso("field = " + afield.toString());
     $bcf = afield;
  }; 

staticspec : staticinvariants? staticconstraints?
             staticrepresents? staticinitially? EOL*;

nsfieldmodifier [BCField bcf]:
     modif=nsjavafieldmodifier
     {
        $bcf.setAccessFlags($bcf.getAccessFlags() | $modif.modif);
     }
   | bmodif=nsbmljavafieldmodifier
     {
         $bcf.setBMLFlags($bcf.getBMLFlags() | $bmodif.modif);
     }
   | kmodif=nsbmlkindmodifier
     {
         $bcf.setBMLKind($bcf.getBMLKind() | $kmodif.modif);
     };
   
nsjavafieldmodifier returns [int modif]:
  (  PUBLIC { $modif = Constants.ACC_PUBLIC; }
   | PROTECTED { $modif = Constants.ACC_PROTECTED; }
   | PRIVATE { $modif = Constants.ACC_PRIVATE; }
   | ABSTRACT { $modif = Constants.ACC_ABSTRACT; }
   | FINAL { $modif = Constants.ACC_FINAL; }
   | STRICTFP { $modif = Constants.ACC_STRICT; } ) ;

nsbmljavafieldmodifier returns [int modif]:
  (  SPEC_PUBLIC { $modif = BMLModifiersFlags.BML_SPEC_PUBLIC; }
   | SPEC_PROTECTED { $modif = BMLModifiersFlags.BML_SPEC_PROTECTED; }
   | NON_NULL { $modif = BMLModifiersFlags.BML_NON_NULL; }
   | NULLABLE { $modif = BMLModifiersFlags.BML_NULLABLE; }
   | PEER { $modif = BMLModifiersFlags.BML_PEER; }
   | REP { $modif = BMLModifiersFlags.BML_REP; }
   | READONLY { $modif = BMLModifiersFlags.BML_READONLY; }
  );

nsbmlkindmodifier returns [int modif]:
  (  MODEL { $modif = BCField.MODEL_FIELD; }
   | GHOST { $modif = BCField.GHOST_FIELD; }
  );

staticinvariants : 
  (staticinvariant)+ EOL
  {
     syso("static invariants");
  };

staticinvariant : 
     BML_START (EOL)? STATIC methodmodifier? INVARIANT f=formula (EOL)? BML_END EOL
     {
        if ($f.ast != null) {
          ClassInvariant inv = new ClassInvariant(bcc, $f.ast, false);
          bcc.setInvariant(inv, invNo++);
        }
     }
  |  BML_START (EOL)* BML_END EOL
     {
        {syso("empty static invariant");}
     }
  |  BML_START (~('\n')* EOL)* BML_END EOL
     {
        {syso("wrong static invariant");}
     };


staticconstraints : BML_START STATIC CONSTRAINT BML_END EOL;

staticrepresents : BML_START STATIC REPRESENTS BML_END EOL;

staticinitially : BML_START STATIC INITIALLY BML_END EOL;

objectsection :
  objectfields? objectspec? (EOL)*
  {
     syso("object section");
  };

objectfields :
  (
    {
      afield = new BCField(bcc);
    }
  field EOL
    {
       if (afield.getNameIndex() >= 0) {
         bcc.updateFields(afield);
       }
    }
  )* EOL*
  {
     syso("object fields");
  };

objectspec : objectinvariants? objectconstraints?
             objectrepresents? objectinitially?;

objectinvariants :
  (objectinvariant)+ EOL
  {
     syso("object invariants");
  };

objectinvariant : 
     BML_START (EOL)? methodmodifier? INVARIANT f=formula (EOL)? BML_END EOL
     {
        if ($f.ast != null) {
          ClassInvariant inv = new ClassInvariant(bcc, $f.ast, true);
          bcc.setInvariant(inv, invNo++);
        }
     }
  |  BML_START (EOL)* BML_END EOL
     {
        {syso("empty object invariant");}
     }
  |  BML_START (~('\n')* EOL)* BML_END EOL
     {
        {syso("wrong object invariant");}
     };

objectconstraints : BML_START CONSTRAINT BML_END EOL;
 
objectrepresents : BML_START REPRESENTS BML_END EOL;

objectinitially : BML_START INITIALLY BML_END EOL;

method :
   { syso("before method spec");}
   (met=methodSpecification {
      if ($met.ast != null) {
        syso("method attribute");
        if (clr) {
          syso("clearing method attributes");
          if (affectBcc) {
            m.setMspec(null);
            m.setMLocalSpecs(null);
          }
          clr = false;
        }
        if (affectBcc)
          $met.ast.replace(m);
      } else {
        syso("empty method attribute");
      }
    }) methodmodifiers arr_type? methodheader
        {
          if (clr) {
            syso("clearing method attributes");
            if (affectBcc) {
              m.setMspec(null);
              m.setMLocalSpecs(null);
            }
            clr = false;
          }
          syso("method header");
          inr = 0;
        }
        method_body
        {
           if (m.getInstructions() != null &&
               inr != m.getInstructions().getInstructionHandles().length) {
             syso("instruction count changed (2)");
             syso("previous length is: " + m.getInstructions().getInstructionHandles().length);
             syso("inr is: " + inr);
             reportError(null);
           }
           syso("end of method");
        } (EOL)*;

method_body :
   (specss=bml_in_method_spec? instruction_line
          {
             inr++;
             if ( specss != null ) {
           		  if (m != null && $specss.ast != null) {
               		$specss.ast.setIh(ih);
              	  m.addAttribute($specss.ast);
               		specss = null;
                }
             }
             syso("inner spec + instruction line");
          })+
 | EOL
   {
     syso("empty method body");
   };

methodmodifiers :
  methodmodifier* {syso("method modifiers");};
  
methodmodifier :
  (  PUBLIC
   | PROTECTED
   | PRIVATE
   | STATIC
   | ABSTRACT
   | FINAL
   | NATIVE
   | SYNCHRONIZED
   | TRANSIENT
   | VOLATILE
   | STRICTFP) {syso("method modifier");};  

arr_type returns [Type typ]:
    {
      fsig = "";
    }
    nm=type (dims)? 
    {
      if ($nm.name != null) {
        try {
          $typ = Type.getType(fsig);
        } catch (ClassFormatException e) {
          //not signature type
          $typ = Type.getType("V"); //TODO stupid default
        }
      }
      syso("arr_type");
    };

type returns [String name] :
    rname=reference_type { $name = $rname.name; }
  | bname=built_in_type { $name = $bname.name; };
  
reference_type returns [String name] :
  rname=typename
  {
    syso("reference type: " + $rname.name);
    $name = $rname.name;
    fsig = $rname.name;
  };

built_in_type returns [String name] :
  (  VOID {
       $name = "void";
       fsig = "V";
     }
   | BOOLEAN {
       $name = "boolean";
       fsig = "Z";
     }
   | BYTE {
       $name = "byte";
       fsig = "B";
     }
   | CHAR {
        $name = "char";
        fsig = "C";
     }
   | SHORT {
        $name = "short";
        fsig = "S";
       }
   | INT {
        $name = "int";
        fsig = "I";
      }
   | LONG {
        $name = "long";
        fsig = "L";
      }
   | FLOAT {
        $name = "float";
        fsig = "F";
      }
   | DOUBLE {
        $name = "double";
        fsig = "D";
      }
  ) {syso("built in type");};


methodheader :
  (i=IDENT | i=CONSNAME | i = STATICCONSNAME) (DOLARSIGN num=NAT)?
  {
     String name = $i.getText();
     if ($num != null) {
       name += "$" + $num.getText();
     }
     syso("method IDENT=" + name);
  }
  formals dims? EOL throws_clause?
  {
     syso("methodheader parsed");
  };

formals : 
  PAR_LEFT {syso("before param_declaration_list");} param_declaration_list? PAR_RIGHT;

param_declaration_list : {syso("started param_declaration_list");}
    param_declaration
      {
         syso("first param");
      }
    (COMMA param_declaration
      {
         syso("second or further param");
      }
    )*
  | param_declaration_noname (COMMA param_declaration_noname)*;

param_declaration :
  param_modifier? arr_type (i=IDENT
    {
       syso("IDENT=" + $i.getText());
    } | exponent_indicator | float_type_suffix)
  dims?
    {
      syso("param_declaration");
    };

param_declaration_noname :
  param_modifier? arr_type 
    {
       syso("noname ident");
    } 
  dims?
    {
      syso("param_declaration_noname");
    };

param_modifier :
  'final' | 'nullable' | 'non_null';

dims :
  (BR_LEFT BR_RIGHT 
    {
       fsig = '[' + fsig;
    } )+
  {syso("dims");};
  
throws_clause :
  (THROWS typename EOL)+;

bml_in_method_spec returns [InCodeAnnotation ast] :
      BML_ONE_LINE_START assrt=assertspec EOL
      {
         if ($assrt.ast != null) {
           $ast = $assrt.ast;
         }
         syso("one line assert with //@");
      }
   |  st=BML_START EOL*
      attr=inCodeAnnot EOL* en=BML_END EOL
      {
         $ast = $attr.ast;
         syso("inCodeAnnot in /*@ @*/");
      }
   | EOL
     {
       $ast = null;
       syso("empty BML spec inside method body");
     };

instruction_line returns [InstructionHandle ih] :
  { 
    if (m == null) {
      throw new RecognitionException();
    };
    MethodGen mg = m.getBcelMethod();
    if (mg == null) {
      throw new RecognitionException();
    }
    InstructionList il = mg.getInstructionList();
    if (il == null) {
      throw new RecognitionException();
    }
    InstructionHandle[] iha = il.getInstructionHandles();
    if (iha.length <= inr) {
      if (affectBcc) {
        System.err.println("mnr="+mnr+", index="+inr+", size="+iha.length);
        throw new RuntimeException("instruction count changed! Bytecode parsing unsupported.");
      } else {
        syso("instruction count changed (1)");
        syso("previous is: " + iha.length);
        syso("inr is: " + inr);
        reportError(null);
      }
    }
    if (inr < iha.length) {
      ih = iha[inr];
      syso("ih@" + inr + "="+ih);
    }
  } (n=NAT COLON (~'\n')* EOL {
      syso("instruction no " + n);
      SingleList sl = m.getAmap().getAllAt(ih);
      if (affectBcc) {
        sl.trunce(minor);
        syso("minor="+minor+", size="+sl.size());
        m.getAmap().setAtributesForInstruction(ih, sl);
      }
     }
    )
  ;

// bml level

printableAttribute returns [BCPrintableAttribute ast] :
   (c=classAttribute {$ast = $c.ast;}
  | met=methodAttribute {$ast = $met.ast;}
  | i=inCodeAnnot {$ast = $i.ast;})
  EOF
  ;

classAttribute returns [BCPrintableAttribute ast] :
  | INVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast, true);}
  | STATIC INVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast, false);}
  ;

methodAttribute returns [MethodAttribute ast] :
  m=methodSpecification {$ast = $m.ast;};

methodSpecification returns [MethodSpecificationAttribute ast] :
    emptyspec
      {
        syso("empty spec parsed");
        $ast = null;
      }
  | s=specCase 
      {
        syso("specCase parsed");
        $ast = new MethodSpecificationAttribute(m);
        $ast.addCase($s.ast);
      };
  
emptyspec :
    st=BML_START (EOL)* en=BML_END EOL
      {
         bml_positions.add(new PosInCode($st.getLine(),
                                         $st.getCharPositionInLine()));
         bml_positions.add(new PosInCode($en.getLine(),
                                         $en.getCharPositionInLine()+3));
         syso("empty spec");
      } 
  | (st=BML_ONE_LINE_START en=EOL
       {
          bml_positions.add(new PosInCode($st.getLine(),
                                          $st.getCharPositionInLine()));
          bml_positions.add(new PosInCode($en.getLine()+1,
                                          0));
       }
    )+
      {
         syso("empty spec");
      };

exname returns [String name] :
  i=typename {$name = $i.name;}
    (SEMICOLON {$name = $name + ';';})?
  | i2=IDENT {$name = $i2.getText();}
    (SEMICOLON {$name = $name + ';';})?
  ;

specCase returns [SpecificationCase ast] :
  st=BML_START EOL
  (REQUIRES f1=formula EOL
   {
      prec = $f1.ast;
      modif = null;
      postc = null;
      exc = new Vector<Exsure>();
   }
   (MODIFIES ml=modifyList {modif = $ml.ast;} EOL)?
   (ENSURES f2=formula {postc = $f2.ast;} EOL)?
   (EXSURES 
     (i=exname COLON f3=formula EOL 
      {
        if (($i.name != null) && ($f3.ast != null)) {
          JavaReferenceType jrt = new JavaReferenceType($i.name);
          Exsure ex = new Exsure(jrt, $f3.ast);
          exc.add(ex);
        }
      }
     )+
   )?
  ) en=BML_END EOL
    {
      bml_positions.add(new PosInCode($st.getLine(),
                                      $st.getCharPositionInLine()));
      bml_positions.add(new PosInCode($en.getLine(),
                                      $en.getCharPositionInLine()+3));
      if (prec != null)
        $ast = new SpecificationCase(m, prec, modif, postc, exc);
    };

inCodeAnnot returns [InCodeAnnotation ast] :
    assrt=assertspec
    {
       if ( $assrt.ast != null ) {
         $ast = $assrt.ast;
       }
       syso("inCodeAnnotation, assertspec");
    }
  | LOOPSPEC EOL
    {
       modif = null;
       inv = null;
       dec = null;
     }
     (LINVARIANT iv=formula {inv = $iv.ast;} EOL)?
     (LDECREASES de=expression {dec = $de.ast;} EOL)?
     {
        $ast = new SingleLoopSpecification(m, null, -1, inv, dec);
     };

assertspec returns [SingleAssert ast]  :
  ASSERT f1=formula
    {
       if ( $f1.ast != null ) {
         $ast = new SingleAssert(m, null, -1, $f1.ast);
       }
       syso("assert formula (1?)");
    };

modifyList returns [ModifyList ast] :
  l=modifyExpression 
  {
    $ast = new ModifyList();
    $ast.addModify($l.ast);
  }
  (COMMA r=modifyExpression  
   {
      $ast.addModify($r.ast);
   }
  )*;

modifyExpression returns [ModifyExpression ast] :
  {initExpression();}
  (   NOTHING
      {
         $ast = ModifyExpression.NOTHING_MODIF;
      }
    | EVERYTHING
      {
         //syso("\\everything parsed");
         $ast = ModifyExpression.EVERYTHING_MODIF;
      }
    | l=localVar
      {
         $ast = new ModifiesLocalVar(l.lv);
      }
    | i=modifySubExpr 
      {
         $ast = new ModifiesIdent($i.ast);
      }
      (DOT j=modifySubExpr 
       {
          $ast = new ModifiesDot($ast, $j.ast);
       }
      )* (BR_LEFT a=specArray BR_RIGHT
          {
             $ast = new ModifiesArray($ast, $a.ast);
          }
         )*
  );

modifySubExpr returns [BCExpression ast] :
  THIS {$ast = new THIS(bcc);}
  | i=IDENT {$ast = whatIsIt($i.getText());}
  ;

specArray returns [SpecArray ast] :
  MULT {$ast = new ModifiesStar();}
  | e=expression {$ast = new ModifiesSingleIndex($e.ast);}
  (DOT2 t=expression {$ast = new ModifiesInterval($ast.getSubExpr(0), $t.ast);})?
  ;

formula returns [AbstractFormula ast] :
  {initExpression();}
  e=uncheckedExpression {
    if ($e.ast == null) {
      syso("*** error ***");
      syso("no unchecked expression error");
      reportError(new RecognitionException(input));
    } else {
      JavaType jt = $e.ast.checkType();
      if (jt != JavaBasicType.JavaBool) {
        syso("*** error ***");
        syso("wrong type error");
        reportError(new RecognitionException(input));
      } else {
        if ($e.ast instanceof AbstractFormula) {
          $ast = (AbstractFormula)$e.ast;
        } else {
          $ast = new BooleanExpression($e.ast);
        }
      }
    }
  };

expression returns [AbstractIntExpression ast] :
  {initExpression();}
  e=uncheckedExpression {
    if ($e.ast == null) {
      syso("*** error ***");
      syso("no unchecked expression error");
      reportError(null);
    } else {
      if ($e.ast.getType() != JavaBasicType.JavaInt) {
        syso("*** error ***");
        syso("wrong type error");
        reportError(null);
      } else {
        if ($e.ast instanceof AbstractIntExpression) {
          $ast = (AbstractIntExpression)$e.ast;
        } else {
          $ast = new IntExpression($e.ast);
        }
      }
    }
  };

uncheckedExpression returns [BCExpression ast] :
  e=conditionalExpression {$ast = $e.ast;};

conditionalExpression returns [BCExpression ast] :
  c=equivalenceExpr {$ast = $c.ast;}
  (COND t=uncheckedExpression COLON f=uncheckedExpression {
    $ast = new ConditionalExpression($c.ast, $t.ast, $f.ast);
  })?
  ;

equivalenceExpr returns [BCExpression ast] :
  e=impliesExpr {$ast = $e.ast;}
  ( EQUIV r=impliesExpr {$ast = new Formula(Code.EQUIV, $ast, $r.ast);}
    | NOTEQUIV r=impliesExpr {$ast = new Formula(Code.NOTEQUIV, $ast, $r.ast);}
  )*
  ;

impliesExpr returns [BCExpression ast] :
  e=logicalOrExpr {$ast = $e.ast;}
  (IMPLIES r=logicalOrExpr {$ast = new Formula(Code.IMPLIES, $ast, $r.ast);})*
  ;

logicalOrExpr returns [BCExpression ast] :
  e=logicalAndExpr {$ast = $e.ast;}
  (LOG_OR r=logicalAndExpr {$ast = new Formula(Code.OR, $ast, $r.ast);})*
  ;

logicalAndExpr returns [BCExpression ast] :
  e=bitwiseOrExpr {$ast = $e.ast;}
  (LOG_AND r=bitwiseOrExpr {$ast = new Formula(Code.AND, $ast, $r.ast);})*
  ;

bitwiseOrExpr returns [BCExpression ast] :
  e=bitwiseXorExpr {$ast = $e.ast;}
  (BITWISEOR r=bitwiseXorExpr {$ast = new ArithmeticExpression(Code.BITWISEOR, $ast, $r.ast);})*
  ;

bitwiseXorExpr returns [BCExpression ast] :
  e=bitwiseAndExpr {$ast = $e.ast;}
  (BITWISEXOR r=bitwiseAndExpr {$ast = new ArithmeticExpression(Code.BITWISEXOR, $ast, $r.ast);})*
  ;

bitwiseAndExpr returns [BCExpression ast] :
  e=equalityExpr {$ast = $e.ast;}
  (BITWISEAND r=equalityExpr {$ast = new ArithmeticExpression(Code.BITWISEAND, $ast, $r.ast);})*
  ;

equalityExpr returns [BCExpression ast] :
    l=shiftExpr EQ r=shiftExpr
    {
       $ast = new Predicate2Ar(Code.EQ, $l.ast, $r.ast);
    }
  | l=shiftExpr NOTEQ r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.NOTEQ, $l.ast, $r.ast);
    }
  | e=relationalExpr
    {
      $ast = $e.ast;
    };

relationalExpr returns [BCExpression ast] :
    l=shiftExpr LESS r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.LESS, $l.ast, $r.ast);
    }
  | l=shiftExpr GRT r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.GRT, $l.ast, $r.ast);
     }
  | l=shiftExpr LESSEQ r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.LESSEQ, $l.ast, $r.ast);
    }
  | l=shiftExpr GRTEQ r=shiftExpr
    {
      $ast = new Predicate2Ar(Code.GRTEQ, $l.ast, $r.ast);
    }
  | e=shiftExpr
    {
      $ast = $e.ast;
    };

shiftExpr returns [BCExpression ast] :
    p=additiveExpr
    {
      $ast = $p.ast;
    }
    (  SHL r1=additiveExpr
       {
         $ast = new ArithmeticExpression(Code.SHL, $ast, $r1.ast);
       }
     | SHR r2=additiveExpr
       {
         $ast = new ArithmeticExpression(Code.SHR, $ast, $r2.ast);
       }
     | USHR r3=additiveExpr 
       {
          $ast = new ArithmeticExpression(Code.USHR, $ast, $r3.ast);
        }
    )*;

additiveExpr returns [BCExpression ast] :
  e=multExpr {$ast = $e.ast;}
  (PLUS r1=multExpr {$ast = new ArithmeticExpression(Code.PLUS, $ast, $r1.ast);}
  | MINUS r2=multExpr {$ast = new ArithmeticExpression(Code.MINUS, $ast, $r2.ast);}
  )*
  ;

multExpr returns [BCExpression ast] :
  e=quantifiedFormula {$ast = $e.ast;}
  (  MULT r1=quantifiedFormula {$ast = new ArithmeticExpression(Code.MULT, $ast, $r1.ast);}
   | DIV  r2=quantifiedFormula {$ast = new ArithmeticExpression(Code.DIV, $ast, $r2.ast);}
   | REM  r3=quantifiedFormula {$ast = new ArithmeticExpression(Code.REM, $ast, $r3.ast);}
  )*
  ;

quantifiedFormula returns [BCExpression ast] :
  ((  FORALL {$ast = new QuantifiedFormula(Code.FORALL_WITH_NAME); lqfs=0;}
    | EXISTS {$ast = new QuantifiedFormula(Code.EXISTS_WITH_NAME); lqfs=0;}
   )
   (t=type v=ident
      {
        try {
          JavaBasicType jt = JavaType.getJavaBasicType($t.text);
          lqfs++;
          BoundVar bv = new BoundVar(jt, bvc++, (QuantifiedFormula)$ast, $v.text);
          // uncomment this to forbid bound variable shadowing 
          //      if (env.containsKey($v.text))
          //        reportError(null);
          env.put($v.text, bv);
          ((QuantifiedFormula)$ast).addVariable(bv);
        } catch(ReadAttributeException e) {
          reportError(new MismatchedRangeException(t.start.getTokenIndex(),
                                                   t.stop.getTokenIndex(),
                                                   input));
          //throw new RuntimeException("Error in BML.g3.quantifiedFormula");
        }
      }
   )+
   SEMICOLON
   f=uncheckedExpression
     {
       ((QuantifiedFormula)$ast).setFormula($f.ast);
       env.remove($v.text);
       bvc -= lqfs;
     }
  )
  | p=dotExpr {$ast = $p.ast;};

dotExpr returns [BCExpression ast] :
  l=primaryExpr {$ast = $l.ast;}
  (DOT r=primaryExpr {$ast = new FieldAccess(Code.FIELD_ACCESS, $ast, $r.ast);}
    | BR_LEFT p=uncheckedExpression BR_RIGHT {$ast = new ArrayAccess($ast, $p.ast);}
  )*
  ;

primaryExpr returns [BCExpression ast] :
  l=localVar {$ast = $l.lv;}
  | n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
  | i=ident {$ast = whatIsIt($i.text);}
  | MINUS min=primaryExpr {$ast = new UnaryArithmeticExpression(Code.NEG, $min.ast);}
  | PLUS px=primaryExpr {$ast = $px.ast;}
  | LOG_NOT p=primaryExpr {$ast = new Formula(Code.NOT, $p.ast);}
  | BITWISENOT p=primaryExpr {$ast = new UnaryArithmeticExpression(Code.BITWISENOT, $p.ast);}
  | FALSE {$ast = new Predicate0Ar(false);}
  | TRUE {$ast = new Predicate0Ar(true);}
  | RESULT {if (m == null) {reportError(null);} else {$ast = new RESULT(m);}}
  | NULL {$ast = new NULL();}
  | THIS {$ast = new THIS(bcc);}
  | OLD PAR_LEFT e1=uncheckedExpression PAR_RIGHT {$ast = new OLD($e1.ast);}
  | PAR_LEFT e=uncheckedExpression PAR_RIGHT {$ast = $e.ast;}
  | LENGTH {$ast = new ArrayLength();}
  ;

localVar returns [LocalVariable lv] :
  LV BR_LEFT n=NAT BR_RIGHT {
    int i;
    try {
      i = Integer.parseInt($n.text);
    } catch (NumberFormatException e) {
      i = -1;
    }
    if (m == null) {
      syso("*** error ***");
      syso("outside method error");      
      reportError(null);
    } else {
      if (!m.canBeLocalVariable(i)) {
        syso("*** error ***");
        syso("no such variable error");
        reportError(null);
      } else {
        $lv = m.getLocalVariable(i);
      }
    }
  };

ident returns [String name]:
  i=IDENT {$name = $i.getText();};

// ***** LEXER RULES *****

// bytecode level

//Java keywords

PACKAGE: 'package';
DEFAULTPACKAGE: '[default]';
IMPORT: 'import';
CLASS: 'class';
INTERFACE: 'interface';
PUBLIC: 'public';
PROTECTED: 'protected';
PRIVATE: 'private';
ABSTRACT: 'abstract';
STATIC: 'static';
FINAL: 'final';
NATIVE: 'native';
SYNCHRONIZED: 'synchronized';
TRANSIENT: 'transient';
VOLATILE: 'volatile';
STRICTFP: 'strictfp';
VOID: 'void';
BOOLEAN: 'boolean';
BYTE: 'byte';
CHAR: 'char';
SHORT: 'short';
INT: 'int';
LONG: 'long';
FLOAT: 'float';
DOUBLE: 'double';
EXTENDS: 'extends';
IMPLEMENTS: 'implements';
THROWS: 'throws';


// bml level
// IDisplayStyle must be modified as well

EOF: '\f';
EOL: '\n';
CONSNAME: '<init>';
STATICCONSNAME: '<clinit>';
ASSERT: 'assert';
LOOPSPEC: 'loop_specification';
LINVARIANT: 'loop_inv';
LDECREASES: 'decreases';
INVARIANT: 'invariant';
CONSTRAINT: 'constraint';
REPRESENTS: 'represents';
INITIALLY: 'initially';
REQUIRES: 'requires';
SPEC_PUBLIC: 'spec_public';
SPEC_PROTECTED: 'spec_protected';
MODEL: 'model';
GHOST: 'ghost';
PURE: 'pure';
HELPER: 'helper';
NON_NULL: 'non_null';
NULLABLE: 'nullable';
PEER: 'peer';
REP: 'rep';
READONLY: 'readonly';
SC_START: '{|';
SC_END: '|}';
PRECONDITION: 'precondition';
MODIFIES: 'modifies';
ENSURES: 'ensures';
CONSTANT_POOL: 'Constant pool:';
SECOND_CONSTANT_POOL: 'Second constant pool:';
CONST: 'const';
COMMA: ',';
EXSURES: 'exsures';
COLON: ':';
NOTHING: '\\nothing';
EVERYTHING: '\\everything';
LOG_AND: '&&';
LOG_OR: '||';
LOG_NOT: '!';
IMPLIES: '==>';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
SEMICOLON: ';';
FORALL: '\\forall';
EXISTS: '\\exists';
TRUE: 'true';
FALSE: 'false';
LESS: '<';
LESSEQ: '<=';
EQ: '==';
NOTEQ: '!=';
GRTEQ: '>=';
GRT: '>';
EQUALS : '=';
PAR_LEFT: '(';
PAR_RIGHT: ')';
BR_LEFT: '[';
BR_RIGHT: ']';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
REM: '%';
HASH: '#';
SHL: '<<';
SHR: '>>';
USHR: '>>>';
BITWISEAND: '&';
BITWISEOR: '|';
BITWISEXOR: '^';
BITWISENOT: '~';
COND: '?';
NULL: 'null'|'NULL';
THIS: 'this'|'THIS';
RESULT: '\\result';
LV: 'lv';
DOT2: '..';
DOT: '.';
OLD: '\\old';
LENGTH: 'length';
BML_ONE_LINE_START: '//@';
ONE_LINE_COMMENT: '//';
BML_START: '/*@';
BML_END: '@*/';
COMMENT_END: '*/';
DOLARSIGN: '$';
CLASS_CP: 'Class';
FIELDREF_CP: 'Fieldref';
METHODREF_CP: 'Methodref';
INTERFACEMETHODREF_CP: 'InterfaceMethodref';
STRING_CP: 'String';
INTEGER_CP: 'Integer';
UTF8_CP: 'Utf8';
LONG_CP: 'Long';
DOUBLE_CP: 'Double';
NAMEANDTYPE_CP: 'NameAndType';
FLOAT_CP: 'Float';

fragment
HNUM: ('0'..'9') | ('a'..'f') | ('A'..'F');
IDENT: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
NAT: ('0'..'9')+;
NATL: ('0'..'9')+'L';

StringLiteral
    :  '"' ( EscapeSequence | ~('\\'|'"') )* '"'
    ;

fragment
EscapeSequence
    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
    |   UnicodeEscape
    |   OctalEscape
    ;

fragment
OctalEscape
    :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7')
    ;

fragment
UnicodeEscape
    :   '\\' 'u' HexDigit HexDigit HexDigit HexDigit
    ;

fragment
HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;

WS: (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;} ;