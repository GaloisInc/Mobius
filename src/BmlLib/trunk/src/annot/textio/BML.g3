grammar BML;

options {
	output=AST;
	ASTLabelType=CommonTree;
	backtrack=true;
}

@header {
	package annot.textio;

	import annot.bcclass.*;
	import annot.attributes.*;
	import annot.bcexpression.*;
	import annot.bcexpression.modifies.*;
	import annot.formula.*;
	import annot.io.Code;
	import annot.io.ReadAttributeException;

	import org.apache.bcel.generic.InstructionHandle;
	import java.util.Vector;
}

@members {
	public RecognitionException lastE = null;
	
	// initail data (parser parameters)
	private BCClass bcc;
	private BCMethod m;
	private BCConstantPool cp;
	private InstructionHandle ih;
	private int minor;
	private boolean affectBcc = false;

	// global variables
	private int mnr;						// number of current method
	private int inr;						// number of current instruction
	private int bvc;  						// number of currently visible bound variables
	private int lqfs; 						// last (current) quantified formula size
	private HashMap<String, BoundVar> env;	// bound variable map
	
	//local variables
	private boolean clr = false;
	private AbstractFormula prec;
	private ModifyExpression modif;
	private AbstractFormula postc;
	private Vector<Exsure> exc;

	// set wether to affect parsed BCClass, or only check syntax
	public void initClass(BCClass bcc, boolean affectBcc) {
		this.bcc = bcc;
		this.affectBcc = affectBcc;
		this.cp = bcc.getCp();
	}

	// initialize environment for expression parsing
	private void initExpression() {
		this.bvc = 0;
		this.lqfs = 0;
		this.env = new HashMap<String, BoundVar>();
	}

	// set context for attribute parsing
	public void init(BCClass bcc, BCMethod m, BCConstantPool cp, InstructionHandle ih, int minor) {
		this.bcc = bcc;
		this.m = m;
		this.cp = cp;
		this.ih = ih;
		this.minor = minor;
	}

	private void syso(String msg) {
		MLog.putMsg(MLog.PParser, msg);
	}

	public void reportError(RecognitionException rex) {
		if (rex == null)
			rex = new RecognitionException();
		lastE = rex;
		syso("*** error ***");
		if ((MLog.mask & MLog.PParser) > 0)
			super.reportError(rex);
	}
	
	// Searches for an identifier name in diffrent locations
	// and returns proper one, or null if no identifier
	// of this name could be found.
	private BCExpression whatIsIt(String ident) {
		if (env.containsKey(ident))
			return env.get(ident);
		MLog.putMsg(MLog.PInfo, "undefined identifier: "+ident);
		RecognitionException rex = new RecognitionException();
		reportError(rex);
		return null;
	}
}

@lexer::header {
	package annot.textio;
	import annot.bcclass.*;
}

@lexer::members {
	public RecognitionException lastE = null;

	public void reportError(RecognitionException rex) {
		lastE = rex;
		MLog.putMsg(MLog.PParser, "LEXER ERROR");
		if ((MLog.mask & MLog.PParser) > 0) {
			System.err.println("LEXER ERROR");
			super.reportError(rex);
		}
	}
}

// ***** PARSER RULES *****

// bytecode level

parseClass :
	{syso("--------------- parsing started ---------------");}
	PACKAGE? CLASS?
	{syso("class");}
	(NO_CLA {syso("skipping class declarations");}
		| classComment {syso("class declarations");}
			EOD)
	{syso("end of class decl");
	mnr = 0;
	m = bcc.getMethod(mnr);
	}
	(method
		{syso("method");
		mnr++;
		if (mnr < bcc.getMethodCount())
			m = bcc.getMethod(mnr);
	})+
	EOF
	{syso("-------------- parsing completed --------------");}
	;

classComment :
	EOA {
		syso("begin of class decl");
		if (affectBcc)
			bcc.setInvariant(null);
	}
	(c=classAttribute {
		if ($c.ast != null) {
			syso("next class attribute");
			if (affectBcc)
				$c.ast.replace(bcc);
		}
	}
		EOA)*
	;

method :
	NO_METHOD {syso("skipping method");}
	|	{clr = true;}
		((NO_MSPEC {syso("skipping method specification");}
		MHEAD {
			syso("method header");
			inr = 0;
		}
		| (met=methodAttribute {
			if ($met.ast != null) {
				syso("method attribute");
				if (clr) {
					syso("clearing method attributes");
					if (affectBcc)
						m.setMspec(null);
					clr = false;
				}
				if (affectBcc)
					$met.ast.replace(m);
			}
			} EOA)*
			MHEAD {
				if (clr) {
					syso("clearing method attributes");
					if (affectBcc)
						m.setMspec(null);
					clr = false;
				}
				syso("method header");
				inr = 0;
			})
		(instruction {inr++;})+
		EOM {
			syso("end of method");
			if (inr != m.getInstructions().getInstructionHandles().length) {
				syso("instruction count changed!");
				reportError(null);
			}
		})
	;

instruction :
	{InstructionHandle[] iha = m.getBcelMethod().getInstructionList().getInstructionHandles();
		if (iha.length <= inr) {
			if (affectBcc) {
				System.err.println("mnr="+mnr+", index="+inr+", size="+iha.length);
				throw new RuntimeException("instruction count changed! Bytecode parsing unsupported.");
			} else {
				syso("instruction count changed");
				reportError(null);
			}
		}
		if (inr < iha.length) {
			ih = iha[inr];
			syso("ih="+ih);
		}
	}
	(NO_INSTRUCTION {syso("skipping instruction");}
	| ((comment {syso("comment");})?
		INSTRUCTION {
			syso("instruction");
			SingleList sl = m.getAmap().getAllAt(ih);
			if (affectBcc) {
				sl.trunce(minor);
				syso("minor="+minor+", size="+sl.size());
				m.getAmap().setAtributesForInstruction(ih, sl);
			}
		}))
	;

comment :
	EOA {syso("beginning of comment");
		minor = 0;
	}
	( NO_ANNOTATION {
		syso("annotation unaffected");
		minor++;
	}
		| ica=inCodeAttribute {
			if ($ica.ast != null) {
				syso("annotation");
				SingleList sl = m.getAmap().getAllAt(ih);
				if (affectBcc) {
					sl.setNth(minor, $ica.ast);
					m.getAmap().setAtributesForInstruction(ih, sl);
				}
				minor++;
			}
		} EOA)*
	;

// bml level

printableAttribute returns [BCPrintableAttribute ast] :
	(c=classAttribute {$ast = $c.ast;}
	| met=methodAttribute {$ast = $met.ast;}
	| i=inCodeAttribute {$ast = $i.ast;})
	EOF
	;

classAttribute returns [ClassAttribute ast] :
	| CLASSINVARIANT f2=formula {$ast = new ClassInvariant(bcc, $f2.ast);}
	;

methodAttribute returns [MethodAttribute ast] :
	m=methodSpecification {$ast = $m.ast;};

methodSpecification returns [MethodSpecification ast] :
	| REQUIRES f3=formula {$ast = new MethodSpecification(m, $f3.ast, new SpecificationCase[0]);}
		(SC_START s=specCase {$ast.addCase($s.ast);} SC_END)*
	;

exname returns [String name] :
	i=EXC_IDENT {$name = $i.getText();}
	| i2=IDENT {$name = $i2.getText();}
	;

specCase returns [SpecificationCase ast] :
	(PRECONDITION f1=formula {
		prec = $f1.ast;
		modif = null;
		postc = null;
		exc = new Vector<Exsure>();
	}
	(MODIFIES me=modifyExpression {modif = $me.ast;})?
	(POSTCONDITION f2=formula {postc = $f2.ast;})?
	(EXSURES (i=exname EXCNAMEEND f3=formula {
		if (($i.name != null) && ($f3.ast != null)) {
			JavaReferenceType jrt = new JavaReferenceType($i.name);
			Exsure ex = new Exsure(jrt, $f3.ast);
			exc.add(ex);
		}
	})*)?)
		{if (prec != null)
			$ast = new SpecificationCase(m, prec, modif, postc, exc);
		};

inCodeAttribute returns [InCodeAttribute ast] :
	ASSERT f1=formula {$ast = new SingleAssert(m, ih, -1, $f1.ast);}
	;

modifyExpression returns [ModifyExpression ast] :
	NOTHING {$ast = ModifyExpression.Nothing;}
	| EVERYTHING {$ast = ModifyExpression.Everything;}
	;

expression returns [BCExpression ast] :
	e=bitwiseOrExpr {$ast = $e.ast;};

formula returns [AbstractFormula ast] :
	{initExpression();}
	e=uncheckedFormula {
		if ($e.ast == null) {
			reportError(null);
		} else {
			if ($e.ast.getType() != JavaBasicType.JavaBool) {
				reportError(null);
			} else {
				$ast = (AbstractFormula)$e.ast;
			}
		}
	};

uncheckedFormula returns [BCExpression ast] :
	e=equivalenceExpr {$ast = $e.ast;};

equivalenceExpr returns [BCExpression ast] :
	e=impliesExpr {$ast = $e.ast;}
	( EQUIV r=impliesExpr {$ast = new Formula(Code.EQUIV, $ast, $r.ast);}
		| NOTEQUIV r=impliesExpr {$ast = new Formula(Code.NOTEQUIV, $ast, $r.ast);}
	)*;

impliesExpr returns [BCExpression ast] :
	e=logicalOrExpr {$ast = $e.ast;}
	(IMPLIES r=logicalOrExpr {$ast = new Formula(Code.IMPLIES, $ast, $r.ast);})*;

logicalOrExpr returns [BCExpression ast] :
	e=logicalAndExpr {$ast = $e.ast;}
	(LOG_OR r=logicalAndExpr {$ast = new Formula(Code.OR, $ast, $r.ast);})*;

logicalAndExpr returns [BCExpression ast] :
	e=equalityExpr {$ast = $e.ast;}
	(LOG_AND r=equalityExpr {$ast = new Formula(Code.AND, $ast, $r.ast);})*;

bitwiseOrExpr returns [BCExpression ast] :
	e=bitwiseXorExpr {$ast = $e.ast;}
	(BITWISEOR r=bitwiseXorExpr {$ast = new ArithmeticExpression(Code.BITWISEOR, $ast, $r.ast);})*;

bitwiseXorExpr returns [BCExpression ast] :
	e=bitwiseAndExpr {$ast = $e.ast;}
	(BITWISEXOR r=bitwiseAndExpr {$ast = new ArithmeticExpression(Code.BITWISEXOR, $ast, $r.ast);})*;

bitwiseAndExpr returns [BCExpression ast] :
	e=shiftExpr {$ast = $e.ast;}
	(BITWISEAND r=shiftExpr {$ast = new ArithmeticExpression(Code.BITWISEAND, $ast, $r.ast);})*;

equalityExpr returns [BCExpression ast] :
	l=shiftExpr EQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.EQ, $l.ast, $r.ast);}
	| l=shiftExpr NOTEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.NOTEQ, $l.ast, $r.ast);}
	| e=relationalExpr {$ast = $e.ast;}
	;

relationalExpr returns [BCExpression ast] :
	| l=shiftExpr LESS r=shiftExpr
		{$ast = new Predicate2Ar(Code.LESS, $l.ast, $r.ast);}
	| l=shiftExpr GRT r=shiftExpr
		{$ast = new Predicate2Ar(Code.GRT, $l.ast, $r.ast);}
	| l=shiftExpr LESSEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.LESSEQ, $l.ast, $r.ast);}
	| l=shiftExpr GRTEQ r=shiftExpr
		{$ast = new Predicate2Ar(Code.GRTEQ, $l.ast, $r.ast);}
	| q=quantifiedFormula {$ast = $q.ast;}
	;

quantifiedFormula returns [BCExpression ast] :
	((FORALL {$ast = new QuantifiedFormula(Code.FORALL_WITH_NAME); lqfs=0;}
	| EXISTS {$ast = new QuantifiedFormula(Code.EXISTS_WITH_NAME); lqfs=0;})
	 (t=ident v=ident {try {
			JavaBasicType jt = JavaType1.getJavaBasicType($t.text);
			lqfs++;
			BoundVar bv = new BoundVar(jt, bvc++, (QuantifiedFormula)$ast, $v.text);
			if (env.containsKey($v.text))
				reportError(null);
			env.put($v.text, bv);
	 		((QuantifiedFormula)$ast).addVariable(bv);
	 	} catch(ReadAttributeException e) {
	 		reportError(null);
	 		//throw new RuntimeException("Error in BML.g3.quantifiedFormula");
	 	}})+
	 	SEMICOLON
	 	f=uncheckedFormula {((QuantifiedFormula)$ast).setFormula($f.ast);
	 		env.remove($v.text);
	 		bvc -= lqfs;
	 	})
	| p=primaryFormula {$ast = $p.ast;}
	;

primaryFormula returns [BCExpression ast] :
	FALSE {$ast = Predicate0Ar.FALSE;}
	| TRUE {$ast = Predicate0Ar.TRUE;}
	| i=ident {$ast = whatIsIt($i.text);}
	| LOG_NOT p=primaryFormula {$ast = new Formula(Code.NOT, $p.ast);}
	| PAR_LEFT f=uncheckedFormula PAR_RIGHT {$ast = $f.ast;}
	;

shiftExpr returns [BCExpression ast] :
	p=additiveExpr {$ast = $p.ast;}
	(SHL r1=additiveExpr {$ast = new ArithmeticExpression(Code.SHL, $ast, $r1.ast);}
	| SHR r2=additiveExpr {$ast = new ArithmeticExpression(Code.SHR, $ast, $r2.ast);}
	| USHR r3=additiveExpr {$ast = new ArithmeticExpression(Code.USHR, $ast, $r3.ast);}
	)*;

additiveExpr returns [BCExpression ast] :
	e=multExpr {$ast = $e.ast;}
	(PLUS r1=multExpr {$ast = new ArithmeticExpression(Code.PLUS, $ast, $r1.ast);}
	| MINUS r2=multExpr {$ast = new ArithmeticExpression(Code.MINUS, $ast, $r2.ast);}
	)*;

multExpr returns [BCExpression ast] :
	e=unaryExpr {$ast = $e.ast;}
	(MULT r1=unaryExpr {$ast = new ArithmeticExpression(Code.MULT, $ast, $r1.ast);}
	| DIV r2=unaryExpr {$ast = new ArithmeticExpression(Code.DIV, $ast, $r2.ast);}
	| REM r3=unaryExpr {$ast = new ArithmeticExpression(Code.REM, $ast, $r3.ast);}
	)*;

unaryExpr returns [BCExpression ast] :
	e=primaryExpr {$ast = $e.ast;};

primaryExpr returns [BCExpression ast] :
	n=NAT {$ast = new NumberLiteral(Integer.parseInt($n.text));}
	| i=ident {$ast = whatIsIt($i.text);}
	| MINUS m=primaryExpr {$ast = new UnaryArithmeticExpression(Code.NEG, $m.ast);}
//	| PLUS px=primaryExpr {$ast = $px.ast;}
	| PAR_LEFT e=expression PAR_RIGHT {$ast = $e.ast;}
	;

ident returns [String name]:
	i=IDENT {$name = $i.getText();};

// ***** LEXER RULES *****

// bytecode level

PACKAGE: '[package]';
CLASS: '[class]';
NO_CLA: '\\class attributes unaffected';
NO_METHOD: '\\method unaffected';
MHEAD: '[method header]';
NO_INSTRUCTION: '\\instruction unaffected';
INSTRUCTION: '[instruction]';
NO_MSPEC: '\\method specification unaffected';
NO_ANNOTATION: '\\annotation unaffected';
EOD: 'EOD';
EOM: 'EOM';
EOA: 'EOA';

// bml level

ASSERT: '\\assert';
CLASSINVARIANT: '\\class invariant';
REQUIRES: '\\requires';
SC_START: '{|';
SC_END: '|}';
PRECONDITION: '\\precondition';
MODIFIES: '\\modifies';
POSTCONDITION: '\\ensures';
EXSURES: '\\exsures';
EXCNAMEEND: ':';
NOTHING: 'nothing';
EVERYTHING: 'everything';
LOG_AND: '&&';
LOG_OR: '||';
IMPLIES: '==>';
EQUIV: '<==>';
NOTEQUIV: '<=!=>';
LOG_NOT: '~';
SEMICOLON: ';';
FORALL: 'forall';
EXISTS: 'exists';
TRUE: 'true';
FALSE: 'false';
LESS: '<';
LESSEQ: '<=';
EQ: '==';
NOTEQ: '!=';
GRTEQ: '>=';
GRT: '>';
PAR_LEFT: '(';
PAR_RIGHT: ')';
PLUS: '+';
MINUS: '-';
MULT: '*';
DIV: '/';
REM: '%';
SHL: '<<';
SHR: '>>';
USHR: '>>>';
BITWISEAND: '&';
BITWISEOR: '|';
BITWISEXOR: '^';

NAT: ('0'..'9')+;
IDENT: ('a'..'z'|'A'..'Z')+;
EXC_IDENT: (('a'..'z'|'A'..'Z')+('/'|'.')+)+('a'..'z'|'A'..'Z')+;

WS: (' '|'\t'|'\n')+ {skip();};
EOF: '\f';
