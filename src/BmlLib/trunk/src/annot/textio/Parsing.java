package annot.textio;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.apache.bcel.generic.InstructionHandle;

import annot.attributes.BCPrintableAttribute;
import annot.bcclass.BCClass;
import annot.bcclass.BCMethod;

/**
 * Class used for parsing BML annotations (real parser has been
 * generated by antlr tool to <code>antlr3-generated</code>
 * package). It contains also some methods for String
 * opetarions on BML annotations.
 * 
 * @author tomekb
 */
public class Parsing {

	/**
	 * BCClass of all BML annotations parsing here.
	 */
	private BCClass bcc;

	/**
	 * A standard constructor.
	 * 
	 * @param bcc - BCClass of all BML annotations
	 * 		to be parsed here.
	 */
	public Parsing(BCClass bcc) {
		this.bcc = bcc;
	}

	/**
	 * Returns line of given number of given String.
	 * 
	 * @param code - multi line String,
	 * @param pos - number of line in <code>code</code>.
	 * @return <code>pos</code>'s line of <code>code</code>.
	 */
	public static int lineAt(String code, int pos) {
		return code.substring(0, pos).split("\n").length - 1;
	}

	/**
	 * Returns fragment of given code.
	 * 
	 * @param code - multi line String,
	 * @param start - start line number,
	 * @param end - end line number,
	 * @return substring of <code>code</code>, from line
	 * 		no. <code>start</code> to line no. <code>end</code>
	 * 		(including both start and end lines).
	 */
	public static String getLines(String code, int start, int end) {
		String ret = "";
		String[] lines = code.split("\n");
		for (int i = start; i <= end; i++)
			ret += lines[i];
		return ret;
	}

	/**
	 * Escapes given String, for use as a regexp pattern.
	 * 
	 * @param str - any String.
	 * @return escaped <code>str</code>, to use as regexp
	 * 		pattern to match <code>str</code> literally.
	 */
	public static String escape(String str) {
		str = str.replaceAll("\\\\", "\\\\\\\\");
		str = str.replaceAll("\\*", "\\\\\\*");
		str = str.replaceAll("\\{", "\\\\\\{");
		str = str.replaceAll("\\}", "\\\\\\}");
		return str;
	}

	/**
	 * Removes comment surrounding given BML annotation.
	 * 
	 * @param attr - String representation of an BML
	 * 		annotation.
	 * @return <code>attr</code> without surrounding comment.
	 */
	public static String removeComment(String attr) {
		attr = attr.replaceAll(escape(IDisplayStyle.comment_start), "");
		attr = attr.replaceAll(escape("\n" + IDisplayStyle.comment_next), "\n");
		attr = attr.replaceAll(escape(IDisplayStyle.comment_end), "");
		return attr;
	}

	/**
	 * Removes comment, line-breaks and stray spaces from
	 * given BML annotation. Can be used to compare BML
	 * annotation (eg. in parser test).
	 * 
	 * @param attr - String representation of an BML
	 * 		annotation.
	 * @return <code>attr</code> with unnessesery characters
	 * 		removed.
	 */
	public static String purge(String attr) {
		attr = removeComment(attr);
		attr = attr.replaceAll("\n", "");
		while (attr.lastIndexOf("  ") >= 0)
			attr = attr.replaceAll("  ", " ");
		return attr;
	}

	/**
	 * Surrounds given BML annotation's code with comment.
	 * 
	 * @param code - String representation of one or more
	 * 		BML annotations (after line-breaing).
	 * @return <code>code</code> surrounded by common comment.
	 */
	public static String addComment(String code) {
		if (code.length() < 1)
			return "";
		if (code.lastIndexOf("\n") == code.length() - 1)
			code = code.substring(0, code.length() - 1);
		if ((code.lastIndexOf("\n") >= 0)
				|| (code.length() > IDisplayStyle.max_total_line_width
						- IDisplayStyle.comment_start.length()
						- IDisplayStyle.comment_end.length())) {
			String[] lines = code.split("\n");
			code = "";
			for (int i = 0; i < lines.length; i++) {
				if (!lines[i].startsWith(IDisplayStyle.comment_next))
					lines[i] = IDisplayStyle.comment_next + lines[i];
				if (lines[i].equals(IDisplayStyle.comment_next))
					continue;
				code += lines[i] + "\n";
			}
			return IDisplayStyle.comment_start + "\n" + code
					+ IDisplayStyle.comment_end + "\n";
		} else {
			return IDisplayStyle.comment_start + code
					+ IDisplayStyle.comment_end + "\n";
		}
	}

	/**
	 * Parse an BML annotation using parser generated from
	 * <code>BML.g3</code> grammatic.
	 * 
	 * @param m - parsing annotation's method (or null for
	 * 		class annotations),
	 * @param ih - instructionHandle of parsing annotation, 
	 * @param minor - minor number of parsing annotation,
	 * @param str - new String representation to be parsed
	 * 		(without surrounding comment - use
	 * 		{@link #purge(String)} method to remove comment),
	 * @return new BCPrintableAttribute parsed from
	 * 		<code>str</code>.
	 * @throws RecognitionException - if <code>str</code>
	 * 		isn't correct BML annotation.
	 */
	public BCPrintableAttribute parseAttribute(BCMethod m,
			InstructionHandle ih, int minor, String str)
			throws RecognitionException {
		CharStream chstr = new ANTLRStringStream(str);
		BMLLexer lex = new BMLLexer(chstr);
		CommonTokenStream tokens = new CommonTokenStream(lex);
		BMLParser parser = new BMLParser(tokens);
		parser.init(bcc, m, bcc.getCp(), ih, minor);
		BCPrintableAttribute result = parser.printableAttribute().ast;
		if (lex.lastE != null)
			throw lex.lastE;
		if (parser.lastE != null)
			throw parser.lastE;
		return result;
	}

	/**
	 * Perform syntax and (basic) semantics checks of given
	 * BML annotation String.
	 * 
	 * @param m - parsing annotation's method (or null for
	 * 		class annotations),
	 * @param ih - instructionHandle of parsing annotation, 
	 * @param minor - minor number of parsing annotation,
	 * @param str - new String representation to be parsed
	 * 		(without surrounding comment - use
	 * 		{@link #purge(String)} method to remove comment),
	 * @return true iff <code>str</code> is correct, false
	 * 		otherwise.
	 */
	public BCPrintableAttribute checkSyntax(BCMethod m, InstructionHandle ih,
			int minor, String str) {
		try {
			BCPrintableAttribute newattr = parseAttribute(m, ih, minor, str);
			return newattr;
		} catch (RecognitionException e) {
			return null;
		}
	}

}
