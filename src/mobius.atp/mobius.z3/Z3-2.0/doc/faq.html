 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: SMT solver" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: SMT solver</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="status.html"><span>Status</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient SMT Solver</p>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="faq">FAQ (Frequently Asked Questions) </a></h1><ul>
<li>
<b>Are you going to support plataform X?</b><br>
<br>
 We only support Windows. A Linux binary can be downloaded from the <a href="http://www.smtcomp.org/2007" class="el">SMT-COMP</a> website.<p>
</li>
<li>
<b>Are you going to release Z3 source code?</b><br>
<br>
 We do not know yet.<p>
</li>
<li>
<b>Why is Z3 1.0 (1.1) slower than Z3 0.1 on the SMT-LIB benchmarks?</b><br>
<br>
 It is not, you should use the option <code>AUTO_CONFIG=true</code> with Z3 1.0. In <a href="http://www.smtcomp.org/2007" class="el">SMT-COMP'07</a>, Z3 0.1 used this option by default. Example: <div class="fragment"><pre class="fragment"> z3 AUTO_CONFIG=<span class="keyword">true</span> -st QF_BV\spear\inn_v2.4.3\innd_innd_vc32473.smt 
</pre></div><p>
</li>
<li>
<b>Why does Z3 1.2 ignore some of my command line options?</b><br>
<br>
 AUTO_CONFIG is enabled by default starting at Z3 1.2. You should use the option <code>AUTO_CONFIG=false</code> if you want to tune Z3 manually.<p>
</li>
<li>
<b><code>AUTO_CONFIG</code> does not work with Simplify and Z3 formats.</b><br>
<br>
 <code>AUTO_CONFIG</code> is only supported in the SMT-LIB front-end.<p>
</li>
<li>
<b>Can I use the Z3 DLL with gcc?</b><br>
<br>
 The subdirectory <code>examples\C_API</code> contains the shell script <code>build.sh</code> to build the test application using gcc.<p>
</li>
<li>
<b>What is the calling convention used in the Z3 DLL?</b><br>
<br>
 We use the native calling convention of C/C++ (<code>__cdecl</code>).<p>
</li>
<li>
<b>What is the difference between <code>z3.dll</code> and <code>z3_dbg.dll</code>?</b><br>
<br>
 <code>z3_dbg.dll</code> contains assertion checking. You can use it to check whether you are using the API correctly or not.<p>
</li>
<li>
<b>Which API should I use?</b><br>
<br>
 If you are using C/C++ or a programming language that is not available in the .NET framework, you should use the C API. Otherwise, you should use the Managed (.NET) API. We also provide an <a href="http://caml.inria.fr/ocaml/">OCaml</a> API.<p>
</li>
<li>
<b>What is the license for Z3?</b><br>
<br>
 The license text is available from the <a href="http://research.microsoft.com/research/downloads/details/5fdacfa1-6c93-4a16-a2ac-6f4775e8ad1e/details.aspx" class="el">download location</a>.<p>
</li>
<li>
<b>Can I use Z3 for commercial purposes?</b><br>
<br>
 The Z3 download on this site is available for non-commercial use only. For more information about commercial licensing, contact the <a href="mailto:msrlg@microsoft.com" class="el">Microsoft Research Licensing Group</a>. <p>
</li>
<li>
<b>Why can small modifications in the input formula produce significant runtime differences?</b><br>
<br>
 Z3 solves problem instances that are co-NP complete. In particular, you can pass formulas where Z3 can immediately identify a satisfying assignment because the search happened to initially choose the <em>right</em> assignments, or Z3 may be able to identify a small proof quickly because it performed the <em>right</em> case splits early. But if Z3 does not start with the right assignments or case splits it is possible that search may take a long time. The input format influences the initial assignments and case split order. You can pertube the case split order by using the options <code>/rd:</code> and <code>/rs</code>. These options control the randomization in Z3. Example: <div class="fragment"><pre class="fragment"> z3 -rd:5 -rs:100 -st withOpt.smt 
</pre></div> <p>
</li>
<li>
<b>What is the meaning of <code>(bvudiv x bv0[32])</code>?</b><br>
<br>
 SMT-LIB does not specify its value. That is, <code>bvudiv(x, y)</code> is uninterpreted when <code>y = 0</code>, one can also say that <code>bvudiv</code> is under-specified. For example, <code>(= (bvudiv x bv0[32]) bv3[32])</code> is satisfiable. Z3 produces an interpretation for <code>(bvudiv x bv0[32])</code>. The default interpretation is: <code>(bvudiv x bv0[32])</code> equals zero for every <code>x</code>. Z3 will display the intepretation for <code>(bvudiv x bv0[32])</code> only when it is not the default one. Z3 uses the same approach to handle other under-specified functions such as: <code>bvsdiv</code>, <code>bvurem</code>, <code>bvsrem</code>, and <code>bvsmod</code>. Note: if you don't like this semantics, you can wrap each occurence of <code>bvudiv</code> with an if-then-else term: <code>(ite (= y 0) [whatever_you_want] (bvudiv x y))</code>.<p>
</li>
<li>
<b>Why does Z3 fail to prove <code>(EXISTS (x) (EQ x 0))</code>?</b><br>
<br>
 Indeed the fomula is valid, but the handling of quantifiers is incomplete in Z3. So the proof search simply terminates inconclusively, and Z3 states that the formula was invalid. Z3 is complete for various quantifier free fragments, so it will give correct answers when the formulas are quantifier free, but when the formulas contain quantifiers, only answers of the form <code>Valid</code> or <code>unsat</code> are conclusive. In the SMT-LIB front-end, Z3 will return <code>unknown</code> for satisfiable formulas that contain quantifiers.<p>
</li>
<li>
<b>Are there restrictions on what terms can be used in patterns?</b><br>
<br>
 Yes, Z3 does not support patterns with interpreted function symbols. That is, you cannot use functions such as <code>+</code>, or relations <code>&lt;=</code>, <code>&lt;</code>. As an exception, array functions <code>select</code> and <code>store</code> can be used in patterns. There is a simple trick to avoid the interpreted function symbols in patterns, but still allow you to have the benefit of matching with them: For every interpreted function symbol add a ghost function. For example, for <code>&lt;=</code> add the function <code>my_LEQ</code>. Add axioms for them: <code>(forall (x y) { (my_LEQ x y) } (iff (my_LEQ x y) (&lt;= x y)))</code>. Use the ghost functions everywhere else.<p>
</li>
</ul>
</div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Jun 18 11:31:26 2009
</BODY>
</HTML>
