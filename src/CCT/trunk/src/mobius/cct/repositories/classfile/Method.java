package mobius.cct.repositories.classfile;

import java.io.DataInputStream;
import java.io.IOException;

import mobius.cct.repositories.InvalidFormatException;
import mobius.cct.repositories.cp.ConstantPool;
import mobius.cct.repositories.cp.DefaultPool;

/**
 * Method in a class file.
 * @author Tadeusz Sznuk (ts209501@gmail.com)
 */
public class Method {
  // ACCESS FLAGS
  /** 
   *  Declared public; may be accessed from outside its package.
   */
  public static final int ACC_PUBLIC = 0x0001; 
  /** 
   *  Declared private; accessible only within the deÔ¨Åning class.
   */
  public static final int ACC_PRIVATE = 0x0002; 
  /** 
   *  Declared protected; may be accessed within subclasses.
   */
  public static final int ACC_PROTECTED = 0x0004; 
  /** 
   *  Declared static.
   */
  public static final int ACC_STATIC = 0x0008; 
  /** 
   *  Declared final; must not be overridden.
   */
  public static final int ACC_FINAL = 0x0010; 
  /** 
   *  Declared synchronized; invocation is wrapped in a monitor lock.
   */
  public static final int ACC_SYNCHRONIZED = 0x0020; 
  /** 
   *  A bridge method, generated by the compiler.
   */
  public static final int ACC_BRIDGE = 0x0040; 
  /** 
   *  Declared with variable number of arguments.
   */
  public static final int ACC_VARARGS = 0x0080; 
  /** 
   *  Declared native; implemented in a language other than Java.
   */
  public static final int ACC_NATIVE = 0x0100; 
  /** 
   *  Declared abstract; no implementation is provided.
   */
  public static final int ACC_ABSTRACT = 0x0400; 
  /** 
   *  Declared strictfp; floating-point mode is FP-strict.
   */
  public static final int ACC_STRICT = 0x0800; 
  /** 
   *  Declared synthetic; Not present in the source code.
   */
  public static final int ACC_SYNTHETIC = 0x1000; 
  
  /**
   * Method name and type.
   */
  private final MethodName fName;
  
  /**
   * Access flags.
   */
  private final int fAccessFlags;
  
  /**
   * Attributes.
   */
  private final AttributeMap fAttributes;
  
  /**
   * Constructor - read method from a stream.
   * @param ds Input stream.
   * @param cp Constant pool.
   * @throws IOException .
   */
  public Method(final DataInputStream ds, 
                final ConstantPool cp) throws IOException {
    fAccessFlags = ds.readUnsignedShort();
    final int nameIndex = ds.readUnsignedShort();
    final String name = DefaultPool.getString(cp, nameIndex);
    if (name == null) {
      throw new InvalidFormatException("Invalid method name.");
    }
    final int typeIndex = ds.readUnsignedShort();
    final String type = DefaultPool.getString(cp, typeIndex);
    if (type == null) {
      throw new InvalidFormatException("Invalid method type.");
    }
    fName = MethodName.get(name, type);
    fAttributes = new AttributeMap(ds, cp);
  }
  
  /**
   * Get method name.
   * @return Method name.
   */
  public MethodName getName() {
    return fName;
  }
  
  /**
   * Get method access flags.
   * @return Access flags.
   */
  public int getAccessFlags() {
    return fAccessFlags;
  }
  
  /**
   * Access method attributes.
   * @return Attribute map.
   */
  public AttributeMap getAttributes() {
    return fAttributes;
  }
  
}
